10.3  A Design Checklist for Testability
169
10.3  A Design Checklist for Testability
Table 10.2 is a checklist to support the design and analysis process for testability.
Table 10.2  Checklist to Support the Design and Analysis Process for Testability
Category
Checklist
Allocation of 
Responsibilities
Determine which system responsibilities are most critical 
and hence need to be most thoroughly tested.
Ensure that additional system responsibilities have been 
allocated to do the following:
■
■
Execute test suite and capture results (external test or 
self-test)
■
■
Capture (log) the activity that resulted in a fault or that 
resulted in unexpected (perhaps emergent) behavior 
that was not necessarily a fault
■
■
Control and observe relevant system state for testing
Make sure the allocation of functionality provides high 
cohesion, low coupling, strong separation of concerns, and 
low structural complexity.
Coordination Model
Ensure the system’s coordination and communication 
mechanisms:
■
■
Support the execution of a test suite and capture the 
results within a system or between systems
■
■
Support capturing activity that resulted in a fault within 
a system or between systems
■
■
Support injection and monitoring of state into the 
communication channels for use in testing, within a 
system or between systems
■
■
Do not introduce needless nondeterminism
Data Model
Determine the major data abstractions that must be tested 
to ensure the correct operation of the system.
■
■
Ensure that it is possible to capture the values of 
instances of these data abstractions 
■
■
Ensure that the values of instances of these data 
abstractions can be set when state is injected into the 
system, so that system state leading to a fault may be 
re-created
■
■
Ensure that the creation, initialization, persistence, 
manipulation, translation, and destruction of instances 
of these data abstractions can be exercised and 
captured 
Mapping among 
Architectural Elements
Determine how to test the possible mappings of 
architectural elements (especially mappings of processes 
to processors, threads to processes, and modules to 
components) so that the desired test response is achieved 
and potential race conditions identified.
In addition, determine whether it is possible to test for 
illegal mappings of architectural elements.
continues
