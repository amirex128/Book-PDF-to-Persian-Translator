<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 130</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>6.1  سناریوی عمومی قابلیت همکاری</h4>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   (ادامه)
  </p>
  <ul>
   <li>
    قابلیت اطمینان. <strong>SOAP</strong>، به خودی خود، تحویل پیام‌های قابل اطمینان را تضمین نمی‌کند. برنامه‌هایی که به چنین تضمین‌هایی نیاز دارند، باید از <strong>Services</strong>های سازگار با استاندارد قابلیت اطمینان <strong>SOAP</strong> استفاده کنند: <strong>WS-Reliability</strong>.
   </li>
  </ul>
  <p>
   <strong>SOAP</strong> بسیار عمومی است و ریشه در یک مدل فراخوانی رویه‌ای از راه دور (<strong>RPC</strong>) از برنامه‌های تعاملی دارد، اگرچه سایر مدل‌ها مطمئناً امکان‌پذیر هستند. <strong>SOAP</strong>، یک سیستم نوع ساده دارد، که با آن سیستم نوع موجود در زبان‌های برنامه‌نویسی اصلی قابل مقایسه است. <strong>SOAP</strong> به <strong>HTTP</strong> و <strong>RPC</strong> برای انتقال پیام متکی است، اما از نظر تئوری می‌تواند بر روی هر پروتکل ارتباطی <strong>Implemented</strong> شود. <strong>SOAP</strong>، نام روش، مدل آدرس‌دهی یا قراردادهای رویه‌ای <strong>Service</strong> را اجباری نمی‌کند. بنابراین، انتخاب <strong>SOAP</strong>، قابلیت همکاری واقعی کمی را بین برنامه‌ها فراهم می‌کند—این فقط یک استاندارد تبادل اطلاعات است. برنامه‌های تعاملی باید در مورد نحوه تفسیر <strong>Payload</strong> توافق کنند، که در آن قابلیت همکاری معنایی را دریافت می‌کنید.
  </p>
  <p>
   از طرف دیگر، <strong>REST</strong> یک سبک <strong>Architectural</strong> مبتنی بر <strong>Client-server</strong> است که حول مجموعه کوچکی از عملیات ایجاد، خواندن، به‌روزرسانی، حذف (<strong>CRUD</strong>) ساختار یافته است (که به ترتیب در دنیای <strong>REST</strong> به عنوان <strong>POST, GET, PUT, DELETE</strong> نامیده می‌شوند) و یک طرح آدرس‌دهی واحد (بر اساس یک <strong>URI</strong>، یا <strong>Uniform Resource Identifier</strong>). <strong>REST</strong> محدودیت‌های کمی را بر یک <strong>Architecture</strong> تحمیل می‌کند: <strong>SOAP</strong>، کامل بودن را ارائه می‌دهد. <strong>REST</strong>، سادگی را ارائه می‌دهد.
  </p>
  <p>
   <strong>REST</strong> در مورد وضعیت و انتقال وضعیت است و وب (و <strong>Services</strong>ی که سیستم‌های <strong>Service-oriented</strong> می‌توانند با هم ترکیب کنند) را به‌عنوان یک شبکه عظیم از اطلاعات در نظر می‌گیرد که توسط یک طرح آدرس‌دهی مبتنی بر <strong>URI</strong> واحد قابل دسترسی است. هیچ تصوری از نوع و از این رو، هیچ بررسی نوعی در <strong>REST</strong> وجود ندارد—این به عهده برنامه‌ها است که معنای تعامل را درست کنند.
  </p>
  <p>
   از آنجایی که <strong>REST Interfaces</strong> بسیار ساده و عمومی هستند، هر <strong>HTTP Client</strong> می‌تواند با هر <strong>HTTP Server</strong>، با استفاده از عملیات <strong>REST</strong> (<strong>POST, GET, PUT, DELETE</strong>) بدون پیکربندی بیشتر، صحبت کند. این امر قابلیت همکاری نحوی را برای شما به ارمغان می‌آورد، اما البته باید توافق‌نامه در سطح سازمان در مورد آنچه این برنامه‌ها در واقع انجام می‌دهند و اطلاعاتی که تبادل می‌کنند، وجود داشته باشد. یعنی قابلیت همکاری معنایی بین <strong>Services</strong> تضمین نمی‌شود، فقط به این دلیل که هر دو دارای <strong>REST Interfaces</strong> هستند.
  </p>
  <p>
   <strong>REST</strong>، علاوه بر <strong>HTTP</strong>، قرار است خود توصیفی باشد و در بهترین حالت یک پروتکل <strong>Stateless</strong> است. به مثال زیر، در <strong>REST</strong>، از یک <strong>Service</strong> دفترچه تلفن که به کسی اجازه می‌دهد یک شخص را جستجو کند، با توجه به برخی شناسه منحصربه‌فرد برای آن شخص، توجه کنید:
  </p>
  <p>
   <code>http://www.XYZdirectory.com/phonebook/UserInfo/99999</code>
  </p>
  <p>
   همین جستجوی ساده، که در <strong>SOAPImplemented</strong> شده است، به چیزی شبیه موارد زیر مشخص می‌شود:
  </p>
  <p>
   <code>&#60;?xml version="1.0"?&#62;</code>
  </p>
  <p>
   <code>&#60;soap:Envelope xmlns:soap=http://www.w3.org/2001/12/soap-envelope</code>
  </p>
  <p>
   <code>soap:encodingStyle=http://www.w3.org/2001/12/soap-encoding”&#62;</code>
  </p>
  <p>
   <code>&#60;soap:Body pb="http://www.XYZdirectory.com/phonebook"&#62;</code>
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>