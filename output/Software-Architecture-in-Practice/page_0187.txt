166 
Part Two  Quality Attributes	
10—Testability
about having to undo the consequences of the experiment. Testing is helped 
by the ability to operate the system in such a way that it has no permanent 
consequences, or so that any consequences can be rolled back. This can 
be used for scenario analysis, training, and simulation. (The Spring frame-
work, which is quite popular in the Java community, comes with a set of 
test utilities that support this. Tests are run as a “transaction,” which is 
rolled back at the end.)
A common form of sandboxing is to virtualize resources. Testing a 
system often involves interacting with resources whose behavior is outside 
the control of the system. Using a sandbox, you can build a version of the 
resource whose behavior is under your control. For example, the system 
clock’s behavior is typically not under our control—it increments one 
second each second—which means that if we want to make the system 
think it’s midnight on the day when all of the data structures are supposed 
to overflow, we need a way to do that, because waiting around is a poor 
choice. By having the capability to abstract system time from clock time, 
we can allow the system (or components) to run at faster than wall-clock 
time, and to allow the system (or components) to be tested at critical time 
boundaries (such as the next shift on or off Daylight Savings Time). Similar 
virtualizations could be done for other resources, such as memory, battery, 
network, and so on. Stubs, mocks, and dependency injection are simple but 
effective forms of virtualization.
■
■Executable assertions. Using this tactic, assertions are (usually) hand-coded 
and placed at desired locations to indicate when and where a program is in 
a faulty state. The assertions are often designed to check that data values 
satisfy specified constraints. Assertions are defined in terms of specific data 
declarations, and they must be placed where the data values are referenced 
or modified. Assertions can be expressed as pre- and post-conditions for 
each method and also as class-level invariants. This results in increasing 
observability, when an assertion is flagged as having failed. Assertions 
systematically inserted where data values change can be seen as a manual 
way to produce an “extended” type. Essentially, the user is annotating 
a type with additional checking code. Any time an object of that type is 
modified, the checking code is automatically executed, and warnings are 
generated if any conditions are violated. To the extent that the assertions 
cover the test cases, they effectively embed the test oracle in the code—
assuming the assertions are correct and correctly coded.
All of these tactics add capability or abstraction to the software that (were we 
not interested in testing) otherwise would not be there. They can be seen as replac-
ing bare-bones, get-the-job-done software with more elaborate software that has 
bells and whistles for testing. There are a number of techniques for effecting this 
replacement. These are not testability tactics, per se, but techniques for replacing 
one component with a different version of itself. They include the following:
