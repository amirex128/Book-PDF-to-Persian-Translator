32 
Part One  Introduction	
2—Why Is Software Architecture Important?
So it is with architecture design. An architecture design can also be viewed 
as a set of decisions. The early design decisions constrain the decisions that fol-
low, and changing these decisions has enormous ramifications. Changing these 
early decisions will cause a ripple effect, in terms of the additional decisions that 
must now be changed. Yes, sometimes the architecture must be refactored or re-
designed, but this is not a task we undertake lightly (because the “ripple” might 
turn into a tsunami).
What are these early design decisions embodied by software architecture? 
Consider:
■
■Will the system run on one processor or be distributed across multiple 
processors?
■
■Will the software be layered? If so, how many layers will there be? What 
will each one do?
■
■Will components communicate synchronously or asynchronously? Will 
they interact by transferring control or data or both?
■
■Will the system depend on specific features of the operating system or 
hardware? 
■
■Will the information that flows through the system be encrypted or not?
■
■What operating system will we use?
■
■What communication protocol will we choose?
Imagine the nightmare of having to change any of these or a myriad other 
related decisions. Decisions like these begin to flesh out some of the structures of 
the architecture and their interactions. In Chapter 4, we describe seven categories 
of these early design decisions. In Chapters 5–11 we show the implications of 
these design decision categories on achieving quality attributes.
2.6  Defining Constraints on an Implementation
An implementation exhibits an architecture if it conforms to the design decisions 
prescribed by the architecture. This means that the implementation must be im-
plemented as the set of prescribed elements, these elements must interact with 
each other in the prescribed fashion, and each element must fulfill its responsibil-
ity to the other elements as dictated by the architecture. Each of these prescrip-
tions is a constraint on the implementer.
Element builders must be fluent in the specifications of their individual ele-
ments, but they may not be aware of the architectural tradeoffs—the architecture 
(or architect) simply constrains them in such a way as to meet the tradeoffs. A 
classic example of this phenomenon is when an architect assigns performance 
budget to the pieces of software involved in some larger piece of functionality. 
If each software unit stays within its budget, the overall transaction will meet its 
