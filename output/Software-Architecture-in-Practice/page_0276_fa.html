<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 276</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
  <h3>14—Quality Attribute Modeling and Analysis</h3>
  <p>
    255
  </p>
  <p>
    <em>Part Two Quality Attributes</em>
  </p>
  <p>
    با توجه به همه این فرضیات، می‌توان <em>latency</em> سیستم را تخمین زد. گاهی اوقات فرمول‌های شناخته شده از نظریه صف اعمال می‌شوند. برای موقعیت‌هایی که راه‌حل‌های بسته وجود ندارد، تخمین‌ها اغلب می‌توانند از طریق شبیه‌سازی به دست آیند. از شبیه‌سازی می‌توان برای ایجاد فرضیات واقع‌بینانه‌تر مانند توزیع ورود رویدادها استفاده کرد. تخمین‌ها فقط به اندازه فرضیات خوب هستند، اما می‌توانند برای ارائه مقادیر تقریبی که می‌توانند در طراحی یا ارزیابی استفاده شوند، مفید باشند. با به دست آوردن اطلاعات بهتر، تخمین‌ها بهبود می‌یابند.
  </p>
  <p>
    برای ساخت مدل صف نشان داده شده در شکل 14.3، باید تعداد مناسبی از پارامترها را دانست یا تخمین زد. سپس مدل باید حل یا شبیه‌سازی شود تا <em>latency</em> مورد انتظار به دست آید. این سمت هزینه از هزینه/فایده انجام یک تجزیه و تحلیل صف است. سمت فایده این است که در نتیجه تجزیه و تحلیل، یک تخمین برای <em>latency</em> وجود دارد، و سوالات "چه می‌شود اگر" می‌توانند به راحتی پاسخ داده شوند. سؤالی که شما باید تصمیم بگیرید این است که آیا داشتن یک تخمین از <em>latency</em> و توانایی پاسخ به سؤالات "چه می‌شود اگر" ارزش هزینه انجام تجزیه و تحلیل را دارد یا خیر. یک راه برای پاسخ به این سؤال این است که اهمیت داشتن یک تخمین برای <em>latency</em> را قبل از ساخت سیستم یا یک نمونه اولیه که یک معماری را تحت یک بار فرضی شبیه‌سازی می‌کند، در نظر بگیرید. اگر داشتن یک <em>latency</em> کم یک الزام حیاتی است که موفقیت سیستم به آن بستگی دارد، تولید یک تخمین مناسب است.
  </p>
  <p>
    <em>Performance</em> یک <em>quality attribute</em> به‌خوبی مطالعه‌شده است که ریشه‌هایی فراتر از صنعت کامپیوتر دارد. به عنوان مثال، مدل صف که در شکل 14.1 ارائه شده است، به دهه 1930 برمی‌گردد. نظریه صف برای کف کارخانه‌ها، صف‌های بانکی، و بسیاری از <em>domains</em> دیگر اعمال شده است. مدل‌هایی برای <em>real-time performance</em>، مانند تجزیه و تحلیل یکنواخت نرخ، نیز وجود دارند و دارای تکنیک‌های تجزیه و تحلیل پیچیده هستند.
  </p>
  <h4>Analyzing Availability</h4>
  <p>
    <em>Availability</em>، <em>quality attribute</em> دیگری با یک چارچوب تحلیلی به‌خوبی درک شده است. مدل‌سازی یک معماری برای <em>availability</em> - یا با دقت بیشتری، مدل‌سازی یک معماری برای تعیین <em>availability</em> یک سیستم بر اساس آن معماری - موضوع تعیین میزان شکست و زمان بازیابی است. همانطور که ممکن است از فصل 5 به یاد داشته باشید، <em>availability</em> را می‌توان به صورت زیر بیان کرد
    <br>
    <em>MTBF / (MTBF + MTTR)</em>
  </p>
  <p>
    این مدل چیزی را که به عنوان <em>steady-state availability</em> شناخته می‌شود، مدل می‌کند، و برای نشان دادن زمان روشن بودن یک سیستم (یا <em>component</em> یک سیستم) در یک بازه زمانی به‌اندازه کافی طولانی استفاده می‌شود. در معادله، <em>MTBF</em>، زمان متوسط بین شکست است، که بر اساس مقدار مورد انتظار تابع چگالی احتمال شکست (<em>PDF</em>) پیاده‌سازی به‌دست می‌آید، و <em>MTTR</em> به زمان متوسط برای تعمیر اشاره دارد.
  </p>
  <p>
    درست همانطور که برای <em>performance</em>، برای مدل‌سازی یک معماری برای <em>availability</em>، ما به یک معماری برای تجزیه و تحلیل نیاز داریم. بنابراین، فرض کنید ما می‌خواهیم <em>availability</em> سیستمی را که از الگوی <em>broker</em> استفاده می‌کند، با اعمال تاکتیک‌های <em>redundancy</em> افزایش دهیم. شکل 14.4
  </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>