178 
Part Two  Quality Attributes	
11—Usability
Separate the User Interface!
One of the most helpful things an architect can do to make a system 
usable is to facilitate experimentation with the user interface via the con-
struction of rapid prototypes. Building a prototype, or several prototypes, 
to let real users experience the interface and give their feedback pays 
enormous dividends. The best way to do this is to design the software so 
that the user interface can be quickly changed.
Tactics for modifiability that we saw in Chapter 7 support this goal per-
fectly well, especially these:
■
■
Increase semantic coherence, encapsulate, and co-locate related re-
sponsibilities, which localize user interface responsibilities to a single 
place
■
■
Restrict dependencies, which minimizes the ripple effect to other soft-
ware when the user interface changes
■
■
Defer binding, which lets you make critical user interface choices without 
having to recode
Defer binding is especially helpful here, because you can expect that 
your product’s user interface will face pressure to change during testing 
and even after it goes to market.
User interface generation tools are consistent with these tactics; most 
produce a single module with an abstract interface to the rest of the soft-
ware. Many provide the capability to change the user interface after compile 
time. You can do your part by restricting dependencies on the generated 
module, should you later decide to adopt a different tool.
Much work in different user interface separation patterns occurred in the 
1980s and 90s. With the advent of the web and the modernization of the 
model-view-controller (MVC) pattern to reflect web interfaces, MVC has 
become the dominant separation pattern. Now the MVC pattern is built into 
a wide variety of different frameworks. (See Chapter 14 for a discussion of 
MVC.) MVC makes it easy to provide multiple views of the data, supporting 
user initiative, as we discuss next.
Many times quality attributes are in conflict with each other. Usability 
and modifiability, on the other hand, often complement each other, 
because one of the best ways to make a system more usable is to make 
it modifiable. However, this is not always the case. In many systems busi-
ness rules drive the UI—for example, specifying how to validate input. To 
realize this validation, the UI may need to call a server (which can neg-
atively affect performance). To get around this performance penalty, the 
architect may choose to duplicate these rules in the client and the server, 
which then makes evolution difficult. Alas, the architect’s life is never easy!
