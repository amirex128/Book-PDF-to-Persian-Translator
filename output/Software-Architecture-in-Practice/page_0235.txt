214 
Part Two  Quality Attributes	
13—Architectural Tactics and Patterns
There may, in fact, be many views and many controllers associated with 
a model. For example, a set of business data may be represented as columns of 
numbers in a spreadsheet, as a scatter plot, or as a pie chart. Each of these is a 
separate view, and this view can be dynamically updated as the model changes 
(for example, showing live transactions in a transaction processing system). A 
model may be updated by different controllers; for example, a map could be 
zoomed and panned via mouse movements, trackball movements, keyboard 
clicks, or voice commands; each of these different forms of input needs to be 
managed by a controller. 
The MVC components are connected to each other via some flavor of 
notification, such as events or callbacks. These notifications contain state updates. 
A change in the model needs to be communicated to the views so that they may 
be updated. An external event, such as a user input, needs to be communicated to 
the controller, which may in turn update the view and/or the model. Notifications 
may be either push or pull.
Because these components are loosely coupled, it is easy to develop and 
test them in parallel, and changes to one have minimal impact on the others. The 
relationships between the components of MVC are shown in Figure 13.7.
• Encapsulates application state
• Responds to state queries
• Exposes application functionality
• Notifies views of changes
Model
• Renders the models
• Requests updates from models
• Sends user gestures to controller
• Allows controller to select view
View
• Defines application behavior
• Maps user actions to model updates
• Selects view for response
• One for each functionality
Controller
State
Query
State
Change
User Gestures
View Selection
Change
Notification
Key:
Events
Method 
Invocations
Figure 13.7  The model-view-controller pattern
