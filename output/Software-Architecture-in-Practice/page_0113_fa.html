<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 113</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>5.2  تاکتیک‌ها برای در دسترس بودن</h4>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   (ادامه)
  </p>
  <ul>
   <li>
    افزونگی فعال (یدکی داغ). این به پیکربندی اشاره دارد که در آن همه <strong>Nodes</strong> (یدکی فعال یا افزونه) در یک گروه حفاظت2، ورودی‌های یکسانی را به موازات هم دریافت و پردازش می‌کنند، که به یدکی‌های افزونه اجازه می‌دهد تا حالت همزمان را با <strong>Node</strong>(های) فعال حفظ کنند. از آنجایی که یدکی افزونه، یک حالت یکسان با پردازنده فعال دارد، می‌تواند در عرض چند میلی‌ثانیه از یک <strong>Component</strong> شکست‌خورده بر عهده بگیرد. مورد ساده یک <strong>Node</strong> فعال و یک <strong>Node</strong> یدکی افزونه معمولاً به عنوان افزونگی 1+1 ("یک به علاوه یک") نامیده می‌شود. افزونگی فعال را می‌توان برای حفاظت از امکانات نیز استفاده کرد، جایی که از لینک‌های شبکه فعال و آماده به کار برای اطمینان از اتصال شبکه با در دسترس بودن بالا استفاده می‌شود.
   </li>
   <li>
    افزونگی منفعل (یدکی گرم). این به پیکربندی اشاره دارد که در آن فقط اعضای فعال گروه حفاظت، ترافیک ورودی را پردازش می‌کنند. یکی از وظایف آنها این است که یدکی‌های افزونه را با به‌روزرسانی‌های دوره‌ای وضعیت ارائه دهند. از آنجایی که وضعیتی که توسط یدکی‌های افزونه حفظ می‌شود، فقط به‌طور سست با وضعیت <strong>Node</strong>(های) فعال در گروه حفاظت جفت می‌شود (با سستی اتصال که تابعی از مکانیسم بازرسی مورد استفاده بین <strong>Nodes</strong> فعال و افزونه است)، به <strong>Nodes</strong> افزونه، یدکی‌های گرم گفته می‌شود. بسته به الزامات در دسترس بودن سیستم، افزونگی منفعل، راه‌حلی را ارائه می‌دهد که تعادلی را بین تاکتیک افزونگی فعال که بسیار در دسترس‌تر اما محاسباتی فشرده‌تر (و گران‌تر) است، و تاکتیک یدکی سرد که کمتر در دسترس اما به‌طور قابل‌توجهی ارزان‌تر است، ایجاد می‌کند. (برای یک
    <br>
    2. یک گروه حفاظت، گروهی از گره‌های پردازشی است که در آن یک یا چند گره "فعال" هستند، در حالی که گره‌های باقیمانده در گروه حفاظت به عنوان یدکی‌های افزونه عمل می‌کنند.
   </li>
   <li>
    یدکی (سرد یدکی). <strong>Cold Sparing</strong> به پیکربندی‌ای اشاره دارد که در آن یدکی‌های افزونه یک گروه حفاظت تا زمان وقوع خرابی، خارج از سرویس باقی می‌مانند، که در این مرحله یک روش راه‌اندازی مجدد در یدکی افزونه، قبل از قرار گرفتن آن در سرویس، آغاز می‌شود. با توجه به عملکرد ضعیف بازیابی، <strong>Cold Sparing</strong> برای سیستم‌هایی که فقط دارای الزامات قابلیت اطمینان بالا (<strong>MTBF</strong>) هستند، مناسب‌تر است، بر خلاف آنهایی که الزامات در دسترس بودن بالا را نیز دارند.
   </li>
   <li>
    رسیدگی به استثنا. هنگامی که یک استثنا تشخیص داده شد، سیستم باید آن را به نحوی مدیریت کند. ساده‌ترین کاری که می‌تواند انجام دهد، این است که به‌سادگی از کار بیفتد، اما البته این از نظر در دسترس بودن، قابلیت استفاده، قابلیت آزمایش، و عقل سلیم، یک ایده وحشتناک است. امکانات بسیار مفیدتری وجود دارد. مکانیسم مورد استفاده برای رسیدگی به استثنا، تا حد زیادی به محیط برنامه‌نویسی مورد استفاده بستگی دارد، که از کدهای بازگشتی تابع ساده (کدهای خطا) تا استفاده از کلاس‌های استثنایی که حاوی اطلاعات مفیدی در همبستگی خطا هستند، مانند نام استثنای پرتاب شده، مبدأ استثنا، و علت استثنای پرتاب شده، متغیر است. سپس نرم‌افزار می‌تواند از این اطلاعات برای پنهان کردن خطا استفاده کند، معمولاً با اصلاح علت استثنا و تلاش مجدد عملیات.
   </li>
   <li>
    بازگشت. این تاکتیک به سیستم اجازه می‌دهد تا با تشخیص یک شکست، به یک حالت خوب قبلی که به عنوان "خط بازگشت"—بازگشت به زمان—شناخته می‌شود، برگردد. پس از رسیدن به حالت خوب، سپس اجرا می‌تواند ادامه یابد. این تاکتیک اغلب با تاکتیک‌های افزونگی فعال یا منفعل ترکیب می‌شود تا پس از وقوع یک بازگشت، یک نسخه آماده به کار از <strong>Component</strong> ناموفق به وضعیت فعال ارتقا یابد. بازگشت به وجود یک کپی از یک حالت خوب قبلی (یک <strong>Checkpoint</strong>) برای <strong>Components</strong> که در حال بازگشت هستند، بستگی دارد. <strong>Checkpoints</strong> را می‌توان در یک مکان ثابت ذخیره کرد و در فواصل منظم، یا در زمان‌های مناسب یا مهم در پردازش، مانند تکمیل یک عملیات پیچیده، به‌روزرسانی کرد.
   </li>
   <li>
    ارتقاء نرم‌افزار، تاکتیک آماده‌سازی و تعمیر دیگری است که هدف آن دستیابی به ارتقاء در سرویس به تصاویر کد اجرایی به روشی غیر تأثیرگذار بر <strong>Service</strong> است. این ممکن است به عنوان یک <strong>Function Patch</strong>، یک <strong>Class Patch</strong>، یا یک ارتقاء نرم‌افزاری بدون ضربه در سرویس (<strong>ISSU</strong>) محقق شود. یک <strong>Function Patch</strong> در برنامه‌نویسی رویه‌ای استفاده می‌شود و از یک <strong>Linker/loader</strong> افزایشی برای ذخیره یک تابع نرم‌افزاری به‌روزرسانی‌شده در یک بخش از حافظه هدف از قبل اختصاص داده شده استفاده می‌کند. نسخه جدید تابع نرم‌افزاری، از نقاط ورودی و خروجی تابع منسوخ‌شده استفاده خواهد کرد. همچنین، پس از بارگذاری تابع نرم‌افزاری جدید، جدول نمادها باید به‌روزرسانی شود و <strong>Instruction Cache</strong> نامعتبر شود. تاکتیک <strong>Class Patch</strong> برای اهداف اجرای کد شیء گرا قابل اجرا است، جایی که تعاریف کلاس شامل یک مکانیسم پشتیبان است که امکان افزودن <strong>Member Data</strong> و توابع را در زمان اجرا فراهم می‌کند. ارتقاء نرم‌افزار در سرویس بدون ضربه، از افزونگی فعال یا منفعل استفاده می‌کند
   </li>
  </ul>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>