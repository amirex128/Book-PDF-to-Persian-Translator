104 
Part Two  Quality Attributes	
6—Interoperability
with any success. The highest level signifies systems that work together seam-
lessly, never make any mistakes interpreting each other’s communications, and 
share the same underlying semantic model of the world in which they work. 
“Exchanging Information via Interfaces”
Interoperability, as we said, is about two or more systems exchanging 
information via interfaces. 
At this point, we need to clarify two critical concepts central to this dis-
cussion and emphasize that we are taking a broad view of each.
The first is what it means to “exchange information.” This can mean 
something as simple as program A calling program B with some param-
eters. However, two systems (or parts of a system) can exchange infor-
mation even if they never communicate directly with each other. Did you 
ever have a conversation like the following in junior high school? “Charlene 
said that Kim told her that Trevor heard that Heather wants to come to 
your party.” Of course, junior high school protocol would preclude the 
possibility of responding directly to Heather. Instead, your response (if you 
like Heather) might be, “Cool,” which would make its way back through 
Charlene, Kim, and Trevor. You and Heather exchanged information, but 
never talked to each other. (We hope you got to talk to each other at the 
party.)
Entities can exchange information in even less direct ways. If I have an 
idea of a program’s behavior, and I design my program to work assuming 
that behavior, the two programs have also exchanged information—just not 
at runtime.
One of the more infamous software disasters in history occurred when 
an antimissile system failed to intercept an incoming ballistic rocket in 
Operation Desert Storm in 1991, resulting in 28 fatalities. One of the mis-
sile’s software components “expected” to be shut down and restarted peri-
odically, so it could recalibrate its orientation framework from a known initial 
point. The software had been running for some 100 hours when the missile 
was launched, and calculation errors had accumulated to the point where 
the software component’s idea of its orientation had wandered hopelessly 
away from truth.
Systems (or components within systems) often have or embody ex-
pectations about the behaviors of its “information exchange” partners. 
The assumption of everything interacting with the errant component in the 
preceding example was that its accuracy did not degrade over time. The 
result was a system of parts that did not work together correctly to solve 
the problem they were supposed to.
The second concept we need to stress is what we mean by “interface.” 
Once again, we mean something beyond the simple case—a syntactic 
description of a component’s programs and the type and number of their 
parameters, most commonly realized as an API. That’s necessary for 
