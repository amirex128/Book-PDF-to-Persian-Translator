13.2  Overview of the Patterns Catalog
217
capacity = 40
end-of-data = empty record
when-full = block for 2 sec and retry
when-empty = block for 30 sec and retry
capacity = 50
end-of-data = ”EOT” String
when-full = block for 2 sec and retry
when-empty = block for 20 sec and retry
capacity = 10
end-of-data = empty record
when-full = block for 2 sec and retry
when-empty = block for 60 sec and retry
capacity = 40
end-of-data = empty record
when-full = block for 2 sec and retry
when-empty = block for 30 sec and retry
«pipe»
«pipe»
«pipe»
«pipe»
out
in
out
in
out
out
in
in
«filter»
:XmlToObject
«filter»
:Process
Payment
«filter»
:FormatRejected
Records
«filter»
:Calculate
DirectDeposit
«filter»
:Format
DirectDeposit
Figure 13.8  A UML diagram of a pipe-and-filter-based system
Client-Server Pattern
Context: There are shared resources and services that large numbers of distrib-
uted clients wish to access, and for which we wish to control access or quality of 
service.
Problem: By managing a set of shared resources and services, we can promote 
modifiability and reuse, by factoring out common services and having to modify 
these in a single location, or a small number of locations. We want to improve 
scalability and availability by centralizing the control of these resources and ser-
vices, while distributing the resources themselves across multiple physical servers. 
Solution: Clients interact by requesting services of servers, which provide a set 
of services. Some components may act as both clients and servers. There may be 
one central server or multiple distributed ones. 
The client-server pattern solution is summarized in Table 13.5; the 
component types are clients and servers; the principal connector type for the 
client-server pattern is a data connector driven by a request/reply protocol used 
for invoking services. 
Some of the disadvantages of the client-server pattern are that the server 
can be a performance bottleneck and it can be a single point of failure. Also, 
decisions about where to locate functionality (in the client or in the server) are 
often complex and costly to change after a system has been built.
