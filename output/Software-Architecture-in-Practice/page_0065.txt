44 
Part One  Introduction	
3—The Many Contexts of Software Architecture
3.2  Architecture in a Project Life-Cycle Context
Software development processes are standard approaches for developing software 
systems. They impose a discipline on software engineers and, more important, 
teams of software engineers. They tell the members of the team what to do next. 
There are four dominant software development processes, which we describe in 
roughly the order in which they came to prominence: 
1.	
Waterfall. For many years the Waterfall model dominated the field of 
software development. The Waterfall model organized the life cycle into a 
series of connected sequential activities, each with entry and exit conditions 
and a formalized relationship with its upstream and downstream neighbors. 
The process began with requirements specification, followed by design, 
then implementation, then integration, then testing, then installation, 
all followed by maintenance. Feedback paths from later to earlier steps 
allowed for the revision of artifacts (requirements documents, design 
documents, etc.) on an as-needed basis, based on the knowledge acquired 
in the later stage. For example, designers might push back against overly 
stringent requirements, which would then be reworked and flow back down. 
Testing that uncovered defects would trigger reimplementation (and maybe 
even redesign). And then the cycle continued.
2.	
Iterative. Over time the feedback paths of the Waterfall model became 
so pronounced that it became clear that it was better to think of software 
development as a series of short cycles through the steps—some 
requirements lead to some design, which can be implemented and tested 
while the next cycle’s worth of requirements are being captured and 
designed. These cycles are called iterations, in the sense of iterating toward 
the ultimate software solution for the given problem. Each iteration should 
deliver something working and useful. The trick here is to uncover early 
those requirements that have the most far-reaching effect on the design; the 
corresponding danger is to overlook requirements that, when discovered 
later, will capsize the design decisions made so far. An especially well-
known iterative process is called the Unified Process (originally named the 
Rational Unified Process, after Rational Software, which originated it). It 
defines four phases of each iteration: inception, elaboration, construction, 
and transition. A set of chosen use cases defines the goals for each iteration, 
and the iterations are ordered to address the greatest risks first.
3.	
Agile. The term “Agile software development” refers to a group of 
software development methodologies, the best known of which include 
Scrum, Extreme Programming, and Crystal Clear. These methodologies 
are all incremental and iterative. As such, one can consider some iterative 
