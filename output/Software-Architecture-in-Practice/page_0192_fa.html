<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 192</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
  <h3>10.3  A Design Checklist for Testability</h3>
  <p>
    171
  </p>
  <p>
    سیستم نیازهای آن را برای <em>throughput</em>، <em>latency</em> و زمان پاسخ برآورده می‌کند). برای <em>unit tests</em>، و معمولاً برای <em>user acceptance tests</em>، داده‌های <em>test</em> معمولاً با دست ایجاد می‌شوند.
  </p>
  <p>
    به عنوان مثال، ممکن است به 50 محصول، 100 مشتری و 500 سفارش در پایگاه داده <em>test</em> خود نیاز داشته باشید، تا بتوانید مراحل عملکردی درگیر در ایجاد، اصلاح یا حذف سفارش‌ها را آزمایش کنید. این داده‌ها باید به اندازه کافی متفاوت باشند تا <em>testing</em> ارزش داشته باشد، باید با تمام قوانین <em>referential integrity</em> و سایر محدودیت‌های مدل داده‌های شما مطابقت داشته باشند، و شما باید بتوانید نتایج مورد انتظار <em>tests</em> را محاسبه و مشخص کنید.
  </p>
  <p>
    من در دو راه انجام این کار دیده‌ام - و درگیر بوده‌ام: شما یا سیستمی برای تولید داده‌های <em>test</em> خود می‌نویسید، یا یک مجموعه داده نماینده را از محیط تولید ضبط می‌کنید و در صورت لزوم آن را ناشناس می‌کنید. (ناشناس کردن داده‌های <em>test</em> شامل حذف هرگونه اطلاعات حساس، مانند داده‌های شخصی افراد یا سازمان‌ها، جزئیات مالی و غیره است.)
  </p>
  <p>
    ایجاد داده‌های <em>test</em> خودتان ایده‌آل است، زیرا می‌دانید از چه داده‌هایی استفاده می‌کنید و می‌توانید اطمینان حاصل کنید که تمام <em>edge cases</em> شما را پوشش می‌دهد، اما تلاش زیادی می‌طلبد. ضبط داده‌ها از محیط زنده آسان‌تر است، با فرض اینکه سیستمی از قبل وجود دارد، اما شما نمی‌دانید چه داده‌هایی و از این رو چه پوششی دریافت می‌کنید، و ممکن است مجبور شوید مراقبت بیشتری برای انطباق با قوانین حفظ حریم خصوصی و حفاظت از داده‌ها انجام دهید.
  </p>
  <p>
    این می‌تواند به طرق مختلف بر معماری سیستم تأثیر بگذارد و باید در مراحل اولیه توسط <em>architect</em> مورد توجه قرار گیرد. به عنوان مثال، سیستم ممکن است نیاز داشته باشد که بتواند تراکنش‌های زنده را ثبت کند، یا "<em>snapshots</em>" از داده‌های زنده را بگیرد، که می‌توان از آنها برای تولید داده‌های <em>test</em> استفاده کرد. علاوه بر این، سیستم تولید داده‌های <em>test</em> ممکن است به معماری خاص خود نیاز داشته باشد.
  </p>
  <p>
    Test Automation
  </p>
  <p>
    دومین چالش شما مربوط به اتوماسیون <em>test</em> است. در عمل <em>test</em> کردن سیستم‌های بزرگ به صورت دستی به دلیل تعداد <em>tests</em>، پیچیدگی آنها، و مقدار بررسی نتایجی که مورد نیاز است، امکان‌پذیر نیست. در دنیای ایده‌آل، شما یک چارچوب اتوماسیون <em>test</em> ایجاد می‌کنید تا این کار را به‌طور خودکار انجام دهید، که به آن داده‌های <em>test</em> می‌دهید و هر شب آن را اجرا می‌کنید، یا حتی هر بار که چیزی را <em>check in</em> می‌کنید (مدل <em>continuous integration</em>).
  </p>
  <p>
    این حوزه‌ای است که در بسیاری از پروژه‌های توسعه نرم‌افزار بزرگ، توجه کمی به آن می‌شود. اغلب در برنامه پروژه بودجه‌بندی نمی‌شود، با این فرض ناگفته که تلاش مورد نیاز برای ساخت آن را می‌توان به نوعی در هزینه‌های توسعه "جذب" کرد. یک چارچوب اتوماسیون <em>test</em> می‌تواند به‌خودی خود یک چیز بسیار پیچیده باشد (که این سوال را مطرح می‌کند که چگونه آن را <em>test</em> می‌کنید!). باید مانند هر <em>deliverable</em> پروژه دیگری، دامنه و برنامه‌ریزی شود.
  </p>
  <p>
    باید توجه کافی به نحوه فراخوانی توابع چارچوب در سیستم تحت <em>test</em>، به‌ویژه برای <em>testing user interfaces</em>، که تقریباً بدون استثنا یک کابوس است، شود. (اجرای یک <em>UI test</em> بسیار به چیدمان پنجره‌ها، ترتیب فیلدها و غیره بستگی دارد، که معمولاً در سیستم‌های متمرکز بر کاربر، بسیار تغییر می‌کند. گاهی اوقات می‌توان کنترل‌های پنجره را به صورت برنامه‌نویسی اجرا کرد، اما در بدترین حالت ممکن است مجبور شوید <em>keystrokes</em> یا حرکات ماوس را ضبط و پخش کنید.)
  </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>