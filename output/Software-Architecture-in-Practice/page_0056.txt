2.11  Allowing Incorporation of Independently Developed Components
35
2.10  Supplying a Transferable, Reusable Model
The earlier in the life cycle that reuse is applied, the greater the benefit that can 
be achieved. While code reuse provides a benefit, reuse of architectures provides 
tremendous leverage for systems with similar requirements. Not only can code be 
reused, but so can the requirements that led to the architecture in the first place, 
as well as the experience and infrastructure gained in building the reused archi-
tecture. When architectural decisions can be reused across multiple systems, all 
of the early-decision consequences we just described are also transferred.
A software product line or family is a set of software systems that are all 
built using the same set of reusable assets. Chief among these assets is the archi-
tecture that was designed to handle the needs of the entire family. Product-line 
architects choose an architecture (or a family of closely related architectures) that 
will serve all envisioned members of the product line. The architecture defines 
what is fixed for all members of the product line and what is variable. Software 
product lines represent a powerful approach to multi-system development that 
is showing order-of-magnitude payoffs in time to market, cost, productivity, 
and product quality. The power of architecture lies at the heart of the paradigm. 
Similar to other capital investments, the architecture for a product line becomes 
a developing organization’s core asset. Software product lines are explained in 
Chapter 25. 
2.11  Allowing Incorporation of Independently 
Developed Components
Whereas earlier software paradigms have focused on programming as the prime 
activity, with progress measured in lines of code, architecture-based development 
often focuses on composing or assembling elements that are likely to have been 
developed separately, even independently, from each other. This composition is 
possible because the architecture defines the elements that can be incorporated 
into the system. The architecture constrains possible replacements (or additions) 
according to how they interact with their environment, how they receive and re-
linquish control, what data they consume and produce, how they access data, and 
what protocols they use for communication and resource sharing. 
In 1793, Eli Whitney’s mass production of muskets, based on the principle 
of interchangeable parts, signaled the dawn of the industrial age. In the days be-
fore physical measurements were reliable, manufacturing interchangeable parts 
was a daunting notion. Today in software, until abstractions can be reliably de-
limited, the notion of structural interchangeability is just as daunting and just as 
significant. 
