<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 121</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>4.6  تاکتیک‌ها برای در دسترس بودن</h4>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   (ادامه)
  </p>
  <ul>
   <li>
    <strong>Timeout</strong>، یک تاکتیک است که یک استثنا را افزایش می‌دهد، زمانی که یک <strong>Component</strong> تشخیص دهد که آن یا <strong>Component</strong> دیگری، محدودیت‌های زمانی خود را برآورده نکرده است. به عنوان مثال، یک <strong>Component</strong> که منتظر پاسخ از <strong>Component</strong> دیگری است، می‌تواند یک استثنا را در صورت تجاوز از یک مقدار معین، ایجاد کند.
   </li>
   <li>
    خود آزمایی. <strong>Components</strong> (یا، به احتمال زیاد، کل زیرسیستم‌ها) می‌توانند روال‌هایی را برای آزمایش عملکرد صحیح خود اجرا کنند. رویه‌های خودآزمایی را می‌توان توسط خود <strong>Component</strong> یا از زمان به زمان توسط یک مانیتور سیستم، فعال شوند. اینها ممکن است شامل استفاده از برخی از تکنیک‌های موجود در نظارت بر شرایط، مانند مجموع‌های کنترلی باشند.
   </li>
  </ul>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   یکی از راه‌های مدیریت این موضوع، معرفی یک <strong>Component</strong> از طریق "<strong>Shadow Mode</strong>" است.
  </p>
  <p>
   این به این معنی است که یک <strong>Component</strong> خاص، قبل از اینکه فعال شود، آزمایش می‌شود تا اطمینان حاصل شود که عملکردی دارد که می‌توان از آن استفاده کرد.
  </p>
  <p>
   
  </p>
  <p>
   هنگامی که در <strong>Architecture</strong>، یک <strong>Fault</strong> رخ می‌دهد، اقدامات مختلفی را می‌توان انجام داد.
  </p>
  <p>
   
  </p>
  <p>
   این یک فرآیند پیچیده است، اما با در نظر گرفتن <strong>Tactics</strong> مختلف و تعیین اینکه کدام یک از آنها در حال حاضر در سیستم استفاده می‌شود، می‌توان در دسترس بودن را بهبود بخشید.
  </p>
  <p>
   
  </p>
  <p>
   در ادامه، راه‌های مختلفی برای یافتن <strong>Fault</strong> وجود دارد:
  </p>
  <ul>
   <li>
    <strong>Ping/Echo</strong>
   </li>
   <li>
    مانیتور
   </li>
   <li>
    <strong>Heartbeat</strong>
   </li>
   <li>
    مهر زمانی
   </li>
   <li>
    بررسی صحت
   </li>
   <li>
    نظارت بر شرایط
   </li>
   <li>
    رأی‌گیری
   </li>
   <li>
    تشخیص استثنا
   </li>
   <li>
    خودآزمایی
   </li>
  </ul>
  <p>
   
  </p>
  <p>
   اینها تاکتیک‌هایی هستند که برای تشخیص وجود خرابی سیستم استفاده می‌شوند.
  </p>
  <p>
   یکی از این موارد، <strong>Ping/Echo</strong> است.
  </p>
  <p>
   
  </p>
  <p>
   این نشان‌دهنده یک <strong>Component</strong> خاص است که برای بررسی وجود <strong>Component</strong> دیگر استفاده می‌شود.
  </p>
  <p>
   
  </p>
  <p>
   هنگامی که <strong>Component</strong> شناسایی شد، به هر دلیل، از بین می‌رود.
  </p>
  <p>
   
  </p>
  <p>
   این موضوع باعث می‌شود سیستم قابل‌اطمینان‌تر شود.
  </p>
  <p>
   
  </p>
  <p>
   اگر سیستمی بتواند خود را بازیابی کند، به احتمال زیاد در دسترس خواهد بود.
  </p>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   راه‌های دیگری برای این کار وجود دارد، اما این یک رویکرد اساسی است.
  </p>
  <p>
   
  </p>
  <p>
   به عنوان مثال، در سیستم‌های <strong>Real-time</strong>، بسیار مهم است که اطمینان حاصل شود که با زمان‌بندی مشکلی وجود ندارد.
  </p>
  <p>
   
  </p>
  <p>
   مانند هر <strong>Process</strong> دیگری، در دسترس بودن با <strong>Tradeoffs</strong> مواجه می‌شود.
  </p>
  <p>
   
  </p>
  <p>
   یکی از راه‌ها برای حصول اطمینان از در دسترس بودن، جلوگیری از وقوع خطاها در وهله اول است.
  </p>
  <p>
   
  </p>
  <p>
   در اینجا، در دسترس بودن از این منظر در نظر گرفته می‌شود.
  </p>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   در حالی که تلاش‌های مختلفی در این زمینه وجود دارد، یک <strong>Architect</strong> باید تمام تلاش خود را برای درک همه اجزای مختلف این راه‌حل‌ها انجام دهد.
  </p>
  <p>
   
  </p>
  <p>
   مراحل مختلفی وجود دارد که یک سیستم برای اجرای یک <strong>Architecture</strong> مناسب باید دنبال کند.
  </p>
  <p>
   
  </p>
  <p>
   در حالی که این موارد را می‌توان <strong>Implement</strong> کرد، مهم است که درک کنیم هرگز نباید به <strong>Implementations</strong>های خاص وابسته باشیم.
  </p>
  <p>
   
  </p>
  <p>
   یکی از جنبه‌های حیاتی، تلاش برای درک ماهیت عملکرد <strong>Implementations</strong>های مختلف است.
  </p>
  <p>
   
  </p>
  <p>
   اینها تاکتیک‌ها هستند.
  </p>
  <p>
   
  </p>
  <p>
   به همین دلیل است که ما در مورد الزامات <strong>Quality Attribute</strong> صحبت می‌کنیم.
  </p>
  <p>
   
  </p>
  <h4>5.5  برای مطالعه بیشتر</h4>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   (ادامه)
  </p>
  <ul>
   <li>
    <strong>Exception Handling</strong> را برای افزایش در دسترس بودن می‌خوانیم. این، <strong>Tactic</strong> معمول را ارائه می‌دهد و باید در برنامه‌نویسی به‌طور مداوم در نظر گرفته شود.
   </li>
  </ul>
  <p>
   
  </p>
  <p>
   -
  </p>
  <p>
   
  </p>
  <p>
   به‌عنوان مثال، <strong>Smart Pointers</strong> در جاوا، یک رویکرد استاندارد برای جلوگیری از نشت حافظه هستند.
  </p>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   از آنجایی که <strong>Availability Requirements</strong> با هم در ارتباط هستند، هر یک از آنها در عملکرد تأثیر متفاوتی خواهند داشت.
  </p>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   
  </p>
  <h4>5.3  یک <strong>Design Checklist</strong> برای در دسترس بودن</h4>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   (ادامه)
  </p>
  <p>
   با توجه به توضیحات فوق، در اینجا می‌توانیم راه‌حل‌ها را از طریق هفت دسته اصلی تقسیم کنیم.
  </p>
  <p>
   
  </p>
  <p>
   این، یکی دیگر از لیست‌های ماست که برای در نظر گرفتن یک <strong>Architecture</strong> عالی به آن نیاز دارید.
  </p>
  <p>
   
  </p>
  <p>
   یکی از تاکتیک‌های اساسی تشخیص خطا، این است که قبل از وقوع آن، شکست را پیش‌بینی کنید.
  </p>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   در این فصل، ما به بحث در مورد <strong>Tactics</strong> و چگونگی <strong>Implementing</strong> آنها می‌پردازیم.
  </p>
  <p>
   
  </p>
  <p>
   در این مورد، یک <strong>Architect</strong> باید تصمیمات طراحی را در مورد راه‌های مختلف برای مقابله با آن، در نظر بگیرد.
  </p>
  <p>
   
  </p>
  <p>
   این، مجموعه‌ای از تصمیمات است که یک <strong>Architect</strong> باید در هنگام تلاش برای <strong>Implementing</strong> یک <strong>Architecture</strong>، آنها را در نظر بگیرد.
  </p>
  <p>
   
  </p>
  <p>
   در اینجا، ما یک نمای کلی در مورد نحوه نگاه به این موضوع ارائه می‌دهیم.
  </p>
  <p>
   
  </p>
  <p>
   در مورد در دسترس بودن، چندین تاکتیک و راه‌حل وجود دارد که می‌توان از آنها استفاده کرد.
  </p>
  <p>
   
  </p>
  <p>
   این، جنبه‌های بسیار اساسی در دسترس بودن است.
  </p>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   بنابراین، درک راه‌حل‌های مختلف بسیار مهم است.
  </p>
  <p>
   
  </p>
  <p>
   یک تاکتیک دیگر که <strong>Architects</strong> می‌توانند استفاده کنند، <strong>Rollback</strong> است.
  </p>
  <p>
   
  </p>
  <p>
   همانطور که در بالا مشاهده می‌شود، یک <strong>Tactics</strong> از طریق یک <strong>Quality Attribute Scenario</strong>، برای اطمینان از در دسترس بودن به کار می‌رود.
  </p>
  <p>
   
  </p>
  <p>
   تاکتیک‌های در دسترس بودن را می‌توان در موارد زیر طبقه‌بندی کرد:
  </p>
  <ul>
   <li>
    جلوگیری از شکست
   </li>
   <li>
    تشخیص شکست
   </li>
   <li>
    بازیابی از شکست
   </li>
  </ul>
  <p>
   تاکتیک‌های تشخیص خطا به گونه‌ای طراحی شده‌اند که تشخیص دهند چه زمانی یک <strong>Component</strong> شکست خورده است.
  </p>
  <p>
   
  </p>
  <p>
   این‌ها، رویکردهایی برای مقابله با مسائل در مورد در دسترس بودن هستند.
  </p>
  <p>
   
  </p>
  <p>
   برخی از <strong>Tactics</strong>های رایج عبارتند از:
  </p>
  <ol>
   <li>
    <strong>Ping/Echo</strong>
   </li>
   <li>
    مانیتور
   </li>
   <li>
    <strong>Heartbeat</strong>
   </li>
   <li>
    مهر زمانی
   </li>
   <li>
    بررسی صحت
   </li>
   <li>
    نظارت بر شرایط
   </li>
   <li>
    رأی‌گیری
   </li>
   <li>
    تشخیص استثنا
   </li>
   <li>
    خودآزمایی
   </li>
  </ol>
  <p>
   همانطور که در مورد بحث <strong>Availability</strong> می‌بینیم، اینها مواردی هستند که <strong>Architects</strong> باید به آنها توجه کنند.
  </p>
  <p>
   
  </p>
  <p>
   <strong>Architects</strong> باید تشخیص دهند که کدام عناصر ممکن است باعث شکست شوند.
  </p>
  <p>
   
  </p>
  <p>
   هدف از این، درک بهترین راه‌حل برای استفاده است.
  </p>
  <p>
   
  </p>
  <p>
   درست مانند فصل‌های قبلی، شما نیاز دارید که یک درک جامع از این موضوع داشته باشید.
  </p>
  <p>
   
  </p>
  <p>
   این، شامل یک درک اساسی از <strong>Software Architecture</strong> و درک اینکه چگونه می‌تواند در دسترس بودن را تحت تأثیر قرار دهد، می‌شود.
  </p>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   برخی از <strong>Tactics</strong>ها، مانند <strong>Ping/Echo</strong> و <strong>Heartbeat</strong>، برای شناسایی مشکلات در یک <strong>System</strong> در نظر گرفته شده‌اند.
  </p>
  <p>
   
  </p>
  <p>
   مانند سایر جنبه‌های یک <strong>Architecture</strong>، در دسترس بودن در مورد <strong>Tradeoffs</strong> است.
  </p>
  <p>
   
  </p>
  <p>
   برای یادگیری مطالب بیشتر در مورد این موضوع، نگاهی به فصل‌های زیر بیندازید.
  </p>
  <p>
   
  </p>
  <p>
   همانطور که قبلاً در فصل‌های قبل بحث کردیم، این <strong>Tactics</strong>، اغلب با استفاده از <strong>Architectural Patterns</strong>، <strong>Implement</strong> می‌شوند.
  </p>
  <p>
   
  </p>
  <p>
   <strong>Architects</strong>، به این درک نیاز دارند که این الگوها و تصمیمات، چگونه بر قابلیت اطمینان و در دسترس بودن تأثیر می‌گذارند.
  </p>
  <p>
   
  </p>
  <p>
   همانطور که قبلاً در مورد آن صحبت کردیم، یک <strong>Architect</strong> باید اطمینان حاصل کند که می‌تواند این <strong>Tradeoffs</strong> را با درک دقیق و روشنی از آنچه در حال ساخت آن است، درک کند.
  </p>
  <p>
   
  </p>
  <p>
   در این فصل، ما <strong>Tactics</strong> مختلفی را پوشش خواهیم داد که می‌توانید برای اطمینان از وجود <strong>System Availability</strong> از آنها استفاده کنید.
  </p>
  <p>
   
  </p>
  <p>
   این تاکتیک‌ها به این صورت دسته‌بندی می‌شوند:
  </p>
  <ul>
   <li>
    جلوگیری از خطا
   </li>
   <li>
    تشخیص خطا
   </li>
   <li>
    بازیابی از خطا
   </li>
  </ul>
  <p>
   
  </p>
  <p>
   هر یک از این تاکتیک‌ها با در دسترس بودن در ارتباط هستند.
  </p>
  <p>
   
  </p>
  <p>
   به همین دلیل، شناخت آنها ضروری است.
  </p>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   همچنین، به یاد داشته باشید که <strong>Architectural Patterns</strong> اغلب می‌توانند در <strong>Process</strong>، <strong>Implement</strong> شوند.
  </p>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   آنها معمولاً به‌جای انتخاب‌های فردی، راه‌حل‌های طراحی را ارائه می‌دهند.
  </p>
  <p>
   
  </p>
  <p>
   این بدان معناست که شما نیازی به اتخاذ چندین تصمیم مختلف ندارید.
  </p>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   در نهایت، هنگام بررسی سیستم‌ها و <strong>Architectures</strong>، این <strong>Design Checklist</strong> را در نظر داشته باشید تا به ایجاد یک <strong>Architecture</strong> که قابلیت اطمینان را دارد، کمک کنید.
  </p>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   متعاقباً، می‌توانیم هر یک از این موضوعات را از طریق جنبه‌های مختلف <strong>Process</strong> بررسی کنیم.
  </p>
  <p>
   
  </p>
  <p>
   
  </p>
  <p>
   
  </p>
  <h4>4.7  خلاصه</h4>
  <p>
   الزامات <strong>Quality Attribute</strong>، ساختارها و عملکردهایی را تعیین می‌کنند که باید در <strong>Architecture</strong> وجود داشته باشند.
  </p>
  <p>
   
  </p>
  <p>
   بنابراین، ما در اینجا نشان می‌دهیم که یک <strong>Architect</strong> چگونه می‌تواند اینها را در نظر بگیرد.
  </p>
  <p>
   
  </p>
  <p>
   ما رویکردهای مختلفی را برای اطمینان از در دسترس بودن سیستم بیان می‌کنیم، که شامل:
  </p>
  <ol>
   <li>
    جلوگیری از خطا
   </li>
   <li>
    تشخیص خطا
   </li>
   <li>
    بازیابی از خطا
   </li>
  </ol>
  <p>
   
  </p>
  <p>
   در ادامه، ما همچنین در مورد <strong>Architectural Patterns</strong> و روش‌های استفاده از آنها برای ایجاد سیستم‌ها بحث می‌کنیم.
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>