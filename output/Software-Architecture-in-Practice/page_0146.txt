7.3  A Design Checklist for Modifiability
125
In general, the later in the life cycle we can bind values, the better. However, 
putting the mechanisms in place to facilitate that late binding tends to be more 
expensive—yet another tradeoff. And so the equation on page 118 comes into 
play. We want to bind as late as possible, as long as the mechanism that allows it 
is cost-effective.
Tactics to bind values at compile time or build time include these:
■
■Component replacement (for example, in a build script or makefile)
■
■Compile-time parameterization
■
■Aspects
Tactics to bind values at deployment time include this:
■
■Configuration-time binding
Tactics to bind values at startup or initialization time include this:
■
■Resource files
Tactics to bind values at runtime include these:
■
■Runtime registration
■
■Dynamic lookup (e.g., for services)
■
■Interpret parameters
■
■Startup time binding
■
■Name servers
■
■Plug-ins
■
■Publish-subscribe
■
■Shared repositories
■
■Polymorphism
Separating building a mechanism for modifiability from using the 
mechanism to make a modification admits the possibility of different stakeholders 
being involved—one stakeholder (usually a developer) to provide the mechanism 
and another stakeholder (an installer, for example, or a user) to exercise it later, 
possibly in a completely different life-cycle phase. Installing a mechanism so that 
someone else can make a change to the system without having to change any 
code is sometimes called externalizing the change.
7.3  A Design Checklist for Modifiability
Table 7.2 is a checklist to support the design and analysis process for modifiability.
