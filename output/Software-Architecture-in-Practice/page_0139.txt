118 
Part Two  Quality Attributes	
7—Modifiability
■
■When is the change made and who makes it? Most commonly in the 
past, a change was made to source code. That is, a developer had to make 
the change, which was tested and then deployed in a new release. Now, 
however, the question of when a change is made is intertwined with the 
question of who makes it. An end user changing the screen saver is clearly 
making a change to one of the aspects of the system. Equally clear, it is 
not in the same category as changing the system so that it can be used 
over the web rather than on a single machine. Changes can be made to the 
implementation (by modifying the source code), during compile (using 
compile-time switches), during build (by choice of libraries), during 
configuration setup (by a range of techniques, including parameter setting), 
or during execution (by parameter settings, plugins, etc.). A change can also 
be made by a developer, an end user, or a system administrator.
■
■What is the cost of the change? Making a system more modifiable involves 
two types of cost:
■
■The cost of introducing the mechanism(s) to make the system more 
modifiable
■
■The cost of making the modification using the mechanism(s) 
For example, the simplest mechanism for making a change is to wait for 
a change request to come in, then change the source code to accommodate the 
request. The cost of introducing the mechanism is zero; the cost of exercising 
it is the cost of changing the source code and revalidating the system. At the 
other end of the spectrum is an application generator, such as a user interface 
builder. The builder takes as input a description of the designer user interface 
produced through direct manipulation techniques and produces (usually) source 
code. The cost of introducing the mechanism is the cost of constructing the UI 
builder, which can be substantial. The cost of using the mechanism is the cost of 
producing the input to feed the builder (cost can be substantial or negligible), the 
cost of running the builder (approximately zero), and then the cost of whatever 
testing is performed on the result (usually much less than usual).
For N similar modifications, a simplified justification for a change mecha-
nism is that 
N × Cost of making the change without the mechanism <_  
Cost of installing the mechanism +  
(N × Cost of making the change using the mechanism).
N is the anticipated number of modifications that will use the modifiability 
mechanism, but N is a prediction. If fewer changes than expected come in, then 
an expensive modification mechanism may not be warranted. In addition, the cost 
of creating the modifiability mechanism could be applied elsewhere—in adding 
functionality, in improving the performance, or even in nonsoftware investments 
such as buying tech stocks. Also, the equation does not take time into account. It 
