<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 160</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>8.2  Tactics for Performance</h4>
  <p>
   Cost is usually a consideration in the choice of resources, but increasing the
   resources is definitely a tactic to reduce <strong>latency</strong> and in many cases is the
   cheapest way to get immediate improvement.
  </p>
  <ul>
   <li>
    Introduce concurrency. اگر درخواست‌ها را بتوان به صورت موازی پردازش کرد، زمان مسدود شده را می توان کاهش داد. <strong>Concurrency</strong> را می توان با پردازش جریان های مختلف رویدادها در <strong>threads</strong> مختلف یا با ایجاد <strong>threads</strong> اضافی برای پردازش مجموعه های مختلف فعالیت ها معرفی کرد. هنگامی که <strong>concurrency</strong> معرفی شد، می توان از سیاست های زمانبندی برای دستیابی به اهدافی که مطلوب می دانید استفاده کرد. سیاست های زمانبندی مختلف ممکن است انصاف (همه درخواست‌ها زمان مساوی دریافت می‌کنند)، <strong>throughput</strong> (کوتاه‌ترین زمان برای اولین بار) یا اهداف دیگر را به حداکثر برسانند. (به نوار کناری مراجعه کنید.)
   </li>
   <li>
    Maintain multiple copies of computations. سرورهای متعدد در یک الگوی <strong>client-server</strong>، نسخه‌های تکراری از محاسبات هستند. هدف از <strong>replicas</strong>، کاهش رقابتی است که در صورت انجام تمام محاسبات در یک سرور واحد رخ می دهد. یک <strong>load balancer</strong> قطعه ای از نرم افزار است که کار جدید را به یکی از سرورهای تکراری موجود اختصاص می دهد. معیارهای اختصاص متفاوت است اما می تواند به سادگی <strong>round-robin</strong> یا اختصاص درخواست بعدی به سرور کم کار باشد.
   </li>
   <li>
    Maintain multiple copies of data. Caching یک تاکتیک است که شامل نگه داشتن کپی هایی از داده ها (احتمالاً یک زیر مجموعه از دیگری) در فضای ذخیره سازی با سرعت های دسترسی متفاوت است. سرعت های دسترسی متفاوت ممکن است ذاتی (حافظه در مقابل فضای ذخیره سازی ثانویه) باشند یا ممکن است به دلیل ضرورت ارتباط شبکه باشند. <strong>Data replication</strong> شامل نگه داشتن کپی های جداگانه ای از داده ها برای کاهش رقابت از دسترسی های همزمان متعدد است. از آنجایی که داده هایی که در حال <strong>cached</strong> یا <strong>replicated</strong> هستند معمولاً یک کپی از داده های موجود هستند، حفظ سازگاری و همگام سازی کپی ها به مسئولیتی تبدیل می شود که سیستم باید بپذیرد. مسئولیت دیگر انتخاب داده هایی است که باید <strong>cached</strong> شوند. برخی از <strong>caches</strong> با صرفاً نگه داشتن کپی هایی از هر چیزی که اخیراً درخواست شده است، عمل می کنند، اما همچنین می توان درخواست های آتی کاربران را بر اساس الگوهای رفتاری پیش بینی کرد و محاسبات یا <strong>prefetches</strong> لازم برای انطباق با آن درخواست ها را قبل از اینکه کاربر آنها را انجام دهد، شروع کرد.
   </li>
   <li>
    Bound queue sizes. این تعداد حداکثر ورودهای صف را کنترل می کند و در نتیجه منابعی که برای پردازش ورودی ها استفاده می شود. اگر این تاکتیک را اتخاذ کنید، باید سیاستی را برای آنچه در هنگام سرریز شدن صف‌ها اتفاق می‌افتد، اتخاذ کنید و تصمیم بگیرید که آیا پاسخ ندادن به رویدادهای از دست رفته قابل قبول است یا خیر. این تاکتیک اغلب با تاکتیک <strong>limit event response</strong> جفت می شود.
   </li>
   <li>
    Schedule resources. هر زمان که برای یک منبع رقابتی وجود داشته باشد، منبع باید زمانبندی شود. پردازنده ها زمانبندی می شوند، بافرها زمانبندی می شوند و شبکه ها زمانبندی می شوند. هدف شما این است که ویژگی های استفاده از هر منبع را درک کنید و استراتژی زمانبندی را انتخاب کنید که با آن سازگار باشد. (به نوار کناری مراجعه کنید.)
   </li>
  </ul>
  <p>
   تاکتیک های <strong>performance</strong> در شکل 8.3 خلاصه شده است.
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>