4 
Part One  Introduction	
1—What Is Software Architecture?
In this chapter we will focus on architecture strictly from a software engineer-
ing point of view. That is, we will explore the value that a software architecture 
brings to a development project. (Later chapters will take a business and organi-
zational perspective.)
1.1  What Software Architecture Is and What It Isn’t
There are many definitions of software architecture, easily discoverable with 
a web search, but the one we like is this one:
The software architecture of a system is the set of structures needed to 
reason about the system, which comprise software elements, relations 
among them, and properties of both. 
This definition stands in contrast to other definitions that talk about the sys-
tem’s “early” or “major” design decisions. While it is true that many architectural 
decisions are made early, not all are—especially in Agile or spiral-development 
projects. It’s also true that very many decisions are made early that are not archi-
tectural. Also, it’s hard to look at a decision and tell whether or not it’s “major.” 
Sometimes only time will tell. And since writing down an architecture is one of 
the architect’s most important obligations, we need to know now which decisions 
an architecture comprises.
Structures, on the other hand, are fairly easy to identify in software, and they 
form a powerful tool for system design. 
Let us look at some of the implications of our definition. 
Architecture Is a Set of Software Structures
This is the first and most obvious implication of our definition. A structure is sim-
ply a set of elements held together by a relation. Software systems are composed 
of many structures, and no single structure holds claim to being the architecture. 
There are three categories of architectural structures, which will play an import-
ant role in the design, documentation, and analysis of architectures:
1.	
First, some structures partition systems into implementation units, which 
in this book we call modules. Modules are assigned specific computational 
responsibilities, and are the basis of work assignments for programming 
teams (Team A works on the database, Team B works on the business rules, 
Team C works on the user interface, etc.). In large projects, these elements 
(modules) are subdivided for assignment to subteams. For example, the da-
tabase for a large enterprise resource planning (ERP) implementation might 
be so complex that its implementation is split into many parts. The structure 
that captures that decomposition is a kind of module structure, the module 
