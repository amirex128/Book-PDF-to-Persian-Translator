<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 277</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
  <h3>13—Architectural Tactics and Patterns</h3>
  <p>
    256
  </p>
  <p>
    <em>Part Two Quality Attributes</em>
  </p>
  <p>
    نشان می‌دهد که سه تاکتیک <em>redundancy</em> شناخته‌شده از فصل 5: <em>active redundancy</em>، <em>passive redundancy</em>، و <em>cold spare</em>. هدف ما این است که هر گزینه <em>redundancy</em> را برای <em>availability</em> آن تجزیه و تحلیل کنیم، تا به ما در انتخاب یک مورد کمک کند.
  </p>
  <p>
    همانطور که به یاد دارید، هر یک از این تاکتیک‌ها یک نسخه پشتیبان از یک <em>component</em> را معرفی می‌کنند که در صورت شکست <em>component</em> اصلی، کنترل را در دست می‌گیرد. در مورد ما، یک <em>broker replica</em> به‌عنوان <em>redundant spare</em> به‌کار گرفته شده است. تفاوت بین آنها این است که هر پشتیبان، خود را با رویدادهای جاری تا چه حد به‌روز نگه می‌دارد:
  </p>
  <ul>
    <li>
      در مورد <em>active redundancy</em>، <em>brokers</em> فعال و <em>redundant</em> هر دو نسخه‌های یکسانی از پیام‌های دریافتی از <em>client</em> و <em>server proxies</em> را دریافت می‌کنند. <em>The internal broker state</em> به‌طور همزمان بین <em>active</em> و <em>redundant spare</em> نگهداری می‌شود تا <em>failover</em> سریع را پس از تشخیص خطا در <em>active broker</em> تسهیل کند.
    </li>
    <li>
      برای پیاده‌سازی <em>passive redundancy</em>، فقط <em>active broker</em>، پیام‌ها را از <em>client</em> و <em>server proxies</em> دریافت و پردازش می‌کند. هنگام استفاده از این تاکتیک، <em>checkpoints</em> از <em>internal broker state</em> به‌طور دوره‌ای از فرآیند <em>active broker</em> به <em>redundant spare</em> منتقل می‌شوند، با استفاده از تاکتیک <em>checkpoint-based rollback</em>.
    </li>
    <li>
      در نهایت، هنگام استفاده از تاکتیک <em>cold spare</em>، فقط <em>active broker</em>، پیام‌ها را از <em>client</em> و <em>server proxies</em> دریافت و پردازش می‌کند، زیرا <em>redundant spare</em> در یک <em>dormant</em> یا حتی <em>powered-off state</em> است. استراتژی‌های بازیابی با استفاده از این تاکتیک شامل راه‌اندازی، بوت شدن و بارگذاری پیاده‌سازی <em>broker</em> در <em>spare</em> است. در این سناریو، <em>internal broker state</em>، به‌جای عملیات همزمان یا <em>checkpointing</em>، که برای دو تاکتیک <em>redundancy</em> دیگر توضیح داده شد، ارگانیک بازسازی می‌شود.
    </li>
  </ul>
  <p>
    علاوه بر این، فرض کنید که ما خرابی را با تاکتیک <em>heartbeat</em> تشخیص می‌دهیم، که در آن هر <em>broker</em> (فعال و یدکی) به‌طور دوره‌ای یک پیام <em>heartbeat</em> را به یک فرآیند جداگانه ارسال می‌کند که مسئول تشخیص خطا، همبستگی، گزارش‌دهی و بازیابی است. این فرآیند <em>fault manager</em>، مسئول هماهنگی انتقال نقش <em>active broker</em> از فرآیند <em>failed broker</em> به <em>redundant spare</em> است.
  </p>
  <p>
    اکنون می‌توانید از مدل <em>steady state</em> <em>availability</em> برای اختصاص مقادیر برای <em>MTBF</em> و <em>MTTR</em> برای هر یک از سه تاکتیک <em>redundancy</em> که در نظر داریم، استفاده کنید. انجام این کار، تمرینی است که به خواننده واگذار می‌شود (همانطور که وقتی به سؤالات بحث برای این فصل می‌رسید مشاهده خواهید کرد). از آنجایی که این سه تاکتیک، عمدتاً در مدت زمانی که برای راه‌اندازی نسخه پشتیبان زمان می‌برد، متفاوت هستند، <em>MTTR</em> جایی است که تفاوت بین تاکتیک‌ها نشان داده می‌شود.
  </p>
  <p>
    مدل‌های پیچیده‌تری از <em>availability</em> وجود دارد که مبتنی بر احتمال هستند. در این مدل‌ها، می‌توانیم احتمال شکست را در یک دوره زمانی بیان کنیم. با توجه به یک <em>MTBF</em> خاص و یک مدت زمان <em>T</em>، احتمال شکست <em>R</em> توسط
    <br>
    <em>R(T ) = e(    ) –T / MTBF</em>
  </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>