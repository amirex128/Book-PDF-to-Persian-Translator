13.2  Overview of the Patterns Catalog
213
to the user interface software separate from the rest of the system. Users often 
wish to look at data from different perspectives, such as a bar graph or a pie chart. 
These representations should both reflect the current state of the data. 
Problem: How can user interface functionality be kept separate from application 
functionality and yet still be responsive to user input, or to changes in the under-
lying application’s data? And how can multiple views of the user interface be cre-
ated, maintained, and coordinated when the underlying application data changes?
Solution: The model-view-controller (MVC) pattern separates application func-
tionality into three kinds of components: 
■
■A model, which contains the application’s data
■
■A view, which displays some portion of the underlying data and interacts 
with the user
■
■A controller, which mediates between the model and the view and manages 
the notifications of state changes
MVC is not appropriate for every situation. The design and implementation 
of three distinct kinds of components, along with their various forms of 
interaction, may be costly, and this cost may not make sense for relatively 
simple user interfaces. Also, the match between the abstractions of MVC and 
commercial user interface toolkits is not perfect. The view and the controller split 
apart input and output, but these functions are often combined into individual 
widgets. This may result in a conceptual mismatch between the architecture and 
the user interface toolkit.
Table 13.3 summarizes the solution of the MVC pattern.
Table 13.3  Model-View-Controller Pattern Solution
Overview
The MVC pattern breaks system functionality into three components: a 
model, a view, and a controller that mediates between the model and 
the view.
Elements
The model is a representation of the application data or state, and it 
contains (or provides an interface to) application logic.
The view is a user interface component that either produces a 
representation of the model for the user or allows for some form of 
user input, or both.
The controller manages the interaction between the model and the 
view, translating user actions into changes to the model or changes to 
the view.
Relations
The notifies relation connects instances of model, view, and controller, 
notifying elements of relevant state changes. 
Constraints
There must be at least one instance each of model, view, and 
controller.
The model component should not interact directly with the controller.
Weaknesses
The complexity may not be worth it for simple user interfaces.
The model, view, and controller abstractions may not be good fits for 
some user interface toolkits.
