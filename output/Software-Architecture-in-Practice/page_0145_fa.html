<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 145</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h3>7—Modifiability</h3>
  <p>
   از مصرف کنندگان آن است. همچنین یک <strong>shared data repository</strong> اینگونه خواهد بود، که خوانندگان یک قطعه داده را از نویسندگان آن داده جدا می کند. در یک <strong>service-oriented architecture</strong> که در آن <strong>services</strong> یکدیگر را با <strong>dynamic lookup</strong> کشف می کنند، <strong>directory service</strong> یک واسطه است.
  </p>
  <ul>
   <li>
    Restrict dependencies تاکتیکی است که ماژول هایی را که یک ماژول معین با آنها تعامل دارد یا به آنها وابسته است، محدود می کند. در عمل این تاکتیک با محدود کردن دید یک ماژول به دست می آید (زمانی که <strong>developers</strong> نمی توانند یک <strong>interface</strong> را ببینند، نمی توانند از آن استفاده کنند) و با <strong>authorization</strong> (محدود کردن دسترسی فقط به ماژول های مجاز). این تاکتیک در معماری های لایه ای دیده می شود، که در آن یک لایه فقط مجاز به استفاده از لایه های پایین تر است (گاهی فقط لایه بعدی) و در استفاده از <strong>wrappers</strong>، جایی که موجودیت های خارجی فقط می توانند (و از این رو به) <strong>wrapper</strong> و نه <strong>functionality</strong> داخلی که آن را احاطه کرده است، وابسته باشند.
   </li>
   <li>
    Refactor تاکتیکی است که زمانی انجام می شود که دو ماژول تحت تأثیر یک تغییر قرار می گیرند زیرا (حداقل جزئی) کپی یکدیگر هستند. بازسازی کد یک عمل اصلی پروژه های توسعه <strong>Agile</strong> است، به عنوان یک مرحله پاکسازی برای اطمینان از اینکه تیم ها کد تکراری یا بیش از حد پیچیده تولید نکرده اند. با این حال، این مفهوم در مورد عناصر معماری نیز صدق می کند. مسئولیت های مشترک (و کدی که آنها را پیاده سازی می کند) از ماژول هایی که در آن وجود دارند "فاکتور" می شوند و خانه مناسبی برای خود اختصاص می دهند. با قرار دادن مسئولیت های مشترک - یعنی ساختن آنها <strong>submodules</strong> از همان ماژول والد - <strong>architect</strong> می تواند <strong>coupling</strong> را کاهش دهد.
   </li>
   <li>
    Abstract common services. در مواردی که دو ماژول خدمات نه کاملاً یکسان، اما مشابه ارائه می دهند، پیاده سازی <strong>services</strong> فقط یک بار در یک فرم کلی تر (انتزاعی) می تواند مقرون به صرفه باشد. سپس هر گونه اصلاح در <strong>service</strong> (مشترک) فقط باید در یک مکان رخ دهد، که هزینه های اصلاح را کاهش می دهد. یک راه معمول برای معرفی یک انتزاع، <strong>parameterizing</strong> توصیف (و پیاده سازی) فعالیت های یک ماژول است. پارامترها می توانند به سادگی مقادیری برای متغیرهای کلیدی یا به پیچیدگی عباراتی در یک زبان تخصصی باشند که متعاقباً تفسیر می شوند.
   </li>
  </ul>
  <p>
   Defer Binding
  </p>
  <p>
   از آنجایی که کار مردم تقریباً همیشه گران‌تر از کار کامپیوترها است، اجازه دادن به کامپیوترها برای رسیدگی به یک تغییر تا حد امکان، تقریباً همیشه هزینه ایجاد آن تغییر را کاهش می‌دهد. اگر <strong>artifacts</strong> را با انعطاف‌پذیری داخلی طراحی کنیم، اعمال آن انعطاف‌پذیری معمولاً ارزان‌تر از کدنویسی دستی یک تغییر خاص است.
  </p>
  <p>
   Parameters شاید شناخته شده ترین مکانیسم برای معرفی انعطاف پذیری باشد و این یادآور تاکتیک abstract common services است. یک تابع پارامتری f(a, b) عمومی تر از تابع مشابه f(a) است که b = 0 را فرض می کند. هنگامی که مقدار برخی از پارامترها را در فاز متفاوتی از چرخه عمر نسبت به موردی که در آن پارامترها را تعریف کردیم، <strong>bind</strong> می کنیم، در حال اعمال تاکتیک <strong>defer binding</strong> هستیم.
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>