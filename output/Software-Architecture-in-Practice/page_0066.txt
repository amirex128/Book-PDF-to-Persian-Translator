3.2  Architecture in a Project Life-Cycle Context
45
methodologies as Agile. What distinguishes Agile practices is early 
and frequent delivery of working software, close collaboration between 
developers and customers, self-organizing teams, and a focus on adaptation 
to changing circumstances (such as late-arriving requirements). All Agile 
methodologies focus on teamwork, adaptability, and close collaboration 
(both within the team and between team members and customers/end 
users). These methodologies typically eschew substantial up-front work, 
on the assumption that requirements always change, and they continue to 
change throughout the project’s life cycle. As such, it might seem that Agile 
methodologies and architecture cannot happily coexist. As we will show in 
Chapter 15, this is not so.
4.	
Model-driven development. Model-driven development is based on the 
idea that humans should not be writing code in programming languages, 
but they should be creating models of the domain, from which code is 
automatically generated. Humans create a platform-independent model 
(PIM), which is combined with a platform-definition model (PDM) to 
generate running code. In this way the PIM is a pure realization of the 
functional requirements while the PDM addresses platform specifics and 
quality attributes.
All of these processes include design among their obligations, and because 
architecture is a special kind of design, architecture finds a home in each one. 
Changing from one development process to another in the middle of a project re-
quires the architect to save useful information from the old process and determine 
how to integrate it into the new process.
No matter what software development process or life-cycle model you’re 
using, there are a number of activities that are involved in creating a software 
architecture, using that architecture to realize a complete design, and then imple-
menting or managing the evolution of a target system or application. The process 
you use will determine how often and when you revisit and elaborate each of 
these activities. These activities include: 
1.	
Making a business case for the system 
2.	
Understanding the architecturally significant requirements 
3.	
Creating or selecting the architecture
4.	
Documenting and communicating the architecture 
5.	
Analyzing or evaluating the architecture
6.	
Implementing and testing the system based on the architecture
7.	
Ensuring that the implementation conforms to the architecture
Each of these activities is covered in a chapter in Part III of this book, and 
described briefly below.
