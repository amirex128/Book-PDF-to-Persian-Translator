2.2  Reasoning About and Managing Change
27
A good architecture is necessary, but not sufficient, to ensure quality. Achiev-
ing quality attributes must be considered throughout design, implementation, and 
deployment. No quality attribute is entirely dependent on design, nor is it entirely 
dependent on implementation or deployment. Satisfactory results are a matter of 
getting the big picture (architecture) as well as the details (implementation) correct. 
For example, modifiability is determined by how functionality is divided 
and coupled (architectural) and by coding techniques within a module (nonar-
chitectural). Thus, a system is typically modifiable if changes involve the fewest 
possible number of distinct elements. In spite of having the ideal architecture, 
however, it is always possible to make a system difficult to modify by writing 
obscure, tangled code. 
2.2  Reasoning About and Managing Change
This point is a corollary to the previous point.
Modifiability—the ease with which changes can be made to a system—is 
a quality attribute (and hence covered by the arguments in the previous section), 
but it is such an important quality that we have awarded it its own spot in the List 
of Thirteen. The software development community is coming to grips with the 
fact that roughly 80 percent of a typical software system’s total cost occurs after 
initial deployment. A corollary of this statistic is that most systems that people 
work on are in this phase. Many programmers and software designers never get 
to work on new development; they work under the constraints of the existing 
architecture and the existing body of code. Virtually all software systems change 
over their lifetime, to accommodate new features, to adapt to new environments, 
to fix bugs, and so forth. But these changes are often fraught with difficulty. 
Every architecture partitions possible changes into three categories: local, 
nonlocal, and architectural. 
■
■A local change can be accomplished by modifying a single element. For 
example, adding a new business rule to a pricing logic module. 
■
■A nonlocal change requires multiple element modifications but leaves 
the underlying architectural approach intact. For example, adding a new 
business rule to a pricing logic module, then adding new fields to the 
database that this new business rule requires, and then revealing the results 
of the rule in the user interface. 
■
■An architectural change affects the fundamental ways in which the 
elements interact with each other and will probably require changes all 
over the system. For example, changing a system from client-server to 
peer-to-peer. 
