<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 111</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>4.6  تاکتیک‌ها برای در دسترس بودن</h4>
  <p>
   
  </p>
  <p>
   یک سیستم را قادر سازید تا خطاهای سیستم را تحمل کند، به‌طوری‌که یک <strong>Service</strong> که توسط سیستم ارائه می‌شود، با مشخصات آن مطابقت داشته باشد.
  </p>
  <p>
   آنها در برابر شکست، از جمله خود تخریبی (خودویرانی) و همچنین حملات فعال، مقاوم خواهند بود.
  </p>
  <p>
   یک تاکتیک، تصمیم طراحی است که بر یک <strong>Quality Attribute Response</strong> تأثیر می‌گذارد.
  </p>
  <p>
   در یک طراحی خاص، <strong>Tactics</strong>، <strong>Architects</strong> را قادر می‌سازد تا یک <strong>Architecture</strong> را بسازند که <strong>Quality Attribute</strong>های مورد نظر را محقق کند.
  </p>
  <p>
   
  </p>
  <p>
   محرک:
  </p>
  <p>
   یک شکست (یا ترکیبی از شکست‌ها)
  </p>
  <p>
   پاسخ:
  </p>
  <p>
   بهبود و به حداقل رساندن زمان از کار افتادگی خدمات.
  </p>
  <p>
   <strong>Tactics</strong> برای در دسترس بودن:
  </p>
  <ul>
   <li>
    تشخیص خطاها
   </li>
   <li>
    جلوگیری از خطاها
   </li>
   <li>
    بهبودی از خطاها
   </li>
  </ul>
  <p>
   همچنین، اگر یک <strong>Component</strong> دارای یک <strong>Fault</strong> باشد، با استفاده از این تاکتیک، این <strong>Component</strong> از سرویس خارج می‌شود. برای مثال، مانیتور سیستم می‌تواند خودآزمایی را آغاز کند، یا <strong>Component</strong> باشد که مهر زمانی معیوب یا ضربان قلب از دست رفته را تشخیص می‌دهد.
  </p>
  <p>
   
  </p>
  <p>
   با تشخیص خطاها، سیستم‌های در دسترس بودن ممکن است برای کاهش زمان خرابی، قبل از تبدیل شدن خطاها به شکست، آماده شوند.
  </p>
  <p>
   
  </p>
  <p>
   سیستم‌های با قابلیت اطمینان بالا، معمولاً با یک <strong>Fault</strong> به صورت پیش‌بینی شده یا پیشگیرانه (به‌جای واکنشی) مقابله می‌کنند و تلاش می‌کنند تا از ایجاد آسیب جلوگیری کنند.
  </p>
  <p>
   
  </p>
  <p>
   <strong>Fault Recovery</strong>، تاکتیک‌ها را توصیف می‌کند که وقتی یک خطا رخ می‌دهد، چه باید کرد.
  </p>
  <p>
   همانطور که در شکل 5.5 (در صفحه بعد) مشاهده می‌شود، رویکردها به سمت بالا از آن طبقه‌بندی <strong>Architecture</strong> با <strong>Tactics</strong> مختلف هستند.
  </p>
  <p>
   
  </p>
  <p>
   همانطور که در بخش قبل توضیح دادیم، این‌ها همگی تصمیمات هستند که توسط <strong>Architects</strong> ایجاد می‌شوند.
  </p>
  <p>
   
  </p>
  <p>
   تکرار یک <strong>Component</strong> در <strong>Redundancy</strong>، ساده‌ترین شکل رأی‌گیری است.
  </p>
  <ul>
   <li>
    تکرار، ساده‌ترین شکل رأی‌گیری است. در اینجا، اجزا دقیقاً کلون یکدیگر هستند. داشتن چندین کپی از اجزای یکسان می‌تواند در محافظت در برابر شکست‌های تصادفی سخت‌افزاری مؤثر باشد، اما این نمی‌تواند در برابر خطاهای طراحی یا <strong>Implementation</strong>، در سخت‌افزار یا نرم‌افزار محافظت کند، زیرا هیچ نوع تنوعی در این تاکتیک تعبیه نشده است.
   </li>
   <li>
    افزونگی عملکردی، شکلی از رأی‌گیری است که برای رسیدگی به مشکل خرابی‌های حالت رایج (خطاهای طراحی یا <strong>Implementation</strong>) در <strong>Components</strong> سخت‌افزاری یا نرم‌افزاری در نظر گرفته شده است. در اینجا، <strong>Components</strong> باید همیشه با توجه به ورودی‌های یکسان، خروجی یکسانی را ارائه دهند، اما آنها به طور متنوع طراحی و به‌طور متفاوتی پیاده‌سازی شده‌اند.
   </li>
   <li>
    افزونگی تحلیلی، نه‌تنها تنوع را در میان بخش‌های خصوصی <strong>Components</strong> مجاز می‌داند، بلکه تنوع را در ورودی‌ها و خروجی‌های <strong>Components</strong> نیز مجاز می‌داند. این تاکتیک، برای تحمل خطاهای مشخصات با استفاده از مشخصات الزامات جداگانه در نظر گرفته شده است. در سیستم‌های تعبیه‌شده، افزونگی تحلیلی همچنین زمانی کمک می‌کند که برخی از منابع ورودی احتمالاً در زمان‌هایی در دسترس نباشند. به عنوان مثال، برنامه‌های <strong>Avionics</strong> راه‌های متعددی برای محاسبه ارتفاع هواپیما دارند، مانند استفاده از فشار بارومتریک، رادار ارتفاع‌سنج، و از نظر هندسی با استفاده از فاصله خط مستقیم و زاویه دید به سمت پایین یک نقطه جلو روی زمین. مکانیسم رأی‌دهی که با افزونگی تحلیلی استفاده می‌شود، باید پیچیده‌تر از صرفاً گذاشتن اکثریت حکم یا محاسبه میانگین ساده باشد. ممکن است مجبور شود بفهمد که کدام سنسورها در حال حاضر قابل اعتماد هستند یا خیر، و ممکن است از آن خواسته شود که با ترکیب و هموار کردن مقادیر فردی در طول زمان، یک مقدار با دقت بالاتر نسبت به هر <strong>Component</strong> فردی تولید کند.
   </li>
  </ul>
  <p>
   تشخیص استثنا به تشخیص وضعیت سیستمی اشاره دارد که جریان اجرای عادی را تغییر می‌دهد. تاکتیک تشخیص استثنا را می‌توان بیشتر اصلاح کرد:
  </p>
  <ul>
   <li>
    استثناهای سیستم با توجه به <strong>Architecture</strong> سخت‌افزاری پردازنده مورد استفاده متفاوت خواهد بود و شامل خطاهایی مانند تقسیم بر صفر، خطاهای <strong>Bus</strong> و آدرس، دستورالعمل‌های غیرقانونی برنامه و غیره می‌شود.
   </li>
   <li>
    تاکتیک <strong>Parameter Fence</strong>، یک الگوی داده <strong>A Priori</strong> (مانند 0xDEADBEEF) را بلافاصله پس از هر پارامتر با طول متغیر یک <strong>Object</strong> قرار می‌دهد. این امر امکان تشخیص زمان اجرای بازنویسی حافظه تخصیص‌یافته برای پارامترهای طول متغیر <strong>Object</strong> را فراهم می‌کند.
   </li>
   <li>
    <strong>Parameter Typing</strong> از یک کلاس پایه استفاده می‌کند که توابعی را تعریف می‌کند که پارامترهای پیام‌های قالب‌بندی شده نوع-طول-مقدار (<strong>TLV</strong>) را اضافه، پیدا و تکرار می‌کنند. کلاس‌های مشتق‌شده از توابع کلاس پایه برای <strong>Implement</strong> کردن توابعی استفاده می‌کنند که تایپ پارامتر را با توجه به ساختار هر پارامتر ارائه می‌دهند. استفاده از تایپ‌بندی قوی برای ساختن و تجزیه پیام‌ها، در دسترس بودن بالاتری نسبت به پیاده‌سازی‌هایی که به‌سادگی با پیام‌ها به‌عنوان <strong>Byte Buckets</strong> رفتار می‌کنند، دارد.
    البته، همه طراحی‌ها شامل مبادلات می‌شوند. هنگامی که از تایپ‌بندی قوی استفاده می‌کنید، معمولاً در دسترس بودن بالاتر را در مقابل سهولت تکامل مبادله می‌کنید.
   </li>
  </ul>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>