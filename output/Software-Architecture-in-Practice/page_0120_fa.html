<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 120</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>5.5  برای مطالعه بیشتر</h4>
  <p>
   همه تاکتیک‌های در دسترس بودن شامل مدل هماهنگی می‌شوند، زیرا مدل هماهنگی باید از خطاهایی که رخ می‌دهند، آگاه باشد تا پاسخ مناسبی ایجاد کند.
  </p>
  <p>
   
  </p>
  <p>
   الگوهای در دسترس بودن:
  </p>
  <ul>
   <li>
    شما می‌توانید الگوهایی برای تحمل خطا را در [Hanmer 07] پیدا کنید.
   </li>
  </ul>
  <p>
   تاکتیک‌های در دسترس بودن، به طور کلی:
  </p>
  <ul>
   <li>
    بحثی دقیق‌تر در مورد برخی از تاکتیک‌های در دسترس بودن در این فصل در [Scott 09] ارائه شده است. این منبع بسیاری از مطالب این فصل است.
   </li>
   <li>
    کارگروه مهندسی اینترنت، تعدادی از استانداردهای پشتیبانی از تاکتیک‌های در دسترس بودن را منتشر کرده است. این استانداردها شامل <strong>Non-stop forwarding</strong> [IETF 04]، <strong>Ping/echo ICMPv6</strong> [IETF 06b]، درخواست/پاسخ <strong>Echo</strong>)، و شبکه‌های <strong>MPLS (LSP Ping)</strong> [IETF 06a] هستند.
   </li>
  </ul>
  <p>
   تاکتیک‌های در دسترس بودن، تشخیص خطا:
  </p>
  <ul>
   <li>
    تاکتیک <strong>Parameter Fence</strong>، برای اولین بار (به دانش ما) در رایانه‌های <strong>Control Data Series</strong> در اواخر دهه 1960 استفاده شد.
   </li>
   <li>
    افزونگی مدولار سه‌گانه (<strong>TMR</strong>)، بخشی از تاکتیک رأی‌گیری، در اوایل دهه 1960 توسط لیونز توسعه داده شد [Lyons 62].
   </li>
   <li>
    تاکتیک تشخیص خطا رأی‌گیری، بر اساس مشارکت‌های اساسی در نظریه اتوماسیون توسط فون نویمان است، که نشان داد چگونه سیستم‌هایی با قابلیت اطمینان تجویز شده را می‌توان از اجزای غیرقابل اعتماد ساخت [Von Neumann 56].
   </li>
  </ul>
  <p>
   تاکتیک‌های در دسترس بودن، بازیابی خطا:
  </p>
  <ul>
   <li>
    پیاده‌سازی‌های مبتنی بر استاندارد افزونگی فعال برای محافظت از لینک‌های شبکه (یعنی، امکانات) هم در لایه فیزیکی [<strong>Bellcore 99, Telcordia</strong> 00] و هم در لایه شبکه/پیوند [<strong>IETF 05</strong>] وجود دارد.
   </li>
   <li>
    <strong>Exception Handling</strong> توسط [<strong>Powel Douglass 99</strong>] نوشته شده است. سپس نرم‌افزار می‌تواند از این اطلاعات برای پنهان کردن خطا استفاده کند، معمولاً با اصلاح علت استثنا و تلاش مجدد عملیات.
   </li>
   <li>
    [<strong>Morelos-Zaragoza 06</strong>] و [<strong>Schneier 96</strong>] در مورد مقایسه وضعیت در حین همگام‌سازی مجدد، نوشته‌اند.
   </li>
   <li>
    برخی از نمونه‌هایی از اینکه چگونه یک سیستم می‌تواند از طریق استفاده (تخریب) تنزل پیدا کند، در [<strong>Nygard 07</strong>] ارائه شده است.
   </li>
   <li>
    [<strong>Utas 05</strong>] در مورد راه‌اندازی مجدد تشدیدکننده نوشته است.
   </li>
  </ul>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>