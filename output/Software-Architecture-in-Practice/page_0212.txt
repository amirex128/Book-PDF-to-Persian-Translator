12.3  Software Quality Attributes and System Quality Attributes
191
Two percent of all U.S. electricity now goes to data centers, according 
to the Environmental Protection Agency. Electricity has become the 
biggest cost for processing data—more than the equipment to do it, 
more than the buildings to house that equipment. . . . Google’s making 
data servers that can float offshore, cooled by ocean breezes. HP has 
plans to put data servers near farms, and power them with methane gas 
from cow pies.
The lesson here is that if you are the architect for software that resides in a 
larger system, you will need to understand the quality attributes that are import-
ant for the containing system to achieve, and work with the system architects and 
engineers to see how your software architecture can contribute to achieving them.
The Vanishing Line between Software and System Qualities
This is a book about software architecture, and so we treat quality attri-
butes from a software architect’s perspective. But you may have already 
noticed that the quality attributes that the software architect can bring to 
the party are limited by the architecture of the system in which the soft-
ware runs. 
For example: 
■
■
The performance of a piece of software is fundamentally constrained 
by the performance of the computer that runs it. No matter how well you 
design the software, you just can’t run the latest whole-earth weather 
forecasting models on Grampa’s Commodore 64 and hope to know if it’s 
going to rain tomorrow.
■
■
Physical security is probably more important and more effective than 
software security at preventing fraud and theft. If you don’t believe this, 
write your laptop’s password on a slip of paper, tape it to your laptop, 
and leave it in an unlocked car with the windows down. (Actually, don’t 
really do that. Consider this a thought experiment.) 
■
■
If we’re being perfectly honest here, how usable is a device for web 
browsing that has a screen smaller than a credit card and keys the size 
of a raisin?
For me, nowhere is the barrier between software and system more 
nebulous than in the area of safety. The thought that software—strings 
of 0’s and 1’s—can kill or maim or destroy is still an unnatural notion. Of 
course, it’s not the 0’s and 1’s that wreak havoc. At least, not directly. It’s 
what they’re connected to. Software, and the system in which it runs, has 
to be connected to the outside world in some way before it can do damage. 
That’s the good news. The bad news is that the good news isn’t all that 
good. Software is connected to the outside world, always. If your program 
