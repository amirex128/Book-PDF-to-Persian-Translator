159
10
Testability
Testing leads to failure, and failure 
leads to understanding
—Burt Rutan
Industry estimates indicate that between 30 and 50 percent (or in some cases, 
even more) of the cost of developing well-engineered systems is taken up by test-
ing. If the software architect can reduce this cost, the payoff is large.
Software testability refers to the ease with which software can be made to 
demonstrate its faults through (typically execution-based) testing. Specifically, 
testability refers to the probability, assuming that the software has at least one 
fault, that it will fail on its next test execution. Intuitively, a system is testable if it 
“gives up” its faults easily. If a fault is present in a system, then we want it to fail 
during testing as quickly as possible. Of course, calculating this probability is not 
easy and, as you will see when we discuss response measures for testability, other 
measures will be used.
Figure 10.1 shows a model of testing in which a program processes input 
and produces output. An oracle is an agent (human or mechanical) that decides 
whether the output is correct or not by comparing the output to the program’s 
specification. Output is not just the functionally produced value, but it also can 
include derived measures of quality attributes such as how long it took to produce 
the output. Figure 10.1 also shows that the program’s internal state can also be 
shown to the oracle, and an oracle can decide whether that is correct or not—that 
is, it can detect whether the program has entered an erroneous state and render a 
judgment as to the correctness of the program. 
Setting and examining a program’s internal state is an aspect of testing that 
will figure prominently in our tactics for testability.
