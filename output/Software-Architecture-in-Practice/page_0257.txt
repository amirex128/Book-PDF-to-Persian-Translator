236 
Part Two  Quality Attributes	
13—Architectural Tactics and Patterns
Problem: How can we split the system into a number of computationally inde-
pendent execution structures—groups of software and hardware—connected by 
some communications media? This is done to provide specific server environ-
ments optimized for operational requirements and resource usage. 
Solution: The execution structures of many systems are organized as a set of 
logical groupings of components. Each grouping is termed a tier. The grouping 
of components into tiers may be based on a variety of criteria, such as the type of 
component, sharing the same execution environment, or having the same runtime 
purpose.
The use of tiers may be applied to any collection (or pattern) of runtime 
components, although in practice it is most often used in the context of cli-
ent-server patterns. Tiers induce topological constraints that restrict which com-
ponents may communicate with other components. Specifically, connectors may 
exist only between components in the same tier or residing in adjacent tiers. The 
multi-tier pattern found in many Java EE and Microsoft .NET applications is an 
example of organization in tiers derived from the client-server pattern. 
Additionally, tiers may constrain the kinds of communication that can take 
place across adjacent tiers. For example, some tiered patterns require call-return 
communication in one direction but event-based notification in the other.
The main weakness with the multi-tier architecture is its cost and complex-
ity. For simple systems, the benefits of the multi-tier architecture may not justify 
its up-front and ongoing costs, in terms of hardware, software, and design and 
implementation complexity.
Tiers are not components, but rather logical groupings of components. Also, 
don’t confuse tiers with layers! Layering is a pattern of modules (a unit of imple-
mentation), while tiers applies only to runtime entities. 
Table 13.11 summarizes the solution part of the multi-tier pattern.
Tiers make it easier to ensure security, and to optimize performance and 
availability in specialized ways. They also enhance the modifiability of the sys-
tem, as the computationally independent subgroups need to agree on protocols 
for interaction, thus reducing their coupling.
Figure 13.15 uses an informal notation to describe the multi-tier architecture 
of the Consumer Website Java EE application. This application is part of the Ad-
venture Builder system. Many component-and-connector types are specific to the 
supporting platform, which is Java EE in this case.
