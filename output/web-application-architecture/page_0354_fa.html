<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 354</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>test ما نوشتیم، که در آن ما فقط خود OrderController را تست کردیم، می‌تواند یک تست stable در نظر گرفته شود. عناصر زیادی درگیر نیستند، بنابراین مشکلات نامرتبط زیادی وجود ندارند که بتوانند باعث شکست این test شوند. با این حال، ما تصمیم گرفتیم که assumptionsهای زیادی را تأیید نشده باقی می‌گذارد. استفاده از The WebTestCase، اطمینانی را که ما در کد خود داریم، افزایش می‌دهد، اما مراحل بسیار بیشتری درگیر هستند. چنین تستی می‌تواند به دلایل بی‌شماری نامرتبط شکست بخورد، و از آنجایی که شامل فراخوانی کدهای بیشتری می‌شود، بسیار کندتر نیز خواهد بود. راه‌اندازی یک web server و ایجاد requests HTTP واقعی، تست را حتی کندتر می‌کند و احتمال بیشتری دارد که به دلایل سخت برای اشکال‌زدایی شکست بخورد.</p>
    <p>در تجربه‌ام، سریع و stable نگه داشتن test suite بسیار مهم است. این کار باعث می‌شود که کار من بسیار سرگرم‌کننده شود و من در مورد کیفیت کارم بسیار مطمئن هستم. بنابراین من فکر می‌کنم که اکثر تست‌ها برای incoming adapters نباید requests HTTP واقعی ایجاد کنند. آن‌ها می‌توانند framework را به صورت programmatically فراخوانی کنند و 80٪ از assumptions را تأیید کنند. با این حال، هوشمندانه است که حداقل چند تست داشته باشیم که شبیه‌ساز یک تنظیم production باشند، فقط به این دلیل که ما می‌دانیم که تمام عناصر infrastructure واقعی با هم خوب کار می‌کنند. برای این کار ما tests های End-to-end را می‌نویسیم (به بخش 14.6 مراجعه کنید).</p>
    <p>“چرا mock کردن application در یک adapter test مهم است؟”</p>
    <p>دلیل اینکه ما در حال mock کردن ApplicationInterface هستیم این است که ما نباید از integration tests برای تست core code استفاده کنیم. Core code به خود اجازه می‌دهد که با unit tests یا use case tests، که هر دو بسیار سریع اجرا می‌شوند و همچنین بسیار stable هستند، تست شود زیرا آن‌ها کاملاً deterministic هستند و عناصر بیشتری را نسبت به آنچه که دقیقاً مورد نیاز است، درگیر نمی‌کنند. Adapter tests، integration tests هستند و طبق تعریف کندتر و کمتر stable از isolated tests هستند. بنابراین اگرچه ما می‌توانستیم logic core را با استفاده از یک adapter test تست کنیم، اما بهتر است این را به تست‌های ایزوله‌تر بسپاریم و نقطه ورودی به core (the ApplicationInterface در مثال ما) را با یک test double جایگزین کنیم.</p>
    <p>createService() یک command method است که یک side-effect ایجاد می‌کند. به همین دلیل است که متد request از نوع POST است. web application ما همچنین دارای controllers است که یک side-effect تولید نمی‌کنند، بلکه فقط مقداری اطلاعات را برمی‌گردانند. به عنوان مثال، صفحه /list-available-ebooks یک لیست از e-books را در HTML render می‌کند. The</p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>