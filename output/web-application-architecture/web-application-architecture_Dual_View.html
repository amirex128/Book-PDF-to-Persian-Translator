<!DOCTYPE html>
<html lang="fa">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>web-application-architecture - نسخه دوزبانه</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A3 landscape;
            margin: 1cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            margin: 0;
            padding: 20px;
            background-color: white;
        }
        .book-title {
            text-align: center;
            font-size: 24pt;
            margin: 2cm 0 1cm 0;
        }
        .book-subtitle {
            text-align: center;
            font-size: 18pt;
            margin-bottom: 2cm;
        }
        .dual-page-container {
            display: flex;
            flex-wrap: wrap;
        }
        .dual-page-spread {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 1cm;
            page-break-after: always;
        }
        .page {
            width: 48%;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            padding: 1cm;
            margin: 0 0.5%;
            box-sizing: border-box;
        }
        .persian-page {
            text-align: right;
            direction: rtl;
        }
        .original-page {
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .original-page img {
            max-width: 100%;
            max-height: 100%;
        }
        .persian-translation {
            font-size: 14pt;
        }
        .page-images {
            text-align: center;
            margin-top: 1cm;
        }
        .page-images img {
            max-width: 100%;
            height: auto;
            margin: 0.5cm 0;
        }
        pre {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
            direction: ltr;
            text-align: left;
        }
        span[dir="ltr"] {
            display: inline-block;
            direction: ltr;
            text-align: left;
        }
    </style>
</head>
<body>
    <h1 class="book-title">web-application-architecture</h1>
    <h2 class="book-subtitle">نسخه دوزبانه</h2>
    
    <div class="dual-page-container">
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Advanced Web Application Architecture</strong></h3>
<p>Matthias Noback</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0002_original/original_page.png" alt="Original Page 2">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Advanced Web Application Architecture</strong></h3>
<p>Matthias Noback</p>
<p><em>©2020 Matthias Noback</em></p>
<p>ISBN 978-90-821201-6-5</p>
<p>Cover drawings by Julia Noback</p>
<p>Other books by Matthias Noback:</p>
<ul>
<li>A Year with Symfony (Leanpub, 2014)</li>
<li>Principles of Package Design (Apress, 2018)</li>
<li>Microservices for Everyone (Leanpub, 2018)</li>
<li>Object Design Style Guide (Manning Publications, 2019)</li>
<li>PHP for the Web (Leanpub, 2020)</li>
</ul>
<p>ii</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0003_original/original_page.png" alt="Original Page 3">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p><em>In memory of my grandfather, H.A.J. Noback</em></p>
<p>iii</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0004_original/original_page.png" alt="Original Page 4">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Contents</strong></h3>
<p>Introduction</p>
<p>x</p>
<ol>
<li>
    Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
    x
   </li>
<li>
    Why is decoupling from infrastructure so important? . . . . . . .
    xi
   </li>
<li>
    Who is this book for? . . . . . . . . . . . . . . . . . . . . . . . . . . . xii
   </li>
<li>
    Overview of the contents . . . . . . . . . . . . . . . . . . . . . . . . . xii
   </li>
<li>
    The accompanying demo project . . . . . . . . . . . . . . . . . . . . xiii
   </li>
<li>
    About the author . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiv
   </li>
<li>
    Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiv
   </li>
<li>
    Changelog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xv
    <ol>
<li>
      April 15th, 2020 (initial version) . . . . . . . . . . . . . . . . xv
     </li>
<li>
      April 23rd, 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . xv
     </li>
<li>
      May 1st, 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . xvi
     </li>
<li>
      May 6th, 2020
      . . . . . . . . . . . . . . . . . . . . . . . . . . . xvi
     </li>
<li>
      May 29th, 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . xvi
     </li>
<li>
      June 4th, 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . xvii
     </li>
<li>
      June 12th, 2020
      . . . . . . . . . . . . . . . . . . . . . . . . . . xvii
     </li>
<li>
      June 17th, 2020
      . . . . . . . . . . . . . . . . . . . . . . . . . . xvii
     </li>
<li>
      June 22nd, 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . xviii
     </li>
<li>
      June 26th, 2020
      . . . . . . . . . . . . . . . . . . . . . . . . . . xviii
     </li>
<li>
      July 1st, 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . xviii
     </li>
<li>
      July 6th, 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . xviii
     </li>
<li>
      July 8th, 2020 . . . . . . . . . . . . . . . . . . . . . . . . . . . . xviii
     </li>
</ol>
</li>
</ol>
<p>I. Decoupling from infrastructure</p>
<p>1</p>
<p>1. Introduction</p>
<p>2</p>
<p>1.1. Rule no 1: No dependencies on external systems . . . . . . . . . .
  3</p>
<p>1.2. Abstraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
  5</p>
<p>iv</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0005_original/original_page.png" alt="Original Page 5">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Contents</strong></h3>
<ol start="1">
<li>
    1.3. Rule no 2: No special context needed . . . . . . . . . . . . . . . . .
    7
   </li>
<li>
    1.4. Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
   </li>
</ol>
<h3><strong>2. The domain model</strong></h3>
<ol>
<li>
    2.1. SQL statements all over the place
    . . . . . . . . . . . . . . . . . . . 15
   </li>
<li>
    2.2. Trying to fix it with a table data gateway . . . . . . . . . . . . . . 18
   </li>
<li>
    2.3. Designing an entity . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
   </li>
<li>
    2.4. Introducing a repository . . . . . . . . . . . . . . . . . . . . . . . . . 23
   </li>
<li>
    2.5. Mapping entity data to table columns . . . . . . . . . . . . . . . . 26
    <ol>
<li>
      2.5.1. Using an ORM . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
     </li>
<li>
      2.5.2. Manual mapping
      . . . . . . . . . . . . . . . . . . . . . . . . . 30
     </li>
</ol>
</li>
<li>
    2.6. Generating the identifier earlier . . . . . . . . . . . . . . . . . . . 34
    <ol>
<li>
      2.6.1. Using UUIDs instead of (auto-)incrementing integer IDs
      . 39
     </li>
</ol>
</li>
<li>
    2.7. Using a value object for the identifier . . . . . . . . . . . . . . . . 41
   </li>
<li>
    2.8. Active Record versus Data Mapper . . . . . . . . . . . . . . . . . . 44
   </li>
<li>
    2.9. Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
   </li>
</ol>
<h3><strong>3. Read models and view models</strong></h3>
<ol>
<li>
    3.1. Reusing the write model . . . . . . . . . . . . . . . . . . . . . . . . 53
   </li>
<li>
    3.2. Creating a separate read model . . . . . . . . . . . . . . . . . . . . 58
   </li>
<li>
    3.3. Read model repository implementations . . . . . . . . . . . . . . 60
    <ol>
<li>
      3.3.1. Sharing the underlying data source . . . . . . . . . . . . . 60
     </li>
<li>
      3.3.2. Using write model domain events . . . . . . . . . . . . . . 62
     </li>
</ol>
</li>
<li>
    3.4. Using value objects with internal read models
    . . . . . . . . . . . 67
   </li>
<li>
    3.5. A specific type of read model: the view model
    . . . . . . . . . . . 70
   </li>
<li>
    3.6. Using view models for APIs . . . . . . . . . . . . . . . . . . . . . . 79
   </li>
<li>
    3.7. Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
   </li>
</ol>
<h3><strong>4. Application services</strong></h3>
<ol>
<li>
    4.1. Considering other infrastructures . . . . . . . . . . . . . . . . . . 85
   </li>
<li>
    4.2. Designing a use case to be reusable . . . . . . . . . . . . . . . . . 89
   </li>
<li>
    4.3. Extracting an application service . . . . . . . . . . . . . . . . . . . 91
   </li>
<li>
    4.4. Introducing a parameter object . . . . . . . . . . . . . . . . . . . . 95
   </li>
<li>
    4.5. Dealing with multiple steps . . . . . . . . . . . . . . . . . . . . . . 97
   </li>
<li>
    4.6. Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106
   </li>
</ol>
<p>v</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0006_original/original_page.png" alt="Original Page 6">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Contents</strong></h3>
<ol start="5">
<li>
<strong>Service locators</strong>
<p>109</p>
<ol>
<li>
      5.1. From service location to explicit dependencies . . . . . . . . . . . 109
     </li>
<li>
      5.2. Depending on global state . . . . . . . . . . . . . . . . . . . . . . . . 111
     </li>
<li>
      5.3. Injecting dependencies . . . . . . . . . . . . . . . . . . . . . . . . . 113
     </li>
<li>
      5.4. Injecting configuration values
      . . . . . . . . . . . . . . . . . . . . . 114
     </li>
<li>
      5.5. Using method arguments for job-specific data . . . . . . . . . . . . 115
     </li>
<li>
      5.6. Clients of reusable services . . . . . . . . . . . . . . . . . . . . . . 117
     </li>
<li>
      5.7. Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
     </li>
<li>
      5.8. Effective testing
      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126
     </li>
<li>
      5.9. The Composition root is near the entry point . . . . . . . . . . . 129
     </li>
<li>
      5.10.Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130
     </li>
</ol>
</li>
<li>
<strong>External services</strong>
<p>133</p>
<ol>
<li>
      6.1. Connecting to the external service . . . . . . . . . . . . . . . . . . 135
     </li>
<li>
      6.2. Introducing an abstraction
      . . . . . . . . . . . . . . . . . . . . . . . 144
     </li>
<li>
      6.3. Architectural advantages
      . . . . . . . . . . . . . . . . . . . . . . . . 147
     </li>
<li>
      6.4. Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
     </li>
<li>
      6.5. Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
     </li>
</ol>
</li>
<li>
<strong>Time and randomness</strong>
<p>162</p>
<ol>
<li>
      7.1. Passing current time and random data as method arguments . . 165
     </li>
<li>
      7.2. Introducing factories . . . . . . . . . . . . . . . . . . . . . . . . . 167
     </li>
<li>
      7.3. Introducing value objects
      . . . . . . . . . . . . . . . . . . . . . . . . 170
     </li>
<li>
      7.4. Improving the factories
      . . . . . . . . . . . . . . . . . . . . . . . . . 176
     </li>
<li>
      7.5. Manipulating the current time . . . . . . . . . . . . . . . . . . . . 180
     </li>
<li>
      7.6. Integration tests again
      . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
     </li>
<li>
      7.7. Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
     </li>
</ol>
</li>
<li>
<strong>Validation</strong>
<p>191</p>
<ol>
<li>
      8.1. Protecting entity state . . . . . . . . . . . . . . . . . . . . . . . . . 193
     </li>
<li>
      8.2. Using value objects to validate separate values . . . . . . . . . . 198
     </li>
<li>
      8.3. Form validation
      . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
     </li>
<li>
      8.4. Using exceptions to talk to users . . . . . . . . . . . . . . . . . . 208
     </li>
<li>
      8.5. When validation is not the answer . . . . . . . . . . . . . . . . . . 214
     </li>
<li>
      8.6. Creating and validating command objects . . . . . . . . . . . . . 215
     </li>
<li>
      8.7. Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223
     </li>
</ol>
</li>
</ol>
<p>vi</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0007_original/original_page.png" alt="Original Page 7">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Contents</strong></h3>
<ol start="9">
<li>
<strong>Conclusion</strong>
<p>226</p>
<ol>
<li>
      9.1. Core code and infrastructure code . . . . . . . . . . . . . . . . . . . 226
     </li>
<li>
      9.2. A summary of the strategy . . . . . . . . . . . . . . . . . . . . . . . . 229
      <ol>
<li>
        9.2.1. Use dependency injection and inversion everywhere . . . 229
       </li>
<li>
        9.2.2. Make use cases universally invokable
        . . . . . . . . . . . . 231
       </li>
</ol>
</li>
<li>
      9.3. Focus on the domain
      . . . . . . . . . . . . . . . . . . . . . . . . . . . 233
     </li>
<li>
      9.4. Focus on testability . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
     </li>
<li>
      9.5. Pure object-oriented code . . . . . . . . . . . . . . . . . . . . . . . . 236
     </li>
<li>
      9.6. Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
     </li>
</ol>
</li>
</ol>
<h3>II. Organizing principles</h3>
<p>243</p>
<p>10.Introduction</p>
<p>244</p>
<h3>11.Key design patterns</h3>
<p>245</p>
<ol>
<li>
    11.1.Framework-inspired structural elements . . . . . . . . . . . . . . . 245
   </li>
<li>
    11.2.Entities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246
    <ol>
<li>
      11.2.1. Protect invariants . . . . . . . . . . . . . . . . . . . . . . . . 247
     </li>
<li>
      11.2.2. Constrain updates . . . . . . . . . . . . . . . . . . . . . . . . 248
     </li>
<li>
      11.2.3. Model state changes as actions with state transitions . . . 249
     </li>
<li>
      11.2.4. Don’t think too much about tables . . . . . . . . . . . . . . 250
     </li>
<li>
      11.2.5. Record domain events . . . . . . . . . . . . . . . . . . . . . 251
     </li>
</ol>
</li>
<li>
    11.3.Repositories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
   </li>
<li>
    11.4.Application services . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
    <ol>
<li>
      11.4.1. Return the identifier of a new entity
      . . . . . . . . . . . . . 257
     </li>
<li>
      11.4.2. Input should be defined as primitive-type data . . . . . . . 258
     </li>
<li>
      11.4.3. Wrap input inside command objects . . . . . . . . . . . . . 258
     </li>
<li>
      11.4.4. Translate primitive input to domain objects . . . . . . . . . 260
     </li>
<li>
      11.4.5. Add contextual information as extra arguments . . . . . . 263
     </li>
<li>
      11.4.6. Save only one entity per application service call . . . . . . 264
     </li>
<li>
      11.4.7. Move secondary tasks to a domain event subscriber
      . . . 264
     </li>
</ol>
</li>
<li>
    11.5.Event subscribers . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
    <ol>
<li>
      11.5.1. Move subscribers to the module where they produce their
      effect . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
     </li>
<li>
      11.5.2. Delegate to an application service . . . . . . . . . . . . . . 270
     </li>
</ol>
</li>
</ol>
<p>vii</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0008_original/original_page.png" alt="Original Page 8">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Contents</strong></h3>
<ol start="11">
<li>
    11.6.Read models
    <ol>
<li>
      11.6.1. Use internal read models when you need information . . 271
     </li>
<li>
      11.6.2. Choose a standard implementation for the repository
      . . 274
     </li>
<li>
      11.6.3. For view models, prepare the data for rendering
      . . . . . 276
     </li>
</ol>
</li>
<li>
    11.7.Process modelling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
   </li>
<li>
    11.8.Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
   </li>
</ol>
<h3><strong>12.Architectural layers</strong></h3>
<ol>
<li>
    12.1.MVC
    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
   </li>
<li>
    12.2.A standard set of layers . . . . . . . . . . . . . . . . . . . . . . . . . . 283
    <ol>
<li>
      12.2.1. The infrastructure layer . . . . . . . . . . . . . . . . . . . . 284
     </li>
<li>
      12.2.2. The application layer . . . . . . . . . . . . . . . . . . . . . . . 285
     </li>
<li>
      12.2.3. The domain layer . . . . . . . . . . . . . . . . . . . . . . . . . 286
     </li>
<li>
      12.2.4. Up and down the layer stack . . . . . . . . . . . . . . . . . . 287
     </li>
</ol>
</li>
<li>
    12.3.The Dependency rule . . . . . . . . . . . . . . . . . . . . . . . . . . 288
   </li>
<li>
    12.4.Making layers tangible . . . . . . . . . . . . . . . . . . . . . . . . . 290
    <ol>
<li>
      12.4.1. Documenting the architecture . . . . . . . . . . . . . . . . 290
     </li>
<li>
      12.4.2. Using namespaces for layering . . . . . . . . . . . . . . . . . 291
     </li>
<li>
      12.4.3. Automated verification of design decisions . . . . . . . . . 293
     </li>
</ol>
</li>
<li>
    12.5.Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296
   </li>
</ol>
<h3><strong>13.Ports and adapters</strong></h3>
<ol>
<li>
    13.1.Hexagonal architecture
    . . . . . . . . . . . . . . . . . . . . . . . . . 298
   </li>
<li>
    13.2.Ports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
   </li>
<li>
    13.3.Adapters for outgoing ports . . . . . . . . . . . . . . . . . . . . . . 301
   </li>
<li>
    13.4.Adapters for incoming ports . . . . . . . . . . . . . . . . . . . . . . 303
   </li>
<li>
    13.5.The application as an interface . . . . . . . . . . . . . . . . . . . . 308
   </li>
<li>
    13.6.Combining ports and adapters with layers . . . . . . . . . . . . . 314
   </li>
<li>
    13.7.Structuring the Infrastructure layer . . . . . . . . . . . . . . . . . 315
   </li>
<li>
    13.8.Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 317
   </li>
</ol>
<h3><strong>14.A testing strategy for decoupled applications</strong></h3>
<ol>
<li>
    14.1.Unit tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
   </li>
<li>
    14.2.Adapter tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 323
   </li>
<li>
    14.3.Contract tests for outgoing port adapters . . . . . . . . . . . . . . 324
   </li>
<li>
    14.4.Driving tests for incoming port adapters . . . . . . . . . . . . . . . 329
   </li>
<li>
    14.5.Use case tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338
   </li>
</ol>
<p>viii</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0009_original/original_page.png" alt="Original Page 9">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Contents</strong></h3>
<ol start="14">
<li>
    14.6.End-to-end tests
    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
   </li>
<li>
    14.7.Development workflow
    . . . . . . . . . . . . . . . . . . . . . . . . . 353
   </li>
<li>
    14.8.Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355
   </li>
</ol>
<h3><strong>15.Conclusion</strong></h3>
<ol>
<li>
    15.1.Is a decoupled architecture the right choice for all projects? . . . 359
   </li>
<li>
    15.2.My application is not supposed to live longer than two years
    . . 359
   </li>
<li>
    15.3.My application offers only CRUD functionality
    . . . . . . . . . . . 361
   </li>
<li>
    15.4.My application is a legacy application . . . . . . . . . . . . . . . . . 361
   </li>
<li>
    15.5.I can never make my entire application decoupled . . . . . . . . . 362
   </li>
<li>
    15.6.Isn’t this over-engineering? . . . . . . . . . . . . . . . . . . . . . . . 362
   </li>
</ol>
<p>ix</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0010_original/original_page.png" alt="Original Page 10">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3>Introduction</h3>
<p>
<strong>Preface</strong>
</p>
<p>
   کتاب آخر من،  Object Design Style Guide، با فصل 10 - "راهنمای میدانی برای اشیاء" به پایان می‌رسد که ویژگی‌های برخی از انواع common objects مانند controllers, entities, value objects, repositories, event subscribers و غیره را نشان می‌دهد. این فصل با مروری بر اینکه چگونه این انواع مختلف از objects جایگاه طبیعی خود را در مجموعه‌ای از architectural layers پیدا می‌کنند، به پایان می‌رسد. برخی از خوانندگان اشاره کردند که خود راهنمای میدانی به اندازه کافی دقیق نیست تا به آنها در استفاده از این انواع objects در پروژه‌های خود کمک کند. و برخی از افراد اعتراض کردند که مفاهیم architectural که به طور خلاصه در این فصل توضیح داده شده‌اند، نمی‌توانند به راحتی در پروژه‌های دنیای واقعی اعمال شوند. آنها کاملاً درست می‌گویند؛ آن فصل آخر بیشتر یک teaser بود تا یک treatise. متاسفانه من نمی‌توانستم به منبع جایگزینی فکر کنم که بتوانم به آن خوانندگان ارائه دهم. مقالات و کتاب‌های خوبی در این زمینه وجود دارد، اما آنها فقط برخی از patterns و مفاهیم architectural را پوشش می‌دهند. تا آنجا که می‌دانم، هیچ راهنمای جامعی در مورد همه این patterns با هم وجود ندارد. بنابراین تصمیم گرفتم خودم آن را بنویسم: یک showcase از design patterns، مانند entities و application services، که توضیح می‌دهد چگونه همه آنها در یک application "well-architected" با هم کار می‌کنند. با این حال، یک description ساده از patterns موجود به اندازه کافی مفید نیست، مانند نشان دادن اینکه چگونه می‌توانید آنها را با تلاش برای decouple کردن کد application خود از زیرساخت‌های اطراف آن، خودتان اختراع کنید. به همین دلیل این کتاب به یک راهنما برای decoupling کردن domain model و use cases  application شما از framework، database و غیره تبدیل شد.
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0011_original/original_page.png" alt="Original Page 11">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Introduction</strong></h3>
<p>چرا <strong>decoupling</strong> از infrastructure اینقدر مهم است؟</p>
<p>جدا کردن نگرانی‌های infrastructure از منطق اصلی application شما، منجر به یک <strong>domain model</strong> می‌شود که می‌تواند به روش <strong>domain-driven</strong> توسعه داده شود. همچنین منجر به کد application می‌شود که بسیار آسان برای تست کردن است و به روش <strong>test-driven</strong> توسعه داده می‌شود. در نهایت، تست‌ها تمایل دارند پایدارتر باشند و سریع‌تر از تست‌های functional الهام گرفته از <strong>framework</strong> معمولی شما اجرا شوند.</p>
<p>پشتیبانی از هر دو <strong>Domain-Driven Design (DDD)</strong> و <strong>Test-Driven Development (TDD)</strong> در حال حاضر یک ویژگی عالی از هر <strong>software system</strong> است. اما جدا کردن infrastructure از نگرانی‌های <strong>domain</strong> با اعمال این <strong>design patterns</strong>، دو مزیت دیگر به شما می‌دهد. بدون کار اضافی زیاد، می‌توانید شروع به استفاده از مجموعه‌ای استاندارد از لایه‌ها کنید (که ما آن‌ها را <strong>Domain</strong>، <strong>Application</strong> و <strong>Infrastructure</strong> می‌نامیم). علاوه بر این، می‌توانید به راحتی <strong>use cases</strong> از نوع <strong>decoupled</strong> خود را به عنوان <strong>Ports</strong> و کد پیاده‌سازی پشتیبانی‌کننده را به عنوان <strong>Adapters</strong> علامت‌گذاری کنید.</p>
<p>استفاده از لایه‌ها، <strong>ports</strong> و <strong>adapters</strong> یک راه عالی برای استانداردسازی معماری سطح بالای شماست، و این کار باعث می‌شود که درک کد برای همه آسان‌تر شود، از آن مراقبت کنند و به توسعه آن ادامه دهند. و سورپرایز بزرگی که می‌خواهم الان به شما بگویم این است که با <strong>decoupling</strong> کد اصلی از کد <strong>infrastructure</strong>، همه اینها را رایگان دریافت می‌کنید.</p>
<p>اگر قرار است application شما بیش از، مثلاً، دو سال عمر کند، آنگاه <strong>decoupling</strong> از infrastructure یک شرط ایمن است. infrastructure های اطراف مانند <strong>frameworks</strong>، <strong>remote web services</strong>، <strong>storage systems</strong> و غیره، احتمالاً با سرعتی متفاوت از <strong>domain model</strong> و <strong>use cases</strong> شما تغییر می‌کنند. هر اتفاقی که در دنیای technology پیرامون application شما رخ دهد، کد core با ارزش شما توسط آن مختل نخواهد شد. هر دو می‌توانند با سرعت خودشان تکامل یابند.</p>
<p>ارتقا به نسخه بعدی <strong>framework</strong> شما، مهاجرت به یک <strong>storage backend</strong> متفاوت، یا تغییر به یک <strong>payment provider</strong> متفاوت، به اندازه زمانی که کد <strong>core</strong> و <strong>infrastructure</strong> هنوز با هم مخلوط بودند، هزینه نخواهد داشت.</p>
<p>وابستگی‌ها به کد یا <strong>systems</strong> خارجی همیشه ایزوله خواهند بود و اگر تغییری باید ایجاد شود، فوراً متوجه خواهید شد که کجا باید آن را ایجاد کنید.</p>
<p>از طرف دیگر، اگر قرار نیست application شما بیش از دو سال عمر کند، این ممکن است دلیل خوبی باشد که به رویکرد ارائه شده در این کتاب اهمیت ندهید. با این حال، من فقط یک یا دو بار در زندگی‌ام چنین applicationی را دیده‌ام.</p>
<p>xi</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0012_original/original_page.png" alt="Original Page 12">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Introduction</strong></h3>
<h4>Who is this book for?</h4>
<p>این کتاب برای شما است:</p>
<ul>
<li>اگر شما مقداری تجربه با توسعه "الهام گرفته از <strong>framework</strong>" دارید، یعنی، از مستندات یک <strong>framework</strong> برای ساختاردهی به یک <strong>web application</strong> پیروی می‌کنید، یا</li>
<li>اگر شما مقداری <strong>legacy code</strong> دیده‌اید، که در آن هر قسمت از <strong>code base</strong> از قسمت‌های دیگر باخبر است و نگرانی‌های مختلف کاملاً با هم مخلوط شده‌اند، یا</li>
<li>اگر هر دو را دیده‌اید، که کاملاً محتمل است زیرا این موارد اغلب به هم مرتبط هستند.</li>
</ul>
<p>من تصور می‌کنم که شما در حال خواندن این کتاب هستید زیرا به دنبال راه‌های بهتری برای ساختاربندی چیزها و فرار از آشفتگی هستید که یک پروژه <strong>software</strong> ناگزیر به آن تبدیل می‌شود. نظریه من این است: <strong>software</strong> همیشه به هم ریخته می‌شود، حتی اگر شما تمام بهترین روش‌های شناخته شده برای طراحی <strong>software</strong> را دنبال کنید. اما من متقاعد شده‌ام که اگر شما از روش‌های توضیح داده شده در این کتاب پیروی کنید، بیشتر طول می‌کشد تا به هم ریخته شود، و این در حال حاضر یک مزیت رقابتی بزرگ است.</p>
<h4>Overview of the contents</h4>
<p>این کتاب به سه بخش تقسیم شده است. در قسمت اول ("<strong>Decoupling</strong> از infrastructure") ما به نمونه‌های مختلف کد از یک <strong>legacy application</strong> نگاه می‌کنیم که در آن <strong>core</strong> و کد <strong>infrastructure</strong> با هم مخلوط شده‌اند. ما متوجه می‌شویم که چگونه:</p>
<ul>
<li>یک <strong>domain model</strong> را از کدی که <strong>SQL queries</strong> را با تصمیمات تجاری مخلوط می‌کند، استخراج کنیم (فصل 2)</li>
<li>یک <strong>application service</strong> قابل استفاده مجدد را از یک <strong>controller</strong> که <strong>form handling</strong>، منطق تجاری و <strong>database queries</strong> را با هم مخلوط می‌کند، استخراج کنیم (فصل 4).</li>
<li>یک <strong>read model</strong> را از <strong>data storage</strong> اساسی آن جدا کنیم (فصل 3)</li>
<li>کلاس‌هایی را که از <strong>service location</strong> استفاده می‌کنند، به کلاس‌هایی که به <strong>dependency injection</strong> متکی هستند، بازنویسی کنیم (فصل 5)</li>
</ul>
<p>xii</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0013_original/original_page.png" alt="Original Page 13">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Introduction</strong></h3>
<ul>
<li>جدا کردن آنچه که از <strong>external services</strong> نیاز داریم از چگونگی دریافت آن (فصل 6)</li>
<li>کار کردن با زمان فعلی و داده‌های تصادفی به طور مستقل از چگونگی بازیابی این اطلاعات توسط application در حال اجرا (فصل 7)</li>
</ul>
<p>در طول این مسیر ما تکنیک‌های <strong>refactoring</strong> رایج را برای جدا کردن این نگرانی‌ها پیدا می‌کنیم. ما متوجه می‌شویم که چگونه این تکنیک‌های <strong>refactoring</strong> منجر به <strong>design patterns</strong> می‌شوند که احتمالاً از قبل آشنا هستند، مانند <strong>entities</strong>، <strong>value objects</strong> و <strong>application services</strong>. ما این بخش را با بحث مفصلی در مورد اعتبارسنجی، و اینکه کجا و چگونه باید یا می‌تواند اتفاق بیفتد، به پایان می‌رسانیم (فصل 8).</p>
<p>بخش دوم ("اصول سازماندهی") مروری بر اصول سازمانی ارائه می‌دهد که می‌تواند در مقیاس معماری به طراحی یک application اعمال شود. فصل 11 کاتالوگی از <strong>design patterns</strong> است که ما در قسمت اول به دست آوردیم. ما آنها را با جزئیات بیشتری پوشش می‌دهیم و برخی از ظرافت‌ها و پیشنهادات مرتبط با پیاده‌سازی را اضافه می‌کنیم. فصل 12 نشان می‌دهد که چگونه جدا کردن کد <strong>core</strong> از کد <strong>infrastructure</strong> با استفاده از همه این <strong>design patterns</strong> به شما امکان می‌دهد تا کلاس‌های حاصل را در یک مجموعه لایه‌ای استاندارد گروه بندی کنید. سپس فصل 13 ادامه می‌دهد و توضیح می‌دهد که چگونه می‌توانید از سبک معماری به نام <strong>Ports and adapters</strong> به عنوان نوعی <strong>overlay</strong> برای این معماری لایه‌ای استفاده کنید. در فصل 14 ما به یک استراتژی تست احتمالی برای applications از نوع <strong>decoupled</strong> نگاه می‌کنیم. با فصل 15 به نتیجه‌گیری کتاب می‌رسیم.</p>
<h4>The accompanying demo project</h4>
<p>البته تمام تکنیک‌های طراحی و اصول مورد بحث در این کتاب با نمونه‌های کد زیادی نشان داده شده است. با این حال، این نمونه‌ها همیشه مختصر، ایده‌آل هستند و فقط جنبه‌های ضروری را نشان می‌دهند. برای درک کامل چگونگی کارکرد تمام بخش‌های مختلف یک application با هم، ما به یک پروژه نمایشی نیاز داریم. باز هم، نه یک پروژه ایده‌آل یا ساده شده، بلکه یک پروژه واقعی که در حال اجرا در <strong>production</strong> است. مردم اغلب درخواست چنین پروژه‌ای را داشته‌اند و من همیشه پاسخ داده‌ام: دوست دارم روی آن کار کنم، حالا باید مقداری وقت پیدا کنم. این بار تصمیم گرفتم این کار را انجام دهم. پروژه نمایشی، <strong>source code</strong> برای پلتفرم جدید Read with the Author است. این <strong>software</strong> در <strong>production</strong> اجرا می‌شود. در واقع، ممکن است از <strong>software</strong> استفاده کرده باشید</p>
<p>xiii</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0014_original/original_page.png" alt="Original Page 14">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Introduction</strong></h3>
<p>در حال حاضر اگر بلیط آن را در Leanpub خریداری کرده باشید. اما مهمترین کیفیت این پروژه این است که تکنیک‌های طراحی و اصول این کتاب را در عمل نشان می‌دهد. با پرداخت 5 دلار می‌توانید <strong>source code</strong> را، از جمله هرگونه بروزرسانی‌های آینده آن را بررسی کنید. برای دسترسی فوری به https://advwebapparch.com/repository بروید.</p>
<h4>About the author</h4>
<p>Matthias Noback یک <strong>web developer</strong> حرفه‌ای از سال 2003 است.</p>
<p>او در Zeist، هلند، با دوست دختر، پسر و دخترش زندگی می‌کند.</p>
<p>Matthias شرکت توسعه، آموزش و مشاوره <strong>web</strong> خود را به نام Noback’s Office دارد. او تمرکز زیادی بر توسعه و معماری <strong>backend</strong> دارد و همیشه به دنبال راه‌های بهتری برای طراحی <strong>software</strong> است.</p>
<p>از سال 2011 او در حال نوشتن در مورد انواع موضوعات مرتبط با برنامه نویسی در وبلاگ خود بوده است1. کتاب‌های دیگر Matthias عبارتند از Principles of Package Design (Apress، 2018) و Object Design Style Guide (Manning، 2019).</p>
<p>شما می‌توانید با Matthias تماس بگیرید:</p>
<ul>
<li>از طریق ایمیل: info@matthiasnoback.nl</li>
<li>در توییتر: @matthiasnoback</li>
</ul>
<h4>Acknowledgements</h4>
<p>این ششمین کتابی است که من با استفاده از پلتفرم Leanpub2 منتشر کردم. همیشه یک تجربه عالی بوده است، بنابراین دوباره از Peter Armstrong و Lenn متشکرم</p>
<p>1 https://advwebapparch.com/blog</p>
<p>2 https://advwebapparch.com/leanpub</p>
<p>xiv</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 15" src="page_0015/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0015_original/original_page.png" alt="Original Page 15">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Introduction</strong></h3>
<p>Ep.</p>
<p>متشکرم، 307 خواننده علاقه‌مند، برای ثبت‌نام در این کتاب قبل از اینکه نوشته شود. متشکرم، 440 خواننده، برای خرید این کتاب قبل از اینکه تمام شود. از خوانندگانی که به جلسات read-with-the-author برای این کتاب پیوستند: از شما برای سوالات بصیرت‌آمیز و نظرات دلگرم‌کننده شما متشکرم. و از همه کسانی که بازخورد، نظرات و پیشنهادات را از طریق کانال‌های مختلف به اشتراک گذاشته‌اند متشکرم. بیایید امیدوار باشیم که کسی را از قلم نیندازم: Christopher L Bray، Ondřej Bouda، Samir Boulil، Iosif Chiriluta، Biczó Dezsö، Nicola Fornaciari، Ramon de la Fuente، Raúl Fraile، Alex Gemmell، Gary Jones، Luis-Ramón López، Hazem Noor، Thomas Nunninger، Nikola Paunovic، José María Valera Reales، Gildas Quéméner، Onno Schmidt، Daniel Martín Spiridione، Harm van Tilborg، Stijn Vergote، Tom de Wit.</p>
<h4>Changelog</h4>
<h5>April 15th, 2020 (initial version)</h5>
<ol>
<li>Released: <strong>Front matter</strong>، قسمت اول: <strong>Decoupling</strong> از <strong>infrastructure</strong>، و فصل 1: <strong>The domain model</strong>.</li>
</ol>
<h5>April 23rd, 2020</h5>
<p>از پیشنهادات شما متشکرم، Christopher L. Bray، Iosif Chiriluta، Biczó Dezsö، Luis Ramon Lopez و Thomas Nunninger!</p>
<ol>
<li>Released: فصل 3: <strong>Read models</strong> و <strong>view models</strong></li>
<li>رفع برخی از مشکلات املایی</li>
<li>فصل 1: اضافه شدن یک بخش فرعی (“Wait, is UUID the best we can get?”)</li>
<li>تصحیح عنوان فهرست 2.29.</li>
<li>فصل 1: اضافه شدن زیربخش 2.5.1 (Using an ORM)</li>
</ol>
<p>xv</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0016_original/original_page.png" alt="Original Page 16">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Introduction</strong></h3>
<h5>May 1st, 2020</h5>
<p>متشکرم برای پیشنهادات شما، Christopher L. Bray، José María Valera Reales، و Raúl Fraile!</p>
<ol>
<li>Released: فصل 4: <strong>Application services</strong></li>
<li>اضافه شدن دو تمرین به فصل 2</li>
<li>استفاده از <strong>PHP arrow functions</strong> (fn () =&gt; /* ... */) در صورت امکان</li>
<li>اضافه شدن یک پاراگراف به بخش 1.3 توضیح اینکه چرا من از کلمات "<strong>core</strong>" و "<strong>infrastructure</strong>" استفاده می‌کنم</li>
<li>اضافه شدن یک نمودار برای نشان دادن نحوه قرار گرفتن <strong>infrastructure</strong> application در اطراف <strong>core</strong> آن، اتصال آن به <strong>external systems</strong> و کاربران</li>
</ol>
<h5>May 6th, 2020</h5>
<p>متشکرم برای پیشنهادات شما، Christopher L Bray، Thomas Nunninger، Iosif Chiriluta، Nikola Paunovic، Gildas Quéméner، Samir Boulil، Harm van Tilborg!</p>
<ol>
<li>Released: فصل 5: <strong>Service locators</strong></li>
<li>رفع اشتباه در مثال آخر بخش فرعی "آیا <strong>getters</strong> روی <strong>entities</strong> ممنوع هستند؟"</li>
<li>رفع برخی از اشتباهات تایپی و ناسازگاری‌ها در نمونه‌های کد فصل 4</li>
<li>رفع مشکل تورفتگی در تمرین‌های فصل 4</li>
<li>تغییر فونت به چیزی خواناتر</li>
</ol>
<h5>May 29th, 2020</h5>
<p>متشکرم برای پیشنهادات شما، Christopher L Bray، Harm van Tilborg، Daniel Martín Spiridione، Gary Jones، Thomas Nunninger!</p>
<ol>
<li>Released: فصل 6: <strong>External services</strong></li>
</ol>
<p>xvi</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0017_original/original_page.png" alt="Original Page 17">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Introduction</strong></h3>
<h5>June 4th, 2020</h5>
<p>متشکرم برای پیشنهادات شما Ramon de la Fuente!</p>
<ol>
<li>Released: فصل 7: <strong>Time and randomness</strong>.</li>
<li>رفع پاسخ تمرین 2 فصل 4.</li>
<li>جایگزینی 'NL' از نوع <strong>hard-coded</strong> با استفاده از متغیر $countryCode در Listing 6.14.</li>
</ol>
<h5>June 12th, 2020</h5>
<p>متشکرم برای پیشنهادات شما، Christopher L Bray و Thomas Nunninger!</p>
<ol>
<li>Released: فصل 8: <strong>Validation</strong>.</li>
<li>رفع ارجاع به Listing 3.10.</li>
<li>رفع ارجاع به Figure 7.1.</li>
<li>رفع ارجاع به Listing 7.8.</li>
<li>اضافه شدن برخی از <strong>listing captions</strong> های از دست رفته.</li>
</ol>
<h5>June 17th, 2020</h5>
<ol>
<li>Released: فصل 9: <strong>Conclusion</strong></li>
</ol>
<p>xvii</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0018_original/original_page.png" alt="Original Page 18">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Introduction</strong></h3>
<h5>June 22nd, 2020</h5>
<ol>
<li>Released: Part II, Chapter 10: Introduction</li>
<li>Released: Chapter 11: Key design patterns</li>
</ol>
<h5>June 26th, 2020</h5>
<ol>
<li>Released: Chapter 12: Architectural layers</li>
</ol>
<h5>July 1st, 2020</h5>
<ol>
<li>Released: Chapter 13: Ports and adapters</li>
<li>تغییر فونت‌های PDF به Droid، با تشکر از Harm van Tilborg</li>
</ol>
<h5>July 6th, 2020</h5>
<ol>
<li>Released: Chapter 14: Testing strategy</li>
<li>بهبود فایل‌های EPUB و MOBI (یادداشت‌های پایانی به جای پاورقی، رفع مشکلات رمزگذاری فونت)</li>
<li>اضافه شدن یک پاراگراف در مورد عدم تقارن بین <strong>incoming</strong> و <strong>outgoing ports</strong> و <strong>adapters</strong> (در انتهای بخش 13.5)</li>
</ol>
<h5>July 8th, 2020</h5>
<p>متشکرم برای پیشنهادات شما Hazem Noor، Ramon de la Fuente و Biczó Dezsö!</p>
<ol>
<li>Released last chapter: Chapter 15</li>
<li>رفع مراجع <strong>listing</strong> نامعتبر در فایل‌های EPUB و MOBI</li>
<li>رفع یک ناسازگاری مربوط به $ebookPrice در فصل 4</li>
</ol>
<p>xviii</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0019_original/original_page.png" alt="Original Page 19">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Introduction</strong></h3>
<ol>
<li>Exercise 2 of Chapter 13: changed “Port” into “Adapter”</li>
<li>اضافه شدن یک مثال از <strong>loading</strong> یک <strong>view model</strong> در <strong>controller</strong> بر اساس یک <strong>entity ID</strong> که از یک <strong>application service</strong> برگردانده شده است (بخش 11.4.1).</li>
<li>اضافه شدن یک بحث کوتاه در مورد اضافه کردن <strong>value object getters</strong> به <strong>command DTOs</strong> در بخش 11.4.4.</li>
<li>اضافه شدن یک بخش فرعی در مورد الزامات پیاده‌سازی <strong>repository</strong> (“That’s too easy!”) در بخش 11.3.</li>
<li>بازنویسی بخش 11.5.2 برای واضح‌تر کردن تمایز بین مشترکین <strong>core</strong> و <strong>infrastructure event</strong>.</li>
</ol>
<p>xix</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0020_original/original_page.png" alt="Original Page 20">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3>Part I.</h3>
<p>Decoupling from infrastructure</p>
<p>1</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0021_original/original_page.png" alt="Original Page 21">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>1. Introduction</strong></h3>
<p>این بخش موارد زیر را پوشش می‌دهد:</p>
<ul>
<li>Decoupling your domain model from the database</li>
<li>Decoupling the read model from the write model (and from the database)</li>
<li>Extracting an application service from a <em>controller</em></li>
<li>Rewriting calls to service locators</li>
<li>Splitting a call to external systems into the “what” and “how” of the call</li>
<li>Inverting dependencies on system devices for retrieving the current time, and randomness</li>
</ul>
<p>هدف اصلی سبک معماری ارائه شده در این کتاب، ایجاد یک تمایز واضح بین کد اصلی <strong>application</strong> شما و کد <strong>infrastructure</strong> است که از آن پشتیبانی می‌کند. این به اصطلاح کد <strong>infrastructure</strong>، منطق اصلی <strong>application</strong> شما را به سیستم‌های اطراف آن، مانند <em>database</em>، وب سرور، <em>file system</em> و غیره متصل می‌کند. هر دو نوع کد به یک اندازه مهم هستند، اما نباید در یک کلاس با هم قرار گیرند. دلایل انجام این کار در نتیجه‌گیری این بخش به تفصیل مورد بحث قرار خواهد گرفت، اما خلاصه سریع این است که جداسازی core از infrastructure…</p>
<ul>
<li>یک پایه فنی قوی برای انجام domain-first development فراهم می‌کند، و</li>
<li>مجموعه‌ای غنی و موثر از امکانات testing را فعال می‌کند و test-first development را آسان‌تر می‌کند</li>
</ul>
<p>برای کمک به شما در توسعه یک دید برای تمایز بین <strong>core</strong> و <strong>infrastructure</strong></p>
<p>2</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0022_original/original_page.png" alt="Original Page 22">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>1. Introduction</strong></h3>
<p>با توجه به <strong>infrastructure</strong>، هر یک از فصل‌های زیر با برخی از نمونه‌های رایج کد "مخلوط" در یک <em>legacy</em> <strong>web application</strong> شروع می‌شود. پس از اشاره به مشکلات این نوع کد، تعدادی از مراحل <strong>refactoring</strong> را برای جداسازی بخش <strong>core</strong> از بخش <strong>infrastructure</strong> انجام می‌دهیم. پس از شش مورد از این تکرارها، تمام تکنیک‌های برنامه‌نویسی را که می‌تواند شما را از داشتن کد مخلوط در کلاس‌هایتان نجات دهد، مشاهده خواهید کرد.</p>
<p>اما قبل از اینکه شروع به <strong>refactoring</strong> و بهبود نمونه‌های کد کنیم، اجازه دهید تعریفی از اصطلاحات "<strong>core</strong>" و کد "<strong>infrastructure</strong>" ارائه دهیم. ما کد <strong>core</strong> را با معرفی دو قانون برای آن تعریف می‌کنیم. هر کد دیگری که از قوانین کد <strong>core</strong> پیروی نمی‌کند، باید کد <strong>infrastructure</strong> در نظر گرفته شود.</p>
<h4><strong>1.1. Rule no 1: No dependencies on external systems</strong></h4>
<p>بیایید با قانون اول شروع کنیم:</p>
<p>کد <strong>core</strong> مستقیماً به سیستم‌های خارجی وابسته نیست و نه به کدی که برای تعامل با یک نوع خاص از سیستم خارجی نوشته شده است، وابسته است.</p>
<p>یک سیستم خارجی چیزی است که خارج از <strong>application</strong> شما وجود دارد، مانند یک <em>database</em>، برخی از <strong>web service</strong> های از راه دور، ساعت سیستم، <em>file system</em> و غیره. کد <strong>core</strong> باید بتواند بدون این وابستگی‌های خارجی اجرا شود.</p>
<p>Listing 1.1 تعدادی از متدهای کلاس را نشان می‌دهد که از این قانون اول پیروی نمی‌کنند و بنابراین باید کد <strong>infrastructure</strong> در نظر گرفته شوند. شما نمی‌توانید هیچ یک از این متدها را بدون اینکه وابستگی‌های خارجی آنها واقعاً در دسترس باشند، فراخوانی کنید.</p>
<p>Listing 1.1. Examples of code that needs external dependencies to run.</p>
<pre><code class="language-php">
final class NeedsExternalDependencies
{
    public function callARemoteService(): void
    {
        /*
         * To run this code, we need an internet connection,
         * and the API of remoteservice.com should be responsive.
         */
        $ch = curl_init('https://remoteservice.com/api');
    }
}
  </code></pre>
<p>3</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0023_original/original_page.png" alt="Original Page 23">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>1. Introduction</p>
<pre><code class="language-php">
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
$response = curl_exec($ch);
// ...
}

public function useTheDatabase(): void
{
    /*
     * To run this code, the database that we connect to
     * using new PDO('...') should be up and running, and
     * it should contain a table called orders.
     */
    $pdo = new PDO('...');
    $statement = $pdo-&gt;prepare('INSERT INTO orders ...');
    $statement-&gt;execute();
}

public function loadAFile(): string
{
    /*
     * To run this code, the settings.xml file should exist
     * in the correct location.
     */
    return file_get_contents(
        __DIR__ . '/../app/config/settings.xml'
    );
}
</code></pre>
<p>هنگامی که کد از قانون اول پیروی می‌کند، به این معنی است که شما می‌توانید آن را در ایزوله کامل اجرا کنید. <em>Isolation</em> برای <em>testability</em> عالی است. هنگامی که می‌خواهید یک <em>automated test</em> برای کد <strong>core</strong> بنویسید، بسیار آسان خواهد بود. شما نیازی به راه‌اندازی یک <em>database</em>، ایجاد جدول، بارگذاری <em>fixtures</em> و غیره نخواهید داشت. شما به یک اتصال اینترنتی یا یک هارد دیسک با فایل‌ها در مکان‌های خاص نیاز نخواهید داشت. تنها چیزی که نیاز دارید این است که بتوانید کد را اجرا کنید و مقداری حافظه کامپیوتر در دسترس داشته باشید.</p>
<p>4</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0024_original/original_page.png" alt="Original Page 24">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>1. Introduction</p>
<h4>1.2. Abstraction</h4>
<p>در مورد متد <code>registerUser()</code> در Listing 1.2 چطور؟ آیا این هم کد <strong>infrastructure</strong> است؟</p>
<p>Listing 1.2. Depending on an interface.</p>
<pre><code class="language-php">
interface Connection
{
    public function insert(string $table, array $data): void;
}

final class UserRegistration
{
    /**
     * @var Connection
     */
    private Connection $connection;

    public function __construct(Connection $connection)
    {
        $this-&gt;connection = $connection;
    }

    public function registerUser(
        string $username,
        string $plainTextPassword
    ): void {
        $this-&gt;connection-&gt;insert(
            'users',
            [
                'username' =&gt; $username,
                'password' =&gt; $plainTextPassword
            ]
        );
    }
}
  </code></pre>
<p>5</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0025_original/original_page.png" alt="Original Page 25">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>مقدمه</strong></h3>
<p>متد <code>registerUser()</code> مستقیماً از PDO1 برای اتصال به یک database و اجرای queries استفاده نمی‌کند. در عوض، از یک abstraction برای database connections (interface به نام <code>Connection</code>) استفاده می‌کند. این بدان معناست که object از نوع <code>Connection</code> که به عنوان یک constructor argument تزریق می‌شود، می‌تواند با یک پیاده‌سازی ساده‌تر از همان interface جایگزین شود که در واقع به یک database نیاز ندارد (به Listing 1.3 مراجعه کنید).</p>
<p><strong>Listing 1.3.</strong> یک پیاده‌سازی از <code>Connection</code> که به یک database نیاز ندارد.</p>
<pre><code class="language-php">
 final class ConnectionDummy implements Connection
 {
  /**
  * @var array&lt;array&lt;string,mixed&gt;&gt;
  */
  private array $records;
  /**
  * @param array&lt;string,mixed&gt; $data
  */
  public function insert(string $table, array $data): void
  {
  $this-&gt;records[$table][] = $data;
  }
 }
 </code></pre>
<p>این امر باعث می‌شود که کد در متد <code>registerUser()</code> اجرا شود، بدون اینکه نیازی به راه‌اندازی و اجرای database واقعی باشد. آیا این باعث می‌شود این کد core code باشد؟ نه، زیرا interface از نوع <code>Connection</code> به طور خاص برای برقراری ارتباط با relational databases طراحی شده است، همانطور که خود signature از متد <code>insert()</code> نشان می‌دهد. بنابراین، اگرچه متد <code>registerUser()</code> مستقیماً به یک system خارجی وابسته نیست، اما به کدی که برای تعامل با یک نوع خاص از system خارجی نوشته شده است، وابسته است. این بدان معنی است که کد در Listing 1.2 core code نیست، بلکه infrastructure code است.</p>
<p>به طور کلی، abstraction راه‌حل مناسبی برای خلاص شدن از وابستگی‌ها به external systems است. ما در فصل‌های بعدی چندین مثال از abstraction را مورد بحث قرار خواهیم داد، اما ممکن است ارائه خلاصه ای در اینجا مفید باشد. ایجاد</p>
<p>1PDO یک PHP extension است که یک API برای دسترسی به relational databases فراهم می‌کند. به آدرس https://advwebapparch.com/pdo مراجعه کنید.</p>
<p>6</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0026_original/original_page.png" alt="Original Page 26">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>1. Introduction</strong></h3>
<p>abstraction کامل برای services که به external systems متکی هستند شامل دو مرحله است:</p>
<ol>
<li>معرفی یک interface</li>
<li>برقراری ارتباط با purpose به جای implementation details</li>
</ol>
<p>به عنوان مثال: به جای یک interface از نوع <code>Connection</code> و یک متد <code>insert()</code>، که فقط در context مربوط به کار با relational databases معنی دارد، می‌توانیم یک interface از نوع <code>Repository</code> را با یک متد <code>save()</code> تعریف کنیم. چنین interfaceای با purpose (saving objects) به جای implementation details (storing data in tables) ارتباط برقرار می‌کند. ما جزئیات این نوع refactoring را در فصل 2 مورد بحث قرار خواهیم داد.</p>
<p><strong>1.3. Rule no 2: No special context needed</strong></p>
<p>دومین rule برای core code این است:</p>
<p><em>Core code</em> نیازی به یک environment خاص برای اجرا ندارد، و همچنین وابستگی‌هایی ندارد که فقط برای اجرا در یک context خاص طراحی شده باشند.</p>
<p>Listing 1.4 برخی از مثال‌های کدی را نشان می‌دهد که قبل از اینکه بتوانید آن را اجرا کنید، به context خاصی نیاز دارد. فرض می‌کند که موارد خاصی تنظیم شده‌اند، یا اینکه در داخل یک نوع خاص از application، مانند یک web یا یک application از نوع command-line (CLI) اجرا می‌شود.</p>
<p><strong>Listing 1.4.</strong> Examples of code that needs a special context to run in.</p>
<pre><code class="language-php">
 final class RequiresASpecialContext
 {
  public function usesGlobalState(): void
  {
  /*
  * Here we rely on global state, and we assume this
  * method gets executed as part of an HTTP request.
  */
  $host = $_SERVER['HTTP_HOST'];
  }
 }
 </code></pre>
<p>7</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0027_original/original_page.png" alt="Original Page 27">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>1. Introduction</strong></h3>
<p>
</p>
<pre><code class="language-php">
 // ...
 }
 public function usesAStaticServiceLocator(): void
 {
  /*
  * Here we rely on Zend_Registry to have been
  * configured before calling this method.
  */
  $translator = Zend_Registry::get('Zend_Translator');
  // ...
 }
 public function onlyWorksAtTheCommandLine(): void
 {
  /*
  * Here we rely on php_sapi_name() to return a specific
  * value. Only when this application has been started from
  * the command line will this function return 'cli'.
  */
  if (php_sapi_name() !== 'cli') {
  return;
  }
  // ...
 }
 </code></pre>
<p>برخی از کدها در تئوری می‌توانند در هر environment اجرا شوند، اما در عمل انجام این کار دشوار خواهد بود. مثال موجود در Listing 1.5 را در نظر بگیرید. <code>OrderController</code> را می‌توان در هر context ای نمونه‌سازی کرد و فراخوانی متد <code>action</code> و انتقال یک instance از <code>RequestInterface</code> به آن نسبتاً آسان خواهد بود. با این حال، واضح است که این کد فقط برای اجرا در یک environment بسیار خاص طراحی شده است، یعنی یک web application.</p>
<p><strong>Listing 1.5.</strong> Code that is designed to run in a web application.</p>
<p>8</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0028_original/original_page.png" alt="Original Page 28">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>1. Introduction</strong></h3>
<p>
</p>
<pre><code class="language-php">
 use Psr\Http\Message\RequestInterface;
 use Psr\Http\Message\ResponseInterface;
 final class OrderController
 {
  public function createOrderAction(
  RequestInterface $request
  ): ResponseInterface {
  // ...
  }
 }
 </code></pre>
<p>فقط در صورتی که کد به یک context خاص نیاز نداشته باشد، و همچنین برای اجرا در یک context خاص طراحی نشده باشد یا وابستگی‌هایی نداشته باشد که این مورد برای آنها صدق کند، می‌توان آن را core code در نظر گرفت.</p>
<p>Listing 1.6 چندین مثال از core code را نشان می‌دهد. این کلاس‌ها را می‌توان در هر جایی نمونه‌سازی کرد، و هر client باید قادر باشد هر یک از متدهای موجود را فراخوانی کند. هیچ یک از این متدها به چیزی خارج از خود application وابسته نیستند.</p>
<p><strong>Listing 1.6.</strong> Some examples of core code.</p>
<pre><code class="language-php">
 /*
 * This is a proper abstraction for an object that talks to the database:
 */
 interface MemberRepository
 {
  public function save(Member $member): void;
 }
 final class MemberService
 {
  private MemberRepository $memberRepository;
  public function requestAccess(
  string $emailAddress,
  string $purchaseId
  ): void {
  $member = Member::requestAccess(
  EmailAddress::fromString($emailAddress),
  9
 </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0029_original/original_page.png" alt="Original Page 29">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>1. Introduction</strong></h3>
<pre><code class="language-php">
  PurchaseId::fromString($purchaseId)
  );
  $this-&gt;memberRepository-&gt;save($member);
  }
 }
 final class EmailAddress
 {
  private string $emailAddress;
  private function __construct(string $emailAddress)
  {
  if (!filter_var($emailAddress, FILTER_VALIDATE_EMAIL)) {
  throw new InvalidArgumentException('...');
  }
  $this-&gt;emailAddress = $emailAddress;
  }
  public static function fromString(string $emailAddress): self
  {
  return new self($emailAddress);
  }
 }
 final class Member
 {
  public static function requestAccess(
  EmailAddress $emailAddress,
  PurchaseId $purchaseId
  ): self {
  // ...
  }
 }
 </code></pre>
<p>عدم نیاز به ایجاد یک context خاص برای اجرای کد، دوباره برای testability عالی است. تنها کاری که باید در یک سناریوی test انجام دهید این است که کلاس را نمونه‌سازی کنید و یک متد را روی آن فراخوانی کنید. اما پیروی از rules برای core code فقط برای testing عالی نیست. همچنین به محافظت از core code شما در برابر همه کمک می‌کند</p>
<p>10</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0030_original/original_page.png" alt="Original Page 30">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>1. Introduction</strong></h3>
<p> انواع تغییرات خارجی، مانند ارتقاء major framework، تغییر به یک database vendor متفاوت، و غیره.</p>
<p>تصادفی نیست که کلاس‌های موجود در این مثال domain-oriented هستند. در فصل 12 ما در مورد architectural layering بحث خواهیم کرد و قوانینی را برای لایه‌های <code>Domain</code> و <code>Application</code> تعریف می‌کنیم که به طور طبیعی با rules برای core و infrastructure code هم‌راستا هستند. به طور خلاصه: تمام کد domain و use cases از application باید core code باشند، و نباید به infrastructure اطراف تکیه کنند یا به آن متصل باشند.</p>
<p>این همچنین توضیح می‌دهد که چرا من از کلمات "core" و "infrastructure" استفاده می‌کنم. <code>Infrastructure</code> یک اصطلاح رایج است که برای توصیف جنبه‌های فنی یک تعامل استفاده می‌شود. در یک web application، infrastructure از ارتباط بین application شما و دنیای بیرون پشتیبانی می‌کند. <em>Core</em> مرکز application شما است، infrastructure در اطراف آن قرار دارد، هم از <em>core</em> محافظت می‌کند و هم آن را به external systems و کاربران متصل می‌کند (شکل 1.1).</p>
<p><strong>Figure 1.1.</strong> Connecting the core to external systems and users through infrastructure</p>
<p>“آیا تمام کد موجود در دایرکتوری vendor من، infrastructure code است؟”</p>
<p>سوال عالی است. در /vendor شما web framework خود را خواهید یافت، که ارتباط با مرورگرها و external systems را با استفاده از HTTP تسهیل می‌کند. شما</p>
<p>11</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 31" src="page_0031/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0031_original/original_page.png" alt="Original Page 31">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>1. Introduction</strong></h3>
<p>همچنین ORM را پیدا می‌کنید، که ارتباط با database را تسهیل می‌کند، و به شما کمک می‌کند تا objects خود را در tables ذخیره کنید. تمام این کد با تعریف core code ارائه شده در این فصل مطابقت ندارد. برای اجرای این کد، معمولاً به external systems مانند database یا web server نیاز دارید تا در دسترس باشند. کد برای اجرا در یک context خاص، مانند terminal، یا به عنوان بخشی از یک چرخه request/response در وب، طراحی شده است. بنابراین بیشتر کد موجود در /vendor باید infrastructure code در نظر گرفته شود.</p>
<p>با این حال، قرار گرفتن در یک دایرکتوری خاص تعیین نمی‌کند که آیا چیزی infrastructure code است یا خیر. قوانین در این مورد چیزی نمی‌گویند. آنچه مهم است این است که کد چه کاری انجام می‌دهد و برای انجام آن به چه چیزی نیاز دارد. این بدان معناست که ممکن است مقداری، یا شاید مقدار زیادی از کد موجود در /vendor، در نهایت core code در نظر گرفته شود، حتی اگر توسط شما یا به طور خاص برای application شما نوشته نشده باشد.</p>
<p><strong>1.4. Summary</strong></p>
<p>در سراسر این کتاب، ما بین core و infrastructure code تمایز قائل می‌شویم، که اساس برخی از تصمیمات معماری در ادامه خواهد بود. Core code کدی است که می‌تواند در هر context، بدون هیچ setup خاص یا external systems که نیاز به در دسترس بودن داشته باشند، اجرا شود. برای infrastructure code برعکس این است: به external systems، setup خاص، یا فقط برای اجرا در یک context خاص طراحی شده است.</p>
<p>در فصل‌های بعدی، به نحوه refactor کردن کد mixed به core و infrastructure code که به درستی از هم جدا شده‌اند و از rules ارائه شده در این فصل پیروی می‌کنند، خواهیم پرداخت.</p>
<p><strong>Exercises</strong></p>
<p>1. آیا کد زیر باید infrastructure code در نظر گرفته شود؟</p>
<pre><code class="language-php">
  $now = new DateTimeImmutable('now');
  $expirationDate = $now-&gt;modify('+2 days');
 </code></pre>
<p>12</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0032_original/original_page.png" alt="Original Page 32">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>1. Introduction</strong></h3>
<pre><code class="language-php">
  $membershipRequest = new MembershipRequest($expirationDate);
 </code></pre>
<p><strong>2. Should the code below be considered infrastructure code?b</strong></p>
<pre><code class="language-php">
 namespace Symfony\Component\EventDispatcher;
 class EventDispatcher implements EventDispatcherInterface
 {
  // ...
  public function dispatch(
  object $event,
  string $eventName = null
  ): object {
  $eventName = $eventName ?? get_class($event);
  // ...
  if ($listeners) {
  $this-&gt;callListeners($listeners, $eventName, $event);
  }
  return $event;
  }
  // ...
 }
 </code></pre>
<p><strong>3. Should the code below be considered core code?c</strong></p>
<pre><code class="language-php">
 interface HttpClient
 {
  public function get(string $url): Response;
 }
 final class Importer
 {
  private HttpClient $httpClient;
 </code></pre>
<p>13</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0033_original/original_page.png" alt="Original Page 33">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>1. Introduction</strong></h3>
<pre><code class="language-php">
 public function __construct(HttpClient $httpClient)
 {
  $this-&gt;httpClient = $httpClient;
 }
 public function importPurchasesFromLeanpub(): void
 {
  $response = $this-&gt;httpClient-&gt;get(
  'https://leanpub.com/api/individual-purchases'
  );
  // ...
 }
 </code></pre>
<p>aپاسخ صحیح: بله. برای تعیین زمان فعلی، application به infrastructure اطراف، در این مورد clock system، دسترسی پیدا می‌کند.</p>
<p>bپاسخ صحیح: خیر. اگرچه این کد بخشی از فریم‌ورک Symfony است، اما برای اجرا به هیچ setup خاصی نیاز ندارد. به external systems نیازی ندارد که در دسترس باشند، و برای اجرا در یک context خاص، مانند terminal یا یک web server، طراحی نشده است.</p>
<p>cپاسخ صحیح: خیر. اگرچه کد به یک interface وابسته است، اما abstraction از وابستگی کامل نیست. interface از نوع <code>HttpClient</code> برای ارتباط مبتنی بر HTTP با external services طراحی شده است و نمی‌توان آن را با یک alternative معقول در صورت عدم نیاز به فناوری HTTP جایگزین کرد.</p>
<p>14</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0034_original/original_page.png" alt="Original Page 34">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>2. The domain model</strong></h3>
<p>این فصل شامل موارد زیر است:</p>
<ul>
<li>Extracting یک entity و یک repository از database interaction code</li>
<li>استفاده از یک entity برای محافظت از model در برابر data ناهمسان</li>
<li>Mapping کردن entity به یک database table در داخل یک repository implementation</li>
<li>ارائه یک entity با هویت قبل از ذخیره آن</li>
</ul>
<p><strong>2.1. SQL statements all over the place</strong></p>
<p>در این فصل ما با یک web application خیالی کار می‌کنیم که به کاربران اجازه می‌دهد تا کاتالوگ e-books را مرور کنند، یکی را انتخاب کنند و آن را سفارش دهند. این یک legacy application است که نگهداری آن دشوار می‌شود. یافتن آنچه کد انجام می‌دهد، مفاهیمی که با آنها سروکار دارد و rules کسب و کاری که قابل اجرا هستند، دشوار است. همچنین، هیچ‌کس تست‌ها را ننوشته است زیرا نوشتن آنها برای این نوع کد دشوار است.</p>
<p>بیایید به کدی نگاهی بیندازیم که application ما زمانی که کاربر یک e-book را از کاتالوگ ما انتخاب می‌کند و آن را سفارش می‌دهد اجرا می‌کند (به Listing 2.1 مراجعه کنید).</p>
<p><strong>Listing 2.1.</strong> The original <code>orderEbookAction()</code>.</p>
<pre><code class="language-php">
 public function orderEbookAction(Request $request): Response
 {
  $connection = $this-&gt;container-&gt;get('connection');
  15
 </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0035_original/original_page.png" alt="Original Page 35">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<p>
    در این بخش، نمونه‌ای از چگونگی تعامل با یک <strong>domain model</strong> در یک application را بررسی می‌کنیم. این کد، یک <code>API</code> برای پردازش سفارش‌ها را نشان می‌دهد.
  </p>
<p>
    ابتدا، قیمت <code>ebook</code> را از <code>database</code> دریافت می‌کنیم. سپس، مقدار سفارش (<code>orderAmount</code>) را بر اساس تعداد درخواستی و قیمت <code>ebook</code> محاسبه می‌کنیم.
  </p>
<p>
    یک <code>array</code> به نام <code>record</code> ایجاد می‌کنیم که شامل اطلاعات سفارش مانند <code>email</code>، <code>quantity</code> و <code>amount</code> است.
  </p>
<p>
    سپس، با استفاده از <code>array_keys</code> و <code>array_map</code>، ستون‌ها و مقادیر برای <code>SQL</code> را آماده می‌کنیم.
  </p>
<p>
    در نهایت، یک <code>INSERT</code> <code>SQL</code> <code>query</code> اجرا می‌کنیم تا سفارش را در <code>database</code> ذخیره کنیم. پس از درج، <code>ID</code> آخرین سفارش درج شده را بازیابی می‌کنیم و آن را در <code>session</code> ذخیره می‌کنیم.
  </p>
<p>
    در اینجا کد مورد نظر را مشاهده می کنید:
  </p>
<pre><code class="language-php">
    $ebookPrice = $connection-&gt;execute(
    'SELECT price FROM ebooks WHERE id = :id',
    [
    'id' =&gt; $request-&gt;request-&gt;get('ebook_id')
    ]
    )-&gt;fetchColumn(0);
    $orderAmount = (int)$request-&gt;get('quantity')
    * (int)$ebookPrice;
    $record = [
    'email' =&gt; $request-&gt;get('email_address'),
    'quantity' =&gt; (int)$request-&gt;get('quantity'),
    'amount' =&gt; $orderAmount,
    ];
    $columns = array_keys($record);
    $values = array_map(
    fn ($value) =&gt; $connection-&gt;escape($value),
    array_values($record)
    );
    $sql = 'INSERT INTO orders ('
    . implode(', ', $columns)
    . ') VALUES (' . implode(', ', $values) . ')';
    $connection-&gt;execute($sql);
    $lastInsertedId = $connection-&gt;execute(
    'SELECT LAST_INSERT_ID()'
    )-&gt;fetchColumn(0);
    $this-&gt;container-&gt;get('session')-&gt;set(
    'currentOrderId',
    $lastInsertedId
    );
    // ...
    return new Response(/* ... */);
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0036_original/original_page.png" alt="Original Page 36">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<p>
    اگر شما می‌توانید بین خطوط را بخوانید (و از طریق <code>SQL</code> <code>statements</code> ببینید)، چند چیز یاد خواهید گرفت. به عنوان یک <code>user</code>، شما می‌توانید یک <code>e-book</code> را با <code>ID</code> آن سفارش دهید.
    شما باید <code>email address</code> خود را ارائه دهید، و سفارش شما به عنوان یک <code>record</code> در جدول <code>orders</code> <code>persisted</code> خواهد شد. خود جدول <code>orders</code> دارای یک ستون شناسایی با افزایش خودکار است.
    پس از درج یک <code>record</code> جدید در جدول <code>orders</code>، <code>controller</code> <code>ID</code> اختصاص داده شده به آن را <code>automatically</code> واکشی می‌کند و آن را در <code>session</code> ذخیره می‌کند.
  </p>
<p>
    ممکن است از قبل برای شما واضح باشد که این کد بد است. با این وجود، من به اختصار معایب را در اینجا ذکر می‌کنم:
  </p>
<ol>
<li>
      واقعاً سخت است که بفهمیم داستان، یا سناریوی این <code>action</code> چیست. <em>Use case</em> سفارش یک <code>e-book</code> چه چیزی را در بر می‌گیرد؟ چه مراحلی درگیر هستند؟ نتیجه چه خواهد بود؟
    </li>
<li>
      جزئیات <code>implementation</code>، دید را نسبت به مراحل سطح بالاتر سناریو مبهم می‌کند. به عنوان مثال، یک مرحله ذخیره <code>order</code> جدید است. با این حال، کد نمی‌گوید "ذخیره <code>order</code>". این به سادگی نشان می‌دهد که این ذخیره چگونه انجام می‌شود.
      ما باید <code>SQL statement</code> را تجزیه و تحلیل کنیم و متوجه شویم که این یک <code>INSERT statement</code> است، که از آن می‌توانیم استنباط کنیم که این کد برای ذخیره یک <code>order</code> جدید است.
    </li>
<li>
      ترکیب مراحل سطح بالا با جزئیات <code>implementation</code> سطح پایین، <code>use case</code> را مستقیماً به هر تصمیم <code>technological</code> مرتبط متصل می‌کند. این امر تغییر جهت را در آینده بسیار دشوار می‌کند. به عنوان مثال، ما در
      <code>migration</code> به یک <code>database</code> متفاوت مشکل خواهیم داشت. همچنین در جایگزینی فرم وب با یک <code>JSON API</code> برای این <code>use case</code> مشکل خواهیم داشت.
    </li>
</ol>
<p>
    در این فصل ما بر روی مشکل دوم تمرکز خواهیم کرد. ما می‌خواهیم <code>order</code> را در یک مرحله ذخیره کنیم و جزئیات اینکه دقیقاً چگونه این کار انجام می‌شود را پنهان کنیم. در فصل 3 و فصل 4 ما روی
    مسائل باقی مانده کار خواهیم کرد.
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0037_original/original_page.png" alt="Original Page 37">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<h4>2.2. Trying to fix it with a table data gateway</h4>
<p>
    یک راه‌حل سنتی برای push کردن <code>SQL statements</code> در خارج از کد معمولی استفاده از <code>Table Data Gateway</code> (یا به اختصار <code>table gateway</code>) <code>design pattern</code><sup>1</sup> است.
    این <code>SQL statements</code> و سایر جزئیات <code>implementation</code> را پشت یک <code>interface</code> واحد در هر جدول <code>database</code> پنهان می‌کند. Listing 2.2 نشان می‌دهد که زمانی که ما شروع به استفاده از <code>table gateways</code> می‌کنیم،
    <code>controller action</code> چگونه به نظر می‌رسد.
  </p>
<p>
<em>Listing 2.2.</em> <code>orderEbookAction</code> از <code>Table gateways</code> برای تعامل با <code>database</code> استفاده می‌کند.
  </p>
<pre><code class="language-php">
    public function orderEbookAction(Request $request): Response
    {
    $ebooksGateway = $this-&gt;container-&gt;get('ebooks_gateway');
    $ebookPrice = $ebooksGateway-&gt;select(
    [
    'id' =&gt; $request-&gt;request-&gt;get('ebook_id')
    ]
    )[0]['price'];
    $orderAmount = (int)$request-&gt;get('quantity')
    * (int)$ebookPrice;
    $ordersGateway = $this-&gt;container-&gt;get('orders_gateway');
    $lastInsertedId = $ordersGateway-&gt;insert(
    [
    'email' =&gt; $request-&gt;get('email_address'),
    'quantity' =&gt; (int)$request-&gt;get('quantity'),
    'amount' =&gt; $orderAmount
    ]
    );
    $this-&gt;container-&gt;get('session')-&gt;set(
    'currentOrderId',
    $lastInsertedId
    );
  </code></pre>
<p>
<sup>1</sup>Martin Fowler, “Patterns of Enterprise Application Architecture”, Addison-Wesley Professional (2003).
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0038_original/original_page.png" alt="Original Page 38">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    // ...
    return new Response(/* ... */);
  </code></pre>
<p>
    این <code>method</code> اکنون بسیار کوتاه‌تر است. ما دیگر <code>SQL statements</code> در کد معمولی خود نداریم. هنگام خواندن آن، ما مجبور نیستیم به دفعات <code>contexts</code> را تغییر دهیم، بنابراین قطعاً درک آنچه اتفاق می‌افتد آسان‌تر است.
    با این حال، ما فقط موفق شدیم نیمی از مشکل اصلی را برطرف کنیم. ما می‌توانستیم فقط برخی از جزئیات <code>implementation</code> (نام جدول، <code>SQL queries</code>) را پنهان کنیم، اما سایر جزئیات <code>implementation</code> را
    درون <code>controller action</code> (نام و انواع ستون‌ها) باقی گذاشتیم. این امر ما را همچنان بسیار وابسته به تصمیمات <code>technological</code> که برای این قطعه کد گرفته‌ایم، می‌کند: کد،
    کد بسیار table-oriented باقی می‌ماند، بنابراین ما مجبور به استفاده از یک <code>relational database</code> هستیم.
  </p>
<p>
    ارائه دستکاری‌های table-oriented عمومی مانند یک <code>table gateway</code>، یک مشکل دیگر را نشان می‌دهد که ما هنوز متوجه آن نشده‌ایم، اما از ابتدا وجود داشته است. هیچ چیز مانع از این نمی‌شود که ما یک <code>string</code> را در ستون <code>email</code> درج کنیم
    که حتی شبیه یک <code>email address</code> نباشد. <code>table gateway</code> همچنین ما را از محاسبه نادرست مقدار سفارش و درج مستقیم آن در <code>database</code> باز نمی‌دارد. به عبارت دیگر: ما نمی‌توانیم از <code>internal consistency</code> یک سفارش <code>e-book</code> محافظت کنیم.
  </p>
<h4>2.3. Designing an entity</h4>
<p>
    ما می‌خواهیم سفارش یک <code>e-book</code> مشتری را بگیریم و آن را به خاطر بسپاریم، بنابراین می‌توانیم بعداً آن را پردازش کنیم. بنابراین قبل از ذخیره یک سفارش، باید اطمینان حاصل کنیم که کامل و صحیح است.
    اگر این کار را نکنیم، ممکن است حتی مجبور شویم بعداً با مشتریان خود تماس بگیریم و از آنها بخواهیم داده‌هایی را که از آنها دریافت کرده‌ایم تصحیح کنند. ما همچنین می‌خواهیم اطمینان حاصل کنیم که آنچه در <code>database</code> قرار می‌گیرد،
    می‌تواند با خیال راحت توسط سایر قسمت‌های <code>application</code> استفاده شود، به عنوان مثال توسط ماژول پرداخت، یا ماژول انجام، که <code>e-book</code> را برای مشتری ارسال می‌کند.
  </p>
<p>
    ما خوش شانس هستیم که <code>object-oriented programming</code> را انجام می‌دهیم، زیرا با <code>objects</code> می‌توانیم به تمام اهداف خود دست یابیم. هنگامی که یک <code>object</code> ایجاد می‌شود، می‌تواند بپذیرد
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0039_original/original_page.png" alt="Original Page 39">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<p>
<code>data</code> را به عنوان آرگومان‌های <code>constructor</code> می‌پذیرد، آن <code>data</code> را تجزیه و تحلیل می‌کند، و زمانی که هر بخشی از آن درست به نظر نمی‌رسد، یا منجر به این می‌شود که <code>object</code> در یک حالت <code>inconsistent</code> یا <code>incomplete</code> قرار گیرد، <code>exceptions</code> پرتاب می‌کند.
    در مورد ما، ما یک کلاس <code>Order</code> را تعریف می‌کنیم (به Listing 2.3 مراجعه کنید)، که با حضور پارامترهای <code>constructor</code> خود می‌تواند خالق خود را مجبور کند که تمام <code>data</code>های لازم را یک‌جا ارائه دهد.
  </p>
<p>
<em>Listing 2.3.</em> نسخه اولیه <code>Order entity</code>.
  </p>
<pre><code class="language-php">
    final class Order
    {
    private int $ebookId;
    private string $emailAddress;
    private int $quantityOrdered;
    private int $pricePerUnitInCents;
    private int $orderAmountInCents;
    public function __construct(
    int $ebookId,
    string $emailAddress,
    int $quantityOrdered,
    int $pricePerUnitInCents,
    int $orderAmountInCents
    ) {
    $this-&gt;ebookId = $ebookId;
    $this-&gt;emailAddress = $emailAddress;
    $this-&gt;quantityOrdered = $quantityOrdered;
    $this-&gt;pricePerUnitInCents = $pricePerUnitInCents;
    $this-&gt;orderAmountInCents = $orderAmountInCents;
    }
  </code></pre>
<p>
    // یک <code>client</code> باید تمام آرگومان‌های مورد نیاز را ارائه دهد:
  </p>
<pre><code class="language-php">
    $order = new Order(/* ... */);
  </code></pre>
<p>
    مجبور کردن <code>clients</code> به ارائه تعدادی از آرگومان‌ها هنگام <code>instantiating</code> کلاس <code>Order</code> برای تضمین <code>consistency</code> کافی نیست. اطلاعاتی که <code>clients</code> ارائه می‌دهند هنوز هم می‌تواند نامعتبر یا بی‌معنی باشد.
    به عنوان مثال، <code>implementation</code> فعلی شما را از <code>instantiating</code> یک <code>Order</code> به روش زیر، که بدیهی است نامعتبر است، باز نمی‌دارد: <code>new Order(-10, 'foobar', 0, 1000000, 25)</code>.
  </p>
<p>
    ما می‌توانیم <code>constructor</code> را با انجام برخی از <code>checks</code> های اساسی در داخل آن بهبود دهیم، با استفاده از
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0040_original/original_page.png" alt="Original Page 40">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<p>
<code>assertions</code> از یکی از <code>libraries</code> های <code>assertion</code> موجود (به عنوان مثال beberlei/assert2)، یا استفاده از <code>native assertions</code><sup>3</sup> اگر دوست دارید. به Listing 2.4 مراجعه کنید که نشان می‌دهد چگونه
    می‌توان از <code>assertion functions</code> از پیش تعریف شده برای جلوگیری از اختصاص <code>data</code> بد به <code>properties</code> یک <code>Order instance</code> استفاده کرد.
  </p>
<p>
<em>Listing 2.4.</em> <code>Order entity</code> آرگومان‌های <code>constructor</code> خود را با استفاده از <code>assertions</code> اعتبارسنجی می‌کند.
  </p>
<pre><code class="language-php">
    use Assert\Assertion;
    final class Order
    {
    // ...
    public function __construct(
    int $ebookId,
    string $emailAddress,
    int $quantityOrdered,
    int $pricePerUnitInCents,
    int $orderAmountInCents
    ) {
    Assertion::greaterThan($ebookId, 0);
    Assertion::email($emailAddress);
    Assertion::greaterThan($quantityOrdered, 0);
    Assertion::greaterThan($pricePerUnitInCents, 0);
    Assertion::greaterThan($orderAmountInCents, 0);
    $this-&gt;ebookId = $ebookId;
    $this-&gt;emailAddress = $emailAddress;
    $this-&gt;quantityOrdered = $quantityOrdered;
    $this-&gt;pricePerUnitInCents = $pricePerUnitInCents;
    $this-&gt;orderAmountInCents = $orderAmountInCents;
    }
  </code></pre>
<p>
    کد در <code>Assertion::greaterThan()</code> اگر <code>$ebookId</code> 0 یا کمتر باشد، یک <code>exception</code> پرتاب می‌کند. به همین ترتیب، اگر <code>$emailAddress</code> یک <code>string</code> است، اما شبیه یک
  </p>
<p>
<sup>2</sup> https://advwebapparch.com/beberlei-assert
  </p>
<p>
<sup>3</sup> https://advwebapparch.com/native-assertions
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0041_original/original_page.png" alt="Original Page 41">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<p>
<code>email address</code>، یک <code>exception</code> پرتاب می‌کند. این <code>assertions</code> از این طریق از <code>instantiated</code> شدن یک <code>Order object</code> با <code>data</code> نامعتبر جلوگیری می‌کنند.
    با وجود این <code>assertions</code>، <code>Order object</code> می‌تواند <code>consistency</code> اساسی را برای <code>data</code>ای که در اختیار دارد، فراهم کند.
  </p>
<p>
    "آیا می‌توانیم از این <code>assertion functions</code> برای اعتبارسنجی <code>user input</code> استفاده کنیم؟"
  </p>
<p>
    اگر کاربر یک <code>email address</code> نامعتبر را وارد کند، احتمالاً می‌خواهیم یک پیام خطا زیبا و دوستانه در کنار فیلد فرم <code>email</code> نشان دهیم که کاربر آن را ارائه کرده است.
    با نسخه فعلی <code>Order entity</code> ما، نمی‌توانیم این کار را انجام دهیم، زیرا فراخوانی <code>Assertion::email()</code> با یک <code>string</code> که شبیه <code>email address</code> نیست، یک <code>exception</code> پرتاب می‌کند.
    اگر شما آن <code>exception</code> را در جایی <code>catch</code> نکنید، فقط صفحه خطای پیش‌فرض <code>application</code> با یک پیام عمومی مانند "Oops, an error occurred" نشان داده می‌شود.
    به طور خلاصه: <code>assertions</code> زمانی که ما نیاز به اعتبارسنجی <code>user input</code> داریم، خیلی مفید نخواهند بود. در عوض، آنها باید توسط <code>objects</code> به عنوان راهی برای محافظت از خود در برابر <code>data</code>
    ناقص، <code>inconsistent</code> یا بی‌معنی استفاده شوند. هنگامی که صحبت از بازگشت به یک کاربر، اطلاع‌رسانی به آنها در مورد اشتباهاتشان می‌شود، باید به دنبال جایگزین‌ها باشید. ما در فصل 8 به چندین مورد از این موارد می‌پردازیم.
  </p>
<p>
    یک <code>object</code> <code>stateful</code> که <code>consistency</code> خود را تضمین می‌کند، و قرار است به نحوی <code>persisted</code> شود، اغلب یک <code>Entity</code><sup>4</sup> نامیده می‌شود. <code>Entities</code> طبق تعریف دارای یک <code>identity</code> هستند، که ما می‌توانیم از آن برای ذخیره و
    بازگرداندن آن از <code>storage</code> استفاده کنیم. اگرچه <code>Order</code> ما هنوز یک <code>identity</code> (<code>ID</code>) ندارد، ما قصد داریم در بخش 2.6 به آن یک <code>identity</code> بدهیم، بنابراین اجازه دهید <code>Order</code> را از قبل یک <code>entity</code> در نظر بگیریم.
  </p>
<p>
    ما تقریباً آماده‌ایم تا از <code>Order instance</code> جدید در <code>controller action</code> استفاده کنیم. یک چیز وجود دارد که ما را از انجام این کار باز می‌دارد: <code>table gateway</code> برای <code>orders</code> یک <code>insert() method</code> دارد که یک <code>array</code> از <code>columns =&gt; values</code> را می‌پذیرد (به Listing 2.5 مراجعه کنید).
    اما اکنون که ما <code>form data</code> را به <code>constructor</code> <code>Order</code> منتقل می‌کنیم، دیگر چنین <code>array</code>ای در داخل <code>controller</code> نداریم. ما می‌توانیم آن را دوباره اضافه کنیم، اما خلاص شدن از نام‌های <code>column</code> واقعی در داخل <code>controller action</code>
    از قبل در لیست بهبودهای ما بود، بنابراین ما نباید این کار را انجام دهیم.
  </p>
<p>
<sup>4</sup>Eric Evans, “Domain-Driven Design”, Addison-Wesley Professional (2003).
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0042_original/original_page.png" alt="Original Page 42">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<p>
<em>Listing 2.5.</em> برای ذخیره یک <code>Order entity</code> با استفاده از یک <code>table gateway</code>، ما هنوز به یک <code>map</code> از ستون‌ها به مقادیر نیاز داریم.
  </p>
<pre><code class="language-php">
    public function orderEbookAction(Request $request): Response
    {
    // ...
    // We'd like to use the new Order entity...
    $order = new Order(
    $request-&gt;get('ebook_id'),
    $request-&gt;get('email_address'),
    (int)$request-&gt;get('quantity'),
    (int)$pricePerUnitInCents,
    (int)$orderAmount
    );
    // But how to save an Order object to the database?
    $ordersGateway = $this-&gt;container-&gt;get('orders_gateway');
    $lastInsertedId = $ordersGateway-&gt;insert(
    [
    // We need a map of columns =&gt; values
    ]
    );
    // ...
  </code></pre>
<p>
    چیزی که ما می‌خواهیم ذخیره کنیم (<code>Order object</code>)، و چیزی که می‌تواند آن را ذخیره کند (<code>OrdersGateway</code>) ناسازگار هستند. اما ما هنوز می‌خواهیم <code>Order object</code> را به نحوی در <code>database</code> ذخیره کنیم، بنابراین باید یک <code>design</code> متفاوت برای چیزی که می‌تواند این کار را انجام دهد، پیدا کنیم.
  </p>
<h4>2.4. Introducing a repository</h4>
<p>
    اگر یک <code>facility</code> خاص هنوز در یک <code>project</code> در دسترس نیست، می‌توانید یک ترفند برنامه‌نویسی را اعمال کنید: طوری عمل کنید که گویی قبلاً در دسترس بوده است. به عنوان مثال، اگر شما به دنبال
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0043_original/original_page.png" alt="Original Page 43">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<p>
    برای چیزی که می‌تواند یک <code>Order</code> را در <code>database</code> ذخیره کند، فقط تصور کنید که آن چیز از قبل وجود دارد، و شروع به استفاده از آن کنید (به Listing 2.6 مراجعه کنید).
  </p>
<p>
<em>Listing 2.6.</em> یک <code>object</code> خیالی برای ذخیره <code>orders</code>.
  </p>
<pre><code class="language-php">
    $order = new Order(/* ... */);
    $lastInsertedId = $orderSaver-&gt;save($order);
  </code></pre>
<p>
    برای اینکه در این مکان برای ما مفید باشد، چیزی که می‌تواند یک <code>order</code> را ذخیره کند، فقط به یک <code>method</code> <code>save()</code> با یک پارامتر واحد از نوع <code>Order</code> نیاز دارد. از آنجایی که <code>database</code>، <code>ID</code> یک <code>order</code> جدید را با استفاده از یک ستون عدد صحیح با افزایش خودکار تعیین می‌کند،
    ما می‌توانیم این <code>method</code> را یک نوع بازگشتی <code>int</code> بدهیم، بنابراین یک <code>client</code> از این <code>method</code> می‌تواند بعداً از <code>ID</code> تازه اختصاص داده شده استفاده کند. بیایید همه اینها را با تعریف یک
    <code>interface</code> برای "<code>order saver</code>" خود (به Listing 2.7 مراجعه کنید) رسمی کنیم.
  </p>
<p>
<em>Listing 2.7.</em> <code>The OrderSaver interface</code>.
  </p>
<pre><code class="language-php">
    interface OrderSaver
    {
    /**
    * @return int The ID of the saved Order
    */
    public function save(Order $order): int;
    }
  </code></pre>
<p>
    "<code>Object savers</code>" معمولاً <code>repositories</code> نامیده می‌شوند. <code>Repository</code> نام یک <code>design pattern</code> است که یک راه‌حل برای یک مشکل رایج ارائه می‌دهد: نیاز به ذخیره یک <code>domain object</code> و
    بعداً بازسازی آن. برای اینکه روشن شود که ما قصد داریم از <code>repository design pattern</code><sup>5</sup> در اینجا استفاده کنیم، اجازه دهید <code>OrderSaver</code> را به <code>OrderRepository</code> تغییر نام دهیم (به Listing 2.8 مراجعه کنید).
  </p>
<p>
<em>Listing 2.8.</em> <code>The OrderRepository interface</code>.
  </p>
<pre><code class="language-php">
    interface OrderRepository
    {
    public function save(Order $order): int;
    }
  </code></pre>
<p>
<sup>5</sup>Eric Evans, “Domain-Driven Design”, Addison-Wesley Professional (2003).
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0044_original/original_page.png" alt="Original Page 44">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<p>
    "آیا ما نباید یک <code>method</code> <code>getById()</code> هم داشته باشیم؟"
  </p>
<p>
    علاوه بر ذخیره یک <code>entity</code>، یک <code>repository</code> معمولاً راهی برای بازیابی یک <code>entity</code> قبلاً ذخیره شده از <code>database</code> ارائه می‌دهد. به طور معمول یک <code>repository</code> دارای یک <code>method</code> <code>getById()</code> است که به <code>clients</code> اجازه می‌دهد این کار را انجام دهند:
  </p>
<pre><code class="language-php">
    interface OrderRepository
    {
    public function save(Order $order): void;
    /**
    * @throws CouldNotFindOrder
    */
    public function getById(int $orderId): Order;
    }
  </code></pre>
<p>
    یک <code>client</code>، <code>ID</code> <code>entity</code> را که می‌خواهد بازیابی کند، ارائه می‌کند، و <code>repository</code> <code>data</code> را برای <code>order</code> مربوطه از <code>database</code> می‌گیرد، و در نهایت کل <code>entity object</code> را با استفاده از این <code>data</code> بازسازی می‌کند.
    اگر <code>repository</code> نتواند یک <code>order</code> با <code>ID</code> ارائه شده پیدا کند، یک <code>exception</code> سفارشی (به عنوان مثال <code>CouldNotFindOrder</code>) که از <code>RuntimeException</code> گسترش می‌یابد، پرتاب می‌کند.
  </p>
<p>
    از آنجایی که ما در حال <code>refactoring</code> کد موجود برای فقط یک <code>controller</code> هستیم، نمی‌خواستم بلافاصله اضافه کردن یک <code>method</code> <code>getById()</code> را به <code>OrderRepository</code> پیشنهاد کنم، اما وقتی زمانش فرا می‌رسد، خوب است بدانید که <code>save()</code> یک
    <code>counterpart</code> متقارن به نام <code>getById()</code> دارد.
  </p>
<p>
    در <code>controller</code>، همه چیز اکنون بسیار تمیزتر می‌شود (به Listing 2.9 مراجعه کنید). ما می‌توانیم یک <code>object</code> جدید از نوع <code>Order</code> را <code>instantiate</code> کنیم و آن را به <code>OrderRepository</code> تحویل دهیم، که سپس آن را در <code>database</code> ذخیره می‌کند. با فرض اینکه ما به نوعی می‌توانیم یک <code>instance</code> کارآمد از <code>OrderRepository</code> را از
    <code>service container</code> خود دریافت کنیم، اینطور است.
  </p>
<p>
<em>Listing 2.9.</em> <code>orderEbookAction()</code> اکنون از <code>OrderRepository</code> و <code>Order entity</code> استفاده می‌کند.
  </p>
<pre><code class="language-php">
    public function orderEbookAction(Request $request): Response
    {
    // ...
    $order = new Order(/* ... */);
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0045_original/original_page.png" alt="Original Page 45">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    $orderRepository = $this-&gt;container-&gt;get('order_repository');
    $lastInsertedId = $orderRepository-&gt;save($order);
    // ...
  </code></pre>
<h4>2.5. Mapping entity data to table columns</h4>
<p>
    تا کنون ما با <code>OrderRepository interface</code> کار می‌کردیم، که در حال حاضر هیچ <code>implementation</code> ندارد. نوشتن یک <code>implementation</code> که در واقع یک <code>Order</code> را در <code>database</code> ذخیره می‌کند، ممکن است به سادگی آنطور که ما امیدواریم نباشد.
    همانطور که در Listing 2.10 می‌بینید، در مقطعی ما هنوز به آن <code>array</code> از <code>columns =&gt; values</code> نیاز خواهیم داشت که دیگر نداریم.
  </p>
<p>
<em>Listing 2.10.</em> <code>SqlOrderRepository</code> به یک <code>map</code> از ستون‌ها و مقادیر نیاز دارد.
  </p>
<pre><code class="language-php">
    final class SqlOrderRepository implements OrderRepository
    {
    private Connection $connection;
    public function __construct(Connection $connection)
    {
    $this-&gt;connection = $connection;
    }
    public function save(Order $order): int
    {
    $data = [
    // Again, we need an array of columns =&gt; values
    ];
    $columns = array_keys($data);
    $values = array_map(
    fn ($value) =&gt; $this-&gt;connection-&gt;escape($value),
    array_values($data)
    );
    $sql = 'INSERT INTO orders ('
    . implode(', ', $columns)
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0046_original/original_page.png" alt="Original Page 46">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    . ') VALUES (' . implode(', ', $values) . ')';
    $this-&gt;connection-&gt;execute($sql);
    $lastInsertedId = $this-&gt;connection-&gt;execute(
    'SELECT LAST_INSERT_ID();'
    )-&gt;fetchColumn(0);
    return $lastInsertedId;
    }
    }
  </code></pre>
<p>
    گزینه‌های مختلفی در اینجا وجود دارد. رایج‌ترین گزینه این است که یک <code>ORM</code> را در <code>project</code> خود نصب کنید، که می‌تواند <code>mapping</code> از <code>object properties</code> به ستون‌های جدول را برای شما انجام دهد.
  </p>
<h4>2.5.1. Using an ORM</h4>
<p>
    در بخش 2.8 ما در مورد اینکه چه نوع <code>ORM</code> در این سناریو بهترین عملکرد را دارد، صحبت خواهیم کرد. در حال حاضر، بیایید به یک مثال با استفاده از <code>Doctrine ORM</code> محبوب<sup>6</sup> نگاهی بیندازیم.
    هنگامی که ما <code>Doctrine ORM</code> را در <code>project</code> خود نصب کردیم و <code>database connection</code> را راه‌اندازی کردیم، ابتدا باید <code>mapping configuration</code> را به کلاس <code>entity</code> و
    <code>properties</code> آن اضافه کنیم. Listing 2.11 نشان می‌دهد که چگونه این کار را با استفاده از <code>annotations</code> انجام دهیم.
  </p>
<p>
<em>Listing 2.11.</em> استفاده از <code>annotations</code> برای <code>mapping configuration</code>.
  </p>
<pre><code class="language-php">
    use Doctrine\ORM\Mapping as ORM;
    /**
    * @ORM\Entity
    * @ORM\Table(name="orders")
    */
    final class Order
    {
    /**
    * @ORM\Id
    * @ORM\GeneratedValue
  </code></pre>
<p>
<sup>6</sup> https://advwebapparch.com/doctrine-orm
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0047_original/original_page.png" alt="Original Page 47">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    /**
    * @ORM\Column(type="integer")
    */
    private int $id;
    /**
    * @ORM\Column(type="string")
    */
    private string $emailAddress;
    /**
    * @ORM\Column(type="int")
    */
    private int $quantityOrdered;
    /**
    * @ORM\Column(type="int")
    */
    private int $pricePerUnitInCents;
    // ...
    }
  </code></pre>
<p>
    بر اساس <code>annotations</code>، <code>Doctrine</code> باید بتواند <code>data</code> <code>object</code> را در جدول و ستون‌های مناسب ذخیره کند. ما اکنون می‌توانیم یک <code>implementation</code> بسیار ساده از <code>OrderRepository interface</code> بنویسیم که از <code>Doctrine’s EntityManager</code> برای <code>persist</code> کردن <code>Order objects</code> استفاده می‌کند (به Listing 2.12 مراجعه کنید).
  </p>
<p>
<em>Listing 2.12.</em> یک <code>implementation</code> از <code>OrderRepository</code> با استفاده از <code>Doctrine ORM</code>.
  </p>
<pre><code class="language-php">
    use Doctrine\ORM\EntityManagerInterface;
    final class OrderRepositoryUsingDoctrineOrm implements OrderRepository
    {
    private EntityManagerInterface $entityManager;
    public function __construct(EntityManagerInterface $entityManager)
    {
    $this-&gt;entityManager = $entityManager;
    }
    public function save(Order $order): void
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0048_original/original_page.png" alt="Original Page 48">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    {
    $this-&gt;entityManager-&gt;persist($order);
    $this-&gt;entityManager-&gt;flush();
    }
    }
  </code></pre>
<p>
    همانطور که در این نمونه‌های کد مشاهده می‌کنید، نصب و استفاده از یک <code>ORM</code> برای ذخیره یک <code>entity</code> در <code>database</code> کار زیادی نمی‌برد. و بله، ممکن است در زمان شما و احتمالاً خطوط زیادی از کد صرفه‌جویی کند، اما ممکن است شما را به دردسر هم بیندازد.
    من شخصاً زمان زیادی را صرف تلاش برای فهمیدن این موضوع کرده‌ام که چگونه یا چرا چیزی کار نمی‌کرد، یا چرا <code>Doctrine</code> ناگهان مجبور شد تعداد زیادی <code>queries</code> انجام دهد. همچنین بیش از یک بار اتفاق افتاد که متوجه شدم چیزی خراب است در حالی که از قبل در <code>production</code> در حال اجرا بود.
    مشکل خود <code>Doctrine ORM</code> نیست، بلکه استفاده از <code>abstractions</code> های عمومی است. پنهان کردن بسیاری از جزئیات <code>implementation</code> و مقدار زیادی "<code>magic</code>" پشت یک <code>abstract EntityManagerInterface</code> واحد به این معنی است که دیر یا زود با مشکل مواجه خواهید شد. با این حال، استفاده از یک <code>ORM</code> محبوب، مزایای متعددی نیز دارد، مانند:
  </p>
<ol>
<li>
<code>Documentation</code> گسترده، نمونه‌های آنلاین، پست‌های وبلاگ، سؤالات و پاسخ‌ها در Stack Overflow و غیره.
    </li>
<li>
      راه‌حل‌های خودکار برای مشکلات رایج مانند <code>database migrations</code>، بارگذاری <code>fixture</code> و غیره.
    </li>
</ol>
<p>
    طبق تجربه من، استفاده از یک <code>ORM</code> در صورتی که بتوانید به قوانین زیر پایبند باشید، اشکالی ندارد:
  </p>
<ol>
<li>
      فقط از <code>mapping configuration</code> ساده استفاده کنید. بدون <code>table inheritance</code>، "<code>embeddables</code>"، <code>custom types</code> و غیره<sup>7</sup>
</li>
<li>
      به <code>one-to-many associations</code> پایبند باشید.
    </li>
<li>
<code>Entities</code> را با <code>ID</code> خود ارجاع دهید.
    </li>
<li>
      از <code>entity</code> به <code>entity</code> با استفاده از فیلدهای <code>association</code> پرش نکنید.
    </li>
</ol>
<p>
    این تصادفی نیست که این قوانین با قوانین "<code>effective aggregate design</code>" که توسط Vaughn Vernon<sup>8</sup> توضیح داده شده است، مشترکات زیادی دارند. ما خواهیم گرفت
  </p>
<p>
<sup>7</sup> https://advwebapparch.com/doctrine-orm-and-ddd-aggregates
  </p>
<p>
<sup>8</sup> https://advwebapparch.com/effective-aggregate-design
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0049_original/original_page.png" alt="Original Page 49">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<p>
    بازگشت به این موضوع در بخش 11.2.
  </p>
<p>
    چگونه <code>Doctrine</code> می‌تواند <code>data</code> را از <code>entity</code> بیرون بکشد؟ این از <code>reflection</code><sup>9</sup> برای دسترسی به داخل <code>object</code>، کپی کردن <code>data</code> از <code>private properties</code> <code>object</code> و آماده‌سازی <code>array</code> مورد نظر با استفاده از این <code>data</code> استفاده می‌کند.
    Listing 2.13 نشان می‌دهد که اگر کد <code>mapping</code> را در <code>method</code> <code>save()</code> خودمان <code>inline</code> کنیم، چگونه خواهد بود.
  </p>
<p>
<em>Listing 2.13.</em> یک <code>implementation</code> از <code>save()</code> که از <code>reflection</code> استفاده می‌کند.
  </p>
<pre><code class="language-php">
    public function save(Order $order): int
    {
    // ...
    $data = [];
    $object = new ReflectionObject($order);
    $emailProperty = $object-&gt;getProperty('emailAddress');
    // Make the private property accessible:
    $emailProperty-&gt;setAccessible(true);
    // Get the current value of the emailAddress property:
    $data['email'] = $emailProperty-&gt;getValue($order);
    // And so on, for all the properties of Order...
    // ...
    }
  </code></pre>
<h4>2.5.2. Manual mapping</h4>
<p>
    اگرچه این عالی است که <code>Doctrine</code> می‌تواند تمام این کار را برای ما انجام دهد، اما ما نمی‌بینیم که چگونه همه این کار را انجام می‌دهد. و این دلیل این است که وقتی چیزی آنطور که انتظار می‌رود کار نمی‌کند، پیدا کردن مشکل سخت خواهد بود.
    در چند سال گذشته، من بیش از یک بار به این نتیجه رسیده‌ام که انجام <code>mapping</code> به صورت دستی، یعنی نوشتن کد برای این کار خودم، می‌تواند یک راه‌حل بسیار خوب باشد. در این صورت ما می‌توانیم، اما مجبور نیستیم از <code>reflection</code> استفاده کنیم، و ما به <code>mapping configuration</code> جداگانه (با استفاده از <code>annotations</code>، یا <code>XML</code> و غیره) نیازی نداریم.
  </p>
<p>
<sup>9</sup> https://advwebapparch.com/php-reflection
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0050_original/original_page.png" alt="Original Page 50">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<p>
    دو گزینه <code>implementation</code> وجود دارد: یا به <code>entity</code> اجازه می‌دهید <code>array</code> <code>columns =&gt; values</code> را آماده کند، یا به آن اجازه می‌دهید که <code>data</code> داخلی خود را به عنوان یک <code>array</code> در معرض دید قرار دهد و <code>mapping</code> را در داخل <code>repository</code> انجام دهید.
    Listing 2.14 نمونه‌ای از گزینه اول را نشان می‌دهد.
  </p>
<p>
<em>Listing 2.14.</em> <code>save()</code> <code>data</code> <code>mapped</code> شده را از <code>Order entity</code> بازیابی می‌کند.
  </p>
<pre><code class="language-php">
    final class Order
    {
    // ...
    public function mappedData(): array
    {
    return [
    'email' =&gt; $this-&gt;emailAddress,
    'quantity' =&gt; $this-&gt;quantityOrdered,
    // ...
    ];
    }
    }
    final class SqlOrderRepository implements OrderRepository
    {
    // ...
    public function save(Order $order): int
    {
    // ...
    $data = $order-&gt;mappedData();
    // $data is an array of columns =&gt; values
    // ...
    }
  </code></pre>
<p>
    نقطه ضعف این رویکرد این است که <code>Order entity</code> در مورد نام و انواع ستون‌های <code>database</code> اطلاعات دارد. هر زمان که یک ستون <code>re-named</code> شود، شما همچنین باید کلاس <code>Order</code> را به روز کنید.
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0051_original/original_page.png" alt="Original Page 51">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<p>
    Listing 2.15 جایگزین را نشان می‌دهد، که در آن <code>entity</code> فقط <code>data</code> داخلی خود را در معرض دید قرار می‌دهد، و <code>repository</code> خود <code>mapping</code> را انجام می‌دهد.
  </p>
<p>
<em>Listing 2.15.</em> <code>save()</code> <code>mapping</code> را به ستون‌های <code>database</code> انجام می‌دهد.
  </p>
<pre><code class="language-php">
    final class Order
    {
    // ...
    public function internalData(): array
    {
    return get_object_vars($this);
    }
    }
    final class SqlOrderRepository implements OrderRepository
    {
    // ...
    public function save(Order $order): int
    {
    // ...
    $internalData = $order-&gt;internalData();
    $data = [
    'email' =&gt; $internalData['emailAddress'],
    'quantity' =&gt; $internalData['quantityOrdered'],
    // ...
    ];
    // ...
    }
  </code></pre>
<p>
    نقطه ضعف این رویکرد این است که سطح <code>encapsulation</code> <code>Order</code> را کاهش می‌دهد. <code>SqlOrderRepository</code> باید در مورد <code>properties</code> خصوصی <code>Order</code> بداند: چه تعداد <code>properties</code> وجود دارد و نام و انواع آنها چیست.
    هر زمان که یک <code>property</code> را تغییر نام دادید، نوع آن را تغییر دادید، <code>properties</code> را اضافه یا حذف کردید، شما همچنین باید کد <code>mapping</code> مربوطه را در <code>SqlOrderRepository</code> به روز کنید.
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0052_original/original_page.png" alt="Original Page 52">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<p>
    من ترجیح می‌دهم <code>Order</code> نام و انواع <code>properties</code> داخلی خود را برای خودش نگه دارد. اگر جزئیات داخلی آن دیگر <code>private</code> نباشد، <code>refactor</code> کردن <code>object</code> <code>Order</code> بسیار سخت خواهد بود.
    توانایی تغییر آزادانه ساختار داخلی یک <code>object</code> همان چیزی است که شما را قادر می‌سازد تا <code>design</code> آن را بهبود بخشید. بنابراین برای من فاش کردن نام‌های <code>property</code> خصوصی بهای سنگینی است، و ما باید با گزینه اول برویم:
    اجازه دهید <code>entity</code> خود <code>mapping</code> را انجام دهد.<sup>10</sup>
</p>
<p>
    "اما اکنون ما نام ستون‌ها را در داخل <code>entity</code> داریم... آیا این باعث ایجاد یک ترکیب ناسالم از زیرساخت‌ها و کد اصلی نمی‌شود؟"
  </p>
<p>
    یک سؤال عالی، با یک پاسخ ظریف.
  </p>
<p>
    برای نشان دادن اینکه داشتن نام ستون‌ها در داخل یک کلاس <code>entity</code>، آن را به طور خودکار به کد زیرساخت تبدیل نمی‌کند، بیایید قوانین را یک بار دیگر بررسی کنیم.
  </p>
<ol>
<li>
      کد اصلی مستقیماً به سیستم‌های خارجی وابسته نیست، و همچنین به کدی که برای تعامل با یک نوع خاص از سیستم خارجی نوشته شده است، وابسته نیست.
    </li>
<li>
      کد اصلی نیازی به یک محیط خاص برای اجرا ندارد، و همچنین وابستگی‌هایی ندارد که فقط برای اجرا در یک <code>context</code> خاص طراحی شده باشند.
    </li>
</ol>
<p>
    به <code>method</code> <code>mappedData()</code> نگاهی بیندازید:
  </p>
<pre><code class="language-php">
    final class Order
    {
    // ...
    public function mappedData(): array
    {
    return [
    'email' =&gt; $this-&gt;emailAddress,
    'quantity' =&gt; $this-&gt;quantityOrdered,
    // ...
    ];
  </code></pre>
<p>
<sup>10</sup>من در مورد این موضوع، معاوضه‌هایی که در آن دخیل هستند، و گزینه‌های مختلف <code>implementation</code>، بیشتر نوشته‌ام. ببینید: "ORMless; a Memento-like pattern for object persistence", https://advwebapparch.com/ormless.
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0053_original/original_page.png" alt="Original Page 53">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    }
    }
  </code></pre>
<p>
    هنگام فراخوانی <code>mappedData()</code>، سیستم‌های خارجی مانند <code>database</code>، نیازی به در دسترس بودن ندارند. در واقع، کد در این <code>method</code> هیچ وابستگی ندارد. <code>method</code> <code>mappedData()</code> می‌تواند در هر <code>context</code> بدون هیچ راه‌اندازی خاصی اجرا شود.
    نیازی به هیچ راه‌اندازی خاصی ندارد: شما می‌توانید یک <code>object</code> <code>Order</code> را به روش معمول <code>instantiate</code> کنید و این <code>method</code> <code>mappedData()</code> را فراخوانی کنید. این کد نیز هیچ وابستگی ندارد که برای اجرا فقط در یک <code>context</code> خاص طراحی شده باشد.
    بنابراین <code>mappedData()</code> با هر دو قانون برای کد اصلی مطابقت دارد. چگونه می‌تواند کد اصلی نباشد. فقط برخی از <code>transformations</code> های ساده را روی مقادیر در حافظه انجام می‌دهد.
  </p>
<p>
    در مورد افزودن <code>Doctrine mapping annotations</code> به <code>entity</code> خود، مانند <code>@Entity</code>، <code>@Table</code> و <code>@Column</code> چطور؟ آیا این منجر به کد ترکیبی می‌شود؟ خوب، <code>instantiating</code> یک <code>entity</code> با <code>mapping annotations</code> نیازی به هیچ راه‌اندازی خاصی ندارد.
    و فراخوانی هر <code>method</code> روی آن نیازی به در دسترس بودن وابستگی‌های خارجی ندارد. بنابراین اگر <code>entity</code> شما آماده <code>persisted</code> شدن با استفاده از <code>Doctrine</code> است، هنوز هم باید کد اصلی در نظر گرفته شود، نه کد <code>infrastructure</code>.
  </p>
<p>
    با این حال، یک <code>entity</code> با <code>Doctrine annotations</code> یا یک <code>method</code> <code>mappedData()</code> شامل جزئیات <code>implementation</code> فنی (مانند نام جدول و ستون و انواع ستون) می‌شود. بنابراین وقتی شما به نقطه‌ای می‌رسید که می‌خواهید <code>databases</code> را در هر صورت تغییر دهید،
    هنوز هم باید این کد را اصلاح کنید. برای من این دلیلی برای انتقال کد <code>mapping</code> به خارج از <code>entity</code> نیست. به خصوص به این دلیل که حفظ <code>properties</code> <code>entity</code> و کد <code>mapping</code> نزدیک به هم بسیار راحت است.
  </p>
<h4>2.6. Generating the identifier earlier</h4>
<p>
    بیایید دوباره به کد <code>controller</code> نگاهی بیندازیم، همانطور که بعد از شروع استفاده از <code>Order entity</code> و <code>OrderRepository</code> بود (به Listing 2.16 مراجعه کنید).
  </p>
<p>
<em>Listing 2.16.</em> وضعیت فعلی <code>orderEbookAction()</code>.
  </p>
<pre><code class="language-php">
    public function orderEbookAction(Request $request): Response
    {
    // ...
    $order = new Order(/* ... */);
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0054_original/original_page.png" alt="Original Page 54">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    $orderRepository = $this-&gt;container-&gt;get('order_repository');
    $lastInsertedId = $orderRepository-&gt;save($order);
    // ...
  </code></pre>
<p>
    با معرفی <code>OrderRepository interface</code> ما موفق شدیم بیشتر جزئیات <code>implementation</code> مربوط به ذخیره <code>orders</code> را پنهان کنیم. فقط یکی باقی مانده است.
    <code>ID</code> <code>Order</code> که ما ایجاد می‌کنیم یک عدد صحیح است. مقدار آن فقط زمانی برای ما مشخص می‌شود که <code>OrderRepository</code> <code>order</code> را ذخیره کرده باشد، به همین دلیل است که آن عدد صحیح مقدار بازگشتی <code>method</code> <code>save()</code> آن است.
    این هنوز به خواننده کد نشان می‌دهد که مکانیسم مورد استفاده برای <code>persist</code> کردن یک <code>Order</code> از یک ستون عدد صحیح با افزایش خودکار برای <code>ID</code> اصلی یک <code>order</code> استفاده می‌کند.
  </p>
<p>
    این لزوماً بد نیست اگر یک <code>object</code> بخشی از عملکرد داخلی خود را آشکار کند، اگرچه ما عموماً تمایل داریم از آن اجتناب کنیم.
    مشکل واقعی در اینجا این است که ما هنوز در موقعیتی نیستیم که بتوانیم به طور کامل <code>storage technology</code> زیربنایی را جایگزین کنیم.
    همه <code>database</code> ها از ستون‌ها یا <code>fields</code> های <code>ID</code> با افزایش خودکار پشتیبانی نمی‌کنند. همه <code>database</code>ها قادر به تولید <code>ID</code> و بازگرداندن آن نخواهند بود. و در موارد بسیار شدید:
    برخی از <code>persistence mechanisms</code>ها ممکن است حتی نتوانند یک <code>identifier</code> را به صورت همزمان به <code>client</code> بازگردانند.
  </p>
<p>
    مشکل دیگر این است که <code>Order entity</code> قرار است از ابتدا کامل باشد. باید حداقل مجموعه داده‌ها را برای مفید بودن و سازگاری در رفتار خود در اختیار داشته باشد.
    با توجه به اینکه یک <code>Order</code> تا زمانی که ذخیره نشده است، <code>ID</code> ندارد، ما باید به نتیجه مخالف برسیم: <code>Order</code> سازگار نیست، تا زمانی که <code>database</code> ذخیره آن را تمام نکرده باشد.
  </p>
<p>
    آنچه ما در عوض دوست داریم، راهی برای ارائه یک <code>ID</code> به یک <code>Order</code> در لحظه‌ای است که آن را <code>instantiate</code> می‌کنیم. اضافه کردن آن به عنوان یک آرگومان <code>constructor</code> مورد نیاز، این کار را انجام می‌دهد.
    با انجام این کار، می‌توانیم اطمینان حاصل کنیم که یک <code>object</code> <code>Order</code> همیشه یک <code>identifier</code> دارد (به Listing 2.25 مراجعه کنید).
  </p>
<p>
<em>Listing 2.17.</em> <code>Order</code> اکنون از ابتدا یک <code>identity</code> دارد.
  </p>
<pre><code class="language-php">
    final class Order
    {
    private int $id;
    // ...
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0055_original/original_page.png" alt="Original Page 55">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    public function __construct(
    int $id
    /* ... */
    ) {
    $this-&gt;id = $id;
    // ...
    }
    }
  </code></pre>
<p>
<code>Clients</code> سپس باید یک <code>ID</code> را از قبل ارائه دهند، زمانی که می‌خواهند یک <code>Order</code> جدید ایجاد کنند. اما چگونه یک <code>client</code> می‌تواند بفهمد که <code>ID</code> بعدی موجود چیست؟ با توجه به اینکه <code>OrderRepository</code> به منبع این دانش نزدیک است، یعنی خود جدول <code>orders</code>، بیایید به آن یک <code>method</code> جدید بدهیم که می‌تواند به این سؤال پاسخ دهد، و آن را <code>nextIdentity()</code> بنامیم (به Listing 2.18 مراجعه کنید).
  </p>
<p>
<em>Listing 2.18.</em> <code>nextIdentity()</code> <code>ID</code> بعدی موجود را برمی‌گرداند.
  </p>
<pre><code class="language-php">
    interface OrderRepository
    {
    public function nextIdentity(): int;
    // ...
    }
  </code></pre>
<p>
    یک <code>implementation</code> احتمالی از <code>method</code> <code>nextIdentity()</code> می‌تواند نمونه‌ای باشد که در Listing 2.19 نشان داده شده است. این <code>ID</code> بزرگترین مورد استفاده فعلی را انتخاب می‌کند و عدد بعدی را برمی‌گرداند، که بنابراین <code>ID</code> بعدی موجود خواهد بود.
  </p>
<p>
<em>Listing 2.19.</em> یک <code>implementation</code> ساده از <code>nextIdentity()</code>.
  </p>
<pre><code class="language-php">
    final class SqlOrderRepository implements OrderRepository
    {
    // ...
    public function nextIdentity(): int
    {
    return (int)$this-&gt;connection-&gt;execute(
    'SELECT MAX(id) AS highestId FROM orders'
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0056_original/original_page.png" alt="Original Page 56">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    )-&gt;fetchColumn(0) + 1;
    }
    }
  </code></pre>
<p>
    ممکن است قبلاً مشکل را متوجه شده باشید: اگر <code>application</code> دارای کاربران همزمان زیادی باشد، این احتمال وجود دارد که دو <code>client</code> تلاش کنند یک <code>record</code> را با همان <code>ID</code> درج کنند. اگر همزمانی معمولاً برای شما یک مشکل نیست، <code>implementation</code> ساده می‌تواند <code>implementation</code> مناسب باشد.
    اگر با مشکلات همزمانی مواجه شدید یا در حال حاضر آنها را دارید، می‌توانید به یک <code>implementation</code> قوی‌تر، به عنوان مثال، موردی که از یک <code>sequence</code> در سطح <code>database</code> استفاده می‌کند، تغییر دهید.
    اگر <code>database</code> شما از <code>sequences</code> پشتیبانی نمی‌کند، نوشتن کد خودتان کار زیادی نخواهد داشت. برای یک پیاده‌سازی نمونه به Listing 2.20 مراجعه کنید.
  </p>
<p>
<em>Listing 2.20.</em> این نسخه از <code>nextIdentity()</code> از یک جدول <code>sequence</code> استفاده می‌کند.
  </p>
<pre><code class="language-php">
    public function nextIdentity(): int
    {
    return $this-&gt;connection-&gt;transactional(function () {
    $nextId = (int)$this-&gt;connection-&gt;execute(
    'SELECT last_id FROM order_id_sequence'
    )-&gt;fetchColumn(0) + 1;
    $this-&gt;connection-&gt;execute(
    'UPDATE order_id_sequence SET last_id = :last_id',
    [
    'last_id' =&gt; $nextId
    ]
    );
    return $nextId;
    });
    }
  </code></pre>
<p>
    هنگامی که یک <code>implementation</code> مناسب از <code>nextIdentity()</code> اضافه کردیم، دیگر نیازی نیست منتظر بمانیم تا <code>database</code> مقدار <code>ID</code> با افزایش خودکار را به ما برگرداند. در عوض، اکنون که <code>Order entity</code> از قبل شامل <code>ID</code> خود از ابتدا است، ما باید از آن <code>ID</code> هنگام <code>mapping</code> <code>data</code> <code>entity</code> به ستون‌ها در <code>database</code> استفاده کنیم (به Listing 2.21 مراجعه کنید).
  </p>
<p>
<em>Listing 2.21.</em> <code>mappedData()</code> نیز یک مقدار برای ستون <code>id</code> برمی‌گرداند.
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0057_original/original_page.png" alt="Original Page 57">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    final class Order
    {
    // ...
    public function mappedData(): array
    {
    return [
    'id' =&gt; $this-&gt;id,
    'email' =&gt; $this-&gt;emailAddress,
    // ...
    ];
    }
    }
  </code></pre>
<p>
    در <code>controller</code>، همه چیز اکنون بسیار بهتر به نظر می‌رسد: ما ابتدا <code>ID</code> سفارش بعدی را دریافت می‌کنیم، آن را به <code>Order</code> به عنوان یک <code>constructor argument</code> ارائه می‌دهیم، سپس <code>Order</code> را با استفاده از <code>repository</code> ذخیره می‌کنیم (به Listing 2.22 مراجعه کنید).
  </p>
<p>
<em>Listing 2.22.</em> <code>orderEbookAction()</code> از <code>nextIdentity()</code> برای تعیین <code>ID</code> سفارش از قبل استفاده می‌کند.
  </p>
<pre><code class="language-php">
    public function orderEbookAction(Request $request): Response
    {
    // ...
    $orderId = $orderRepository-&gt;nextIdentity();
    $order = new Order(
    $orderId,
    // ...
    );
    $orderRepository-&gt;save($order);
    // ...
    }
  </code></pre>
<p>
    از آنجایی که ما دیگر مجبور نیستیم به <code>save()</code> تکیه کنیم تا <code>ID</code> سفارش جدید را برگرداند، باید آن نوع بازگشتی <code>int</code> را از <code>method</code> <code>save()</code> <code>repository</code> حذف کنیم (به Listing 2.23 مراجعه کنید).
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0058_original/original_page.png" alt="Original Page 58">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<p>
<em>Listing 2.23.</em> <code>save()</code> اکنون باید <code>void</code> برگرداند.
  </p>
<pre><code class="language-php">
    interface OrderRepository
    {
    public function save(Order $order): void;
    }
  </code></pre>
<p>
    به عنوان یک امتیاز، این باعث می‌شود که <code>method</code> <code>save()</code> با اصل تفکیک <code>Command Query</code> مطابقت داشته باشد.<sup>11</sup>
</p>
<h4>2.6.1. Using UUIDs instead of (auto-)incrementing integer IDs</h4>
<p>
    یک جایگزین خوب برای استفاده از اعداد صحیح افزایشی، استفاده از یک <code>Universally Unique Identifier</code> (<code>UUID</code>) است. یک <code>UUID</code> اغلب به عنوان یک <code>string</code> نشان داده می‌شود، اما می‌توان آن را به یک عدد صحیح بزرگ تبدیل کرد و دوباره برگرداند.
    هنگامی که آن را به عنوان یک <code>string</code> مشاهده می‌کنید، به این صورت خواهد بود: eb13b0b9-d320-4a45-84f1-62adfc5e0a8e.
  </p>
<p>
    یک <code>UUID</code> بر اساس دو عنصر است: زمان فعلی و یک عدد تصادفی که توسط <code>random device</code> سیستم تولید می‌شود. Listing 2.24 یک <code>implementation</code> از <code>OrderRepository::nextIdentity()</code> را نشان می‌دهد که از <code>ramsey/uuid</code><sup>12</sup>
<code>library</code> برای تولید یک <code>UUID</code> تصادفی استفاده می‌کند.
  </p>
<p>
<em>Listing 2.24.</em> <code>nextIdentity()</code> یک <code>UUID</code> را برمی‌گرداند.
  </p>
<pre><code class="language-php">
    use Ramsey\Uuid\Uuid;
    use Ramsey\Uuid\UuidInterface;
    final class SqlOrderRepository implements OrderRepository
    {
    // ...
    public function nextIdentity(): UuidInterface
    {
    return Uuid::uuid4();
  </code></pre>
<p>
<sup>11</sup>اگرچه این اصطلاح توسط Bertrand Meyer ابداع شد، اما یک خلاصه مفید توسط Martin Fowler وجود دارد: “CommandQuerySeparation”, https://advwebapparch.com/command-query-separation. من این موضوع را با جزئیات در "Style Guide for Object Design", Manning (2019) مورد بحث قرار می‌دهم.
  </p>
<p>
<sup>12</sup> https://advwebapparch.com/ramsey-uuid
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0059_original/original_page.png" alt="Original Page 59">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    }
    }
  </code></pre>
<p>
    اکنون فقط باید نوع <code>parameter</code> <code>constructor</code> <code>$id</code> <code>Order</code> را تغییر دهیم تا یک نمونه <code>UuidInterface</code> را به جای یک <code>int</code> بپذیریم (به Listing 2.25 مراجعه کنید).
  </p>
<p>
<em>Listing 2.25.</em> <code>ID</code> یک <code>Order</code> اکنون یک نمونه از <code>UuidInterface</code> است.
  </p>
<pre><code class="language-php">
    final class Order
    {
    private UuidInterface $id;
    // ...
    public function __construct(
    UuidInterface $id
    /* ... */
    ) {
    $this-&gt;id = $id;
    // ...
    }
    }
  </code></pre>
<p>
    "صبر کنید، آیا <code>UUID</code> بهترین چیزی است که می‌توانیم دریافت کنیم؟"
  </p>
<p>
    طبق گفته چندین خواننده که به من ایمیل زده‌اند، جنبه‌هایی از <code>UUID</code> (نسخه 4) وجود دارد که باید از آنها آگاه باشیم. به عنوان مثال، Thomas Nunninger می‌نویسد که "تا جایی که من متوجه شدم، <code>innodb</code> سوابق یک جدول را بر اساس کلید اصلی <code>reorder</code> می‌کند
    هنگامی که <code>records</code> جدید را درج می‌کنید. بنابراین اگر یک <code>UUID</code> تصادفی دارید، باید صفحات <code>database</code> را دائماً <code>reorganize</code> کنید." همچنین، ممکن است راه‌حل‌های مدرن‌تری در زمان خواندن این مطلب وجود داشته باشد،
    همانطور که Luis Ramon Lopez می‌نویسد: "چند هفته پیش در مورد <code>ULIDs</code> شنیدم... من فکر می‌کنم آنها ممکن است یک <code>addition</code> خوب به فصل باشند زیرا یک جایگزین خوب برای <code>UUIDs</code> در برخی موارد است."
  </p>
<p>
    در زمینه این کتاب فکر می‌کنم دو پیام مهم وجود دارد:
  </p>
<ol>
<li>
      فناوری در حال تغییر است. همیشه راه‌حل‌های جدیدی برای مشکلات قدیمی وجود خواهد داشت
    </li>
</ol>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0060_original/original_page.png" alt="Original Page 60">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<p>
    1. فناوری در حال تغییر است. همیشه راه‌حل‌های جدیدی برای مشکلات قدیمی وجود خواهد داشت.
  </p>
<p>
    2. تصمیمات <code>Technical</code> بر بیش از کیفیت <code>design</code> کد ما تأثیر می‌گذارد.
  </p>
<p>
    به عنوان توسعه‌دهنده-معمار، باید از عواقب انتخاب یک فناوری، مانند <code>UUID</code> نسخه 4 یا <code>ULID</code> آگاه باشیم. ما باید به این سؤال پاسخ دهیم که چگونه انتخاب ما بر عملکرد <code>database</code>، چگونه بر <code>usability</code> و غیره تأثیر می‌گذارد.
    در عین حال، باید چشم خود را به پیشرفت‌های <code>technological</code> بدوزیم. برای اینکه بهترین تصمیم‌ها را بگیریم، باید بدانیم چه خبر است و آماده باشیم که فردا یک تصمیم بهتر بگیریم. در عین حال، و این کل نکته این کتاب است،
    ما نباید مجبور شویم کل کد پایه خود را هنگام تغییر برخی از فناوری‌های خارجی به روز کنیم.
  </p>
<h4>2.7. Using a value object for the identifier</h4>
<p>
    اکنون که ما در حال تغییر نوع <code>identifier</code> یک <code>Order</code> هستیم، بیایید <code>identifier</code> را در داخل یک <code>Value object</code><sup>13</sup> قرار دهیم. به این ترتیب، ما می‌توانیم نوع داده واقعی <code>identifier</code> را کاملاً <code>encapsulate</code> کنیم و به آن اجازه دهیم که یک جزئیات <code>implementation</code> داخلی از <code>entity</code> باشد.
    Listing 2.26 کلاس <code>object</code> <code>OrderId value</code> جدید و تغییراتی را که باید در <code>entity</code> <code>Order</code> و <code>OrderRepository</code> ایجاد کنیم تا از این نوع جدید به جای <code>int</code> یا <code>UuidInterface</code> استفاده کنیم، نشان می‌دهد.
  </p>
<p>
<em>Listing 2.26.</em> <code>OrderId</code> نوع <code>ID</code> اساسی را پنهان می‌کند.
  </p>
<pre><code class="language-php">
    final class OrderId
    {
    private UuidInterface $id;
    private function __construct(UuidInterface $id)
    {
    $this-&gt;id = $id;
    }
    public static function fromUuid(UuidInterface $id): self
    {
    return new self($id);
  </code></pre>
<p>
<sup>13</sup>Eric Evans, “Domain-Driven Design”, Addison-Wesley Professional (2003).
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0061_original/original_page.png" alt="Original Page 61">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    }
    }
    final class Order
    {
    private OrderId $id;
    // ...
    public function __construct(
    OrderId $id
    /* ... */
    ) {
    $this-&gt;id = $id;
    // ...
    }
    }
    final class SqlOrderRepository implements OrderRepository
    {
    // ...
    public function nextIdentity(): OrderId
    {
    return OrderId::fromUuid(
    Uuid::uuid4()
    );
    }
  </code></pre>
<p>
    کد در <code>controller</code> اکنون عالی به نظر می‌رسد (به Listing 2.27 مراجعه کنید). این تمام مراحل درگیر در ایجاد و ذخیره یک <code>order</code> را نشان می‌دهد، و هیچ‌یک از آن مستقیماً به <code>database</code> خاصی که ما استفاده می‌کنیم، گره نخورده است.
  </p>
<p>
<em>Listing 2.27.</em> <code>orderEbookAction()</code> اکنون از <code>nextIdentity()</code> برای تعیین <code>ID</code> سفارش از قبل استفاده می‌کند.
  </p>
<pre><code class="language-php">
    public function orderEbookAction(Request $request): Response
    {
    // ...
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0062_original/original_page.png" alt="Original Page 62">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    $orderRepository = $this-&gt;container-&gt;get('order_repository');
    $orderId = $orderRepository-&gt;nextIdentity();
    $order = new Order(
    $orderId,
    $request-&gt;get('ebook_id'),
    $request-&gt;get('email_address'),
    (int)$request-&gt;get('quantity'),
    (int)$pricePerUnitInCents,
    (int)$orderAmount
    );
    $orderRepository-&gt;save($order);
    $this-&gt;container-&gt;get('session')-&gt;set(
    'currentOrderId',
    $orderId
    );
    // ...
    }
  </code></pre>
<p>
    ما هیچ چیزی را خراب نکردیم، به جز کدی که <code>ID</code> سفارش فعلی را در <code>session</code> ذخیره می‌کند. از آنجایی که <code>$orderId</code> اکنون یک نمونه <code>OrderId</code> است، این دیگر کار نخواهد کرد. شما فقط می‌توانید چیزهایی را در یک <code>session</code> ذخیره کنید که <code>serializable</code> هستند.
    در این مورد، ما می‌توانیم یک <code>method</code> ساده <code>asString()</code> به کلاس <code>OrderId</code> اضافه کنیم و هنگام ذخیره <code>ID</code> سفارش فعلی در <code>session</code>، همانطور که در Listing 2.28 نشان داده شده است، آن را فراخوانی کنیم.
  </p>
<p>
<em>Listing 2.28.</em> <code>OrderId</code> از <code>serialization</code> با استفاده از <code>method</code> <code>asString()</code> پشتیبانی می‌کند.
  </p>
<pre><code class="language-php">
    final class OrderId
    {
    // ...
    public function asString(): string
    {
    // Ramsey\Uuid conveniently has a toString() method
    return $this-&gt;id-&gt;toString();
    }
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0063_original/original_page.png" alt="Original Page 63">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    $this-&gt;container-&gt;get('session')-&gt;set(
    'currentOrderId',
    $orderId-&gt;asString()
    );
  </code></pre>
<h4>2.8. Active Record versus Data Mapper</h4>
<p>
    تا کنون، بدون اینکه به آن اشاره کنیم، ما از <code>Data Mapper design pattern</code><sup>14</sup> برای ذخیره <code>entities</code> پیروی کردیم. این بدان معناست که ما یک <code>object</code> داریم، و وقتی می‌خواهیم آن را ذخیره کنیم، آن را به یک <code>repository</code> می‌دهیم، که سپس <code>data</code> را بیرون می‌کشد و آن را در <code>database</code> ذخیره می‌کند.
    یک جایگزین رایج برای ذخیره <code>entities</code>، <code>Active Record design pattern</code><sup>15</sup> است. اگر از این <code>pattern</code> استفاده کنید، <code>entity</code> قادر خواهد بود خود را از <code>database</code> بارگذاری کند، و همچنین می‌تواند خود را ذخیره و حذف کند.
    آوردن این قابلیت اضافی معمولاً با گسترش کلاس <code>entity</code> از یک کلاس ارائه شده توسط <code>framework</code> به دست می‌آید (به Listing 2.29 مراجعه کنید).
  </p>
<p>
<em>Listing 2.29.</em> یک <code>Active Record entity</code> وظایف <code>repository</code> را نیز انجام می‌دهد.
  </p>
<pre><code class="language-php">
    final class Order extends ActiveRecordEntity
    {
    // ...
    }
  </code></pre>
<p>
    // ما می‌توانیم یک <code>order</code> ایجاد کنیم
  </p>
<pre><code class="language-php">
    $order1 = new Order();
    // Save it to the database
    $order1-&gt;save();
    // Delete it, if we like
    $order1-&gt;delete();
  </code></pre>
<p>
<sup>14</sup>Martin Fowler, “Patterns of Enterprise Application Architecture”, Addison-Wesley Professional (2003).
  </p>
<p>
<sup>15</sup>Martin Fowler, “Patterns of Enterprise Application Architecture”, Addison-Wesley Professional (2003).
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0064_original/original_page.png" alt="Original Page 64">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    // Or load one from the database
    $order2 = Order::getById(2);
  </code></pre>
<p>
    این ممکن است بسیار راحت به نظر برسد، اما از دیدگاه <code>design</code> معایبی دارد:
  </p>
<ul>
<li>
      با به ارث بردن مقدار زیادی از کد <code>infrastructure</code>، ما <code>isolation</code> مورد نیاز خود را برای <code>unit testing</code> مناسب یک <code>Order</code> از دست می‌دهیم.
    </li>
<li>
<code>Active Record frameworks</code> معمولاً به کد <code>custom</code> زیادی در داخل <code>entities</code> شما نیاز دارند تا همه چیز به خوبی کار کند. این کد مختص به <code>framework</code> است و مدل <code>domain</code> شما را مستقیماً به آن متصل می‌کند و فقط در حضور آن <code>framework</code> کاربردی است.
    </li>
<li>
<code>Clients</code> از <code>Order</code> می‌توانند کارهای بسیار بیشتری را با <code>object</code> انجام دهند که به احتمال زیاد نباید اجازه انجام آن را داشته باشند.
    </li>
</ul>
<p>
    ما هیچ یک از این معایب را نداریم، زمانی که ما <code>data mapper pattern</code> را اعمال می‌کنیم، مانند کاری که در این فصل انجام دادیم.
  </p>
<p>
    بزرگترین نقطه ضعف که می‌توانم به آن فکر کنم هنگام استفاده از یک <code>entity</code> و یک <code>repository</code> این است که شما چندین عنصر اضافی دارید: <code>interface</code> <code>repository</code> و حداقل یک <code>implementation</code> <code>repository</code>.
    در زمینه این کتاب، این نباید به عنوان یک نقطه ضعف در نظر گرفته شود. با معرفی یک <code>abstraction</code> شما از <code>infrastructure</code> اطراف <code>decoupling</code> می‌کنید. ما قبلاً یک نقطه ضعف دیگر را در این فصل مشاهده کردیم، زمانی که متوجه شدیم که باید تصمیمی بگیریم:
    آیا باید <code>mapping</code> را به ستون‌های <code>database</code> در داخل یا خارج از <code>entity</code> انجام دهیم؟
    اگرچه ترجیح می‌دهیم این نوع تصمیم را نگیریم، اما با مشکلاتی که <code>Active Record</code> دارد، قابل مقایسه نیست. با مقایسه این <code>design patterns</code>، مشخص است که <code>data mapper</code> امکان جدایی بهتری بین کد اصلی و <code>infrastructure</code> را فراهم می‌کند.
  </p>
<p>
    اگر <code>Active Record</code> در <code>project</code> شما همه‌جا حاضر است و تیم با آن بسیار مؤثر است، ممکن است هنوز هم بخواهید به رویکرد <code>Active Record (AR)</code> <code>framework</code> خود پایبند باشید. در این صورت، توصیه من این است که برخی از معایب را با رعایت قوانین زیر کاهش دهید:
  </p>
<ul>
<li>
<code>AR entities</code> خود را مانند <code>entities</code> واقعی <code>design</code> کنید. به بخش 11.2 نگاهی بیندازید تا در مورد این موضوع بیشتر بدانید.
    </li>
</ul>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0065_original/original_page.png" alt="Original Page 65">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<ul>
<li>
      از همان <code>AR entity</code> برای تغییر <code>state</code> و بازیابی <code>state</code> استفاده نکنید. مدل خود را به یک مدل نوشتن و یک مدل خواندن تقسیم کنید. برای کسب اطلاعات بیشتر در مورد مدل‌های خواندن به فصل 3 مراجعه کنید.
    </li>
<li>
      از <code>AR entity</code> خود برای پیمایش از یک <code>AR entity</code> به سایر <code>AR entities</code> استفاده نکنید. اگر می‌خواهید تغییری در یک <code>AR entity</code> دیگر ایجاد کنید، آن را با <code>ID</code> آن از <code>repository</code> مربوطه واکشی کنید.
    </li>
<li>
      این واقعیت را نادیده بگیرید که یک <code>AR entity</code> امکانات سرویس معمولی مانند ذخیره و حذف را فراهم می‌کند. از یک <code>repository</code> و <code>double dispatch</code> برای انجام این وظایف استفاده کنید.
    </li>
</ul>
<p>
    به عنوان مثال، شما باید <code>method</code> <code>save()</code> <code>entity</code> <code>Order</code> را برای <code>clients</code> معمولی در دسترس ندانید. در عوض، هر زمان که می‌خواهید یک <code>Order</code> را ذخیره کنید، آن را با استفاده از <code>method</code> <code>save()</code> <code>repository</code> ذخیره کنید (به Listing 2.30 مراجعه کنید).
  </p>
<p>
<em>Listing 2.30.</em> ذخیره یک <code>AR entity</code> از طریق <code>repository</code>.
  </p>
<pre><code class="language-php">
    final class ActiveRecordOrderRepository implements OrderRepository
    {
    public function save(Order $order): void
    {
    $order-&gt;save();
    }
    // ...
    }
  </code></pre>
<p>
    به همین ترتیب، هنگامی که می‌خواهید یک <code>Order</code> را با <code>ID</code> آن بازیابی کنید، از <code>repository</code> نیز استفاده کنید (به Listing 2.31 مراجعه کنید).
  </p>
<p>
<em>Listing 2.31.</em> بازیابی یک <code>AR entity</code> از طریق <code>repository</code>.
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0066_original/original_page.png" alt="Original Page 66">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<p>
    مشکلی که با این رویکرد از بین نمی‌رود این است که کدهایی در داخل <code>AR entity</code> شما وجود خواهد داشت که مخصوص <code>framework</code> یا <code>ORM</code> هستند. این لزوماً یک مشکل نیست. شما همیشه به مقداری کد نیاز دارید تا <code>framework</code> یا <code>ORM</code> را برآورده کنید، چه بر اساس <code>Active Record</code> یا <code>Data Mapper pattern</code> باشد.
    فقط تا آنجا که می‌توانید، این جزئیات را در داخل <code>object</code> نگه دارید. و <code>entities</code> خود را به گونه‌ای <code>design</code> کنید که بتوانید آنها را <code>instantiate</code> کنید و <code>methods</code> را روی آنها بدون نیاز به هیچ راه‌اندازی خاصی فراخوانی کنید. این به شما امکان می‌دهد تا
    <code>unit tests</code> واقعی را برای <code>entities</code> خود بنویسید، به جای <code>integration tests</code> که گران‌تر هستند (نوشتن سخت‌تر است، نگهداری سخت‌تر است) و برای اجرا به یک <code>database</code> واقعی نیاز دارند.
  </p>
<p>
    آیا همه این کارهای اضافی واقعاً ضروری است؟ به نظر می‌رسد که این امر باعث ایجاد لایه‌های اضافی در اطراف <code>functionality</code> خارج از <code>framework</code> می‌شود که قرار بود بیشترین سرعت توسعه ممکن را به شما بدهد.
    خوب، اگر می‌خواهید کد اصلی را از کد <code>infrastructure</code> جدا کنید، کار اضافی لازم است، که من فرض می‌کنم از آنجایی که این فرض این کتاب است، شما این کار را انجام می‌دهید. از طرف دیگر، اگر شهود متخصص شما به شما می‌گوید که این ممکن است واقعاً کار زیادی برای سود کم باشد،
    شما نباید آن احساس را نادیده بگیرید. در فصل 15 ما نگاهی دقیق‌تر به خطر <code>over-engineering</code> و چگونگی تصمیم‌گیری در مورد اینکه آیا رویکرد توضیح داده شده در این کتاب یک انتخاب خوب برای موقعیت خاص شما است، خواهیم داشت.
  </p>
<h4>2.9. Summary</h4>
<p>
    در این فصل، ما با یک <code>controller action</code> با منطق <code>domain</code> مختلط و <code>SQL statements</code> شروع کردیم. تلاش برای جداسازی کد اصلی از کد <code>infrastructure</code>، ما یک مرحله <code>refactoring</code> میانی را انجام دادیم و یک <code>table gateway</code> را معرفی کردیم.
    این ما را با کدی باقی گذاشت که هنوز به یک فناوری خاص - یک <code>database</code> رابطه‌ای - متصل بود. در نهایت ما کد را با استفاده از دو <code>design pattern</code> شناخته شده <code>refactor</code> کردیم:
    <code>Entity</code> و <code>Repository</code>. پیاده‌سازی اولیه را می‌توان با ارائه <code>entity</code> با یک <code>ID</code> از قبل بهبود بخشید. <code>repository</code> یک مکان خوب برای تولید آن <code>ID</code> بود. با معرفی یک <code>value object</code> برای <code>ID</code> <code>entity</code>، ما توانستیم
    نوع داده اساسی <code>ID</code> را <code>encapsulate</code> کنیم و آن <code>implementation</code> را به <code>repository</code> واگذار کنیم.
  </p>
<p>
    اکنون که ما یک کلاس <code>entity</code>، یک کلاس <code>repository</code> و یک <code>interface</code> <code>repository</code> داریم، می‌توانیم تمام کادرها را علامت بزنیم و این کد را به عنوان کد اصلی علامت‌گذاری کنیم:
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0067_original/original_page.png" alt="Original Page 67">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<ol>
<li>
<code>Order entity</code> و <code>OrderRepository interface</code> چیزی در مورد <code>client</code> که قرار است آن را فراخوانی یا استفاده کند، نشان نمی‌دهند.
    </li>
<li>
      خود <code>OrderRepository interface</code> یک <code>abstraction</code> است که با استفاده از آن ما می‌توانیم بعداً کدهای اصلی دیگر را بدون <code>databases</code> واقعی یا سایر وابستگی‌های خارجی اجرا کنیم.
    </li>
<li>
      در واقع می‌توان از <code>Order entity</code> بدون یک وب سرور، <code>database</code> و غیره استفاده کرد. این یک کلاس <code>PHP</code> ساده قدیمی است که می‌توانید بدون هیچ راه‌اندازی خاصی آن را اجرا کنید.
    </li>
</ol>
<p>
    ما با کد مختلط شروع کردیم و یک <code>entity</code> و یک <code>interface</code> <code>repository</code>، از جمله یک <code>implementation</code> پیش‌فرض، استخراج کردیم. در فصل 4، ما حتی کدهای اصلی بیشتری را از <code>controller</code> استخراج خواهیم کرد و مشکلات باقی‌مانده را برطرف می‌کنیم:
  </p>
<ol>
<li>
      مراحل سناریو برای ایجاد یک <code>e-book order</code> هنوز کاملاً مبهم هستند و با جزئیات <code>implementation</code> سطح پایین ترکیب شده‌اند
    </li>
<li>
<code>controller action</code> فقط در یک <code>web application</code> که ورودی از طریق پر کردن یک فرم وب ارائه می‌شود، مفید است.
    </li>
</ol>
<p>
    ابتدا، بیایید نگاهی به مدل‌های خواندن بیندازیم.
  </p>
<p>
    Exercises
  </p>
<ol>
<li>
      چه ایرادی در مورد <code>abstraction</code> زیر برای ذخیره <code>Order entities</code> وجود دارد؟a
    </li>
</ol>
<pre><code class="language-php">
    interface OrderRepository
    {
    public function insert(string $tableName, array $data): void;
    }
  </code></pre>
<ol start="2">
<li>
      آیا کلاس زیر یک <code>entity</code> است یا یک <code>value object</code>؟b
    </li>
</ol>
<pre><code class="language-php">
    final class OrderId
    {
    // ...
    public static function fromString(string $orderId): self
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0068_original/original_page.png" alt="Original Page 68">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    {
    return new self($orderId);
    }
    }
  </code></pre>
<ol start="3">
<li>
      آیا کلاس زیر یک <code>entity</code> است یا یک <code>value object</code>؟c
    </li>
</ol>
<pre><code class="language-php">
    final class Order
    {
    // ...
    public static function create(OrderId $orderId): self
    {
    return new self($orderId);
    }
  </code></pre>
<ol start="4">
<li>
      چرا ما باید یک مقدار <code>identity</code> را برای یک <code>entity</code> قبل از <code>instantiating</code> آن برای اولین بار تولید کنیم؟d
    </li>
</ol>
<ol>
<li>
      زیرا <code>entity</code> بدون یک <code>identity</code> کامل نخواهد بود، و همچنین به طور مداوم رفتار نخواهد کرد.
    </li>
<li>
      زیرا در غیر این صورت ممکن است از همان <code>identity</code> در یک <code>process</code> دیگر استفاده شود.
    </li>
<li>
      زیرا با اجازه دادن به <code>database</code> برای تعیین آن، ما به طور ضمنی به توانایی آن در انجام این کار تکیه می‌کنیم، که ممکن است برای <code>persistence mechanisms</code> های جایگزین درست نباشد.
    </li>
</ol>
<ol start="5">
<li>
      آیا کد زیر باید کد ترکیبی در نظر گرفته شود (ترکیبی از کد اصلی و <code>infrastructure</code>)؟e
    </li>
</ol>
<pre><code class="language-php">
    use Doctrine\ORM\Mapping as ORM;
    /**
    * @Entity
    * @Table(name="todo_items")
    */
    final class ToDoItem
    {
    /**
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0069_original/original_page.png" alt="Original Page 69">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<pre><code class="language-php">
    /**
    * @Id
    * @Column(type="integer", name="id")
    * @GeneratedValue
    */
    private int $id;
    /**
    * @Column(type="string", name="desc")
    */
    private string $description;
    // ...
  </code></pre>
<p>
    1. بله، این به ستون‌های <code>database</code> و انواع آنها اشاره می‌کند.
  </p>
<p>
    2. خیر، شما می‌توانید این کلاس را در هر <code>context</code>ای <code>instantiate</code> کرده و از آن استفاده کنید، و این کلاس به سیستم‌های خارجی متکی نیست.
  </p>
<ol start="6">
<li>
      آیا کد زیر باید کد اصلی یا کد <code>infrastructure</code> در نظر گرفته شود؟f
    </li>
</ol>
<pre><code class="language-php">
    final class ToDoItemUsingDoctrineRepository
    implements ToDoItemRepository
    {
    private EntityManagerInterface $em;
    public function __construct(EntityManagerInterface $em)
    {
    $this-&gt;em = $em
    }
    public function save(ToDoItem $toDoItem): void
    {
    $this-&gt;em-&gt;persist($toDoItem);
    $this-&gt;em-&gt;flush();
    }
  </code></pre>
<ol>
<li>
      کد اصلی، زیرا یک <code>repository</code> بخشی از <code>domain model</code> است که منحصراً از کد اصلی تشکیل شده است.
    </li>
</ol>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0070_original/original_page.png" alt="Original Page 70">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>The domain model</strong></h3>
<ol start="2">
<li>
      کد <code>Infrastructure</code>، زیرا این یک <code>repository implementation</code> است که از یک سیستم خارجی (<code>database</code>) برای انجام وظیفه خود استفاده می‌کند.
    </li>
</ol>
<p>
    aپاسخ صحیح: این یک <code>abstraction</code> جزئی است، زیرا این یک <code>interface</code> است که انتزاعی‌تر از یک کلاس است، اما هنوز جزئیات <code>implementation</code> را در مورد مکانیسم <code>persistence</code> زیربنایی لو می‌دهد. به عنوان مثال، کلمه "<code>table</code>" را ذکر می‌کند.
  </p>
<p>
    bپاسخ صحیح: این یک <code>value object</code> است، که در این مورد مقدار <code>identity</code> یک <code>entity</code> را در بر می‌گیرد.
  </p>
<p>
    cپاسخ صحیح: این یک <code>entity</code> است. <code>Identity</code> آن با استفاده از یک <code>value object</code> نشان داده می‌شود. <code>Clients</code> باید <code>identity</code> را به عنوان یک <code>constructor argument</code> ارائه دهند، که باعث می‌شود <code>entity</code> از ابتدا سازگار باشد.
  </p>
<p>
    dپاسخ‌های صحیح: 1 و 3. با استفاده از یک <code>implementation</code> هوشمند برای تولید <code>identity</code>، ما هویت‌های تکراری نخواهیم داشت.
  </p>
<p>
    eپاسخ صحیح: خیر. طبق قوانین ارائه شده در فصل 1، این کد اصلی است.
  </p>
<p>
    fپاسخ صحیح: کد <code>Infrastructure</code>.
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0071_original/original_page.png" alt="Original Page 71">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<p>
    این فصل شامل موارد زیر است:
  </p>
<ul>
<li>ایجاد یک <code>model</code> جدید فقط برای بازیابی <code>information</code></li>
<li>
      راه‌حل‌های مختلف برای پیاده‌سازی یک <code>read model repository</code>
</li>
<li>
      پنهان کردن پیچیدگی <code>query</code> در پشت <code>view models</code> (یک نوع خاص از <code>read models</code>)
    </li>
</ul>
<p>
    در فصل قبل ما از دو مورد از سه <code>SQL queries</code> که در اصل در <code>controller action</code> بودند، خلاص شدیم:
  </p>
<ul>
<li>
      ما <code>query</code> <code>INSERT INTO orders</code> را به <code>SqlOrderRepository</code> منتقل کردیم.
    </li>
<li>
      ما از <code>query</code> <code>SELECT LAST_INSERT_ID()</code> با استفاده از مکانیسم خودمان برای تولید <code>identity</code> خلاص شدیم.
    </li>
</ul>
<p>
<code>SQL query</code> باقی‌مانده یک <code>lookup</code> در جدول <code>ebooks</code> انجام می‌دهد تا قیمت <code>e-book</code> را که کاربر برای خرید انتخاب کرده است، پیدا کند (Listing 3.1).
  </p>
<p>
<em>Listing 3.1.</em> یک <code>SQL query</code> باقی‌مانده در داخل <code>controller</code>.
  </p>
<pre><code class="language-php">
    public function orderEbookAction(Request $request): Response
    {
    $connection = $this-&gt;container-&gt;get('connection');
    // Retrieve the price of the e-book
    $ebookPrice = $connection-&gt;execute(
    'SELECT price FROM ebooks WHERE id = :id',
    [
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0072_original/original_page.png" alt="Original Page 72">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<pre><code class="language-php">
    'id' =&gt; $request-&gt;request-&gt;get('ebook_id')
    ]
    )-&gt;fetchColumn(0);
    $orderAmount = (int)$request-&gt;get('quantity')
    * (int)$ebookPrice;
    // Save the order (Chapter 1)
    // ...
    return new Response(/* ... */);
    }
  </code></pre>
<p>
    به همان دلایلی که در فصل قبل مورد بحث قرار دادیم، ما می‌خواهیم یک راه بهتر برای نشان دادن این مرحله حیاتی از سناریو داشته باشیم. بازیابی قیمت یک <code>e-book</code>. ما می‌خواهیم جزئیات <code>implementation</code> سطح پایین (<code>relational database</code>، جدول <code>ebooks</code>، ستون قیمت و غیره) را پشت یک <code>interface</code> سطح بالا پنهان کنیم، که نشان‌دهنده اطلاعاتی است که ما به آنها علاقه‌مندیم، به جای نحوه بازیابی آن اطلاعات توسط سیستم.
    شاید بتوانیم همان نوع <code>refactoring</code> را که در فصل 2 انجام دادیم، اعمال کنیم؟ یعنی، یک <code>Entity</code> برای نشان دادن <code>e-book</code> معرفی کنیم و آن را از <code>repository</code> آن بازیابی کنیم.
  </p>
<h4>3.1. Reusing the write model</h4>
<p>
    بیایید فرض کنیم که ما در حال حاضر چنین <code>Ebook entity</code> و یک <code>EbookRepository interface</code> را در <code>project</code> خود داریم، همانطور که در Listing 3.2 نشان داده شده است. تا کنون این کلاس‌ها فقط در داخل <code>EbookController</code> برای افزودن یک <code>e-book</code> جدید به <code>catalog</code> یا
    تغییر جزئیات آن استفاده شده‌اند.
  </p>
<p>
<em>Listing 3.2.</em> <code>The Ebook entity and EbookRepository interface</code>.
  </p>
<pre><code class="language-php">
    final class Ebook
    {
    private EbookId $ebookId;
    private int $price;
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0073_original/original_page.png" alt="Original Page 73">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Read models and view models</h3>
<p>...</p>
<p>کد زیر یک نمونه از یک کلاس در یک سیستم مبتنی بر <strong>Domain-Driven Design</strong> را نشان می‌دهد:</p>
<pre><code class="language-php">
public function __construct(
    EbookId $ebookId,
    int $price
    // ...
) {
    $this-&gt;ebookId = $ebookId;
    $this-&gt;price = $price;
    // ...
}

public function changePrice(int $newPrice): void
{
    $this-&gt;price = $newPrice;
}

public function show(): void
{
    // ...
}

public function hide(): void
{
    // ...
}
// More actions...
</code></pre>
<p>این کلاس، یک <strong>Aggregate</strong> به نام <em>Ebook</em> را نشان می‌دهد. این کلاس شامل فیلدهایی مانند <code>EbookId</code> و <code>price</code> و همچنین متدهایی مانند <code>changePrice()</code>، <code>show()</code> و <code>hide()</code> است.</p>
<p>این مثال، نحوه استفاده از مفاهیم <strong>Domain-Driven Design</strong> را نشان می‌دهد:</p>
<ul>
<li><code>EbookId</code>: یک <strong>Value Object</strong> که شناسه یک <strong>Ebook</strong> را نشان می‌دهد.</li>
<li><code>price</code>: یک فیلد عددی که قیمت <strong>Ebook</strong> را نشان می‌دهد.</li>
<li><code>changePrice()</code>: متدی برای تغییر قیمت <strong>Ebook</strong>.</li>
<li><code>show()</code>: متدی برای نمایش <strong>Ebook</strong>.</li>
<li><code>hide()</code>: متدی برای پنهان کردن <strong>Ebook</strong>.</li>
</ul>
<p>علاوه بر این، این مثال یک <strong>interface</strong> به نام <code>EbookRepository</code> را نیز نشان می‌دهد:</p>
<pre><code class="language-php">
interface EbookRepository
{
    /**
     * @throws CouldNotFindEbook
     */
    public function getById(EbookId $ebookId): Ebook;
    /**
     * @throws CouldNotSaveEbook
     */
</code></pre>
<p><code>EbookRepository</code> یک <strong>interface</strong> برای دسترسی به داده‌های مربوط به <strong>Ebook</strong> است. متد <code>getById()</code> یک <strong>Ebook</strong> را با استفاده از <code>EbookId</code> بازیابی می‌کند. این متد ممکن است <strong>exception</strong> از نوع <code>CouldNotFindEbook</code> را <strong>throw</strong> کند.</p>
<p>این مثال، یک نمای کلی از نحوه استفاده از <strong>Read models</strong> و <strong>view models</strong> را در یک سیستم پیچیده نشان می‌دهد.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0074_original/original_page.png" alt="Original Page 74">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<pre><code class="language-php">
    public function save(Ebook $ebook): void;
    }
  </code></pre>
<p>
    اکنون بیایید ببینیم آیا می‌توانیم از این <code>Ebook entity</code> در طول <code>order process</code> استفاده کنیم، زمانی که نیاز به دانستن قیمت یک <code>e-book</code> داریم. ساده‌ترین کاری که می‌توانیم انجام دهیم این است که یک <code>method</code> <code>getPrice()</code> به <code>entity</code> اضافه کنیم.
    این باعث می‌شود که بلافاصله در داخل <code>orderEbookAction()</code> قابل استفاده باشد. Listing 3.3 نشان می‌دهد که چگونه <code>controller</code> <code>Ebook entity</code> مناسب را از <code>EbookRepository</code> بر اساس <code>ID</code>ای که کاربر با ارسال فرم <code>HTML</code> ارائه کرده است، واکشی می‌کند.
  </p>
<p>
<em>Listing 3.3.</em> استفاده از <code>Ebook entity</code> در داخل <code>OrderController</code>.
  </p>
<pre><code class="language-php">
    public function orderEbookAction(Request $request): Response
    {
    $ebook = $this-&gt;ebookRepository-&gt;getById(
    EbookId::fromString($request-&gt;request-&gt;get('ebook_id'))
    );
    $ebookPrice = $ebook-&gt;getPrice();
    $orderAmount = (int)$request-&gt;get('quantity')
    * (int)$ebookPrice;
    // Save the order (Chapter 1)
    // ...
    return new Response(/* ... */);
    }
  </code></pre>
<p>
    این راه‌حل خوب به نظر می‌رسد. <code>Ebook entity</code> موجود یک <code>object</code> مناسب برای دریافت سریع اطلاعات است، زیرا این اطلاعات را از قبل در فیلد <code>$price</code> خود حمل می‌کند. با این حال، چند مشکل در مورد استفاده مجدد از یک <code>entity</code> موجود در یک <code>context</code> متفاوت وجود دارد.
  </p>
<p>
    اولاً، <code>object</code> موجود برای بازیابی اطلاعات <code>design</code> نشده است. ما از آن برای افزودن <code>e-books</code> جدید به <code>catalog</code> خود استفاده می‌کنیم. وقتی می‌خواهیم آن را موقتاً از <code>catalog</code> حذف کنیم، اما نمی‌خواهیم آن را حذف کنیم، <code>method</code> <code>hide()</code> آن را فراخوانی می‌کنیم و دوباره آن را ذخیره می‌کنیم.
    هر چیز دیگری که ما با این <code>Ebook entity</code> انجام می‌دهیم مربوط به تغییرات <code>state</code> است، و در هر جایی که <code>entity</code> را بارگذاری می‌کنیم، این کار را با
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0075_original/original_page.png" alt="Original Page 75">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<p>
    قصد ما برای دستکاری و ذخیره آن است. اما اکنون ما استفاده از <code>Ebook</code> را در <code>createOrderAction()</code> شروع کردیم، جایی که ما نمی‌خواهیم چیزی را در مورد آن تغییر دهیم. ما فقط می‌خواهیم مقداری اطلاعات از آن بگیریم، و به همین دلیل مجبور شدیم <code>method</code> <code>getPrice()</code> را اضافه کنیم.
    با این حال، با بازیابی <code>object</code> کامل <code>Ebook</code>، ما به همه این <code>methods</code> دسترسی داریم که می‌توانند <code>state</code> <code>object</code> را تغییر دهند، مانند <code>changePrice()</code> و <code>hide()</code>. به طور کلی ایده خوبی است که تعداد <code>methods</code> که یک <code>client</code> از یک <code>object</code> به آن دسترسی دارد را محدود کنید.
    حتی بیشتر، اگر این <code>methods</code> دارای <code>side-effects</code> مانند تغییرات <code>state</code> هستند. در این شرایط نیز، ما احتمالاً نباید از <code>Ebook entity</code> استفاده کنیم، زمانی که فقط به اطلاعات نیاز داریم اما هرگز نمی‌خواهیم آن را تغییر دهیم.
  </p>
<p>
    مشکل دیگر مربوط به استفاده مجدد از <code>objects</code> به طور کلی است، نه فقط <code>entities</code>. اگر شروع به استفاده مجدد از یک <code>object</code> در مکان‌های مختلف و به دلایل مختلف کنید، <code>object</code> شروع به ایفای نقش‌های زیادی می‌کند. هر چه یک <code>object</code> نقش‌های بیشتری را ایفا کند، <code>methods</code> و در نتیجه خطوط کد بیشتری را شامل می‌شود.
    به زودی خیلی بزرگ می‌شود که کد را بخوانیم و بفهمیم چه می‌کند، چه رسد به اینکه در آن تغییراتی ایجاد کنیم. وقتی <code>methods</code> با یکدیگر تماس می‌گیرند، یا زمانی که آنها به <code>properties</code> <code>object</code> یکسانی تکیه می‌کنند، تغییر هر چیزی در مورد آن واقعاً دشوار خواهد بود. از آنجایی که <code>clients</code> زیادی اکنون از <code>object</code> استفاده می‌کنند، آنها به رفتار آن متکی هستند تا یکسان بماند.
    ارزیابی اینکه آیا ایجاد تغییر ایمن است یا خیر یا اینکه آیا یک <code>client</code> را که هنوز به برخی از رفتارهای مستند نشده موجود متکی است، خراب می‌کند، دشوار خواهد بود. چنین <code>object</code>ی در برابر تغییر مقاوم می‌شود، که یک کیفیت بد برای <code>objects</code> به طور کلی است.
    شما احتمالاً این زنجیره رویدادها را تشخیص می‌دهید: این نحوه ایجاد کد قدیمی است.
  </p>
<p>
    البته، بدون هیچ‌گونه استفاده مجدد، انجام هر کاری به عنوان یک توسعه‌دهنده نرم‌افزار واقعاً دشوار خواهد بود. اما حداقل استفاده مورد نظر از <code>objects</code> را پیگیری کنید و مراقب تنش در <code>design</code> باشید.
    وقتی دو <code>client</code> از یک <code>object</code> استفاده می‌کنند، به زودی رفتاری را جذب می‌کند که فقط به یکی از <code>clients</code> آن مربوط می‌شود. یا یک <code>client</code> ممکن است به دانشی دسترسی پیدا کند که نباید داشته باشد.
    طبق تجربه من، شما می‌توانید از مقدار زیادی از این تنش <code>design</code> با معرفی <code>objects</code> جداگانه برای تغییر اطلاعات و بازیابی اطلاعات جلوگیری کنید. یا همانطور که به طور سنتی نامیده می‌شود: جدا کردن <code>write model</code> خود از <code>read model</code> خود.
    یک <code>client</code> که به یک <code>object</code> برای دریافت اطلاعات از (خواندن) نیاز دارد، نباید همان <code>object</code> را به عنوان <code>clients</code> که می‌خواهند در آن تغییراتی ایجاد کنند (نوشتن) بازیابی کند.
  </p>
<p>
    اگرچه نسخه فعلی <code>controller</code> ما هنوز در مشکل بزرگی نیست، ما در حال حاضر نوشتن و خواندن را در یک <code>object</code> ترکیب می‌کنیم، بنابراین ما نیز ممکن است
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0076_original/original_page.png" alt="Original Page 76">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<p>
    بنابراین ادامه دهید و با استفاده از <code>objects</code> جداگانه برای تغییر <code>state</code> و بازیابی اطلاعات از بروز مشکلات جلوگیری کنید. این بدان معناست که ما <code>Ebook entity</code> را همانطور که هست رها می‌کنیم، و ما یک <code>object</code> جدید، یک <code>Ebook read model</code> ایجاد می‌کنیم که نیاز محلی به دانستن قیمت <code>e-book</code> را برآورده می‌کند.
    این <code>Ebook read model</code> قرار است یک <code>object</code> فقط خواندنی (همچنین به عنوان یک <code>object</code> غیرقابل تغییر شناخته می‌شود) باشد. <code>Clients</code> که به <code>read model</code> دسترسی دارند، قادر نخواهند بود (به طور تصادفی) <code>state</code> آن را تغییر دهند.
  </p>
<p>
    "آیا <code>getters</code>ها در <code>entities</code> ممنوع هستند؟"
  </p>
<p>
    من تلاش کرده‌ام روشن کنم که نباید از یک <code>entity</code> در مکانی که اطلاعات مورد نیاز است، استفاده شود. افزودن یک <code>getter</code> به یک <code>entity</code> اغلب نشانه‌ای است که شما <code>entity</code> را فقط برای دریافت <code>data</code> از آن بارگذاری کرده‌اید.
    شما باید معرفی یک <code>read model</code> را در چنین سناریویی، درست مانند کاری که در بخش بعدی انجام خواهیم داد، در نظر بگیرید. این بدان معنا نیست که شما هرگز نمی‌توانید یک <code>getter</code> به یک <code>entity</code> اضافه کنید.
    معمولاً من حداقل به یک <code>getter</code> برای <code>ID</code> <code>entity</code> و یک <code>getter</code> برای بازیابی رویدادهای ثبت شده داخلی (در مورد آن در بخش 3.3.2 صحبت خواهیم کرد) نیاز دارم. بسته به شرایط شما، ممکن است اطلاعات دیگری وجود داشته باشد که یک <code>entity</code> باید در معرض دید قرار دهد.
    اما همیشه <code>design</code>های جایگزین را نیز در نظر بگیرید. در اینجا مثالی از یک <code>project</code> قبلی وجود دارد که در آن یک <code>entity</code> یک <code>getter</code> اضافی برای در معرض دید قرار دادن "<code>booking period</code>" خود دریافت کرد:
  </p>
<pre><code class="language-php">
    // $vatReturn is the entity, $bookingPeriods a service
    /*
    * We need to verify that the booking period of the VAT return wasn't
    * closed yet, before we try to roll it back:
    */
    if ($bookingPeriods-&gt;isClosed($vatReturn-&gt;bookingPeriod()) {
    throw CouldNotRollBack::becauseBookingPeriodIsClosed();
    }
    $vatReturn-&gt;rollBack();
  </code></pre>
<p>
    این یک <code>implementation</code> جایگزین است که در آن <code>entity</code> نیازی به داشتن آن <code>getter</code> ندارد:
  </p>
<pre><code class="language-php">
    $vatReturn-&gt;rollBack($bookingPeriods);
    // Inside the entity:
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0077_original/original_page.png" alt="Original Page 77">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<pre><code class="language-php">
    public function rollBack(BookingPeriods $bookingPeriods): void
    {
    if ($bookingPeriods-&gt;isClosed($this-&gt;bookingPeriod) {
    throw CouldNotRollBack::becauseBookingPeriodIsClosed();
    }
    // ...
    }
  </code></pre>
<p>
    صرف نظر از <code>design alternatives</code> و <code>rules of thumb</code>، نیازی به ترس از <code>getters</code> نیست. و آنها قطعاً ممنوع نیستند.
  </p>
<h4>3.2. Creating a separate read model</h4>
<p>
    در هر شرایطی که به اطلاعات نیاز دارید، می‌توانید یک <code>read model</code> معرفی کنید. شما سؤال را به گونه‌ای مطرح می‌کنید که پرسیدن آن برای شما آسان باشد، و نوع پاسخی را که می‌خواهید بازیابی کنید، <code>design</code> می‌کنید.
    در مورد ما، این سؤال این خواهد بود: قیمت یک <code>e-book</code> با <code>ID</code> […]. به من بدهید. پاسخ، یک <code>object</code> خواهد بود که قیمت <code>e-book</code> را نشان می‌دهد.
  </p>
<p>
    به طور کلی دو گزینه برای مدل‌سازی سؤال با کد وجود دارد. شما می‌توانید یک بار دیگر از <code>repository pattern</code> استفاده کنید و کلاس‌هایی با نام یکسان یا مشابه با خود کلاس‌های <code>entity</code> ایجاد کنید (به Listing 3.4 مراجعه کنید).
    در این صورت، شما باید کد را در یک <code>namespace</code> متفاوت قرار دهید تا تشخیص بین <code>read model</code> و <code>write model</code> آسان شود.
  </p>
<p>
<em>Listing 3.4.</em> <code>The Ebook read model and read model repository interface</code>.
  </p>
<pre><code class="language-php">
    interface EbookRepository
    {
    /**
    * @throws CouldNotFindEbook
    */
    public function getById(EbookId $ebookId): Ebook;
    }
    final class Ebook
    {
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0078_original/original_page.png" alt="Original Page 78">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<pre><code class="language-php">
    private EbookId $ebookId;
    private int $price;
    /**
    * @internal Only to be used by implementations
    *
    of EbookRepository
    */
    public function __construct(
    EbookId $ebookId,
    int $price
    ) {
    $this-&gt;ebookId = $ebookId;
    $this-&gt;price = $price;
    }
    public function price(): int
    {
    return $this-&gt;price;
    }
    }
    // usage in the controller:
    $ebook = $this-&gt;ebookRepository-&gt;getById(
    EbookId::fromString($request-&gt;request-&gt;get('ebook_id'))
    );
    $ebookPrice = $ebook-&gt;price();
  </code></pre>
<p>
    این رویکرد در صورتی مفید است که شما بخواهید بیش از یک قطعه <code>information</code> را بازیابی کنید، یا مطمئن هستید که می‌خواهید این کار را در آینده نزدیک انجام دهید.
    به عنوان مثال، بیایید فرض کنیم که شما همچنین به عنوان <code>title</code> <code>e-book</code> برای ذخیره آن در خود <code>Order</code> نیاز دارید. سپس منطقی است که از همان <code>Ebook read model</code> استفاده مجدد کنید و یک <code>method</code> <code>title()</code> به آن اضافه کنید، بنابراین ما می‌توانیم هم <code>title</code> و هم قیمت را از یک <code>object</code> دریافت کنیم.
  </p>
<p>
    از طرف دیگر، اگر شما فقط به یک قطعه از <code>information</code> نیاز دارید، می‌توانید از <code>pseudo-entity</code> صرف نظر کنید. <code>interface</code> می‌تواند یک <code>method</code> داشته باشد که مستقیماً <code>data</code> مورد نیاز شما را برمی‌گرداند.
    Listing 3.5 نشان می‌دهد که چگونه این می‌تواند منجر به یک کلاس <code>read model</code> (<code>Price</code>) و یک <code>interface</code> با یک <code>method</code> برای بازیابی یک قیمت واحد (که در حال حاضر به عنوان یک عدد صحیح نشان داده می‌شود) بر اساس یک <code>EbookId</code> شود.
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0079_original/original_page.png" alt="Original Page 79">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<p>
<em>Listing 3.5.</em> <code>The Ebook read model and repository interface</code>.
  </p>
<pre><code class="language-php">
    interface GetPrice
    {
    /**
    * @throws CouldNotFindEbook
    */
    public function ofEbook(EbookId $ebookId): int;
    }
    // usage in the controller
    $ebookPrice = $this-&gt;getPrice-&gt;ofEbook(
    EbookId::fromString($request-&gt;request-&gt;get('ebook_id'))
    );
  </code></pre>
<p>
    همانطور که در مثال استفاده مشاهده می‌کنید، رویکرد دوم می‌تواند منجر به کدی شود که خواندن آن آسان‌تر است (یا بسته به سلیقه شما، عجیب‌تر). اما اینکه آیا شما باید رویکرد اول یا دوم را انتخاب کنید، به موقعیت شما بستگی دارد.
  </p>
<h4>3.3. Read model repository implementations</h4>
<p>
    در حال حاضر بیایید به گزینه اول بچسبیم: یک <code>Ebook read model</code> و یک <code>EbookRepository interface</code>. هر زمان که یک <code>Ebook entity</code> جدید توسط یک <code>administrator</code> ایجاد می‌شود، باید یک <code>object</code> <code>Ebook read model</code> مربوطه نیز وجود داشته باشد که بتواند قیمت <code>e-book</code> را برای <code>clients</code> که به این اطلاعات نیاز دارند، در معرض دید قرار دهد.
    هر زمان که <code>entity</code> تغییر می‌کند، <code>read model</code> مربوطه نیز باید به‌روزرسانی شود تا آن تغییرات را منعکس کند.
  </p>
<h4>3.3.1. Sharing the underlying data source</h4>
<p>
    ساده‌ترین راه‌حل برای هم‌تراز کردن <code>write</code> با <code>read model</code> این است که به <code>read model</code> اجازه دهیم از <code>data source</code> اساسی <code>entity</code> استفاده کند. در مورد ما، داده‌های یک <code>Ebook entity</code> در جدول <code>ebooks</code> ذخیره می‌شوند.
    ما می‌توانیم یک <code>implementation</code> از <code>interface</code> <code>repository</code> <code>read model</code> ارائه دهیم که <code>data</code> خود را از همان جدول دریافت می‌کند (به Listing 3.6 مراجعه کنید).
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0080_original/original_page.png" alt="Original Page 80">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<p>
<em>Listing 3.6.</em> ایجاد یک <code>Ebook read model object</code> از <code>data source</code> <code>entity</code>.
  </p>
<pre><code class="language-php">
    final class SqlEbookRepository implements EbookRepository
    {
    private Connection $connection;
    public function __construct(Connection $connection)
    {
    $this-&gt;connection = $connection;
    }
    public function getById(EbookId $ebookId): Ebook
    {
    $record = $this-&gt;connection-&gt;execute(
    'SELECT price FROM ebooks WHERE id = ?',
    [
    $ebookId-&gt;asString()
    ]
    )-&gt;fetchAssoc();
    if ($record === false) {
    throw CouldNotFindEbook::withId($ebookId);
    }
    return new Ebook(
    $ebookId,
    (int)$record['price']
    );
    }
  </code></pre>
<p>
    اگرچه یک راه‌حل مناسب است، اما وقتی مدل نوشتن و خواندن از یک <code>data source</code> یکسان استفاده می‌کنند، این می‌تواند منجر به مشکلات جدیدی شود. این امکان وجود دارد که <code>read model repository</code> <code>data</code> را به روشی متفاوت از مدل نوشتن تفسیر کند.
    حتی در مثال بالا، فرض بر این است که ستون قیمت شامل قیمت <code>e-book</code> به سنت است. اگر در مقطعی <code>write model</code> به یک نمایش اعشاری بومی تغییر کند چه؟
    <code>read model</code> شروع به ارائه قیمت‌های نادرست می‌کند، زیرا 1.50 یورو در <code>database</code> زمانی که به یک عدد صحیح تبدیل می‌شود، به 1 سنت در <code>application</code> تبدیل می‌شود. یک راه برای کاهش این خطر
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0081_original/original_page.png" alt="Original Page 81">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<p>
    این است که <code>integration tests</code> را برای <code>read model repositories</code> خود بنویسید. کار دیگری که می‌توانید برای بهبود وضعیت انجام دهید این است که به یک کلاس اجازه دهید هر دو <code>interface</code> <code>repository</code> <code>write</code> و <code>read model</code> را پیاده‌سازی کند.
    به این ترتیب، دانش در مورد جدول <code>database</code> و معنای ستون‌های آن حداقل در یک مکان واحد قرار دارد، و احتمال اینکه با این نوع مشکل مواجه شوید کمتر می‌شود.
  </p>
<h4>3.3.2. Using write model domain events</h4>
<p>
    یک رویکرد دیگر برای همگام‌سازی <code>read model</code> با <code>write model</code> این است که یک <code>domain event</code> را برای هر تغییر مهم در داخل <code>entity</code> ارسال کنید.
    <code>read model</code> سپس قادر است <code>state</code> خود را بر اساس اطلاعات موجود در آن <code>events</code> به‌روزرسانی کند. اینها اجزایی هستند که شما برای این رویکرد به آنها نیاز دارید:
  </p>
<ol>
<li>
      یک <code>entity</code>.
    </li>
<li>
      یک <code>domain event</code> برای هر تغییر <code>state</code> که مربوط به <code>read model</code> است.
    </li>
<li>
      یک <code>service</code> که به این <code>domain events</code> مشترک می‌شود و <code>read model</code> را مطابق با تغییرات نشان داده شده توسط <code>events</code> به‌روزرسانی می‌کند.
    </li>
</ol>
<p>
    Listing 3.7 نشان می‌دهد که چگونه <code>entity</code> می‌تواند <code>domain events</code> را در داخل زمانی که <code>state</code> آن به روشی که ممکن است برای دیگران مرتبط باشد، ثبت کند.
  </p>
<p>
<em>Listing 3.7.</em> یک <code>entity</code> <code>domain events</code> را در داخل ثبت می‌کند.
  </p>
<pre><code class="language-php">
    final class Ebook
    {
    /**
    * @var array&lt;object&gt;
    */
    private array $events;
    private int $price;
    // ...
    public function changePrice(int $newPrice): void
    {
    $this-&gt;price = $newPrice;
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0082_original/original_page.png" alt="Original Page 82">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<pre><code class="language-php">
    // When state changes, we additionally "record" a domain event
    $this-&gt;events[] = new PriceChanged($this-&gt;ebookId, $newPrice);
    }
    public function recordedEvents(): array
    {
    // Clients can find out what happened by calling this method
    return $this-&gt;events;
    }
    }
    /*
    * A PriceChanged domain event is an object that holds the ID of the
    * e-book whose price changed, as well as the new price.
    */
    final class PriceChanged
    {
    private EbookId $ebookId;
    private int $newPrice;
    public function __construct(EbookId $ebookId, int $newPrice)
    {
    $this-&gt;ebookId = $ebookId;
    $this-&gt;newPrice = $newPrice;
    }
    public function ebookId(): EbookId
    {
    return $this-&gt;ebookId;
    }
    public function newPrice(): int
    {
    return $this-&gt;newPrice;
    }
  </code></pre>
<p>
    به منظور مفید بودن <code>events</code> در خارج از <code>entity</code>، آنها باید
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0083_original/original_page.png" alt="Original Page 83">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Read models and view models</h3>
<p> داده‌ها با استفاده از متد <code>recordedEvents()</code> از <strong>entity</strong> استخراج می‌شوند. سپس، ما نیاز داریم هر <strong>service</strong> مرتبط با این <strong>events</strong> را مطلع کنیم، تا آنها بتوانند اقدامات بیشتری انجام دهند. ما به جزئیات مربوط به <strong>event dispatching</strong> و <strong>event subscribing</strong> در بخش 11.5 نگاه خواهیم کرد، بنابراین در اینجا فقط به تصویر بزرگ نگاه می‌کنیم. <strong>Listing</strong> 3.8 نشان می‌دهد که چگونه یک <strong>service</strong>، تغییری در یک <strong>Ebook entity</strong> ایجاد می‌کند، آن را با استفاده از <strong>repository</strong> خود ذخیره می‌کند، و سپس <strong>events</strong> داخلی ثبت شده را با استفاده از یک <strong>event dispatcher service</strong> ارسال می‌کند. در نهایت این کار باعث فراخوانی <strong>subscriber</strong> از نوع <code>UpdateEbookReadModel</code> می‌شود، که <strong>read model</strong> مربوطه را از <strong>repository</strong> واکشی می‌کند و <strong>field</strong> قیمت آن را با استفاده از داده‌های <strong>domain event</strong> از نوع <code>PriceChanged</code> به روز می‌کند.</p>
<p><strong>Listing</strong> 3.8. Using <strong>domain events</strong> to update a <strong>read model</strong>.</p>
<pre><code class="language-php">
/*
* Whenever a service changes the price of an e-book, it will
* internally record a PriceChanged event. We broadcast this
* event by sending it (and other recorded events) to the
* event dispatcher.
*/
$ebook-&gt;changePrice(150);
$this-&gt;ebookRepository-&gt;save($ebook);
$this-&gt;eventDispatcher-&gt;dispatchAll($ebook-&gt;recordedEvents());
/*
* If we register UpdateEbookReadModel as an event subscriber
* for PriceChanged events, the event dispatcher will
* call it whenever such an event occurs.
*
* The listener then updates the read model using the data from
* the event object.
*/
final class UpdateEbookReadModel
{
// ...
public function whenPriceChanged(PriceChanged $event): void
{
    $readModel = $this-&gt;readModelRepository-&gt;getById(
        $event-&gt;ebookId()
    );
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0084_original/original_page.png" alt="Original Page 84">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<pre><code class="language-php">
    $readModel-&gt;setPrice($event-&gt;newPrice());
    $this-&gt;readModelRepository-&gt;save($readModel);
    }
    }
  </code></pre>
<p>
    شکل 3.1 نحوه عملکرد تمام قطعات متحرک را در این <code>scenario</code> نشان می‌دهد.
  </p>
<p>
    Figure 3.1. استفاده از <code>write model events</code> برای به‌روزرسانی یک <code>read model</code>.
  </p>
<p>
    توجه داشته باشید که تنظیم قیمت در <code>read model</code> با تغییر قیمت در <code>entity</code> یکسان نیست. تغییر در <code>entity</code> تغییر واقعی است. هنگامی که ما <code>read model</code> را به‌روزرسانی می‌کنیم، ما صرفاً آن تغییر اصلی را در <code>object</code> <code>read model</code> خود منعکس می‌کنیم.
  </p>
<p>
    سؤال باقی‌مانده این است: چه اتفاقی در داخل <code>method</code> <code>save()</code> از <code>read model repository</code> می‌افتد؟ این یک نگرانی <code>infrastructural</code> است: آیا ما آن را در همان <code>database</code> ذخیره می‌کنیم که <code>entities</code> خود را در آن ذخیره می‌کنیم؟ آیا از یک <code>database</code> متفاوت استفاده می‌کنیم؟
    شاید ما بخواهیم <code>e-book read model</code> را به عنوان یک <code>document</code> در <code>database</code> <code>Elasticsearch</code> خود ذخیره کنیم، بنابراین می‌توانیم آن را به راحتی قابل جستجو کنیم.
  </p>
<p>
    هیچ یک از اینها واقعاً برای هسته <code>application</code> مهم نیست، زیرا ما در حال حاضر یک <code>read model repository interface</code> داریم، که نشان می‌دهد: "من یک نیاز خاص دارم، اما اهمیتی نمی‌دهم که چگونه این نیاز را برآورده می‌کنید.
    من همچنین اهمیتی نمی‌دهم که آیا شما نیاز دارید
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 85" src="page_0085/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0085_original/original_page.png" alt="Original Page 85">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<p>
    "برای صحبت با چیزی در خارج از <code>application</code> برای آن."
  </p>
<p>
    اینکه آیا شما <code>read model repository</code> خود را پیاده‌سازی می‌کنید تا از <code>domain events</code> به عنوان منبع <code>data</code> استفاده کند، یا <code>database</code> <code>write model</code>، یا چیز دیگری کاملاً به این بستگی دارد: هر <code>client</code> می‌تواند از <code>interface</code> <code>repository</code> برای دریافت اطلاعات مورد نیاز خود استفاده کند.
    در <code>controller</code> ما، ما فقط به قیمت یک <code>e-book</code> نیاز داشتیم، که اکنون می‌توانیم آن را از <code>repository</code> <code>read model</code> <code>e-book</code> بازیابی کنیم (Listing 3.9).
  </p>
<p>
<em>Listing 3.9.</em> استفاده از <code>read model</code> در داخل <code>controller</code>.
  </p>
<pre><code class="language-php">
    public function orderEbookAction(Request $request): Response
    {
    $ebook = $this-&gt;ebookRepository-&gt;getById(
    EbookId::fromString($request-&gt;request-&gt;get('ebook_id'))
    );
    $ebookPrice = $ebook-&gt;price();
    // ...
    return new Response(/* ... */);
    }
  </code></pre>
<p>
    "من می‌خواهم در مورد این رویکرد مبتنی بر <code>event</code> بیشتر بدانم!"
  </p>
<p>
    در مورد این رویکرد در "<code>CQRS Documents</code>" از Greg Younga، بیشتر بخوانید.
  </p>
<p>
    Mathias Verraes, “<code>Patterns for Decoupling in Distributed Systems: Summary Event</code>”b.
  </p>
<p>
    استفاده از <code>events</code> برای "<code>synchronization</code>" بین <code>write</code> و <code>read models</code> می‌تواند یک کار پیچیده باشد. برای مشاوره در مورد این موضوع، من "<code>Implementing Domain-Driven Design</code>" از Vaughn Vernon (Addison-Wesley Professional, 2013; به دنبال "<code>Integrating bounded contexts</code>") و وبلاگ Udi Dahanc را توصیه می‌کنم.
  </p>
<p>
    a https://advwebapparch.com/cqrs-documents
  </p>
<p>
    b https://advwebapparch.com/patterns-for-decoupling
  </p>
<p>
    c https://advwebapparch.com/udi-dahan-blog
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0086_original/original_page.png" alt="Original Page 86">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<p>
    برای صحبت با چیزی در خارج از <code>application</code> برای آن.”
  </p>
<p>
    صرف نظر از <code>design alternatives</code> و <code>rules of thumb</code>، نیازی به ترس از <code>getters</code> نیست. و آنها قطعاً ممنوع نیستند.
  </p>
<h4>3.2. Creating a separate read model</h4>
<p>
    در هر شرایطی که به اطلاعات نیاز دارید، می‌توانید یک <code>read model</code> معرفی کنید. شما سؤال را به گونه‌ای مطرح می‌کنید که پرسیدن آن برای شما آسان باشد، و نوع پاسخی را که می‌خواهید بازیابی کنید، <code>design</code> می‌کنید.
    در مورد ما، این سؤال این خواهد بود: قیمت یک <code>e-book</code> با <code>ID</code> […]. به من بدهید. پاسخ، یک <code>object</code> خواهد بود که قیمت <code>e-book</code> را نشان می‌دهد.
  </p>
<p>
    به طور کلی دو گزینه برای مدل‌سازی سؤال با کد وجود دارد. شما می‌توانید یک بار دیگر از <code>repository pattern</code> استفاده کنید و کلاس‌هایی با نام یکسان یا مشابه با خود کلاس‌های <code>entity</code> ایجاد کنید (به Listing 3.4 مراجعه کنید).
    در این صورت، شما باید کد را در یک <code>namespace</code> متفاوت قرار دهید تا تشخیص بین <code>read model</code> و <code>write model</code> آسان شود.
  </p>
<p>
<em>Listing 3.4.</em> <code>The Ebook read model and read model repository interface</code>.
  </p>
<pre><code class="language-php">
    interface EbookRepository
    {
    /**
    * @throws CouldNotFindEbook
    */
    public function getById(EbookId $ebookId): Ebook;
    }
    final class Ebook
    {
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0087_original/original_page.png" alt="Original Page 87">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<pre><code class="language-php">
    {
    private int $priceInCents;
    private function __construct(int $priceInCents)
    {
    $this-&gt;priceInCents = $priceInCents;
    }
    public static function fromInt(int $priceInCents): self
    {
    return new self($priceInCents);
    }
    public function asInt(): int
    {
    return $this-&gt;priceInCents;
    }
    }
    final class Ebook
    {
    // ...
    private Price $price;
    public function __construct(
    /* ... */
    Price $price
    ) {
    // ...
    $this-&gt;price = $price;
    }
    // ...
    public function price(): Price
    {
    return $this-&gt;price;
    }
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0088_original/original_page.png" alt="Original Page 88">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<pre><code class="language-php">
    // Inside the controller:
    /*
    * price() returns a Price object now,
    * so we have to convert it to an integer before multiplying it:
    */
    $orderAmountInCents = (int)$request-&gt;get('quantity')
    * $ebook-&gt;price()-&gt;asInt();
  </code></pre>
<p>
    دریافت <code>data</code> به داخل و خارج از یک <code>value object</code> کم‌اهمیت‌ترین ویژگی <code>value objects</code> است. اگر ما حتی <code>raw value</code> را اعتبارسنجی نکنیم، بهتر است در وهله اول از یک <code>value object</code> استفاده نکنیم. بنابراین گام بعدی باید این باشد که <code>object</code> <code>Price</code> را برای <code>clients</code> خود واقعاً مفید کنیم.
    در این مورد، مفید خواهد بود اگر <code>client</code> نیازی به خارج کردن عدد صحیح از <code>value object</code> نداشته باشد، اما بتواند قیمت را مستقیماً در یک مقدار داده شده ضرب کند. Listing 3.11 نشان می‌دهد که چگونه این کار را با افزودن یک <code>method</code> <code>multiply()</code> به کلاس <code>Price</code> انجام دهیم.
  </p>
<p>
<em>Listing 3.11.</em> افزودن رفتار ضرب به <code>Price</code>.
  </p>
<pre><code class="language-php">
    final class Price
    {
    // ...
    public function multipliedBy(int $quantity): int
    {
    return $this-&gt;priceInCents * $quantity;
    }
  </code></pre>
<pre><code class="language-php">
    $orderAmountInCents = $ebook-&gt;price()-&gt;multipliedBy(
    (int)$request-&gt;get('quantity')
    );
  </code></pre>
<p>
    مقدار سفارش هنوز یک عدد صحیح است و قطعاً از یک <code>value object</code> به نام <code>Amount</code> سود می‌برد، که نشان‌دهنده یک <code>quantity</code> ضرب شده در یک قیمت است. شاید شما حتی بتوانید از یک <code>value object</code> <code>Money</code> عمومی استفاده کنید.
    اما در حال حاضر، ما آن را در این حالت رها می‌کنیم. ما دیده‌ایم که چگونه می‌توانید یک <code>read model</code> را با تنظیم آن با نیازهای <code>client</code> که از آن استفاده می‌کند، بهبود بخشید. یک مزیت اضافه این است که استفاده از <code>value objects</code> به شما امکان می‌دهد از <code>infrastructure</code> جدا شوید.
    <code>Clients</code> می‌توانند حتی اگر نوع داده اساسی تغییر کند، به استفاده از <code>value objects</code> ادامه دهند.
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0089_original/original_page.png" alt="Original Page 89">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<h4>3.5. A specific type of read model: the view model</h4>
<p>
    در بخش قبل ما یک <code>read model</code> اختصاصی و <code>read model repository</code> معرفی کردیم زیرا <code>OrderController</code> به قیمت یک <code>e-book</code> نیاز داشت. شما می‌توانید <code>model</code> حاصل را به عنوان یک <code>read model</code> داخلی طبقه‌بندی کنید، زیرا داده‌هایی که ارائه می‌دهد، فقط به صورت داخلی، توسط خود <code>application</code> استفاده می‌شود.
    <code>information</code> هرگز مستقیماً با <code>user</code> به اشتراک گذاشته نمی‌شود یا به او نمایش داده نمی‌شود.
  </p>
<p>
    از سوی دیگر، مکان‌هایی در <code>application</code> ما وجود دارد که ما <code>data</code> را از <code>database</code> واکشی می‌کنیم تا آن را به کاربر نشان دهیم. یکی از این مکان‌ها صفحه‌ای است که کاربر می‌تواند از طریق لیست <code>e-books</code> موجود برای خرید، مرور کند. Listing 3.12 نشان می‌دهد که چگونه این کار در حال حاضر انجام می‌شود.
    <code>controller action</code> از <code>database connection</code> به طور مستقیم برای یافتن <code>e-books</code> که "<code>hidden</code>" نیستند استفاده می‌کند و در حالی که در <code>database</code> است، برخی از آمار فروش را نیز جمع‌آوری می‌کند.
  </p>
<p>
<em>Listing 3.12.</em> واکشی لیستی از <code>e-books</code> موجود از <code>database</code>.
  </p>
<pre><code class="language-php">
    final class EbookController
    {
    // ...
    public function listEbooksAction(): Response
    {
    $connection = $this-&gt;container-&gt;get(Connection::class);
    $query = &lt;&lt;<eod $records="$connection-" (="" )="" as="" by="" count(*)="" desc="" e="" e.*,="" e.is_hidden="0" ebooks="" eod;="" from="" number_of_times_sold="" o="" o.ebook_id="e.ebook_id" order="" orders="" select="" where="">executeQuery($query)-&gt;fetchAllAssoc();
    return new Response(
  </eod></code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0090_original/original_page.png" alt="Original Page 90">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<pre><code class="language-php">
    $this-&gt;render(
    'list.html.twig', [
    'ebooks' =&gt; $records
    ]
    )
    );
    }
    }
  </code></pre>
<p>
    تا کنون ما به سرعت مشکل را در اینجا تشخیص می‌دهیم: این کد به <code>infrastructure</code> متصل است. توانایی تولید لیستی از <code>e-books</code>های موجود یک <code>use case</code> حیاتی برای فروشگاه‌های <code>e-book</code> است.
    با این حال، این <code>use case</code> در کد ما به عنوان چیزی جدا از <code>infrastructure</code> <code>application</code> قابل تشخیص نیست.
  </p>
<p>
    من معمولاً یک آزمایش فکری کوچک انجام می‌دهم تا بفهمم که آیا ما حتی به جدا کردن یک <code>functionality</code> خاص از <code>infrastructure</code> اساسی آن نیاز داریم یا خیر. به این صورت است:
  </p>
<p>
    اگر هنوز همان کسب‌وکار را اداره می‌کردیم؛ ما هنوز می‌خواهیم <code>e-books</code> را به مشتریان خود بفروشیم. به جز، از این به بعد مردم باید از <code>command-line</code> برای سفارش <code>e-books</code> خود استفاده کنند (می‌دانم، این احمقانه است، اما صبر کنید).
    سؤال این است: آیا <code>application</code> ما همچنان باید <code>functionality</code> را که ما در نظر داریم جدا کنیم، ارائه دهد؟ اگر نه، <code>functionality</code> در واقع به درستی به <code>infrastructure</code> <code>application</code> مرتبط شده است.
    تغییر از یک <code>web frontend</code> به یک <code>CLI frontend</code> باعث می‌شود که نیاز به چنین <code>functionality</code> به طور کامل از بین برود. با این حال، اگر مردم همچنان نیاز به استفاده از آن <code>functionality</code> داشته باشند، حتی از <code>command line</code>، این بدان معناست که ما باید آن را جدا کنیم.
  </p>
<p>
    در موقعیت ما، سؤال خاص‌تر این است: آیا کاربر باید بتواند قبل از خرید یک <code>e-book</code>، به لیستی از <code>e-books</code>های موجود نگاه کند؟ البته که اینطور است. اگر آنها حتی ندانند که چه <code>e-book</code>هایی می‌فروشیم، چگونه تشخیص می‌دهند که کدام <code>e-book</code> را بخرند؟
    به عبارت دیگر، لیست <code>e-books</code>های موجود سزاوار این است که بیش از یک <code>controller</code> با یک <code>database query</code> باشد. باید در کد اصلی نشان داده شود.
  </p>
<p>
    ما باید چندین کار را انجام دهیم:
  </p>
<ol>
<li>
<code>query</code> ما را به عنوان یک <code>method</code> در یک <code>interface</code> مدل‌سازی می‌کنیم.
    </li>
<li>
      نتیجه آن <code>query</code> را به عنوان یک <code>object</code> مدل‌سازی می‌کنیم که پاسخ دقیقی را به ما می‌دهد
    </li>
</ol>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0091_original/original_page.png" alt="Original Page 91">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<p>
    to talk to something outside the application for it.”
  </p>
<p>
    اینکه آیا شما <code>read model repository</code> خود را پیاده‌سازی می‌کنید تا از <code>domain events</code> به عنوان منبع <code>data</code> استفاده کند، یا <code>database</code> <code>write model</code>، یا چیز دیگری کاملاً به این بستگی دارد: هر <code>client</code> می‌تواند از <code>interface</code> <code>repository</code> برای دریافت اطلاعات مورد نیاز خود استفاده کند.
    در <code>controller</code> ما، ما فقط به قیمت یک <code>e-book</code> نیاز داشتیم، که اکنون می‌توانیم آن را از <code>repository</code> <code>read model</code> <code>e-book</code> بازیابی کنیم (Listing 3.9).
  </p>
<p>
<em>Listing 3.9.</em> استفاده از <code>read model</code> در داخل <code>controller</code>.
  </p>
<pre><code class="language-php">
    public function orderEbookAction(Request $request): Response
    {
    $ebook = $this-&gt;ebookRepository-&gt;getById(
    EbookId::fromString($request-&gt;request-&gt;get('ebook_id'))
    );
    $ebookPrice = $ebook-&gt;price();
    // ...
    return new Response(/* ... */);
    }
  </code></pre>
<p>
    ما نیاز داریم.
  </p>
<p>
    مدل‌سازی <code>query</code> ممکن است آسان‌ترین کار باشد. ما فقط باید یک توصیف خوب از سؤال خود پیدا کنیم. ما می‌توانیم یک <code>interface</code> <code>Ebooks</code> با یک <code>method</code> <code>listAvailableEbooks()</code> داشته باشیم (به Listing 3.13 مراجعه کنید).
    آن <code>method</code> یک <code>array</code> از <code>object</code>های <code>Ebook read model</code> را برمی‌گرداند.
  </p>
<p>
<em>Listing 3.13.</em> یک <code>interface</code> برای بازیابی لیستی از <code>e-books</code>های موجود.
  </p>
<pre><code class="language-php">
    interface Ebooks
    {
    /**
    * @return array&lt;Ebook&gt;
    */
    public function listAvailableEbooks(): array;
    }
  </code></pre>
<p>
    باز هم، این کلاس <code>Ebook</code> با کلاس <code>entity</code> یکسان نیست. <code>Objects</code> از این نوع به عنوان <code>read models</code> برای نمایش <code>data</code> در یک صفحه <code>HTML</code> عمل می‌کنند.
    این <code>read models</code> را می‌توان "<code>view models</code>" نامید، زیرا از آنها برای نمایش <code>data</code> به کاربران یا سیستم‌های خارجی استفاده می‌شود. این با هدف <code>Ebook read model</code> از بخش 3.2 که در آن استفاده می‌شد، متفاوت است.
    آن یکی فقط به صورت داخلی، برای محاسبه مقدار سفارش صحیح استفاده می‌شد. <code>data</code> از <code>Ebook view model</code> که ما قصد ایجاد آن را داریم، از مرزهای <code>application</code> ما، به دنیای بیرون، به کاربران واقعی <code>application</code> ما می‌رود.
  </p>
<p>
    این <code>Ebook view model</code> خاص چه شکلی دارد؟ چه <code>data</code>ای را شامل می‌شود، چه انواع <code>data</code>ای باید استفاده شود؟
  </p>
<p>
    برای یافتن پاسخ این سؤالات، ما باید به مکانی نگاه کنیم که <code>view model</code> در آن استفاده می‌شود. در این مورد این فایل <code>list.html.twig</code> است (Listing 3.14)، که <code>template</code> <code>Twig1</code> است که <code>HTML response</code> را برای <code>listEbooksAction()</code> تولید می‌کند.
  </p>
<p>
<em>Listing 3.14.</em> <code>The Twig template</code> که لیست <code>e-books</code>های موجود را <code>renders</code> می‌کند.
  </p>
<p>
<sup>1</sup> https://advwebapparch.com/twig
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0092_original/original_page.png" alt="Original Page 92">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Read models and view models</h3>
<pre><code class="language-twig">
{% extends base.html.twig %}
{% block body %}
<h1>Available e-books</h1>
<table>
<thead>
<tr>
<th>Title</th>
<th>Number of readers</th>
<th>Price</th>
<th>Actions</th>
</tr>
</thead>
{% for ebook in ebooks %}
<tr>
<td>
{{ ebook.title }}
</td>
<td>
{{ ebook.numberOfTimesSold }}
</td>
<td>
{{ ebook.price }}
</td>
<td>
<a href="{{ path('order_ebook', { ebookId: ebook.ebookId }) }}">
Order now
</a>
</td>
</tr>
{% endfor %}
</table>
{% endblock body %}
</code></pre>
<p>بر اساس استفاده مورد نظر از <strong>Ebook view model</strong> در داخل <strong>template</strong>، ما می‌توانیم متدهای <strong>getter</strong> عمومی مورد نیاز و انواع آنها را استخراج کنیم. <strong>Listing</strong> 3.15 طرح کلی کلاس را نشان می‌دهد.</p>
<p><strong>Listing</strong> 3.15. An outline of the <strong>Ebook view model</strong> class</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0093_original/original_page.png" alt="Original Page 93">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<pre><code class="language-php">
    final class Ebook
    {
    public function ebookId(): string
    {
    // ...
    }
    public function title(): string
    {
    // ...
    }
    public function numberOfTimesSold(): int
    {
    // ...
    }
    public function price(): string
    {
    // ...
    }
  </code></pre>
<p>
    بیشتر <code>data</code> ای که توسط <code>view model</code> در معرض دید قرار می‌گیرد باید از نوع <code>string</code> باشد، زیرا <code>rendering</code> خود <code>template</code> اساساً یک تمرین در <code>string concatenation</code> است.
    در برخی موارد، استفاده از انواع بازگشتی ابتدایی دیگر مانند <code>int</code> برای <code>method</code> <code>numberOfTimesSold()</code> منطقی است.
  </p>
<p>
    توجه داشته باشید که <code>price()</code> یک <code>Price value object</code> را بر نمی‌گرداند، مانند <code>method</code> <code>price()</code> که قبلاً در این فصل دیدیم. این یک <code>string</code> را برمی‌گرداند، که قرار است یک مقدار پول به درستی قالب‌بندی شده باشد، از جمله علامت ارز، و با دقت اعشاری صحیح.
    اگر ما تمام این کار <code>formatting</code> را در خود <code>template</code> انجام دهیم، <code>view model</code> به اندازه کافی قابل حمل نخواهد بود.
    دوباره مثال اجرای یک فروشگاه <code>e-book</code> مبتنی بر <code>command-line</code> را در نظر بگیرید. ما همچنان می‌خواهیم قیمت <code>e-book</code> را نشان دهیم، و نمی‌خواهیم منطق <code>formatting</code> قیمت را در مکانی که نمی‌توانیم از <code>HTML templates</code> استفاده کنیم، دوباره بنویسیم.
    ما باید نشان دادن <code>data</code> را به کاربران واقعی تا حد امکان برای هر <code>client</code> آسان کنیم. به طور خاص <code>Templates</code> نباید چیزی در مورد <code>domain objects</code> که <code>application</code> ما به صورت داخلی استفاده می‌کند، بدانند.
    این بدان معناست که <code>view</code> ما
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0094_original/original_page.png" alt="Original Page 94">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<p>
<code>model</code> باید فقط مقادیر <code>primitive-type</code> را برگرداند.
  </p>
<p>
    ما می‌دانیم که <code>object</code> <code>view model</code> ما باید چه شکلی باشد، و ما یک متد <code>interface</code> <code>Ebooks::listAvailableEbooks()</code> تعریف کرده‌ایم که یک <code>array</code> از این <code>object</code>های <code>view model</code> را برمی‌گرداند.
    اکنون ما فقط به یک <code>implementation</code> از آن <code>Ebooks interface</code> نیاز داریم که می‌تواند <code>database</code> را <code>query</code> کند و از <code>data</code> واقعی برای برگرداندن لیست <code>e-books</code>های موجود استفاده کند.
    درست مانند <code>read model</code> در بخش 3.3 گزینه‌های مختلفی وجود دارد، اما بیایید با <code>querying</code> <code>database</code> که توسط <code>write model</code> استفاده می‌شود، پیش برویم. ما می‌توانیم از <code>SQL query</code> موجود استفاده مجدد کنیم.
  </p>
<p>
<em>Listing 3.16.</em> یک <code>implementation</code> برای <code>Ebooks interface</code>.
  </p>
<pre><code class="language-php">
    final class EbooksUsingSql implements Ebooks
    {
    private Connection $connection;
    public function __construct(Connection $connection)
    {
    $this-&gt;connection = $connection;
    }
    public function listAvailableEbooks(): array
    {
    $query = &lt;&lt;<eod $records="$this-" (="" )="" as="" by="" count(*)="" desc="" e="" e.*,="" e.is_hidden="0" ebooks="" eod;="" from="" number_of_times_sold="" o="" o.ebook_id="ebooks.ebook_id" order="" orders="" select="" where="">connection
    -&gt;execute($query)
    -&gt;fetchAllAssoc();
    // Instantiate an Ebook view model for every record
  </eod></code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0095_original/original_page.png" alt="Original Page 95">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<pre><code class="language-php">
    return array_map(
    fn (array $record) =&gt; new Ebook(
    // ...
    ),
    $records
    );
    }
    }
  </code></pre>
<p>
    اکنون ما باید نقاط را به هم متصل کنیم و مطمئن شویم که <code>data</code> از <code>database</code> <code>record</code> در <code>properties</code> صحیح <code>Ebook instance</code> قرار می‌گیرد.
    همچنین، ما باید اطمینان حاصل کنیم که هر <code>getter</code> اطلاعات صحیح را با نوع صحیح برمی‌گرداند. <code>ebookId()</code>، <code>title()</code> و <code>numberOfTimesSold()</code> ساده هستند، اما <code>price()</code> به مقداری کار اضافی نیاز دارد.
    مقدار حاصل از <code>database</code> یک <code>int</code> است، اما مقدار بازگشتی <code>price()</code> باید یک قیمت فرمت شده باشد. اگرچه در داخل <code>method</code> <code>price()</code> ما می‌توانیم این تبدیل را به راحتی انجام دهیم، و ما حتی می‌توانیم در صورت تمایل از <code>Price value object</code> به عنوان یک نوع داده میانی استفاده کنیم (به Listing 3.17 مراجعه کنید).
    هرگز از <code>object</code> <code>view model</code> فرار نمی‌کند، بنابراین یک جزئیات <code>implementation</code> باقی می‌ماند.
  </p>
<p>
<em>Listing 3.17.</em> تبدیل بین انواع داخل <code>view model</code>.
  </p>
<pre><code class="language-php">
    final class Ebook
    {
    // ...
    private int $price;
    public function __construct(
    // ...
    int $price
    ) {
    // ...
    $this-&gt;price = $price;
    }
    // ...
    public function price(): string
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0096_original/original_page.png" alt="Original Page 96">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<pre><code class="language-php">
    {
    return Price::fromInt($this-&gt;price)
    -&gt;asFormattedAmount();
    }
  </code></pre>
<p>
    گزینه‌های زیادی در اینجا وجود دارد. شاید شما دوست ندارید یک <code>method</code> برای <code>string formatting</code> مستقیماً در <code>value object</code> خود داشته باشید. در این صورت یک کلاس <code>utility</code> یا <code>object</code> <code>formatter</code> شماره جداگانه ایجاد کنید.
    شاید بخواهید <code>constructor argument</code> <code>$price</code> را از قبل یک <code>Price value object</code> قرار دهید. در این صورت، بگذارید <code>repository implementation</code> تبدیل از <code>int</code> به <code>Price</code> را انجام دهد.
  </p>
<p>
    "من می‌ترسم که ما با کلاس‌های زیادی به پایان برسیم..."
  </p>
<p>
    نکته خوبیه. شما قطعاً کلاس‌ها و <code>interfaces</code> بیشتری خواهید داشت وقتی که شما کد اصلی را از کد <code>infrastructure</code> جدا می‌کنید. ما حتی می‌توانیم نوعی <code>pattern</code> را در اینجا ببینیم.
    وقتی می‌خواهیم یک <code>query</code> را بازنویسی کنیم (مانند <code>listAvailableEbooks()</code> یا <code>getById()</code>)، ما با یک کلاس "مختلط" واحد شروع می‌کنیم، اما به یک <code>interface</code> جدید و دو کلاس جدید ختم می‌شویم (شکل 3.2).
    <code>interface</code> <code>query</code> را نشان می‌دهد، یکی از کلاس‌ها پاسخ را نشان می‌دهد، و کلاس دیگر یک <code>implementation</code> از <code>query interface</code> است.
  </p>
<p>
    Figure 3.2. بعد از جدا کردن یک <code>query</code> از <code>infrastructure</code> زیربنایی، شما سه عنصر خواهید داشت.
  </p>
<p>
    اگر می‌خواهید از <code>infrastructure</code> جدا شوید، این راه است. اما راه‌های مختلفی نیز برای حفظ تعداد عناصر در سیستم شما وجود دارد که قابل مدیریت باشد.
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 97" src="page_0097/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0097_original/original_page.png" alt="Original Page 97">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<p>
    ۱. فقط یک <code>interface</code> برای <code>objects</code> معرفی کنید که واقعاً با چیزی در خارج از <code>application</code> شما ارتباط برقرار می‌کند. این ممکن است شما را از چند <code>interface</code> نجات دهد.
  </p>
<p>
    ۲. چندین <code>method</code> <code>interface</code> را در یک <code>interface</code> واحد ترکیب کنید. این ممکن است شما را از چند <code>interface</code> نیز نجات دهد.
  </p>
<p>
    ۳. بگذارید یک کلاس واحد چندین <code>interfaces</code> را پیاده‌سازی کند. این قطعاً شما را از چند کلاس نجات می‌دهد.
  </p>
<p>
    ۴. کلاس "پاسخ" را برای <code>queries</code> مختلف استفاده مجدد کنید. این نیز شما را از چند کلاس نجات می‌دهد.
  </p>
<p>
    با این حال، همیشه مراقب تنش در <code>design</code> باشید. معایب کاهش تعداد عناصر در سیستم شما، به ترتیب عبارتند از:
  </p>
<ol>
<li>
      با <code>interfaces</code> کمتر، جایگزینی یک <code>service implementation</code> واقعی با یک <code>test double</code> دشوارتر می‌شود. با این حال، طبق تجربه من، این به ندرت یک مشکل است. وقتی این اتفاق می‌افتد، معرفی مجدد <code>interface</code> پس از آن باید آسان باشد.
    </li>
<li>
      یک <code>interface</code> با چندین <code>method</code> ممکن است به <code>clients</code> اجازه دسترسی به بسیاری از <code>methods</code> نامرتبط را بدهد، که ممکن است هدف خود را گیج کند، آنها را به چیزهای زیادی وابسته کند، و تغییر <code>interface</code> را دشوارتر کند.
    </li>
<li>
      یک کلاس که <code>interfaces</code> زیادی را پیاده‌سازی می‌کند، زمانی که هر <code>method</code> ممکن است مجموعه وابستگی‌ها و دانش وارداتی خود را در داخل آن کلاس داشته باشد که با سایر دانش‌های مشابه درگیر می‌شود، نگهداری آن دشوار خواهد بود.
      یک راه برای رفع این مشکل این است که یک کلاس فقط <code>interfaces</code> را با <code>methods</code> که واقعاً مرتبط هستند، پیاده‌سازی کند.
    </li>
<li>
      اگر از یک کلاس در یک مکان استفاده شود، تغییر آن آسان خواهد بود، زیرا فقط یک <code>client</code> وجود دارد که ممکن است نیاز به به‌روزرسانی داشته باشد. اگر در مکان‌های زیادی استفاده شود، تغییر آن دشوارتر خواهد بود، زیرا <code>clients</code> زیادی وجود دارد که باید به‌روزرسانی شوند و به طور بالقوه ممکن است خراب شوند.
    </li>
</ol>
<p>
    یک مثال عالی از یک کلاس واحد که می‌تواند چندین <code>interfaces</code> مرتبط را پیاده‌سازی کند، کلاس <code>SQL repository</code> است که می‌تواند <code>EbookRepository</code> مدل نوشتن، <code>interface</code> <code>EbookRepository</code> <code>read model</code> و <code>Ebooks interface</code> <code>view model</code> را پیاده‌سازی کند.
    به هر حال، هر <code>method</code> دارای مجموعه‌ای مشترک از وابستگی‌ها (<code>object</code> <code>database Connection</code>) است و کار مشابهی را انجام می‌دهد. با این حال، در عمل من معمولاً حداقل مدل نوشتن را جدا می‌کنم
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0098_original/original_page.png" alt="Original Page 98">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<p>
<code>repository</code> از <code>read model repository implementations</code>.
  </p>
<h4>3.6. Using view models for APIs</h4>
<p>
    در بخش قبل ما در مورد استفاده از <code>view models</code> در <code>HTML templates</code> بحث می‌کردیم. در این صورت کدی وجود خواهد داشت که بر روی <code>return values</code> از برخی از <code>getters</code> <code>view model</code> تکرار می‌شود و
    <code>echo-ing</code> می‌شود. این فرض می‌کند که کاربر نهایی <code>application</code> شما یک شخص واقعی است که از یک مرورگر وب برای بازدید از صفحات <code>web application</code> شما استفاده می‌کند.
    سایر انواع کاربران نیاز دارند که <code>data</code> در فرم‌های مختلف باشد. یک کاربر <code>command-line</code> به اطلاعات متن ساده نیاز دارد، برخی از سیستم‌های از راه دور ممکن است بخواهند با <code>SOAP</code> با <code>application</code> شما صحبت کنند.
  </p>
<p>
    بیایید دریابیم که چگونه این در <code>application</code> ما کار می‌کند. فرض کنید ما می‌خواهیم لیست <code>ebooks</code>های موجود را به عنوان یک <code>array</code> رمزگذاری شده <code>JSON</code> از <code>e-book objects</code> در معرض دید قرار دهیم.
    در داخل <code>controller</code> ما می‌توانیم بر روی <code>array</code> از <code>object</code>های <code>Ebook view model</code> که توسط <code>listAvailableEbooks()</code> برگردانده می‌شود، تکرار کنیم و آن را به یک <code>data structure</code> قابل سریال‌سازی <code>JSON</code>، مانند یک <code>array</code> از <code>associative arrays</code> تبدیل کنیم (به Listing 3.18 مراجعه کنید).
  </p>
<p>
<em>Listing 3.18.</em> بازگرداندن لیستی از <code>e-books</code>های موجود به عنوان <code>JSON</code>.
  </p>
<pre><code class="language-php">
    final class EbookApiController
    {
    private Ebooks $ebooks;
    public function __construct(Ebooks $ebooks)
    {
    $this-&gt;ebooks = $ebooks;
    }
    public function listAvailableEbooksAction(): Response
    {
    $data = [];
    foreach ($this-&gt;ebooks-&gt;listAvailableEbooks() as $ebook) {
    $data[] = [
    'ebookId' =&gt; $ebook-&gt;ebookId(),
    'title' =&gt; $ebook-&gt;title(),
    // ...
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0099_original/original_page.png" alt="Original Page 99">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<pre><code class="language-php">
    ];
    }
    return new Response(json_encode($data));
    }
    }
  </code></pre>
<p>
<code>read models</code> قرار است تا حد امکان برای <code>clients</code> خود کاربرپسند باشند. اما این <code>controller</code> هنوز باید مقدار نسبتاً زیادی کار انجام دهد قبل از اینکه بتواند <code>data</code> را به کاربر نشان دهد.
    ما می‌توانیم اگر <code>object</code>های <code>view model</code> بتوانند در یک مرحله به <code>JSON</code> <code>serialized</code> شوند، این کار را برای این <code>client</code> بسیار آسان‌تر کنیم. راه‌های زیادی برای انجام این کار وجود دارد.
    ما می‌توانیم به <code>view model</code> اجازه دهیم که خود را به یک <code>array</code> انجمنی تبدیل کند (به Listing 3.19 مراجعه کنید).
  </p>
<p>
<em>Listing 3.19.</em> یک <code>view model</code> با یک <code>method</code> <code>asArray()</code>.
  </p>
<pre><code class="language-php">
    final class Ebook
    {
    // ...
    /**
    * @return array&lt;string,mixed&gt;
    */
    public function asArray(): array
    {
    return [
    'ebookId' =&gt; $this-&gt;ebookId(),
    'title' =&gt; $this-&gt;title(),
    // ...
    ];
    }
  </code></pre>
<pre><code class="language-php">
    // Inside the controller:
    return new Response(
    json_encode(
    array_map(
    fn (Ebook $ebook) =&gt; $ebook-&gt;asArray(),
    $this-&gt;ebooks-&gt;listAvailableEbooks()
    )
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0100_original/original_page.png" alt="Original Page 100">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<pre><code class="language-php">
    )
    );
  </code></pre>
<p>
    شما همچنین می‌توانید <code>object</code> <code>view model</code> را با <code>making</code> <code>properties</code> آن <code>public</code> بلافاصله <code>serializable</code> کنید (به Listing 3.20 مراجعه کنید). تنها چیزی که در اینجا وجود ندارد، راهی برای اجرای <code>immutability</code> در این <code>object</code> پس از عمومی کردن <code>properties</code> آن است.
    خود <code>PHP</code> هیچ گزینه‌ای برای انجام این کار در زمان اجرا ندارد، اما می‌توان آن را در زمان "<code>compile</code>" با استفاده از یک <code>static analyzer</code> مانند <code>Psalm</code> انجام داد.
  </p>
<p>
<em>Listing 3.20.</em> یک <code>view model</code> با <code>public properties</code>.
  </p>
<pre><code class="language-php">
    final class Ebook
    {
    public string $ebookId;
    public string $title;
    // ...
    }
    // Inside the controller:
    return new Response(
    json_encode(
    $this-&gt;ebooks-&gt;listAvailableEbooks()
    )
  </code></pre>
<h4>3.7. Summary</h4>
<p>
    در ابتدای این فصل ما نیاز به دریافت اطلاعات در مورد یک <code>entity</code> مرتبط را تشخیص دادیم. به جای استفاده مجدد از خود <code>entity</code> ما تصمیم گرفتیم که <code>responsibilities</code> نوشتن و خواندن را در یک <code>object</code> ترکیب نکنیم.
    ما یک <code>object</code> <code>Ebook read model</code> غیرقابل تغییر را معرفی کردیم که در ارائه اطلاعات تخصص داشت. چنین <code>object</code> <code>read model</code> با <code>interface</code> <code>repository</code> <code>read model</code> خود همراه است.
    این <code>interface</code> به یک <code>implementation</code> نیاز دارد که <code>data</code> را واکشی می‌کند و <code>objects</code> <code>read model</code> را با استفاده از آن <code>data</code> <code>instantiates</code> می‌کند. ما چندین جایگزین برای <code>repository implementations</code> مورد بحث قرار دادیم: شما می‌توانید از منبع داده
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0101_original/original_page.png" alt="Original Page 101">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<p>
<code>repository</code> از <code>read model</code>، یا شما می‌توانید <code>read model</code> را بر اساس <code>events</code> از <code>write model</code> به‌روزرسانی کنید.
  </p>
<p>
    در شرایط دیگر ما نیاز داشتیم تا مقداری <code>data</code> را به <code>user</code> نشان دهیم. باز هم، ما برای این منظور از <code>write model</code> استفاده مجدد نکردیم، بلکه یک <code>view model</code> اختصاصی ایجاد کردیم.
    <code>view model</code> از یک <code>object</code> <code>view model</code>، یک <code>repository interface</code> و یک <code>repository implementation</code> تشکیل شده است. <code>object</code> <code>view model</code> شامل تمام <code>data</code> مورد نیاز است. در یک <code>web application</code> معمولی، یک <code>view model</code> دارای <code>getters</code> است که دریافت <code>data</code> و <code>render</code> آن را در داخل یک <code>HTML template</code> آسان می‌کند.
    هنگامی که یک <code>view model</code> قرار است به عنوان یک <code>API response</code> برگردانده شود، یک الزام این است که در یک مرحله <code>serializable</code> باشد.
  </p>
<p>
    Exercises
  </p>
<ol>
<li>
      آیا استفاده مجدد از یک <code>entity</code> برای هدف <code>querying data</code> هوشمندانه است؟a
    </li>
<li>
      یک <code>read model</code> از سه عنصر کلاس/<code>interface</code> تشکیل شده است. آنها چه هستند؟b
    </li>
<li>
      دو راه رایج برای همگام‌سازی یک <code>read</code> و یک <code>write model</code> چیست؟c
    </li>
<li>
      برخی از مدل‌ها از <code>methods</code> خود <code>value objects</code> را برمی‌گردانند. کدام یک؟d
    </li>
</ol>
<ol>
<li>
<code>Entities</code>
</li>
<li><code>Read models</code></li>
<li><code>View models</code></li>
</ol>
<ol start="5">
<li>
      یک الزام واقعی برای <code>read models</code> چیست؟e
    </li>
</ol>
<ol>
<li>
      آنها باید بر اساس <code>domain events</code> با <code>write model</code> همگام شوند.
    </li>
<li>
      آنها باید از <code>use case</code> <code>clients</code> خود به جای ارائه برخی اهداف عمومی پشتیبانی کنند.
    </li>
<li>
      آنها باید <code>interface</code> <code>repository</code> <code>read model</code> یکسانی را به اشتراک بگذارند.
    </li>
</ol>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0102_original/original_page.png" alt="Original Page 102">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>3. Read models and view models</strong></h3>
<p>
    aپاسخ صحیح: خیر، رویکرد توصیه شده ایجاد یک <code>read model</code> جداگانه است.
  </p>
<p>
    bپاسخ صحیح:
  </p>
<ol>
<li>
      یک <code>interface method</code> که <code>question</code> را نشان می‌دهد، به عنوان مثال
      <code>listAvailableEbooks()</code>، 2. یک کلاس که پاسخ به <code>question</code> را نشان می‌دهد، به عنوان مثال
      <code>Ebook</code>. 3. یک <code>implementation</code> برای <code>query method</code> که قادر به <code>instantiate</code> کردن <code>answer objects</code> است.
    </li>
</ol>
<p>
    cپاسخ صحیح: 1. استفاده از <code>data source</code> <code>write model</code> برای <code>read model</code> نیز. 2. استفاده از <code>events</code> از <code>write model</code> برای منعکس کردن تغییرات در <code>read model</code>.
  </p>
<p>
    dپاسخ صحیح: 1. <code>Entities</code> و 2. <code>Read models</code>. <code>View models</code> قرار است <code>data</code> را به گونه‌ای ارائه دهند که بلافاصله قابل ارائه باشد. یک <code>value object</code> هنوز هم باید به یک نوع ابتدایی تبدیل شود.
  </p>
<p>
    eپاسخ صحیح: 2. گزینه‌های 1 و 3 یک امکان هستند، نه یک ضرورت.
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0103_original/original_page.png" alt="Original Page 103">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<p>
    این فصل شامل موارد زیر است:
  </p>
<ul>
<li>
      استخراج یک <code>application service</code> از یک <code>web controller</code>
</li>
<li>
      ایجاد یک <code>use case</code> مستقل از <code>infrastructure</code> اطراف آن
    </li>
<li>
      معرفی یک <code>parameter object</code> برای ارائه <code>input data</code> برای <code>application service</code>
</li>
<li>
      جدا کردن مراحل سناریوی <code>use case</code> به چندین <code>service</code>
</li>
</ul>
<p>
    پس از همه کارهایی که در دو فصل اول انجام دادیم، <code>orderEbookAction()</code> <code>OrderController</code> از قبل در شکل عالی قرار دارد (به Listing 4.1 مراجعه کنید).
  </p>
<p>
<em>Listing 4.1.</em> وضعیت فعلی <code>orderEbookAction()</code>.
  </p>
<pre><code class="language-php">
    public function orderEbookAction(Request $request): Response
    {
    $ebook = $this-&gt;container-&gt;get('ebook_repository')
    -&gt;getById((int)$request-&gt;get('ebook_id'));
    $orderAmount = $ebook-&gt;price()-&gt;multipliedBy(
    (int)$request-&gt;get('quantity')
    );
    $orderRepository = $this-&gt;container-&gt;get('order_repository');
    $orderId = $orderRepository-&gt;nextIdentity();
    $order = new Order(
    $orderId,
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0104_original/original_page.png" alt="Original Page 104">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<pre><code class="language-php">
    $ebook-&gt;id(),
    $request-&gt;get('email_address'),
    (int)$request-&gt;get('quantity'),
    $ebook-&gt;price(),
    $orderAmount
    );
    $orderRepository-&gt;save($order);
    $this-&gt;container-&gt;get('session')-&gt;set(
    'currentOrderId',
    $orderId-&gt;asString()
    );
    // ...
    return new Response(/* ... */);
    }
  </code></pre>
<p>
    ما <code>domain logic</code> را به یک <code>Order entity</code> منتقل کردیم و یک <code>abstraction</code> برای ذخیره <code>orders</code> معرفی کردیم، که ما آن را <code>OrderRepository</code> نامیدیم. ما همچنین یک <code>Ebook read model</code> ایجاد کردیم، که به این سؤال پاسخ می‌دهد: قیمت این <code>e-book</code> چقدر است؟
    قیمت <code>e-book</code> به عنوان یک <code>Price value object</code> نشان داده می‌شود. این یک <code>method</code> <code>multipliedBy()</code> مناسب برای محاسبه کل مبلغ سفارش دارد. ما تلاش زیادی را برای شفاف‌تر کردن مفاهیم و رفتارهای <code>domain</code> صرف کرده‌ایم، و این نتیجه داده است.
    داستان سفارش یک <code>e-book</code> با هر مرحله <code>refactoring</code> آسان‌تر می‌شود. هنوز یک مشکل وجود دارد: <code>controller action</code> به <code>context</code> یک <code>web application</code> نیاز دارد تا در آن اجرا شود. بنابراین، همه چیز در داخل <code>orderEbookAction()</code> هنوز باید کد <code>infrastructure</code> در نظر گرفته شود.
  </p>
<h4>4.1. Considering other infrastructures</h4>
<p>
    کد برای <code>use case</code> "سفارش یک <code>e-book</code>" نشان می‌دهد که قرار است از طریق <code>HTTP</code> فراخوانی شود. یک صفحه وب با یک فرم وجود دارد که این <code>use case</code> را برای کاربرانش در دسترس قرار می‌دهد.
    هیچ راه دیگری برای سفارش یک <code>e-book</code> وجود ندارد. بیایید آزمایش فکری را که در فصل 3 انجام دادیم تکرار کنیم. اگر کسب و کار ما یک سوئیچ <code>infrastructure</code> اصلی انجام دهد: از وب به
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0105_original/original_page.png" alt="Original Page 105">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<p>
    خط فرمان. آیا <code>application</code> ما هنوز نیاز به پیاده‌سازی این <code>use case</code> دارد؟ اگر چنین است، و من مطمئن هستم که اینگونه است، باید از <code>infrastructure</code> جدا شود، بنابراین از چنین تغییری جان سالم به در خواهد برد.
  </p>
<p>
    اکنون بیایید دریابیم که چه چیزی برای کار کردن <code>use case</code> "سفارش یک <code>e-book</code>" در یک <code>command-line application</code> مورد نیاز است. Listing 4.2 ساختار اساسی کلاس <code>command</code> را نشان می‌دهد که می‌تواند برای سفارش <code>e-books</code> از
    <code>command-line</code> به جای یک مرورگر وب استفاده شود. همانطور که مشاهده می‌کنید، نمونه کد از جزء <code>Symfony Console</code><sup>1</sup> استفاده می‌کند، اما ابزارهای دیگر کلاس‌ها یا <code>interfaces</code> مشابهی دارند، بنابراین من مطمئن هستم که می‌توانید مثال را به یک <code>framework</code> که با آن آشنا هستید، ترجمه کنید.
  </p>
<p>
<em>Listing 4.2.</em> ساختار اساسی یک <code>Symfony console command</code>.
  </p>
<pre><code class="language-php">
    use Symfony\Component\Console\Command\Command;
    use Symfony\Component\Console\Input\InputArgument;
    use Symfony\Component\Console\Input\InputInterface;
    use Symfony\Component\Console\Input\InputOption;
    use Symfony\Component\Console\Output\OutputInterface;
    final class CreateOrderCommand extends Command
    {
    protected function configure(): void
    {
    $this
    -&gt;setName('create-order')
    -&gt;addArgument('ebook_id', InputArgument::REQUIRED)
    -&gt;addArgument('quantity', InputArgument::REQUIRED)
    -&gt;addArgument('email_address', InputArgument::REQUIRED);
    }
    protected function execute(
    InputInterface $input,
    OutputInterface $output
    ): int {
    // How to create an order?
    return 0; // success
    }
  </code></pre>
<p>
<sup>1</sup> https://advwebapparch.com/symfony-console-component
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0106_original/original_page.png" alt="Original Page 106">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<pre><code class="language-php">
    }
    Once Symfony knows about this command, you can run it like this: bin/console
    create-order "21" "2" "info@matthiasnoback.nl". But how do we do the
    actual work, creating an order based on the provided command-line argu-
    ments? Of course, we could simply copy all the code from the controller, and
    I know applications where this has happened. What’s the result of copying
    use case code?
    • If we actually copy the code there are now two places that contain the
    code for this use case. As you probably know, this gets very confusing
    and quickly becomes a maintenance nightmare. A developer changes
    something in one location, and forgets to update the other location too.
    Or they change it in a special undocumented way and nobody under-
    stands what’s going on for what reason anymore.
    • If we don’t actually copy the code but move it to the new location and
    we remove the old code, we’re still looking at the same problem that
    we started with: the core use case of ordering an e-book is now tied to
    other infrastructure and can only run in the context of a command-line
    application.
    So we should neither move the code to the command class, nor copy it. Could
    we somehow run the same controller code from the command-line instead?
    Since a command line application can’t deal with HTTP requests, responses,
    or sessions, we’d have to forge a Request object and define a stand-in session
    service in the container. Finally you would be able to call the controller, as
    shown in Listing 4.3.
    Listing 4.3. The command calls the controller action.
    final class CreateOrderCommand extends Command
    {
    // ...
    protected function execute(
    InputInterface $input,
    OutputInterface $output
    ): int {
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0107_original/original_page.png" alt="Original Page 107">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<pre><code class="language-php">
    $request = new Request([], [
    'ebook_id' =&gt; $input-&gt;getArgument('ebook_id'),
    'quantity' =&gt; $input-&gt;getArgument('quantity'),
    'email_address' =&gt; $input-&gt;getArgument('email_address')
    ]);
    $response = $this-&gt;container-&gt;get('order_controller')
    -&gt;orderEbookAction($request);
    // Somehow extract the order ID from the Response...
    return 0;
    }
    }
    Of course, this is an ugly workaround; I think most people would consider it
    a hack.
  </code></pre>
<p>
    البته، این یک <code>workaround</code> زشت است. فکر می‌کنم اکثر مردم آن را یک <code>hack</code> می‌دانند.
  </p>
<p>
    اجازه دهید یک قدم به عقب برگردیم. ما در حال معرفی <code>hacks</code> برای ایجاد یک <code>web application</code> هستیم که از خط فرمان کار می‌کند. شاید این دارد از کنترل خارج می‌شود؛ شاید کل تمرین خیلی دور از ذهن باشد؟ حتی منطقی نیست که <code>e-books</code> را از <code>command-line</code> سفارش دهیم.
  </p>
<p>
    خوب، من افرادی را می‌شناسم که در حال ساخت یک <code>web application</code> هستند اما نمی‌خواهند منتظر بمانند تا <code>user interface</code> و تعاملات <code>user</code> طراحی شوند تا بتوانند از آن استفاده کنند. آنها فقط می‌خواهند <code>use cases</code> <code>application</code> را بدون <code>web frontend</code>ای که <code>application</code> در نهایت خواهد داشت، تمرین کنند.
    آنها با <code>command-line</code> آشنا هستند، پس چرا چند <code>command</code> نسازیم که به آنها اجازه می‌دهد برخی از <code>exploratory testing</code> را انجام دهند؟
  </p>
<p>
    اما موارد قانع‌کننده‌تری وجود دارد که در آن مهم است که یک <code>use case</code> واحد را بتواند توسط انواع مختلف <code>clients</code> استفاده شود. در اینجا چند نمونه نه چندان دور از ذهن وجود دارد:
  </p>
<ol>
<li>
<code>application</code> باید یک <code>API endpoint</code> را برای یک سیستم خارجی ارائه دهد که سفارش‌های <code>e-book</code> را از طریق <code>frontend</code> خود می‌پذیرد و آنها را به عنوان یک <code>string</code> <code>JSON</code> برای ما ارسال می‌کند.
    </li>
<li>
<code>application</code> باید یک <code>import function</code> داشته باشد، که در آن یک <code>administrator</code> می‌تواند یک فایل <code>CSV</code> را با سفارشات وارد شده دستی از
    </li>
</ol>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0108_original/original_page.png" alt="Original Page 108">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<p>
<code>customers</code> که از غرفه ما در یک کنفرانس بازدید کردند.
  </p>
<p>
    ۳. برخی از <code>use cases</code>ها باید به طور منظم فراخوانی شوند، و اکنون ما باید یک <code>cron job</code> راه‌اندازی کنیم که بتواند این کار را انجام دهد (خوب، شاید نه سفارش یک <code>e-book</code>، اما همگام‌سازی <code>catalog</code> <code>e-books</code> محلی ما با برخی از <code>service</code>های از راه دور).
  </p>
<p>
    در هر نمونه، <code>client</code> از نوع متفاوتی است. در مورد اول ما به یک <code>controller</code> دیگر نیاز داریم که <code>JSON</code> را که از سیستم خارجی دریافت می‌کنیم، تجزیه می‌کند و به نوعی آن را به یک سفارش واقعی تبدیل می‌کند.
    در مورد دوم، ما باید یک فایل <code>CSV</code> را تجزیه کنیم و روی خطوط آن تکرار کنیم و برای هر خط یک سفارش جدید ایجاد کنیم.
    مثال سوم بیشتر شبیه مثال <code>command-line</code> است که قبلاً مورد بحث قرار دادیم: یک <code>cron job</code> نیز به یک نقطه ورود خط فرمان به <code>use cases</code> خاص از <code>application</code> ما نیاز دارد.
  </p>
<p>
    چگونه می‌توانید یک <code>use case</code> را برای همه این <code>clients</code> مختلف قابل استفاده کنید؟
  </p>
<h4>4.2. Designing a use case to be reusable</h4>
<p>
    برای اینکه یک <code>use case</code> قابل استفاده مجدد باشد، ما باید یک زمین مشترک پیدا کنیم که به انواع مختلف <code>clients</code> اجازه دهد تا همان <code>use case</code> را فراخوانی کنند.
    اگر شما با یک <code>controller</code> موجود مانند موردی که در حال حاضر روی آن کار می‌کنیم شروع کنید، باید به دنبال چیزهایی باشید که کد را به <code>infrastructure</code> خاص متصل می‌کنند و سپس آن را از این عناصر جدا کنید.
    به عنوان مثال، کد در حال حاضر به یک <code>object</code> <code>Request</code> متکی است، که آن را فقط در یک <code>web context</code> مفید می‌کند، و همین امر برای انتقال <code>data</code> به درخواست بعدی با ذخیره چیزی در یک <code>object</code> <code>Session</code> صدق می‌کند.
    یک <code>API controller</code> نباید <code>state</code> را بین درخواست‌ها حفظ کند، و یک <code>CLI client</code> حتی در مورد <code>sessions</code> اطلاعی نخواهد داشت. بنابراین برای اینکه کد <code>use case</code> قابل استفاده مجدد باشد، باید وابستگی‌های آن را به <code>Request</code> و <code>Session</code> حذف کنیم.
  </p>
<p>
    ما همچنین باید ورودی و خروجی <code>use case</code> را تجزیه و تحلیل کنیم. در مثال ما، ورودی اطلاعات مورد نیاز برای ایجاد سفارش است: <code>ID</code> <code>e-book</code>، تعداد سفارش و آدرس <code>email</code> خریدار.
    آنچه خارج می‌شود، <code>ID</code> سفارشی است که ایجاد شده است. در حال حاضر داده‌های ورودی از <code>object</code> <code>Request</code> گرفته می‌شود. به منظور جدا کردن از آن و قابل استفاده مجدد کردن این کد، ما باید ورودی را بدون ذکر هیچ مفهوم خاص <code>infrastructure</code> مانند "<code>request</code>" دوباره تعریف کنیم.
    خروجی فقط یک <code>ID</code> است که به یک <code>infrastructure</code> خاص مرتبط نیست، بنابراین ما در آنجا کار اضافی نخواهیم داشت.
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0109_original/original_page.png" alt="Original Page 109">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<p>
    ارائه <code>data</code> ورودی در فرمی که از مکانیزم ارائه <code>data</code> جدا شده است (یعنی، <code>HTTP</code>)، خیلی سخت نیست. ما باید فقط از داده‌های با نوع ابتدایی استفاده کنیم، و این کار را انجام می‌دهد.
    در مثال ما، ما از یک <code>string</code> برای آدرس <code>email</code> خریدار و اعداد صحیح برای <code>ID</code> <code>e-book</code> و تعداد سفارش استفاده خواهیم کرد. Listing 4.4 نشان می‌دهد که اگر استفاده از <code>object</code> <code>Request</code> را به سمت بالای <code>method</code> منتقل کنیم و دیگر از آن در وسط استفاده نکنیم، چه اتفاقی می‌افتد.
    تکنیک <code>refactoring</code> که ما در اینجا استفاده می‌کنیم، <code>Extract Variable</code><sup>2</sup> نامیده می‌شود. <code>IDE</code> شما ممکن است در این مورد به شما کمک کند.
  </p>
<p>
<em>Listing 4.4.</em> <code>Push</code> کردن استفاده از <code>object</code> <code>Request</code> به بالای <code>controller action</code>.
  </p>
<pre><code class="language-php">
    public function orderEbookAction(Request $request): Response
    {
    // We extract
    $ebookId = (int)$request-&gt;get('ebook_id');
    $orderQuantity = (int)$request-&gt;get('quantity');
    $emailAddress = $request-&gt;get('email_address');
    // Below this point, we don't need the Request anymore:
    $ebook = $this-&gt;container-&gt;get('ebook_repository')
    -&gt;getById($ebookId);
    $orderAmount = $ebook-&gt;price()
    -&gt;multipliedBy($orderQuantity);
    // ...
    $orderRepository-&gt;save($order);
    // We make sure that we only use the Session below this point:
    $this-&gt;container-&gt;get('session')-&gt;set(
    'currentOrderId',
    $orderId-&gt;asString()
    );
  </code></pre>
<p>
<sup>2</sup>Martin Fowler, “Refactoring: Improving the Design of Existing Code”, Addison-Wesley Professional (2018). از این به بعد من به سادگی به صفحه وب مربوطه اشاره می‌کنم. در این مورد: https://advwebapparch.com/extract-variable.
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0110_original/original_page.png" alt="Original Page 110">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<pre><code class="language-php">
    // ...
    return new Response(/* ... */);
    }
  </code></pre>
<p>
    به جز چند مورد استفاده از <code>service locator</code> ($this-&gt;container-&gt;get())، بخش بزرگی از <code>controller action</code> شروع به شباهت به کد اصلی می‌کند. مستقل از <code>infrastructure</code>ای که آن را به کاربرانش متصل می‌کند، و مستقل از
    <code>storage</code> اساسی و غیره. هنوز رسماً کد اصلی نیست، زیرا خود <code>method</code> هنوز به <code>web context</code> آن متصل است.
  </p>
<h4>4.3. Extracting an application service</h4>
<p>
    گام بعدی این خواهد بود که تمام کدی را که مختص وب نیست جابه‌جا کرده و آن را به کلاس خودش منتقل کنیم. این گام <code>refactoring</code> استاندارد دیگری است که <code>Extract Class</code><sup>3</sup> نامیده می‌شود. برای انجام این کار ما باید:
  </p>
<ul>
<li>
      یک کلاس جدید ایجاد کنید. بیایید آن را <code>EbookOrderService</code> بنامیم.
    </li>
<li>
      یک <code>method</code> <code>public</code> به آن اضافه کنید. بیایید آن را <code>create()</code> بنامیم.
    </li>
<li>
      کد مستقل از <code>infrastructure</code> را از <code>controller</code> به <code>method</code> جدید منتقل کنید.
    </li>
<li>
      وابستگی‌های لازم (<code>EbookRepository</code> و <code>OrderRepository</code>) را به عنوان آرگومان‌های <code>constructor</code> تزریق کنید.
    </li>
<li>
      از <code>service</code> جدید در داخل <code>controller</code> استفاده کنید.
    </li>
<li>
<code>data</code>ای را که استخراج کردیم به عنوان آرگومان‌های <code>method</code> <code>create()</code> <code>service</code> ارائه دهید.
    </li>
</ul>
<p>
    کلاس <code>service</code> حاصل و استفاده از آن در <code>controller</code> در Listing 4.5 نشان داده شده است. به این <code>service</code> اغلب یک <code>Application service</code> گفته می‌شود.
    از آن برای مدل‌سازی یک <code>use case</code> استفاده می‌شود که دارای <code>side-effects</code> است (مانند ذخیره یک <code>entity</code> جدید) به روشی قابل استفاده مجدد. ما این <code>pattern</code> را با جزئیات بیشتر در بخش 11.4 مورد بحث قرار خواهیم داد.
  </p>
<p>
<sup>3</sup>https://advwebapparch.com/extract-class
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0111_original/original_page.png" alt="Original Page 111">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<p>
<em>Listing 4.5.</em> <code>The extracted EbookOrderService</code>.
  </p>
<pre><code class="language-php">
    final class EbookOrderService
    {
    private EbookRepository $ebookRepository;
    private OrderRepository $orderRepository;
    public function __construct(
    EbookRepository $ebookRepository,
    OrderRepository $orderRepository
    ) {
    $this-&gt;ebookRepository = $ebookRepository;
    $this-&gt;orderRepository = $orderRepository;
    }
    public function create(
    int $ebookId,
    int $orderQuantity,
    string $emailAddress
    ): OrderId {
    $ebook = $this-&gt;ebookRepository-&gt;getById($ebookId);
    $orderAmount = $ebook-&gt;price()
    -&gt;multipliedBy($orderQuantity);
    $orderId = $this-&gt;orderRepository-&gt;nextIdentity();
    $order = new Order(
    $orderId,
    $ebook-&gt;id(),
    $emailAddress,
    $orderQuantity,
    $ebook-&gt;price(),
    $orderAmount
    );
    $this-&gt;orderRepository-&gt;save($order);
    return $orderId;
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0112_original/original_page.png" alt="Original Page 112">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<p>
    Listing 4.6 نشان می‌دهد که چگونه می‌توان از <code>service</code> جدید در داخل <code>controller</code> استفاده کرد.
  </p>
<p>
<em>Listing 4.6.</em> <code>orderEbookAction()</code> از <code>EbookOrderService</code> استفاده می‌کند.
  </p>
<pre><code class="language-php">
    public function orderEbookAction(Request $request): Response
    {
    $ebookId = (int)$request-&gt;get('ebook_id');
    $orderQuantity = (int)$request-&gt;get('quantity');
    $emailAddress = $request-&gt;get('email_address');
    $orderId = $this-&gt;container-&gt;get('ebook_order_service')
    -&gt;create(
    $ebookId,
    $orderQuantity,
    $emailAddress
    );
    // ...
    return new Response(/* ... */);
    }
  </code></pre>
<p>
    از آنجایی که ما واقعاً دیگر نیازی نداریم که <code>data</code> ورودی در یک <code>variable</code> باشد، باید یک <code>refactoring</code> سریع <code>Inline Variable</code><sup>4</sup> انجام دهیم:
  </p>
<pre><code class="language-php">
    $orderId = $this-&gt;container-&gt;get('ebook_order_service')
    -&gt;create(
    (int)$request-&gt;get('ebook_id'),
    (int)$request-&gt;get('quantity'),
    $request-&gt;get('email_address')
    );
  </code></pre>
<p>
    ما به نقطه‌ای رسیده‌ایم که در آن <code>EbookOrderService</code> می‌تواند توسط هر <code>client</code> که قادر به ارائه <code>strings</code> و اعداد صحیح مورد نیاز است، استفاده شود. اکنون می‌توانید یک <code>API endpoint</code> بسازید که یک بدنه درخواست <code>JSON</code> را می‌پذیرد، آن را رمزگشایی می‌کند و <code>EbookOrderService</code> را با استفاده از <code>data</code> آن فراخوانی می‌کند.
    یا شما به همان اندازه می‌توانید به راحتی یک ابزار <code>command-line</code> ایجاد کنید که تعدادی از آرگومان‌ها را می‌پذیرد و آن را به <code>EbookOrderService</code> منتقل می‌کند، همانطور که در Listing 4.7 (شکل 4.1) نشان داده شده است.
    تا زمانی که <code>client</code> بتواند <code>data</code> اولیه را ارائه دهد، می‌تواند <code>use case</code> را فراخوانی کند.
  </p>
<p>
<em>Listing 4.7.</em> استفاده مجدد آسان از همان <code>EbookOrderService</code> در یک <code>command-line application</code>.
  </p>
<p>
<sup>4</sup>https://advwebapparch.com/inline-variable
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0113_original/original_page.png" alt="Original Page 113">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<p>
    Figure 4.1. انواع مختلف <code>clients</code> می‌توانند <code>use case</code> یکسانی را فراخوانی کنند.
  </p>
<pre><code class="language-php">
    final class CreateOrderCommand extends Command
    {
    // ...
    protected function execute(
    InputInterface $input,
    OutputInterface $output
    ): int {
    $orderId = $this-&gt;container-&gt;get('ebook_order_service')
    -&gt;create(
    (int)$input-&gt;getArgument('ebook_id'),
    (int)$input-&gt;getArgument('quantity'),
    $input-&gt;getArgument('email_address')
    );
    $output-&gt;writeln(
    sprintf(
    '<success>Created a new order with ID %s</success>',
    $orderId-&gt;asString()
    )
    );
    return 0;
    }
  </code></pre>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 114" src="page_0114/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0114_original/original_page.png" alt="Original Page 114">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<h4>4.4. Introducing a parameter object</h4>
<p>
    ما یک بخش خوب از کد اصلی را از کد <code>infrastructure</code> که در اصل با آن مخلوط شده بود جدا کردیم، اما یک کار دیگر باقی مانده است. تعداد <code>method parameters</code> از یک <code>service</code> مانند موردی که قبلاً استخراج کردیم، ممکن است به سرعت از کنترل خارج شود.
    علاوه بر یک <code>email address</code>، شما همچنین ممکن است بخواهید نام خریدار را ثبت کنید، یا ممکن است بخواهید سفارش‌ها را به ارز دیگری دریافت کنید. برای ساده نگه داشتن <code>method signature</code> یک <code>application service</code>، یک <code>refactoring</code> خوب دیگر وجود دارد که می‌توانیم انجام دهیم، که <code>Introduce Parameter Object</code><sup>5</sup> نامیده می‌شود.
    نتیجه یک <code>object</code> خواهد بود که تمام <code>data</code> ورودی را برای این <code>use case</code> به عنوان یک مقدار واحد نگه می‌دارد. منطقی است که این <code>object</code> را به نام هدف آن نامگذاری کنید. شما می‌خواهید با آن "یک سفارش ایجاد کنید"، بنابراین بیایید آن را <code>CreateOrder</code> بنامیم (به Listing 4.8 مراجعه کنید).
    به چنین <code>object</code>ی اغلب یک <code>Command object</code> گفته می‌شود. این هیچ ربطی به <code>command-line applications</code> ندارد. به آن <code>command</code> می‌گویند زیرا <code>object</code> نشان دهنده قصد <code>user</code> است: چیزی که <code>user</code> می‌خواهد <code>application</code> انجام دهد.
  </p>
<p>
<em>Listing 4.8.</em> <code>The CreateOrder object</code> تمام <code>data</code> مورد نیاز برای ایجاد یک <code>order</code> را نگه می‌دارد.
  </p>
<pre><code class="language-php">
    final class CreateOrder
    {
    private int $ebookId;
    private int $orderQuantity;
    private string $emailAddress;
    public function __construct(
    int $ebookId,
    int $orderQuantity,
    string $emailAddress
    ) {
    $this-&gt;ebookId = $ebookId;
    $this-&gt;orderQuantity = $orderQuantity;
    $this-&gt;emailAddress = $emailAddress;
    }
    public function ebookId(): int
    {
  </code></pre>
<p>
<sup>5</sup>https://advwebapparch.com/introduce-parameter-object
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0115_original/original_page.png" alt="Original Page 115">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<pre><code class="language-php">
    public function ebookId(): int
    {
    return $this-&gt;ebookId;
    }
    public function orderQuantity(): int
    {
    return $this-&gt;orderQuantity;
    }
    public function emailAddress(): string
    {
    return $this-&gt;emailAddress;
    }
  </code></pre>
<p>
<code>service</code> باید اصلاح شود تا یک نمونه از کلاس <code>CreateOrder</code> جدید را بپذیرد (به Listing 4.9 مراجعه کنید). هر زمان که <code>service</code> به <code>input data</code> نیاز دارد، باید آن را از <code>object</code> <code>CreateOrder</code> واکشی کند.
  </p>
<p>
<em>Listing 4.9.</em> یک <code>object</code> <code>CreateOrder</code> باید به عنوان یک آرگومان <code>method</code> به <code>EbookOrderService</code> منتقل شود.
  </p>
<pre><code class="language-php">
    final class EbookOrderService
    {
    // ...
    public function create(CreateOrder $createOrder): OrderId
    {
    $ebook = $this-&gt;ebookRepository-&gt;getById(
    $createOrder-&gt;ebookId()
    );
    $orderAmount = $ebook-&gt;price()
    -&gt;multipliedBy($createOrder-&gt;orderQuantity());
    // ...
    $order = new Order(
    $orderId,
    $ebook-&gt;id(),
    $createOrder-&gt;emailAddress(),
    $createOrder-&gt;orderQuantity(),
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0116_original/original_page.png" alt="Original Page 116">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<pre><code class="language-php">
    $ebook-&gt;price(),
    $orderAmount
    );
    // ...
    return new Response(/* ... */);
    }
    }
    Finally, any client that uses the EbookOrderService has to be updated too.
    From now on, they need to prepare a CreateOrder instance and pass it to the
    service. See Listing 4.10 for what this looks like in the controller action.
    Listing 4.10. orderEbookAction() instantiates and populates a CreateOrder
    object and passes it to EbookOrderService.
    public function orderEbookAction(Request $request): Response
    {
    $createOrder = new CreateOrder(
    (int)$request-&gt;get('ebook_id'),
    (int)$request-&gt;get('quantity'),
    $request-&gt;get('email_address')
    );
    $orderId = $this-&gt;container-&gt;get('ebook_order_service')
    -&gt;create($createOrder);
    // ...
    return new Response(/* ... */);
    }
  </code></pre>
<p>
    و ما باید این <code>application service</code> را نیز به‌روزرسانی کنیم. از این به بعد، آنها باید یک نمونه <code>CreateOrder</code> را آماده کرده و آن را به <code>service</code> منتقل کنند.
    Listing 4.10 نشان می‌دهد که این در <code>controller action</code> چگونه به نظر می‌رسد.
  </p>
<h4>4.5. Dealing with multiple steps</h4>
<p>
    ما با موفقیت یک تکه از کد جدا شده را از <code>controller</code> به <code>application service</code> خود منتقل کردیم. اما معمولاً انجام این کار به این آسانی نیست.
    در <code>projects</code>های قدیمی شما <code>controller actions</code> را پیدا خواهید کرد که از چندین صد (اگر نه هزاران) خط تشکیل شده‌اند. اگر خوش شانس باشید، این <code>methods</code> مانند <code>scripts</code> خوانده می‌شوند: ابتدا این کار را انجام دهید، سپس آن کار را انجام دهید، سپس این کار دیگر را انجام دهید و غیره.
    اگر اینطور باشد، ممکن است بتوانید این مراحل را استخراج کرده و آنها را در کلاس‌های خود قرار دهید تا قابل نگهداری و شاید حتی قابل آزمایش شوند.
    گاهی اوقات اینطور نیست
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0117_original/original_page.png" alt="Original Page 117">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<p>
    آسان است که مراحل متمایز را در این <code>methods</code> تشخیص دهیم، و شما باید قسمت‌هایی از کد را دوباره مرتب و بازنویسی کنید تا مراحل را روشن‌تر کنید.
  </p>
<p>
    در مورد <code>orderEbookAction()</code> مراحل کاملاً قابل تشخیص هستند. ما اولین مرحله (ذخیره سفارش) را استخراج کردیم، اکنون بیایید به مرحله دوم نگاهی بیندازیم: ارسال یک <code>email</code> تأیید سفارش (به Listing 4.11 مراجعه کنید).
  </p>
<p>
<em>Listing 4.11.</em> پس از ایجاد یک سفارش جدید، ما همچنین یک <code>email</code> تأیید را ارسال می‌کنیم.
  </p>
<pre><code class="language-php">
    public function orderEbookAction(Request $request): Response
    {
    // ...
    $orderId = $this-&gt;container-&gt;get('ebook_order_service')
    -&gt;create($createOrder);
    $this-&gt;container-&gt;get('session')-&gt;set(
    'currentOrderId',
    $orderId-&gt;asString()
    );
    $message = (new Swift_Message('Your Order'))
    -&gt;setFrom($this-&gt;container-&gt;getParameter('system_email_address'))
    -&gt;setTo($request-&gt;request-&gt;get('email_address'))
    -&gt;setBody(
    $this-&gt;container-&gt;get('twig')
    -&gt;render('email/order_confirmation.html.twig')
    );
    $this-&gt;container-&gt;get('mailer')-&gt;send($message);
    return new Response(/* ... */);
    }
  </code></pre>
<p>
    آیا ما باید این کد را در <code>controller</code> نگه داریم؟ خیر، زیرا هر زمان که کسی یک سفارش ایجاد می‌کند، آنها نیز باید یک <code>email</code> تأیید دریافت کنند. تنها راه برای ایجاد یک سفارش، فراخوانی <code>EbookOrderService::create()</code> است.
    اما کد برای ارسال <code>email</code> در orderEbookAction() قرار دارد. بنابراین اگر تا به حال مکان دومی وجود داشته باشد که <code>EbookOrderService::create()</code> فراخوانی شود، مشتری آن <code>email</code> را دریافت نخواهد کرد.
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0118_original/original_page.png" alt="Original Page 118">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<p>
    آیا ما باید آن را به جای <code>EbookOrderService</code> منتقل کنیم؟ به این ترتیب، <code>service</code> ابتدا می‌تواند <code>order</code> را ایجاد کند، و سپس <code>email</code> را ارسال کند.
    Listing 4.12 نتیجه انتقال کد به <code>application service</code> را نشان می‌دهد.
  </p>
<p>
<em>Listing 4.12.</em> ارسال <code>email</code> در داخل <code>application service</code>.
  </p>
<pre><code class="language-php">
    final class EbookOrderService
    {
    private EbookRepository $ebookRepository;
    private OrderRepository $orderRepository;
    private string $systemEmailAddress;
    private Environment $twig;
    private Swift_Mailer $mailer;
    public function __construct(
    EbookRepository $ebookRepository,
    OrderRepository $orderRepository,
    string $systemEmailAddress,
    Environment $twig,
    Swift_Mailer $mailer
    ) {
    $this-&gt;ebookRepository = $ebookRepository;
    $this-&gt;orderRepository = $orderRepository;
    $this-&gt;systemEmailAddress = $systemEmailAddress;
    $this-&gt;twig = $twig;
    $this-&gt;mailer = $mailer;
    }
    public function create(CreateOrder $createOrder): OrderId
    {
    // Step 1: Create the Order entity, save it
    // ...
    // Step 2: Send the confirmation email
    $message = (new Swift_Message('Order ' . $orderId-&gt;asString()))
    -&gt;setFrom($this-&gt;systemEmailAddress)
    -&gt;setTo($createOrder-&gt;emailAddress())
    -&gt;setBody(
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0119_original/original_page.png" alt="Original Page 119">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Application services</h3>
<p>یکی از مزایای انتقال کد به یک <strong>service</strong> این است که وابستگی‌ها اکنون واضح‌تر هستند زیرا <strong>service</strong> از <strong>constructor injection</strong> استفاده می‌کند (اطلاعات بیشتر در این مورد در فصل 5). اما در عین حال دیدن تمام این وابستگی‌ها مرا نگران می‌کند. من نمی‌خواهم که <strong>application service</strong> من به تمام این فناوری خاص وابسته باشد. کلاس <strong>Twig Environment</strong> و <strong>template</strong>، کلاس‌های <strong>Swift_Mailer</strong> و <strong>Swift_Message</strong>، آدرس ایمیل سیستم. این موارد به داخل کد بیشتر <strong>domain-oriented</strong> از <strong>application service</strong> تعلق ندارند.</p>
<p>اما ما هنوز هم می‌خواهیم آن ایمیل را ارسال کنیم. چه کاری می‌توانیم انجام دهیم تا تعداد وابستگی‌ها و همچنین خاص بودن آنها را کاهش دهیم؟ ما باید یک بار دیگر از قدرت <strong>abstraction</strong> استفاده کنیم. به جای استفاده مستقیم از <strong>Twig</strong> و <strong>SwiftMailer</strong> در داخل <strong>application service</strong>، ما باید اجازه دهیم <strong>service</strong> با یک <strong>interface</strong> صحبت کند، مانند <strong>interface</strong> از نوع <code>SendOrderConfirmationEmail</code> در <strong>Listing</strong> 4.13.</p>
<p><strong>Listing</strong> 4.13. An <strong>abstraction</strong> for sending order confirmation emails.</p>
<pre><code class="language-php">
interface SendOrderConfirmationEmail
{
    public function send(OrderId $orderId, string $emailAddress): void;
}
</code></pre>
<p>این <strong>interface</strong> مانند تضمینی است که در زمان اجرا، امکان ارسال یک ایمیل واقعی وجود خواهد داشت. و اگر هر <strong>service</strong> بخواهد این کار را انجام دهد، باید به این <strong>interface</strong> وابسته باشد، بنابراین نیازی نیست نگران جزئیات ارسال آن ایمیل باشد.</p>
<p>اکنون اجازه دهید <strong>application service</strong> را اصلاح کنیم تا از این <strong>interface</strong> جدید به جای وابستگی‌های مشخصی که قبلاً استفاده می‌کرد، استفاده کند. <strong>Listing</strong> 4.14 نشان می‌دهد که چگونه این کار کد را در <strong>application service</strong> بسیار ساده می‌کند. یک مزیت اضافه این است که اکنون تشخیص اینکه ارسال ایمیل تأییدیه، گام دوم در فرآیند ایجاد یک سفارش است، آسان است. شما دیگر مجبور نیستید تمام خطوط کد را که با <strong>Twig</strong> و <strong>SwiftMailer</strong> سروکار دارند بخوانید تا بفهمید چه اتفاقی می‌افتد.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0120_original/original_page.png" alt="Original Page 120">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<p>
    Listing 4.14 نشان می‌دهد که <code>service</code> جدید به یک <code>abstraction</code> وابسته است.
  </p>
<pre><code class="language-php">
    final class EbookOrderService
    {
    // ...
    private SendOrderConfirmationEmail $sendConfirmationEmail;
    public function __construct(
    // ...
    SendOrderConfirmationEmail $sendConfirmationEmail
    ) {
    // ...
    $this-&gt;sendConfirmationEmail = $sendConfirmationEmail;
    }
    public function create(CreateOrder $createOrder): OrderId
    {
    // Create the Order entity, save it
    $this-&gt;sendConfirmationEmail-&gt;send(
    $orderId,
    $createOrder-&gt;emailAddress()
    );
  </code></pre>
<p>
    اغلب، زمانی که من یک <code>interface</code> را معرفی می‌کنم تا جزئیات <code>implementation</code> سطح پایین‌تر را از دید خارج کنم، فراموش می‌کنم که یک <code>implementation</code> واقعی از آن <code>interface</code> ارائه کنم.
    با دانستن اینکه <code>interface</code> <code>SendOrderConfirmationEmail</code> وجود دارد، من اعتماد دارم که می‌توان از آن استفاده کرد. برای من این واقعاً کاهش‌دهنده استرس است.
    من می‌توانم تمام نگرانی‌های خود را در مورد استفاده صحیح از <code>mailer API</code> به تعویق بیندازم، و می‌توانم این جزئیات نامرتب را از دید خارج کنم.
    من می‌دانم که همه چیز در لحظه‌ای که این کد در <code>production</code> اجرا می‌شود، خوب خواهد بود.
  </p>
<p>
    با این حال، در مقطعی شما مجبور هستید <code>emails</code> واقعی را ارسال کنید، بنابراین شما نمی‌توانید این کار را به طور نامحدود به تعویق بیندازید. بیایید این کار را انجام دهیم و یک <code>implementation</code> برای <code>interface</code> ارائه دهیم (به Listing 4.15 مراجعه کنید).
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0121_original/original_page.png" alt="Original Page 121">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>4. Application services</strong></h3>
<p>
<em>Listing 4.15.</em> یک <code>implementation</code> برای <code>SendOrderConfirmationEmail interface</code>.
  </p>
<pre><code class="language-php">
    final class SendOrderConfirmationEmailWithSwiftMailer
    implements SendOrderConfirmationEmail
    {
    private string $systemEmailAddress;
    private Environment $twig;
    private Swift_Mailer $mailer;
    public function __construct(
    string $systemEmailAddress,
    Environment $twig,
    Swift_Mailer $mailer
    ) {
    $this-&gt;systemEmailAddress = $systemEmailAddress;
    $this-&gt;twig = $twig;
    $this-&gt;mailer = $mailer;
    }
    public function send(OrderId $orderId, string $emailAddress): void
    {
    $message = (new Swift_Message('Order ' . $orderId-&gt;asString()))
    -&gt;setFrom($this-&gt;systemEmailAddress)
    -&gt;setTo($emailAddress)
    -&gt;setBody(
    $this-&gt;twig-&gt;render('email/order_confirmation.html.twig')
    );
    $this-&gt;mailer-&gt;send($message);
    }
  </code></pre>
<p>
    در عمل، اکثر <code>services</code>هایی که <code>emails</code> ارسال می‌کنند، به اطلاعات بیشتری از <code>ID</code> و آدرس <code>email</code> گیرنده نیاز خواهند داشت. در این صورت شما باید یک <code>read model</code> معرفی کنید که اطلاعات مورد نیاز را در یک مرحله واکشی می‌کند.
    <code>read model</code> باید <code>data</code> را در قالبی آماده کند که هنگام <code>rendering</code> بدنه <code>email</code> مفید باشد. با توجه به اینکه قرار است از چنین <code>read model</code>ی برای اهداف <code>presentation</code> استفاده شود، در واقع یک <code>view model</code> است.
  </p>
<p>
    اکنون ما دو مرحله در داخل <code>application service</code> داریم:
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0122_original/original_page.png" alt="Original Page 122">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Application services</h3>
<p>1. ایجاد سفارش و ذخیره آن</p>
<p>2. ارسال ایمیل تأیید</p>
<p>شما می‌توانید بگویید که گام اول در واقع از دو گام دیگر تشکیل شده است، اما ایجاد سفارش بدون ذخیره آن فایده‌ای ندارد، شما نمی‌توانید سفارشی را بدون ایجاد آن ذخیره کنید. بنابراین این واقعاً یک گام واحد است. غیر معمول نیست که یک سناریوی <strong>use case</strong> شامل چندین گام باشد، اما من همچنین متوجه شدم که اگر <strong>application service</strong> فقط گام اول را انجام دهد و گام‌های دیگر را به <strong>services</strong> دیگر بسپارد، بهتر عمل می‌کند. در مورد ما، <strong>application service</strong> فقط سفارش را ایجاد و ذخیره می‌کند. سپس یک <strong>event</strong> تولید می‌کند که نشان می‌دهد سفارش ایجاد شده است. سایر <strong>services</strong> می‌توانند به آن <strong>event</strong> پاسخ دهند، به عنوان مثال با ارسال ایمیل تأیید سفارش. ما تنظیمات را قبلاً در بخش 3.3.2 دیده‌ایم، و جزئیات الگو را در بخش 11.5 مورد بحث قرار خواهیم داد. به عنوان یک پیش‌نمایش، <strong>Listing</strong> 4.16 به شما ایده‌ای از چگونگی عملکرد این موضوع می‌دهد.</p>
<p>شکل 4.2 روابط بین این <strong>objects</strong> را در یک نمای واحد نشان می‌دهد. توجه داشته باشید که <strong>EbookOrderService</strong> دیگر مسئول ارسال ایمیل تأیید نیست. <strong>event subscriber</strong> این کار را انجام می‌دهد، و تنها کاری که <strong>EbookOrderService</strong> باید انجام دهد این است که <strong>domain events</strong> ثبت شده را به <strong>EventDispatcher service</strong> ارسال کند.</p>
<p><strong>Listing</strong> 4.16. Sending the email after receiving a <strong>OrderWasCreated event</strong>.</p>
<pre><code class="language-php">
// This is a domain event:
final class OrderWasCreated
{
    private OrderId $orderId;
    private string $emailAddress;

    public function __construct(OrderId $orderId, string $emailAddress)
    {
        $this-&gt;orderId = $orderId;
        $this-&gt;emailAddress = $emailAddress;
    }

    public function orderId(): OrderId
    {
        return $this-&gt;orderId;
    }
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0123_original/original_page.png" alt="Original Page 123">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Application services</h3>
<pre><code class="language-php">
public function emailAddress(): string
{
    return $this-&gt;emailAddress;
}
</code></pre>
<p><strong>فیلدها</strong> و <strong>متدهای</strong> <strong>OrderWasCreated event</strong> را نشان می‌دهد. متد <code>emailAddress()</code> آدرس ایمیل را برمی‌گرداند. کلاس <code>Order</code>، کلاس <strong>Aggregate</strong> که ما در حال تغییر آن هستیم را نشان می‌دهد. متدهای <code>releaseEvents()</code> و <code>__construct()</code> را نشان می‌دهد.</p>
<pre><code class="language-php">
final class Order
{
    /**
     * @var object[]
     */
    private array $events;

    public function __construct(
        OrderId $orderId,
        string $emailAddress
        // ...
    ) {
        // ...
        // When we create an order, a domain event will be "recorded"
        $this-&gt;events[] = new OrderWasCreated($orderId, $emailAddress);
    }

    public function releaseEvents(): array
    {
        return $this-&gt;events;
    }
}
</code></pre>
<p>هنگامی که یک <strong>order</strong> را ایجاد می‌کنیم، یک <strong>domain event</strong> "ثبت" می‌شود. متد <code>releaseEvents()</code> همه <strong>events</strong> ثبت شده را برمی‌گرداند، که متعاقباً توسط <strong>EventDispatcher</strong> ارسال می‌شوند. در نهایت، ما کلاس <code>EbookOrderService</code> را داریم، که <strong>application service</strong> ما است.</p>
<pre><code class="language-php">
final class EbookOrderService
{
    // ...
    private EventDispatcher $eventDispatcher;

    public function __construct(
        // ...
        EventDispatcher $eventDispatcher
    ) {
        // ...
</code></pre>
<p>این کلاس از <strong>Dependency Injection</strong> برای تزریق <code>EventDispatcher</code> استفاده می‌کند.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0124_original/original_page.png" alt="Original Page 124">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Application services</h3>
<pre><code class="language-php">
$this-&gt;eventDispatcher = $eventDispatcher;
}
public function create(CreateOrder $command): OrderId
{
    // ...
    $order = new Order(/* ... */);
    // First, save the Order
    // Then dispatch the events that were recorded inside the event:
    $this-&gt;eventDispatcher-&gt;dispatchAll($order-&gt;releaseEvents());
    return $orderId;
}
</code></pre>
<p>متد <code>create()</code> را نشان می‌دهد. این متد یک <code>Order</code> ایجاد می‌کند، و سپس همه <strong>events</strong> را که در داخل <strong>event</strong> ثبت شده‌اند، ارسال می‌کند.</p>
<p>در نهایت، <strong>Listing</strong> 4.17 یک <strong>event subscriber</strong> را نشان می‌دهد که به <strong>event</strong> از نوع <code>OrderWasCreated</code> گوش می‌دهد. این <strong>subscriber</strong> مسئول ارسال ایمیل تأیید است.</p>
<pre><code class="language-php">
/*
* This is an event subscriber, which should be registered as a
* subscriber for the OrderWasCreated event:
*/
final class SendEmail
{
    private SendOrderConfirmationEmail $sendConfirmationEmail;

    public function __construct(
        SendOrderConfirmationEmail $sendOrderConfirmationEmail
    ) {
        $this-&gt;sendConfirmationEmail = $sendOrderConfirmationEmail;
    }

    /*
     * When the event dispatcher receives an OrderWasCreated event
     * it will call this method:
     */
    public function whenOrderWasCreated(OrderWasCreated $event): void
    {
        $this-&gt;sendConfirmationEmail
</code></pre>
<p>متد <code>whenOrderWasCreated()</code> زمانی فراخوانی می‌شود که <strong>event dispatcher</strong> یک <strong>event</strong> از نوع <code>OrderWasCreated</code> دریافت کند.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0125_original/original_page.png" alt="Original Page 125">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Application services</h3>
<pre><code class="language-php">
-&gt;send($event-&gt;orderId(), $event-&gt;emailAddress());
}
</code></pre>
<p>شکل 4.2. مجموعه <strong>objects</strong> حاصل و تعاملات آنها.</p>
<h4> 4.6. Summary</h4>
<p>ما این فصل را با یک <strong>controller</strong> شروع کردیم که <strong>use case</strong> سفارش یک کتاب الکترونیکی را نشان می‌داد. تنها راهی که این <strong>use case</strong> می‌تواند فراخوانی شود، از طریق یک درخواست فرم وب بود. برای اینکه <strong>use case</strong> قابل استفاده مجدد باشد، ابتدا وابستگی‌های خاص وب مانند <code>Request</code>، <code>Response</code> و <strong>object</strong> از نوع <code>Session</code> را حذف کردیم. پس از آن، کد فقط به داده‌های ورودی از نوع <strong>primitive-type</strong> و چند وابستگی <strong>service</strong> متکی بود. ما کد مستقل از زیرساخت را به کلاس خود منتقل کردیم، و <strong>use case</strong> را به طور موثر قابل استفاده مجدد کردیم. با معرفی این کلاس، که به آن یک <strong>Application service</strong> گفته می‌شود، ما این امکان را فراهم کردیم که هر نوع <strong>client</strong> بتواند داده‌های ورودی لازم را ارائه دهد و از این <strong>use case</strong> استفاده کند. در نهایت، ما از <strong>refactoring</strong> از نوع <code>Introduce Parameter Object</code> برای ترکیب تمام <strong>primitive-type</strong></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 126" src="page_0126/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0126_original/original_page.png" alt="Original Page 126">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Application services</h3>
<p><strong>parameters</strong> از <strong>application service</strong> را به یک کلاس واحد ترکیب کرد. به این کلاس، کلاس <strong>Command</strong> گفته می‌شود.</p>
<p>پس از <strong>decoupling</strong> گام اصلی <strong>use case</strong>، ما همچنین می‌خواستیم گام دوم <strong>use case</strong> را به <strong>application service</strong> منتقل کنیم. به جای انتقال مستقیم کد برای ارسال ایمیل تأیید سفارش، ما یک <strong>abstraction</strong> مناسب معرفی کردیم. این به ما اجازه داد تا جزئیات پیاده‌سازی را از دید خارج کنیم و یک نمایش واضح از این گام در داخل <strong>application service</strong> داشته باشیم. ما همچنین به یک راه‌حل عمومی‌تر برای رسیدگی به مراحل متعدد <strong>use case</strong> که متکی بر <strong>domain events</strong> و ارسال آنها به <strong>event subscribers</strong> از طریق یک <strong>event dispatcher service</strong> است، نگاه کردیم.</p>
<p><strong>Exercises</strong></p>
<p>1. چه چیزی یک <strong>application service</strong> را برای <strong>clients</strong> مختلف قابل استفاده مجدد می‌کند؟</p>
<ol>
<li>ارائه داده‌های ورودی به گونه‌ای که آن را به یک مکانیزم تحویل خاص گره نزند</li>
<li>ترکیب تمام داده‌های ورودی در یک <strong>object</strong> از نوع <strong>Parameter</strong></li>
</ol>
<p>2. مراحل <strong>refactoring</strong> را برای <strong>decoupling</strong> یک <strong>use case</strong> به ترتیب صحیح قرار دهید:</p>
<ol>
<li><strong>Extract Class</strong></li>
<li><strong>Introduce Parameter Object</strong></li>
<li><strong>Extract Variable</strong></li>
<li><strong>Inline Variable</strong></li>
</ol>
<p>3. حداقل چهار نمونه دیگر از <strong>clients</strong> اضافه کنید که نمی‌خواهند یک <strong>use case application</strong> را با ارسال یک فرم وب فراخوانی کنند.</p>
<ol>
<li>یک <strong>endpoint API-JSON HTTP</strong></li>
<li>یک <strong>command</strong> کنسول</li>
<li>...</li>
</ol>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0127_original/original_page.png" alt="Original Page 127">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Application services</h3>
<p>a. پاسخ صحیح: 1. این امر <strong>clients</strong> مختلف را قادر می‌سازد تا از <strong>service</strong> استفاده کنند. ترکیب داده‌های ورودی در یک <strong>object Parameter</strong> اختیاری است.</p>
<p>b. پاسخ صحیح: 3-1-4-2، اگرچه 4 و 2 را می‌توان در صورت تمایل جابجا کرد.</p>
<p>c. چند نمونه: یک <strong>cron job</strong> که روزانه ایمیل ارسال می‌کند، یک مصرف‌کننده پیام که پیامی را از یک صف برمی‌دارد و آن را به عنوان یک <strong>command</strong> پردازش می‌کند، یک <strong>application SOAP</strong> که <strong>objects SOAP</strong> را به عنوان <strong>commands</strong> پردازش می‌کند، یک فرآیند طولانی‌مدت که به طور منظم یک <strong>server FTP</strong> را برای فایل‌های آپلود شده‌ای که باید <strong>imported</strong> شوند، نظرسنجی می‌کند. یکی دیگر از <strong>client</strong> های بسیار مهم یک <strong>use case</strong>، <strong>test suite</strong> خواهد بود. ما در فصل 14 به این موضوع باز خواهیم گشت.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0128_original/original_page.png" alt="Original Page 128">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p>این فصل شامل موارد زیر است:</p>
<ul>
<li>بازنویسی فراخوانی‌های <strong>service</strong> و <strong>configuration locator</strong></li>
<li>به وابستگی‌هایی که به عنوان آرگومان‌های <strong>constructor</strong> تزریق شده‌اند</li>
<li>تعریف <strong>services</strong> <strong>object-oriented</strong> "خالص"، که</li>
<li>چیزی بیش از ساخت و فراخوانی متد نیاز ندارند</li>
<li>قرار دادن <strong>composition root</strong> نزدیک‌تر به نقطه ورود <strong>application</strong></li>
</ul>
<h4> 5.1. From service location to explicit dependencies</h4>
<p>در فصل 4 ما یک <strong>application service</strong> را از یک <strong>web controller</strong> استخراج کردیم. هنگامی که کلاس را ایجاد کردیم، وابستگی‌های آن را نیز صریح‌تر کردیم. وقتی کد هنوز در داخل <strong>controller</strong> بود، ما مجبور بودیم <code>OrderRepository</code> را از <strong>service container</strong> با استفاده از <code>$this-&gt;container-&gt;get('order_repository')</code> واکشی کنیم.</p>
<p>هنگامی که منطق اصلی را به کلاس <code>EbookOrderService</code> منتقل کردیم، <code>OrderRepository</code> به یک آرگومان <strong>constructor</strong> مناسب تبدیل شد:</p>
<pre><code class="language-php">
// Inside the controller:
$orderRepository = $this-&gt;container-&gt;get('order_repository');
// In the application service:
final class EbookOrderService
{
    private OrderRepository $orderRepository;

    public function __construct(
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0129_original/original_page.png" alt="Original Page 129">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<pre><code class="language-php">
// ...
    OrderRepository $orderRepository
) {
    // ...
    $this-&gt;orderRepository = $orderRepository;
}
</code></pre>
<p>ما می‌توانستیم خود <strong>service container</strong> را تزریق کنیم، که این امر انتقال کد را حتی آسان‌تر می‌کرد. اگر این کار را انجام می‌دادیم، <strong>application service</strong> به <code>ContainerInterface</code> وابسته می‌شد:</p>
<pre><code class="language-php">
use Symfony\Component\DependencyInjection\ContainerInterface;

final class EbookOrderService
{
    private ContainerInterface $container;

    public function __construct(ContainerInterface $container)
    {
        $this-&gt;container = $container;
    }

    public function createOrder(/* ... */): OrderId
    {
        // ...
        $orderRepository = $this-&gt;container-&gt;get('order_repository');
        // ...
    }
}
</code></pre>
<p>معرفی یک وابستگی به کد <strong>framework</strong> در داخل کد اصلی، چیز جالبی نیست. اگرچه قانون اول را برای کد اصلی نقض نمی‌کند، زیرا هیچ وابستگی زمان اجرا به سیستم‌های خارجی وجود ندارد. با این حال، تا حدودی با قانون دوم مغایرت دارد. با تزریق <code>ContainerInterface</code> عمومی، ما اکنون به یک <strong>context</strong> خاص برای اجرای <strong>service</strong> خود نیاز داریم. <strong>container</strong> باید در مورد تمام وابستگی‌هایی که <strong>application service</strong> ممکن است به آنها نیاز داشته باشد، بداند، و بداند که چگونه هر یک از آنها را در هر زمان ایجاد کند. اگر ما</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0130_original/original_page.png" alt="Original Page 130">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p><strong>inject</strong> <strong>services</strong> واقعی به جای <strong>service container</strong>، <strong>application service</strong> فقط به <strong>interfaces</strong> و کلاس‌های اصلی ما متصل می‌شود. هر <strong>client</strong> که بتواند پیاده‌سازی‌هایی را برای وابستگی‌های مورد نیاز ارائه دهد، می‌تواند <strong>service</strong> را نمونه‌سازی کرده و متدها را روی آن فراخوانی کند. بنابراین تزریق وابستگی‌های واقعی یک بخش مهم از قابل استفاده کردن <strong>service</strong> در <strong>contexts</strong> مختلف، توسط <strong>clients</strong> مختلف است.</p>
<h4> 5.2. Depending on global state</h4>
<p>بیایید به موقعیت مشابهی نگاهی بیندازیم که در آن <strong>service container</strong> تزریق نمی‌شود، اما وابستگی‌ها را می‌توان در هر نقطه از کد، بنا به درخواست، نمونه‌سازی کرد. <strong>Listing</strong> 5.1 مثالی را با استفاده از <strong>helper functions</strong>1 از <strong>framework Laravel</strong> نشان می‌دهد. آیا این کد می‌تواند در هر <strong>context</strong> اجرا شود؟ چگونه به زیرساخت اطراف خود متصل می‌شود؟</p>
<p><strong>Listing</strong> 5.1. کدی که از فراخوانی‌های <strong>static</strong> برای بارگذاری وابستگی‌ها و <strong>configuration</strong> استفاده می‌کند.</p>
<pre><code class="language-php">
final class SendIpConfirmationEmail
{
    public function send(): void
    {
        $message = EmailMessage::create()
            -&gt;to(Auth::user()-&gt;email())
            -&gt;from(
                config('mail.default_sender')
            )
            -&gt;text(
                trans(
                    'Add your :ip to the whitelist',
                    [
                        'ip' =&gt; request()-&gt;ip()
                    ]
                )
            );
</code></pre>
<p>1 https://advwebapparch.com/laravel-helper-functions</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0131_original/original_page.png" alt="Original Page 131">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<pre><code class="language-php">
resolve(Mailer::class)-&gt;send($message);
}
</code></pre>
<p>قبل از اینکه بتوانید این کد را اجرا کنید، باید مطمئن شوید که تابع <code>resolve()</code> در واقع می‌تواند، یعنی <strong>instantiate</strong> کند، یک <strong>service Mailer</strong>. شما همچنین باید یک مقدار <strong>configuration</strong> برای <code>mail.default_sender</code> تنظیم کنید، در غیر این صورت فراخوانی <code>config()</code> با شکست مواجه خواهد شد. یک مشکل بزرگتر این است که این کد فرض می‌کند یک <strong>session</strong> با یک کاربر وارد شده وجود دارد، و اینکه این کد به عنوان بخشی از یک درخواست <strong>HTTP</strong> اجرا می‌شود که یک آدرس <strong>IP client</strong> شناخته شده دارد. به طور معمول، <strong>framework</strong> با آماده‌سازی <strong>service container</strong> و بارگذاری <strong>configuration</strong> قبل از استفاده از <strong>service</strong> از نوع <code>SendIpConfirmationEmail</code>، از همه اینها مراقبت می‌کند. اما این واقعیت که این آماده‌سازی‌ها باید قبل از آن لحظه اتفاق بیفتد، به این معنی است که این کد به اندازه‌ای که ما می‌خواهیم قابل حمل نیست. ما نمی‌توانیم فقط این <strong>service</strong> را <strong>instantiate</strong> کنیم و شروع به فراخوانی متدهای آن کنیم. علاوه بر یک وابستگی زمانی به <strong>framework</strong>، خود کد نیز به توابع <strong>global</strong> ارائه شده توسط <strong>framework</strong> متصل است. <code>resolve()</code> و <code>config()</code> توابعی هستند که توسط <strong>Laravel</strong> تعریف شده‌اند، بنابراین ما به این <strong>framework</strong> خاص نیاز داریم تا این کد را اجرا کنیم.2</p>
<p><strong>Laravel</strong> تنها <strong>framework</strong> نیست که این نوع <strong>tooling</strong> را ارائه می‌دهد. بیشتر <strong>frameworks</strong> که تاکنون با آنها کار کرده‌ام، برخی متدهای <strong>global</strong> را ارائه می‌دادند که می‌توانید از آنها برای بازیابی یک <strong>service</strong> یا مقدار <strong>configuration</strong> استفاده کنید. نمونه‌های معروف <code>sfContext</code>3 از <strong>symfony 1</strong> و <code>Zend_Registry</code>4 از <strong>Zend Framework 1</strong> هستند. شما می‌توانید از <code>Zend_Registry</code> برای ذخیره هر مقدار یا <strong>object</strong> استفاده کنید و آن را با استفاده از متد <code>get()</code> <strong>static</strong> آن در سطح <strong>global</strong> در دسترس قرار دهید. <code>sfContext</code> به شما اجازه می‌دهد مقادیر <strong>configuration</strong> یا <strong>services</strong> داخلی را بازیابی کنید، بنابراین اگر می‌خواهید، می‌توانید ایمیل‌ها را از <strong>domain model</strong> خود ارسال کنید.</p>
<p>اگر کد قابل استفاده مجدد مانند یک <strong>library</strong> که در <strong>Packagist5</strong> منتشر می‌کنید، بنویسید، اتصال <strong>framework</strong> عموماً چیز بدی است. این امر مخاطبان بالقوه <strong>library</strong> شما را به افرادی که از همان <strong>framework</strong> شما استفاده می‌کنند، محدود می‌کند. اما کد <strong>application</strong> شما برای استفاده مجدد در خارج از پروژه فعلی شما در نظر گرفته نشده است، بنابراین آیا هنوز هم باید نگران اتصال <strong>framework</strong> باشید؟ به طور خلاصه: بله. وجود دارد</p>
<p>2I’ve written in more detail about Laravel and its service container on my blog: https: //advwebapparch.com/laravel-observations .</p>
<p>3 https://advwebapparch.com/sfcontext</p>
<p>4 https://advwebapparch.com/zend-registry</p>
<p>5 https://advwebapparch.com/packagist</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0132_original/original_page.png" alt="Original Page 132">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p>دلایل متعددی برای این امر وجود دارد. کد شما در آینده ایمن‌تر خواهد بود اگر به <strong>helpers</strong> یا "<strong>syntactic sugar</strong>" خاص <strong>framework</strong> متکی نباشید، که در معرض مد هستند. کد شما همچنین آسان‌تر آزمایش می‌شود، و حتی زمانی که به یک <strong>framework</strong> دیگر منتقل شدید، آسان‌تر آزمایش می‌شود. در واقع، اگر به کلاس‌ها و توابع خاص <strong>framework</strong> وابسته باشید، انتقال به <strong>framework</strong> دیگر بسیار دشوار خواهد بود زیرا باید در همه جا تغییراتی ایجاد کنید.</p>
<p>در این فصل، کدی را که به ابزارهای <strong>framework</strong> برای بازیابی <strong>services</strong> یا مقادیر <strong>configuration</strong> متکی است، بازنویسی خواهیم کرد. ما اطمینان حاصل خواهیم کرد که وابستگی‌ها و مقادیر <strong>configuration</strong> به عنوان آرگومان‌های <strong>constructor</strong> ارائه می‌شوند، بنابراین <strong>objects</strong> دیگر برای اجرا به یک <strong>context</strong> خاص متکی نخواهند بود. این یک راه بسیار موثر برای اطمینان از این است که تعویض <strong>frameworks</strong> یا ارتقا به نسخه بعدی که <strong>BC-breaking</strong> است، باعث ایجاد هیچ مشکلی در بزرگترین بخش از <strong>code base</strong> شما نمی‌شود.</p>
<h4> 5.3. Injecting dependencies</h4>
<p>به جای بازیابی <strong>services</strong> از برخی توابع <strong>global</strong> موجود، ما باید به سادگی همه آنها را به عنوان آرگومان‌های <strong>constructor</strong> مورد نیاز تزریق کنیم. <strong>Listing</strong> 5.2 نشان می‌دهد که این چگونه به نظر می‌رسد.</p>
<p><strong>Listing</strong> 5.2. تزریق <strong>Mailer</strong> به عنوان یک وابستگی.</p>
<pre><code class="language-php">
final class SendIpConfirmationEmail
{
    private Mailer $mailer;

    public function __construct(Mailer $mailer)
    {
        $this-&gt;mailer = $mailer;
    }

    public function send(): void
    {
        // ...
        $this-&gt;mailer-&gt;send($message);
    }
}
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0133_original/original_page.png" alt="Original Page 133">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p>یک مزیت اضافه از ارتقاء <strong>service Mailer</strong> به یک آرگومان <strong>constructor</strong> این است که این وابستگی را صریح می‌کند. من دوست دارم <strong>constructor</strong> یک <strong>service</strong> را به عنوان لیستی از چیزهایی که <strong>service</strong> به آنها نیاز دارد، بخوانم. در این مورد: "<strong>service SendIpConfirmationEmail</strong> به <strong>service Mailer</strong> نیاز دارد تا یک ایمیل تأیید <strong>IP</strong> را به کاربر وارد شده فعلی ارسال کند." این را با این مقایسه کنید که باید کل متد را فقط برای یافتن وابستگی‌هایی که در زمان اجرا واکشی می‌شوند، بخوانید.</p>
<h4> 5.4. Injecting configuration values</h4>
<p>علاوه بر وابستگی‌هایی که خودشان <strong>services</strong> هستند، یک <strong>service</strong> گاهی اوقات به مقادیر <strong>configuration</strong> نیز نیاز دارد. در مورد <strong>service SendIpConfirmationEmail</strong>، باید بداند که فرستنده پیش‌فرض ایمیل‌های سیستم چه کسی است. مقادیر <strong>Configuration</strong> نیز باید به عنوان آرگومان‌های <strong>constructor</strong> تزریق شوند، همانطور که در <strong>Listing</strong> 5.3 نشان داده شده است. من همچنین در حال اضافه کردن یک <strong>assertion</strong> هستم، زیرا یک روز این کار باعث صرفه‌جویی در زمان <strong>debugging</strong> ما می‌شود.</p>
<p><strong>Listing</strong> 5.3. Injecting a <strong>configuration value</strong> as a <strong>constructor argument</strong>.</p>
<pre><code class="language-php">
use Assert\Assertion;

final class SendIpConfirmationEmail
{
    private Mailer $mailer;
    private string $defaultSender;

    public function __construct(
        Mailer $mailer,
        string $defaultSender
    ) {
        Assertion::email($defaultSender);
        $this-&gt;mailer = $mailer;
        $this-&gt;defaultSender = $defaultSender;
    }

    public function send(): void
    {
        $message = EmailMessage::create()
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0134_original/original_page.png" alt="Original Page 134">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<pre><code class="language-php">
-&gt;to(Auth::user()-&gt;email())
    -&gt;from($this-&gt;defaultSender)
    // ...
;
        $this-&gt;mailer-&gt;send($message);
    }
}
</code></pre>
<p>با دو آرگومان <strong>constructor</strong>، اکنون می‌توانیم حتی صریح‌تر باشیم: "<strong>service SendIpConfirmationEmail</strong> به <strong>service Mailer</strong> و یک آدرس فرستنده پیش‌فرض نیاز دارد تا یک ایمیل تأیید <strong>IP</strong> را به کاربر وارد شده فعلی ارسال کند."</p>
<h4> 5.5. Using method arguments for job-specific data</h4>
<p>با نگاهی به امضای متد <code>send()</code>، ما نمی‌توانیم مطمئن باشیم که سیستم ایمیل را به چه کسی ارسال می‌کند، یا از کدام آدرس <strong>IP</strong> از آنها خواسته می‌شود تا تأیید کنند. این امر باعث می‌شود که <strong>client</strong> متد هیچ کنترلی بر نتیجه نداشته باشد.</p>
<p>دو اطلاعات وجود دارد که متد <code>send()</code> برای انجام کار خود به آنها نیاز دارد: آدرس <strong>IP</strong> که درخواست <strong>HTTP</strong> فعلی از آن منشا می‌گیرد و آدرس ایمیل کاربر وارد شده فعلی. استفاده از کلمه "فعلی" به این واقعیت اشاره دارد که ما در مورد داده‌های زمینه‌ای صحبت می‌کنیم.6 این داده‌ها برای هر درخواست متفاوت است. نمونه‌هایی از داده‌های زمینه‌ای عبارتند از زمان درخواست، آدرس <strong>IP</strong> <strong>client</strong>، <strong>ID</strong> کاربر وارد شده، اندازه ترمینالی که کاربر برای اجرای <strong>application</strong> ما از آن استفاده می‌کند، اینکه آیا از رنگ پشتیبانی می‌کند یا خیر و غیره.</p>
<p>در مثال ما، <strong>service SendIpConfirmationEmail</strong> برای کسب اطلاعات بیشتر در مورد <strong>context</strong> که <strong>service</strong> در آن فراخوانی شده است، به متدهای <strong>globally</strong> موجود دسترسی پیدا می‌کند. این <strong>object request</strong> فعلی را پس از بازیابی آن از تابع <strong>helper</strong> از نوع <code>request()</code> بررسی می‌کند، و آدرس ایمیل کاربر وارد شده را از طریق متد <code>Auth::user()</code> بازیابی می‌کند. کاربر فعلی و آدرس <strong>IP</strong> نه <strong>services</strong> هستند و نه مقادیر <strong>configuration</strong>. بنابراین ما نمی‌توانیم آنها را به عنوان <strong>constructor</strong> تزریق کنیم</p>
<p>6Read more on contextual data and how to deal with it in my blog post “Context passing”: https://advwebapparch.com/context-passing .</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0135_original/original_page.png" alt="Original Page 135">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p>آرگومان‌ها. در عوض، ما باید آنها را به عنوان آرگومان‌های متد <code>send()</code> به <strong>service</strong> منتقل کنیم. <strong>Listing</strong> 5.4 نتیجه این تغییر را نشان می‌دهد.</p>
<p><strong>Listing</strong> 5.4. Passing contextual data as method arguments.</p>
<pre><code class="language-php">
final class SendIpConfirmationEmail
{
    // ...
    public function send(
        User $user,
        string $ipAddress
    ): void {
        $message = EmailMessage::create()
            -&gt;to($user-&gt;email())
            -&gt;from($this-&gt;defaultSender)
            -&gt;text(
                trans(
                    'Add your :ip to the whitelist',
                    [
                        'ip' =&gt; $ipAddress
                    ]
                )
            );
        $this-&gt;mailer-&gt;send($message);
    }
}
</code></pre>
<p>یک نکته آخر وجود دارد که ما باید صریح کنیم: فراخوانی <code>trans()</code>، که قرار است پیام ایمیل را به زبان کاربر ترجمه کند. در عمل، <code>trans()</code> از <strong>locale</strong> استفاده می‌کند که برای درخواست فعلی <strong>configured</strong> شده است. اگرچه ما صریحاً این اطلاعات را از درخواست واکشی نمی‌کنیم، مانند کاری که با آدرس <strong>IP</strong> <strong>client</strong> انجام دادیم، هنوز هم به آن تکیه می‌کنیم تا قبل از فراخوانی این <strong>service</strong> پیکربندی شود. این امر یک بار دیگر ما را به زیرساخت <strong>framework</strong> وابسته می‌کند. برای صریح کردن این وابستگی، ما باید دو کار انجام دهیم: <strong>locale</strong> کاربر را صریحاً به <strong>translator</strong> منتقل کنیم و <strong>translator</strong> را به عنوان یک وابستگی صریح از <strong>service</strong> قرار دهیم. <strong>Listing</strong> 5.5 نتیجه را نشان می‌دهد.</p>
<p><strong>Listing</strong> 5.5. Injecting an extra dependency and providing an explicit <strong>locale</strong>.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0136_original/original_page.png" alt="Original Page 136">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<pre><code class="language-php">
final class SendIpConfirmationEmail
{
    // ...
    private Translator $translator;

    public function __construct(
        /* ... */
        Translator $translator
    ) {
        // ...
        $this-&gt;translator = $translator;
    }

    public function send(/* ... */): void {
        $message = EmailMessage::create()
            // ...
            -&gt;text(
                $this-&gt;translator-&gt;trans(
                    'Add your :ip to the whitelist',
                    [
                        'ip' =&gt; $ipAddress
                    ],
                    $user-&gt;locale()
                )
            );
        // ...
    }
}
</code></pre>
<p>حالا ما <code>Translator</code> را به عنوان یک وابستگی اضافی تزریق می‌کنیم، و <strong>locale</strong> کاربر را به صراحت به متد <code>trans()</code> منتقل می‌کنیم.</p>
<h4> 5.6. Clients of reusable services</h4>
<p>افزودن آرگومان‌های <strong>constructor</strong> مورد نیاز بیشتر به یک <strong>service</strong>، به برخی تغییرات در جایی که <strong>services</strong> نمونه‌سازی می‌شوند، نیاز دارد. اگر از <strong>auto-wiring</strong> برای <strong>services</strong> استفاده می‌کنید، هیچ تلاشی لازم نیست، اما اگر یک <strong>service container</strong>7 دست‌نویس یا یک <strong>service container</strong> مبتنی بر فایل‌های <strong>configuration</strong> دارید، باید برخی تغییرات دستی انجام دهید.</p>
<p><strong>Clients</strong> که از متد <code>send()</code> استفاده می‌کنند نیز باید به‌روزرسانی شوند. آنها می توانند نه</p>
<p>7 https://advwebapparch.com/hand-written-service-containers</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0137_original/original_page.png" alt="Original Page 137">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p>دیگر متد را بدون هیچ آرگومانی فراخوانی نمی‌کنند، بلکه باید <strong>User</strong> وارد شده و آدرس <strong>IP client</strong> را از درخواست <strong>HTTP</strong> فعلی ارائه دهند.</p>
<p><strong>Listing</strong> 5.6 یکی از <strong>clients</strong> از <strong>service SendIpConfirmationEmail</strong> را نشان می‌دهد: یک <strong>action</strong> از نوع <strong>web controller</strong>. یک <strong>controller</strong> به طور طبیعی به کاربر <strong>authenticated</strong> و <strong>object Request</strong> فعلی دسترسی دارد، بنابراین به‌روزرسانی کد برای فراخوانی <code>send()</code> با آرگومان‌های مناسب آسان است.</p>
<p><strong>Listing</strong> 5.6. <strong>UserController</strong> به اطلاعات زمینه‌ای مورد نیاز دسترسی دارد و آن را به <strong>service SendIpConfirmationEmail</strong> منتقل می‌کند.</p>
<pre><code class="language-php">
final class UserController
{
    private SendIpConfirmationEmail $confirmationEmail;

    public function __construct(
        SendIpConfirmationEmail $confirmationEmail
    ) {
        $this-&gt;confirmationEmail = $confirmationEmail;
    }

    public function sendIpConfirmationEmail(
        Request $request
    ): Response {
        $this-&gt;confirmationEmail-&gt;send(
            Auth::user(),
            $request-&gt;ip()
        );
        // ...
    }
}
</code></pre>
<p>از آنجایی که خود <strong>service SendIpConfirmationEmail</strong> دیگر آدرس <strong>IP</strong> را از <strong>object Request</strong> فعلی نمی‌گیرد، و دیگر به یک <strong>session</strong> فعال با یک کاربر <strong>authenticated</strong> متکی نیست، ما با موفقیت این کد را از زیرساخت‌های اطراف آن <strong>decoupled</strong> کردیم. این به یک <strong>context</strong> خاص متکی نیست که برای آن آماده شده باشد. و به سیستم‌های خارجی متکی نیست تا در دسترس باشند.</p>
<p>ما قبلاً در فصل قبل کار مشابهی را انجام داده‌ایم، جایی که ما</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0138_original/original_page.png" alt="Original Page 138">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p><strong>extracted</strong> <strong>use case</strong> از <strong>web controller</strong>. انجام این کار برای <strong>service SendIp-ConfirmationEmail</strong> نیز، آن را به طور موثر در یک <strong>context</strong> متفاوت قابل استفاده مجدد می‌کند. به عنوان مثال، وب‌سایت پشتیبانی شرکت شما می‌تواند یک فرم ارائه دهد و به یک کارمند اجازه دهد تا در صورت بروز مشکل، ایمیل تأیید را به صورت دستی ارسال کند. چنین <strong>controller action</strong> اطلاعات کاربر را نه از <strong>session</strong>، بلکه از فرم دریافت می‌کند. از آنجایی که <strong>service SendIpConfirmationEmail refactored</strong> به حالت <strong>global</strong> برای ورودی خود متکی نیست، به راحتی می‌توان از آن در این <strong>context</strong> جدید استفاده مجدد کرد، همانطور که در <strong>Listing</strong> 5.7 نشان داده شده است.</p>
<p><strong>Listing</strong> 5.7. Reusing the <strong>SendIpConfirmationEmail service</strong> in a different <strong>context</strong>.</p>
<pre><code class="language-php">
final class SupportController
{
    private SendIpConfirmationEmail $confirmationEmail;
    private UserRepository $userRepository;

    public function __construct(
        UserRepository $userRepository,
        SendIpConfirmationEmail $confirmationEmail
    ) {
        $this-&gt;userRepository = $userRepository;
        $this-&gt;confirmationEmail = $confirmationEmail;
    }

    public function sendIpConfirmationEmail(
        Request $request
    ): Response {
        $user = $this-&gt;userRepository-&gt;getById(
            // Take the user ID from the form:
            $request-&gt;request-&gt;get('user_id')
        );
        $this-&gt;confirmationEmail-&gt;send(
            $user,
            // Take the user's IP address from the form:
            $request-&gt;request-&gt;get('ip')
        );
        // ...
    }
}
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0139_original/original_page.png" alt="Original Page 139">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p>5.7. Testing</p>
<p>من قبلاً <strong>testability</strong> را به عنوان یک دلیل مهم برای کاهش <strong>framework</strong> ذکر کردم. در تئوری، شما باید بتوانید یک <strong>unit test</strong> برای هر کلاس بنویسید. در عمل، ممکن است نخواهید این کار را انجام دهید، زیرا مناطق مختلف یک <strong>code base</strong> به انواع مختلف <strong>tests</strong> نیاز دارند (ما این موضوع را در فصل 14 پوشش خواهیم داد). در حال حاضر، بیایید بگوییم می‌خواهیم یک <strong>unit test</strong> برای <code>SendIpConfirmationEmail</code> بنویسیم. یک <strong>unit test</strong>، تستی است که از هیچ <strong>IO</strong> استفاده نمی‌کند (از سیستم فایل، یک <strong>database</strong>، یک <strong>service</strong> خارجی و غیره استفاده نمی‌کند) و معمولاً اما نه لزوماً یک واحد کد کوچکتر، مانند یک کلاس واحد را پوشش می‌دهد.</p>
<p>بیایید یک <strong>unit test</strong> برای نسخه اولیه <code>SendIpConfirmationEmail</code> بنویسیم. <strong>Listing</strong> 5.8 نشان می‌دهد که این تست چگونه خواهد بود.</p>
<p><strong>Listing</strong> 5.8. A test for the initial version of the <strong>SendIpConfirmationEmail service</strong>.</p>
<pre><code class="language-php">
public function it_sends_an_ip_confirmation_email(): void
{
    $user = new User(/* ... */);
    $ip = '123.234.123.234';
    // Fake the currently logged in user
    Auth::shouldReceive('user')
        -&gt;once()
        -&gt;andReturn($user);

    // Set the user's locale for trans()
    App::setLocale($user-&gt;locale());

    // Configure the default sender email address
    $sender = 'info@mycompany.com';
    Config::set('mail.default_sender', $sender);

    // Fake the current request
    Request::shouldReceive('ip')
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0140_original/original_page.png" alt="Original Page 140">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<pre><code class="language-php">
-&gt;once()
        -&gt;andReturn($ip);

    // Set up the Mailer mock
    $mailer = $this-&gt;createMock(Mailer::class);
    $mailer-&gt;expects($this-&gt;once())
        -&gt;method('send')
        -&gt;willReturn(
            function (Message $message) use ($user, $ip, $sender) {
                $this-&gt;assertEquals(
                    $user-&gt;emailAddress(),
                    $message-&gt;to()
                );
                $this-&gt;assertEquals($sender, $message-&gt;from());
                $this-&gt;assertContains($message-&gt;text(), $ip);
            }
        );
    // Make sure the container will return our mock
    Container::getInstance()-&gt;instance(
        Mailer::class, $mailer
    );

    $service = new SendIpConfirmationEmail();
    $service-&gt;send();
}
</code></pre>
<p><strong>framework</strong> که ما در این مثال استفاده کرده‌ایم، متدهای مناسبی را برای جایگزینی <strong>services</strong> درخواستی، مقادیر <strong>configuration</strong> و اطلاعات زمینه‌ای با <strong>test doubles</strong> ارائه می‌دهد.8. با این حال، قانون <strong>don’t-use-any-IO</strong> در واقع تضمین نشده است. اگر فراموش کنیم یک <strong>test double</strong> صحیح برای <strong>service Mailer</strong> تنظیم کنیم، این <strong>test</strong> ممکن است شروع به ارسال ایمیل‌های واقعی کند. اما <strong>Mailer</strong> تنها مشکل نیست. از آنجایی که کلاس می‌تواند هر <strong>service</strong> را با استفاده از <code>resolve()</code> واکشی کند، و هر یک از آن <strong>services</strong> می‌توانند از <strong>IO</strong> استفاده کنند، ما نمی‌توانیم تضمین کنیم که این <strong>test</strong> یک <strong>unit test</strong> است، یا یک <strong>unit test</strong> باقی می‌ماند.</p>
<p>اکنون <strong>test</strong> را برای نسخه اولیه با <strong>test</strong> برای <strong>service refactored</strong>، نشان داده شده در <strong>Listing</strong> 5.9 مقایسه کنید.</p>
<p><strong>Listing</strong> 5.9. A test for the refactored <strong>service</strong>.</p>
<p>8 https://advwebapparch.com/laravel-mocking</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0141_original/original_page.png" alt="Original Page 141">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<pre><code class="language-php">
public function it_sends_an_ip_confirmation_email(): void
{
    $user = new User(/* ... */);
    $ip = '123.234.123.234';
    $sender = 'info@mycompany.com';

    $mailer = $this-&gt;createMock(Mailer::class);
    $mailer-&gt;expects($this-&gt;once())
        -&gt;method('send')
        -&gt;willReturn(
            function (Message $message) use ($user, $ip, $sender) {
                $this-&gt;assertEquals(
                    $user-&gt;emailAddress(),
                    $message-&gt;to()
                );
                $this-&gt;assertEquals($sender, $message-&gt;from());
                $this-&gt;assertContains($message-&gt;text(), $ip);
            }
        );

    $translator = $this-&gt;createMock(Translator::class);
    $translator-&gt;expects($this-&gt;once())
        -&gt;method('trans')
        -&gt;willReturn(
            function ($message, $replacements, $locale) use ($user) {
                $this-&gt;assertEquals($locale, $user-&gt;locale());
                return $message . ' (translated)';
            }
        );

    $service = new SendIpConfirmationEmail(
        $mailer,
        $sender,
        $translator
    );

    $service-&gt;send($user, $ip);
}
</code></pre>
<p>تعداد خطوط کد تقریباً در هر دو <strong>tests</strong> یکسان است. اما دومی چند مزیت دارد.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0142_original/original_page.png" alt="Original Page 142">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p>اول از همه، درست مانند خود <strong>service refactored</strong>، کاملاً از ابزارهای خاص <strong>framework</strong> جدا شده است، مانند:</p>
<ol>
<li><code>Auth::shouldReceive()</code></li>
<li><code>Container::getInstance()</code></li>
<li><code>App::setLocale()</code></li>
<li><code>Config::set()</code></li>
<li><code>Request::shouldReceive()</code></li>
</ol>
<p>این بدان معناست که خود <strong>unit test</strong> یک <strong>framework migration</strong> را پشت سر می‌گذارد، درست مانند خود <strong>service</strong>.</p>
<p>ثانیاً، هیچ وضعیت <strong>global</strong> وجود ندارد که <strong>service</strong> به آن متکی باشد، بنابراین هیچ وضعیت <strong>global</strong> وجود ندارد که قبل از آزمایش یا اجرای آن، نیاز به آماده‌سازی داشته باشد. هر چیزی که به آن نیاز دارد به عنوان آرگومان <strong>constructor</strong> یا متد ارائه می‌شود. شما می‌توانید <strong>branches</strong> مختلفی از کد را با معرفی کمی تغییر در آرگومان‌های <strong>constructor</strong> یا متد آزمایش کنید. هیچ راه‌های پنهان دیگری وجود ندارد که رفتار کد ممکن است تغییر کند.</p>
<p>این تست ثابت می‌کند که <strong>service</strong> کاملاً قابل حمل است. می‌توان از آن در سایر مناطق <strong>application</strong> استفاده کرد که از یک <strong>framework</strong> متفاوت یا اصلاً از <strong>framework</strong> استفاده نمی‌کنند. <strong>framework</strong> حتی نیازی به <strong>booted</strong> شدن یا هر چیز دیگری ندارد، شما فقط باید <strong>service</strong> را با وابستگی‌های صحیح تنظیم کنید.</p>
<p>با دانستن اینکه <strong>predictability</strong> و توانایی اجرا در انزوا هنگام نوشتن یک <strong>unit test</strong> مطلوب هستند، بیایید این را به عنوان یک ویژگی از کد قابل آزمایش واحد فرموله کنیم:</p>
<p>نتیجه فراخوانی یک متد بر روی یک <strong>object</strong> باید با منطق پیاده‌سازی خود، و به صورت اختیاری با رفتار یکی از آرگومان‌های <strong>constructor</strong> آن، یا آرگومان‌های متدی که به آن ارائه شده است، تعیین شود. و چیزی بیش از این.</p>
<p>به عنوان مثال: رفتار نسخه اصلی <strong>service SendIpConfirmationEmail</strong> را نمی‌توان با نگاهی به آرگومان‌های <strong>constructor</strong> یا آرگومان‌های متد آن توضیح داد. در واقع، هیچ آرگومان <strong>constructor</strong> یا متدی ندارد. بنابراین ما انتظار داریم که پیاده‌سازی خود آن بتواند رفتار خود را توضیح دهد.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0143_original/original_page.png" alt="Original Page 143">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p>این هم درست نیست. بخش بزرگی از رفتار این <strong>service</strong> توسط وابستگی‌هایی که با استفاده از توابع <strong>helper static</strong> بازیابی می‌شوند، تعریف می‌شود، و <strong>service</strong> همچنین به رفتار صحیح این توابع <strong>helper</strong> وابسته است. این امر هنگام آزمایش کد بسیار ناخوشایند است. شما می‌خواهید بتوانید با <strong>unit</strong> به عنوان یک جعبه سیاه رفتار کنید، متدها را روی آن فراخوانی کنید، و <strong>assert</strong> کنید که رفتار مورد نظر را دارد. آنچه در داخل می‌گذرد، نباید دغدغه <strong>unit test</strong> باشد. با این حال، هنگام آزمایش نسخه اولیه، کد تست حاصل بسیار نگران کننده است با <strong>internals</strong> از موضوع تحت تست. باید اطمینان حاصل کند که همه چیز برای فراخوانی متد <code>send()</code> آماده است. البته، برای <strong>service rewritten</strong> ما نیز باید چند چیز را تنظیم کنیم. اما این می‌تواند یک فرآیند "کمک‌کننده کامپایلر" باشد، و وقتی کامپایلر می‌گوید شما کارتان تمام شده است، در واقع کارتان تمام شده است. به <strong>Listing</strong> 5.10 و شکل 5.1 برای نمایش چنین فرآیندی مراجعه کنید.</p>
<p><strong>Listing</strong> 5.10. The compiler assists us when instantiating and using the <strong>ser- service</strong>.</p>
<pre><code class="language-php">
new SendIpConfirmationEmail();
// Error: Missing constructor argument of type Mailer

$mailer = $this-&gt;createMock(Mailer::class);
new SendIpConfirmationEmail($mailer);
// Error: Missing constructor argument of type string

$sender = 'a string';
new SendIpConfirmationEmail($mailer, $sender);
// Error: Missing constructor argument of type Translator

$translator = $this-&gt;createMock(Translator::class);
$service = new SendIpConfirmationEmail(
    $mailer,
    $sender,
    $translator
);
// Error: Value "a string" was expected to be a valid e-mail address.

$sender = 'info@matthiasnoback.nl';
$service = new SendIpConfirmationEmail(
    $mailer,
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0144_original/original_page.png" alt="Original Page 144">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<pre><code class="language-php">
$sender,
        $translator
    );
    // OK

    $service-&gt;send();
    // Error: Missing method argument of type User

    $user = new User(/* ... */);
    $service-&gt;send($user);
    // Error: Missing method argument of type string

    $ip = '127.0.0.1';
    $service-&gt;send($user, $ip);
    // OK
</code></pre>
<p>شکل 5.1. قبل از اینکه بتوانید <code>send()</code> را فراخوانی کنید، کامپایلر به شما کمک می‌کند تا هر چیزی را که باید ارائه دهید، کشف کنید.</p>
<p>اگر سعی کنید همین کار را با نسخه اصلی <strong>service</strong> انجام دهید، نتیجه کاملاً متفاوت خواهد بود. <strong>instantiate</strong> کردن <strong>service</strong> بسیار آسان خواهد بود زیرا <strong>constructor</strong> هیچ آرگومان مورد نیازی ندارد (هیچ</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 145" src="page_0145/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0145_original/original_page.png" alt="Original Page 145">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p>حتی یک <strong>constructor</strong> رسمی)، اما هنگامی که شروع به فراخوانی <code>send()</code> برای تأیید رفتار صحیح می‌کنید، دچار مشکل خواهید شد (<strong>Listing</strong> 5.11).</p>
<p><strong>Listing</strong> 5.11. With implicit dependencies, instantiation is easy, usage is not.</p>
<pre><code class="language-php">
new SendIpConfirmationEmail();
// OK

$service-&gt;send();
// Error: No logged in user
// Or maybe: Fatal error: Call to a member function email() on null
// Or maybe: Error: Undefined config key "mail.default_sender"
</code></pre>
<p>برای رفع مشکلات، باید نگاه دقیق‌تری به کد متد <code>send()</code> داشته باشید. ابتدا باید همه وابستگی‌های ضمنی آن را تنظیم کنید. متأسفانه، شما حتی نمی‌دانید چه زمانی کارتان تمام می‌شود. حتی اگر با دقت در کد جستجو کنید تا بفهمید به چه چیزی نیاز دارد، هنوز این شانس وجود دارد که چیزی را از دست داده باشید. به عنوان مثال، فراخوانی <code>trans()</code> به طور مخفیانه به یک <strong>locale</strong> متکی است که توسط فراخوانی <code>App::setLocale()</code> ارائه می‌شود. کد در <code>send()</code> این اطلاعات را نشان نمی‌دهد. شما باید آن را بدانید. شکل 5.2 نشان می‌دهد که چگونه پیش‌نیازهای فراخوانی <code>send()</code> از ساختار کلاس (آرگومان‌های <strong>constructor</strong> و متد آن) جدا شده است.</p>
<h4> 5.8. Effective testing</h4>
<p>آیا بد است که برای نوشتن یک <strong>unit test</strong> برای یک <strong>object</strong>، باید کد آن را بخوانید؟ خب، من فکر می‌کنم اینطور است. شما باید بین کد تولید و کد تست، رفت و آمد کنید، و تمام کارهایی را که <strong>framework</strong> به طور معمول برای شما انجام می‌دهد، دوباره انجام دهید. این باعث می‌شود احساس کنید دو برابر کاری را انجام می‌دهید که بدون نوشتن یک تست انجام می‌دادید. در عین حال، اگر کد تولید را به گونه‌ای تغییر دهید که یک مرحله راه‌اندازی اضافی لازم باشد، قطعاً یک تست دیگر را که هنوز آن مرحله اضافی را ندارد، می‌شکنید.</p>
<p>مشکل این است که این نوع تست بیش از حد به کد تولید نزدیک است. این به شما کمک نمی‌کند که سریع‌تر کار کنید یا مؤثرتر باشید. بعد از چند تا از این</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0146_original/original_page.png" alt="Original Page 146">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p>شکل 5.2. کامپایلر نمی‌تواند به شما کمک کند تا بفهمید برای فراخوانی <code>send()</code> چه چیزی لازم است. پیش‌نیازها را نمی‌توان از امضاهای <strong>constructor</strong> یا متد استخراج کرد.</p>
<p><strong>tests</strong>، شما وسوسه می‌شوید که نوشتن تست را به طور کلی متوقف کنید.</p>
<p>بخشی از راه‌حل، طراحی <strong>services</strong> خود به روشی متفاوت است. چیزها را صریح‌تر کنید: هر دو وابستگی‌ها و آرگومان‌های متد به این امر کمک می‌کنند. بخش دیگر از راه‌حل این است که برای هر کلاس واحد، یک <strong>unit test</strong> ننویسید. <strong>Unit tests</strong> فقط برای نوع خاصی از <strong>objects</strong> مناسب هستند. <strong>Services Mailer</strong>، <strong>controllers</strong>، <strong>repositories</strong>، همه آنها به <strong>integration tests</strong> نیاز دارند. تست‌هایی که از چیز واقعی (یک سرور ایمیل، یک سرور وب، یک سرور <strong>database</strong>) استفاده می‌کنند. آزمایش این نوع کد به عنوان یک <strong>unit test</strong>، چیزی در مورد اثربخشی آن ثابت نمی‌کند.</p>
<p>اما همیشه ارزش دارد که راهی برای جدا کردن منطق از نگرانی‌های زیرساختی پیدا کنید. اگر می‌توانید این کار را انجام دهید، در نهایت با دو جزیره از کد مواجه خواهید شد: برای یکی شما می‌توانید <strong>unit tests</strong> بنویسید، و برای دیگری <strong>integration tests</strong>. ما در فصل 6 یک نمونه از جداسازی مؤثر این دو نوع کد را خواهیم دید.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 147" src="page_0147/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0147_original/original_page.png" alt="Original Page 147">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p>هر چه جزیره اول بزرگتر باشد، بهتر است. شما کد بیشتری خواهید داشت که می‌تواند <strong>unit tested</strong> باشد. کار با این کد آسان‌تر خواهد بود، زیرا تنها کاری که باید انجام دهید این است که یک <strong>object</strong> را <strong>instantiate</strong> کنید و متدها را روی آن فراخوانی کنید. <strong>Test suite</strong> بسیار سریع خواهد بود، زیرا اجرای یک <strong>unit test</strong> تقریباً هیچ زمانی نمی‌برد. این شما را تشویق می‌کند که <strong>tests</strong> بیشتری بنویسید، و نشان می‌دهد که چگونه کد با تغییرات داده‌های ورودی سروکار دارد.</p>
<p>و حلقه بازخورد بین نوشتن کد و یافتن اینکه آیا کار درست را انجام داده‌اید یا خیر، را محکم می‌کند.</p>
<p>“<strong>Dependency injection</strong>، انتقال اطلاعات زمینه‌ای؛ به نظر می‌رسد که کار زیادی است!”</p>
<p>یک اعتراض رایج به استفاده از <strong>dependency injection</strong>، صریحاً انتقال اطلاعات زمینه‌ای و غیره این است که نوشتن همه آن کد، کار زیادی است.</p>
<p>مقایسه نسخه <strong>refactored</strong> از <code>SendIpConfirmationEmail</code> با نسخه اصلی کلاس، در واقع می‌تواند به این نتیجه برسید: کار زیاد است. شاید عبارات زیادی در نسخه نهایی وجود نداشته باشد، اما در واقع نمادهای بیشتری در آن وجود دارد، به عنوان مثال. پارامترهای <strong>constructor</strong> و متد و <strong>properties</strong>. من امیدوارم که توانسته‌ام مزایای افزودن این عناصر اضافی را نشان دهم، اما این هنوز به این سؤال پاسخ نمی‌دهد: آیا این کار زیادی نیست؟ البته، اگر شما در همه جا از توابع <strong>helper static global</strong> استفاده می‌کنید، <strong>refactoring</strong> همه کد خود به این سبک جدید، تلاش زیادی خواهد بود. اما این دقیقاً همان نکته است: فقط مطمئن شوید که هرگز مجبور به انجام این کار نخواهید شد. از هیچ ابزار مبتنی بر حالت <strong>global</strong> کمک‌کننده از <strong>framework</strong> برای بازیابی وابستگی‌ها، مقادیر <strong>configuration</strong> و غیره استفاده نکنید. شما نمی‌توانید کد قدیمی را به راحتی تعمیر کنید، اما می‌توانید از این به بعد کار درست را انجام دهید.</p>
<p>متأسفانه، این زنجیره استدلال کمبود دارد. "شما باید اکنون A را انجام دهید، زیرا اگر B را انجام دادید و می‌خواهید به A بروید، آن کار زیادی خواهد بود!" بنابراین چرا در B نمانیم اگر از آنجا خوشحال هستید؟ زیرا اگر <strong>application</strong> شما بیش از 2 یا 3 سال عمر کند، هنوز هم می‌خواهید به A بروید. شواهد حکایتی برای این امر این است که من و تیمم در خلاص شدن از <strong>service</strong> و <strong>configuration locator static global</strong> به نام <code>Zend_Registry</code> مشکل زیادی داشتیم (و من مطمئنم که تنها کسی نیستم که این تجربه را دارد). بنابراین باز هم، تنها چیزی که می‌توانم بگویم این است: فقط شروع به استفاده از چیزی شبیه به آن نکنید.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0148_original/original_page.png" alt="Original Page 148">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<h4> 5.9. The Composition root is near the entry point</h4>
<p>در نسخه اولیه <code>SendIpConfirmationEmail</code> ما از <code>resolve()</code> استفاده کردیم تا اجازه دهیم <strong>service container</strong>، <strong>service Mailer</strong> را برای ما <strong>instantiate</strong> کند. گام به گام ما توانستیم تمام آن وابستگی‌های <strong>dynamically resolved</strong> و مقادیر <strong>configuration</strong> را به آرگومان‌های <strong>constructor</strong> تبدیل کنیم. اما ما هنوز هم به <strong>service container</strong> متکی هستیم تا همه آن چیزها را برای ما حل کند و آنها را به عنوان آرگومان‌های <strong>constructor</strong> تزریق کند. تفاوت در این است که در ابتدا ما از <strong>service container</strong> برای یافتن <strong>services</strong> و مقادیر <strong>configuration</strong> برای ما استفاده می‌کردیم، در حالی که اکنون ما به <strong>container</strong> متکی هستیم تا این چیزها را به ما ارائه دهد. کلاس <code>SendIpConfirmationEmail</code> دیگر نیازی نیست نگران این باشد که وابستگی‌های آن از کجا باید بیایند یا چگونه آنها را بسازد. این فقط تعدادی از آرگومان‌های <strong>constructor</strong> مورد نیاز و انواع آنها را اعلام می‌کند. به این <strong>inversion of control</strong> گفته می‌شود. یک قانون کلی این است که هرگز از <strong>service container</strong> به عنوان یک <strong>locator</strong> استفاده نکنید، فقط به عنوان یک <strong>injector</strong>، که گاهی اوقات به آن یک <strong>inversion of control container</strong> می‌گویند.</p>
<p>اما حتی اگر ما از تزریق <strong>constructor</strong> مناسب در همه جا استفاده کنیم، باید حداقل یک تماس واحد با <strong>service container</strong> برای <strong>instantiate</strong> کردن اولین <strong>service</strong> وجود داشته باشد تا بتوانیم از آن در یک <strong>controller</strong> استفاده کنیم. با این حال، ما فقط گفتیم که یک <strong>container</strong> هرگز نباید به عنوان یک <strong>service locator</strong> استفاده شود.</p>
<p>برای حل این پارادوکس، باید به مارک سمان، که در مورد این مشکل خاص9 نوشت، روی آوریم. او مفهوم یک نقطه ورود را معرفی می‌کند، که اولین کد کاربری است که <strong>framework</strong> آن را فراخوانی می‌کند. کد کاربر، کدی است که بخشی از <strong>framework</strong> نیست، بلکه توسط شما یا اعضای تیم شما نوشته شده است. اغلب چنین نقطه ورودی، <strong>controller</strong> است که <strong>framework</strong> تصمیم می‌گیرد بر اساس <strong>URL request</strong> فعلی فراخوانی کند. در این مورد، <strong>framework</strong> ممکن است بتواند <strong>controller</strong> را با انجام کاری مانند <code>new $controllerClass()</code> <strong>instantiate</strong> کند. اما هنگامی که در داخل <strong>controller</strong> هستید، <strong>services</strong> خود را از کجا دریافت می‌کنید؟ شما باید از جایی شروع کنید. مارک پیشنهاد می‌کند که <strong>container</strong> در این شرایط نقش بسیار خاصی را ایفا می‌کند: نقش <strong>Composition root</strong>.</p>
<p>یک <strong>Composition Root</strong> یک مکان (ترجیحاً) منحصر به فرد در یک <strong>application</strong> است که در آن <strong>modules</strong> در کنار هم قرار می‌گیرند.</p>
<p>این جایی است که <strong>object graph</strong>، شامل اولین <strong>service</strong> از جمله همه موارد آن است</p>
<p>9 https://advwebapparch.com/composition-root</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0149_original/original_page.png" alt="Original Page 149">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p>وابستگی‌ها، و وابستگی‌های آنها، و غیره، <strong>composed</strong> می‌شود. در مثال ما <strong>controller</strong> نقطه ورود <strong>application</strong> است:</p>
<p>نقطه ورود، کد کاربری است که <strong>framework</strong> ابتدا آن را فراخوانی می‌کند.</p>
<p>سمان پیشنهاد می‌کند که در یا نزدیک نقطه ورود <strong>application</strong>، به نظر می‌رسد که ما از <strong>container</strong> به عنوان یک <strong>service locator</strong> استفاده می‌کنیم، اما در واقع، ما از آن به عنوان یک <strong>composition root</strong> استفاده می‌کنیم، که یک نقش متفاوت است. بنابراین ما می‌توانیم خاص‌تر باشیم و بگوییم که همه تماس‌ها با <code>resolve()</code>، <code>Container::get()</code> و غیره. نباید ممنوع شوند. تا زمانی که <strong>container</strong> نقش <strong>composition root</strong> را ایفا می‌کند، ما می‌توانیم از آن در نزدیکی نقطه ورود <strong>application</strong> خود استفاده کنیم:</p>
<p>یک <strong>Composition Root</strong> در یا نزدیک نقطه ورود قرار دارد. نقطه ورود جایی است که کد کاربر اولین بار توسط یک <strong>framework</strong> اجرا می‌شود.10</p>
<p>در عمل، این بدان معناست که در داخل یک <strong>controller</strong>، بازیابی یک <strong>service</strong> از <strong>container</strong> کاملاً اشکالی ندارد. با این حال، پس از ورود به آن <strong>service</strong>، استفاده از <strong>service container</strong> دیگر مجاز نیست. اگر <strong>framework</strong> شما این امکان را می‌دهد که <strong>controllers</strong> را نیز به عنوان <strong>services</strong> تعریف کنید، پس شما حتی می‌توانید <strong>composition root</strong> را یک سطح بالاتر ببرید. سپس <strong>framework</strong> از <strong>container</strong> می‌خواهد تا <strong>controller</strong> شما را <strong>instantiate</strong> کند، و تمام وابستگی‌های آن به عنوان آرگومان‌های <strong>constructor</strong> تزریق می‌شوند. توجه داشته باشید که این گام آخر لازم نیست. پیروزی بزرگ این است که ما از یک <strong>service locator</strong> در هیچ جای کدمان به جز نزدیک نقاط ورودی استفاده نمی‌کنیم.</p>
<h4> 5.10. Summary</h4>
<p>در این فصل، ما با یک <strong>service</strong> شروع کردیم که از توابع <strong>helper</strong> <strong>globally</strong> موجود برای حل وابستگی‌ها، مقادیر <strong>configuration</strong> و اطلاعات زمینه‌ای استفاده می‌کرد. ما کد را <strong>refactor</strong> کردیم تا وابستگی‌ها و مقادیر <strong>configuration</strong> خود را به عنوان آرگومان‌های <strong>constructor</strong> تزریق کنیم. ما همچنین اطمینان حاصل کردیم که هر اطلاعات زمینه‌ای مربوطه به عنوان آرگومان‌های متد ارائه شده است. تغییر ساختار <strong>service</strong> آن را به یک <strong>service</strong> "خالص" تبدیل کرد؛ رفتار آن کاملاً توسط پیاده‌سازی خود و رفتار <strong>constructor</strong> و آرگومان‌های متد تعیین می‌شود. این باعث می‌شود که <strong>service</strong>، کاندیدای بسیار بهتری برای <strong>unit</strong> باشد</p>
<p>10 https://advwebapparch.com/composition-root-location</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0150_original/original_page.png" alt="Original Page 150">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p><strong>testing</strong>. در نهایت، ما در مورد اینکه چگونه استفاده از <strong>dependency injection</strong> در همه جا می‌تواند <strong>composition root</strong> از <strong>object graph service</strong> شما را به نقطه ورودی <strong>application</strong> نزدیک‌تر کند، بحث کردیم.</p>
<p><strong>Exercises</strong></p>
<p>1. مزایای استفاده از تزریق <strong>constructor</strong> نسبت به <strong>service location</strong> چیست؟a</p>
<p>2. چرا کد اصلی مجاز نیست به حالت <strong>global</strong> برای وابستگی‌ها و اطلاعات زمینه‌ای متکی باشد؟b</p>
<ol>
<li>زیرا انجام این کار به این معنی است که سیستم‌های خارجی باید در زمان اجرا در دسترس باشند.</li>
<li>زیرا انجام این کار به این معنی است که یک <strong>context</strong> ویژه باید برای اجرای این کد ارائه شود.</li>
</ol>
<p>3. این موارد را به عنوان داده‌های خاص شغل، وابستگی یا اطلاعات زمینه‌ای طبقه‌بندی کنید:c</p>
<ol>
<li><code>EbookRepository</code></li>
<li>نام <strong>hostname</strong> از درخواست <strong>HTTP</strong> فعلی</li>
<li>یک <code>EbookId</code></li>
<li>یک <strong>object</strong> از نوع <strong>command CreateOrder</strong></li>
<li><code>EventDispatcher</code></li>
</ol>
<p>4. این موارد چگونه باید به یک <strong>service</strong> ارائه شوند، به عنوان آرگومان‌های <strong>constructor</strong> یا به عنوان آرگومان‌های متد؟d</p>
<ol>
<li>وابستگی‌ها</li>
<li>اطلاعات زمینه‌ای</li>
<li>داده‌های خاص شغل</li>
<li>مقادیر <strong>Configuration</strong></li>
</ol>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0151_original/original_page.png" alt="Original Page 151">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Service locators</h3>
<p>5. آیا کد شما مجاز است یک <strong>service</strong> را مستقیماً از یک <strong>service con- container</strong> واکشی کند؟e</p>
<ol>
<li>خیر، هرگز. همیشه از <strong>constructor injection</strong> استفاده کنید.</li>
<li>بله، اما فقط خیلی نزدیک به جایی که کد کاربر برای اولین بار توسط <strong>framework</strong> اجرا می‌شود.</li>
</ol>
<p>aپاسخ صحیح: اعلام وابستگی‌ها به عنوان آرگومان‌های <strong>constructor</strong>، مشخص می‌کند که آن وابستگی‌ها چه هستند. <strong>Clients</strong> می‌توانند با بررسی آرگومان‌ها و انواع آنها، نحوه <strong>instantiate</strong> کردن یک <strong>service</strong> را کشف کنند. نیازی به تنظیم هیچ چیز دیگری غیر از خود <strong>object</strong> نیست. اگر تمام وابستگی‌ها را ارائه کرده‌اید، به چیز دیگری نیاز نخواهید داشت.</p>
<p>bاگرچه 1 می‌تواند مورد باشد، <strong>frameworks</strong> راهی را برای پیکربندی مجدد آن وابستگی‌ها ارائه می‌دهند تا نیازی به سیستم‌های خارجی نداشته باشند. پاسخ صحیح 2 است زیرا شما باید حداقل مقداری کار را انجام دهید تا <strong>context</strong> را قبل از اینکه بتوانید کد را اجرا کنید، آماده کنید.</p>
<p>cپاسخ صحیح: 1 و 5 وابستگی‌های <strong>service</strong> هستند که باید به عنوان آرگومان‌های <strong>constructor</strong> تزریق شوند. 2 اطلاعات زمینه‌ای است. 3 و 4 داده‌های خاص شغل هستند.</p>
<p>dپاسخ صحیح: وابستگی‌ها و مقادیر <strong>configuration</strong> باید به عنوان آرگومان‌های <strong>constructor</strong> تزریق شوند، سایر موارد باید به عنوان آرگومان‌های متد ارائه شوند.</p>
<p>eپاسخ صحیح: 2. کد اصلی همیشه باید از <strong>constructor injection</strong> استفاده کند. اما نقطه‌ای وجود دارد که در آن اولین <strong>service</strong> باید از <strong>container</strong> واکشی شود. این باید نزدیک به اولین کد کاربری باشد که <strong>framework</strong> اجرا می‌کند.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0152_original/original_page.png" alt="Original Page 152">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<p>این فصل شامل موارد زیر است:</p>
<ul>
<li>ایجاد یک لایه <strong>object-oriented</strong> در اطراف فراخوانی‌ها به <strong>services</strong> خارجی</li>
<li>معرفی <strong>abstractions</strong> مناسب برای فراخوانی <strong>services</strong> خارجی</li>
<li>ایجاد <strong>integration tests</strong> برای کدی که از <strong>services</strong> خارجی استفاده می‌کند</li>
</ul>
<p>ما فصل 4 را با یک <strong>use case extracted</strong> برای سفارش یک کتاب الکترونیکی به پایان رساندیم. یک جنبه مهم از آن <strong>use case</strong> هنوز وجود ندارد: محاسبه صحیح <strong>VAT</strong> (مالیات بر ارزش افزوده). محاسبه <strong>VAT</strong> یک موضوع بزرگ است، با قوانین زیاد، و همچنین استثنائات زیادی دارد. تلاش برای درست انجام دادن آن برای همه موقعیت‌های ممکن و همه کشورهای جهان، تلاش بسیار زیادی خواهد بود. با ایستادن در مقابل مقدار زیادی کار، ما باید گزینه‌های خود را در نظر بگیریم. به جای صرف زمان بسیار زیاد برای درست کردن هر جزئیات، ما می‌توانیم با محدود کردن تعداد موقعیت‌های احتمالی که <strong>application</strong> باید به آنها توجه کند، دامنه را کاهش دهیم. یا می‌توانیم راه‌حل را برون‌سپاری کنیم. این بدان معنا نیست که ما باید به یک تیم از توسعه‌دهندگان خارجی اجازه دهیم روی آن کار کنند. در عوض، ما باید استفاده از یک راه‌حل موجود را در نظر بگیریم. در مورد محاسبه <strong>VAT</strong> چندین <strong>web services</strong> وجود دارد که می‌تواند پاسخ‌هایی را که ما نیاز داریم به ما بدهد. در حال حاضر، بیایید از <code>vatapi.com</code> استفاده کنیم (به هیچ دلیل خاصی. من هم به هیچ وجه با آنها مرتبط نیستم).</p>
<p><strong>domain model</strong> قبلاً برای مقابله با <strong>VAT</strong> آماده شده است (<strong>Listing</strong> 6.1). یک <strong>object</strong> از نوع <strong>VatRate value</strong> وجود دارد که می‌توان از یک <strong>int</strong> ایجاد کرد، که درصد <strong>VAT</strong> را نشان می‌دهد (در حال حاضر این احتمال را نادیده می‌گیریم که نرخ <strong>VAT</strong> در واقع می‌تواند یک عدد اعشاری باشد). کلاس <strong>Order</strong> دارای یک آرگومان <strong>constructor</strong> اضافی است که یک <strong>object VatRate</strong> را می‌پذیرد. <strong>Order</strong> از این <code>VatRate</code> داخلی استفاده خواهد کرد</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0153_original/original_page.png" alt="Original Page 153">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<p>برای محاسبه مقدار <strong>VAT</strong> که باید دریافت شود.</p>
<p><strong>Listing</strong> 6.1. کلاس <code>VatRate</code> و نحوه استفاده از آن در <strong>constructor</strong> از نوع <code>Order</code>.</p>
<pre><code class="language-php">
final class VatRate
{
    public static function fromInt(int $percentage): self
    {
        // ...
    }
}
final class EbookOrderService
{
    // ...
    public function create(/* ... */): OrderId
    {
        // ...
        $vatRate = // ...
        $order = new Order(
            $orderId,
            $ebook-&gt;id(),
            $emailAddress,
            $orderQuantity,
            $ebook-&gt;priceInCents(),
            $vatRate
        );
        // ...
    }
}
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0154_original/original_page.png" alt="Original Page 154">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<h4> 6.1. Connecting to the external service</h4>
<p>خب، چگونه نرخ <strong>VAT</strong> را تعیین کنیم؟ با نگاهی به <strong>documentation</strong> از <code>vatapi.com</code>1 ما متوجه می‌شویم که یک <strong>endpoint API</strong> از نوع "<strong>VAT Rate Check</strong>" وجود دارد. آنها حتی چند نمونه نوشته شده در <strong>PHP</strong> ارائه می‌دهند. کپی کردن کد در <strong>service</strong> به ما یک ویژگی کم و بیش در حال کار می‌دهد، همانطور که در <strong>Listing</strong> 6.4 نشان داده شده است.</p>
<p><strong>Listing</strong> 6.2. <strong>EbookOrderService</strong> از <code>curl</code> برای واکشی یک نرخ <strong>VAT</strong> از <code>vatapi.com</code> استفاده می‌کند.</p>
<pre><code class="language-php">
public function create(/* ... */): OrderId
{
    // ...
    $curl = curl_init();

    /*
     * Search for TBE services (Telecommunications,
     * broadcasting &amp; electronic services).
     * Filter on "ebooks".
     * For now, let's use a hard-coded country code.
     */
    $url = 'https://eu.vatapi.com/v2/vat-rate-check?' .
        http_build_query(
            [
                'rate_type' =&gt; 'TBE',
                'country_code' =&gt; 'NL',
                'filter' =&gt; 'ebooks'
            ]
        );
    // @todo Inject the API key as a configuration value
    $apiKey = 'THE_SECRET_API_KEY';

    curl_setopt_array(
        $curl,
        [
            CURLOPT_URL =&gt; $url,
            CURLOPT_RETURNTRANSFER =&gt; true,
</code></pre>
<p>1 https://advwebapparch.com/vat-api-docs</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0155_original/original_page.png" alt="Original Page 155">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<pre><code class="language-php">
CURLOPT_ENCODING =&gt; "",
            CURLOPT_MAXREDIRS =&gt; 10,
            CURLOPT_TIMEOUT =&gt; 0,
            CURLOPT_FOLLOWLOCATION =&gt; false,
            CURLOPT_HTTP_VERSION =&gt; CURL_HTTP_VERSION_1_1,
            CURLOPT_CUSTOMREQUEST =&gt; 'GET',
            CURLOPT_HTTPHEADER =&gt; [
                'x-api-key: ' . $apiKey
            ]
        ]
    );

    $response = curl_exec($curl);
    $curlError = curl_error($curl);

    curl_close($curl);

    if ($curlError) {
        throw new RuntimeException('cURL Error #:' . $curlError);
    }

    $responseData = json_decode($response, true);

    if ($responseData['status'] === 200) {
        if ($responseData['filter_match']) {
            $vatRate = VatRate::fromInt(
                // The "ebooks" filter returned a match
                $responseData['rate']
            );
        } else {
            /*
             * The "ebooks" filter didn't return a match.
             * We should take the rate from the generic rates object.
             */
            $vatRate = VatRate::fromInt(
                $responseData['rates']['electronic']['rate']
            );
        }
    } else {
        throw new RuntimeException(
            'Could not determine the VAT rate'
        );
    }
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0156_original/original_page.png" alt="Original Page 156">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<pre><code class="language-php">
// ...
}
</code></pre>
<p>این کد زیادی است، و خود کد هم عالی به نظر نمی‌رسد، اما کار می‌کند. این خوب است، تا زمانی که شما فقط در حال "<strong>spiking</strong>" هستید - با کد و طراحی ور می‌روید، تا زمانی که بدانید چه کاری باید انجام دهید. اما رها کردن آن به این شکل برای قابلیت نگهداری طولانی‌مدت کد، واقعاً بد خواهد بود. یک مسئله طراحی این است که ما <strong>service</strong> را با انواع جزئیات سطح پایین آلوده کرده‌ایم. قرار بود <strong>EbookOrderService</strong> یک نمای کلی سطح بالایی از سناریوی <strong>use case</strong> که پیاده‌سازی می‌کند، ارائه دهد. اکنون بیشتر در مورد اتصال به یک <strong>service</strong> خارجی است. همه این کد واقعاً یک گام در این فرآیند را نشان می‌دهد: "نرخ <strong>VAT</strong> را که باید برای سفارش اعمال شود، تعیین کنید". ما باید در این فصل تمام تلاش خود را انجام دهیم تا کد را ساده کنیم تا زمانی که بتوانید این مرحله را با خواندن کد به وضوح تشخیص دهید.</p>
<p>مسئله دیگر این است که با برقراری تماس با یک <strong>service</strong> خارجی، ما اکنون گزینه‌های تست بسیار محدودی برای کلاس <code>EbookOrderService</code> داریم. ما دیگر نمی‌توانیم یک <strong>test</strong> مجزا برای آن بنویسیم، زیرا اجرای کد یک تماس شبکه واقعی ایجاد می‌کند. ما همچنین راهی برای آزمایش فقط فراخوانی <strong>service</strong> خارجی نداریم، به این معنی که ادغام ما با <code>vatapi.com</code> به <strong>use case</strong> ایجاد یک سفارش گره خورده است. این بدان معناست که ما نمی‌توانیم بدون دست زدن به <code>EbookOrderService</code> به یک <strong>service</strong> دیگر تغییر دهیم یا کد را در صورت تغییر قالب پاسخ <strong>API</strong> ارتقا دهیم.</p>
<p>در بخش‌های زیر، ما به تدریج وضعیت را بهبود می‌بخشیم تا به اهداف زیر برسیم:</p>
<ul>
<li><strong>EbookOrderService</strong> باید به <strong>use case</strong> سفارش یک کتاب الکترونیکی مربوط باشد، و فقط باید کدی برای مراحل سطح بالای آن <strong>use case</strong> داشته باشد. هر مرحله‌ای که ارتباطی با یک سیستم خارجی برقرار می‌کند، مانند <strong>database</strong> یا <strong>VAT API</strong>، باید قابل تعویض باشد تا <strong>service</strong> به صورت مجزا قابل آزمایش باشد.</li>
<li>جزئیات پیاده‌سازی سطح پایین اتصال به یک <strong>service</strong> خارجی برای تعیین نرخ <strong>VAT</strong> باید به یک کلاس متفاوت استخراج شود، که <strong>EbookOrderService</strong> می‌تواند از آن استفاده کند. ما می‌توانیم این کلاس را جداگانه آزمایش کنیم، بنابراین می‌دانیم که با <strong>service</strong> از راه دور <strong>API VAT</strong> واقعی به درستی کار می‌کند.</li>
</ul>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0157_original/original_page.png" alt="Original Page 157">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<p>چیزی که من را در مورد تمام آن فراخوانی‌های <code>curl_*</code> و <code>json_decode()</code> آزار می‌دهد این است که این یک کد رویه‌ای قدیمی است که امکانات زیادی را باز می‌گذارد و به انواع باگ‌ها اجازه می‌دهد بدون اینکه متوجه شوند از بین بروند. من معمولاً می‌خواهم از <strong>objects</strong> استفاده کنم و اجازه دهم این <strong>objects</strong> انواع بررسی‌ها را انجام دهند تا مطمئن شوند که داده‌ها خوب و ایمن هستند. اساساً آنچه من می‌خواهم، یک <strong>wrapper object-oriented</strong> در اطراف <strong>API</strong> از راه دور است. من با ایجاد یک <strong>object</strong> واحد که نشان دهنده <strong>API</strong> است، شروع به توسعه چنین لایه‌ای خواهم کرد، مانند کلاس <code>VatApi</code> در <strong>Listing</strong> 6.3. این به <strong>clients</strong> اجازه می‌دهد تا از <strong>web service</strong> استفاده کنند بدون اینکه نگران این باشند که درخواست‌های <strong>HTTP</strong> باید چگونه باشد. چنین کلاس <code>VatApi</code> می‌تواند متدی داشته باشد که نامی مشابه <strong>endpoint</strong> <strong>API</strong> داشته باشد. در مورد ما، کلاس متدی به نام <code>vatRateCheck()</code> دارد که مربوط به <strong>endpoint</strong> از نوع <code>/vat-rate-check</code> است. متد <code>vatRateCheck()</code>، درخواست <strong>HTTP</strong> واقعی را انجام می‌دهد، و از رمزگشایی پاسخ، از جمله <strong>error handling</strong> اولیه مراقبت می‌کند. پارامترهای <strong>query</strong> از نوع <code>rate_type</code>، <code>country_code</code>، و <code>filter</code> به پارامترهای متد ارتقا می‌یابند. توجه داشته باشید که <strong>API key</strong> به عنوان یک آرگومان <strong>constructor</strong> ارائه می‌شود، نه به عنوان یک آرگومان متد، زیرا این یک مقدار <strong>configuration</strong> است.</p>
<p><strong>Listing</strong> 6.3. <code>VatApi</code> تماس واقعی با <code>vatapi.com</code> را برقرار می‌کند.</p>
<pre><code class="language-php">
final class VatApi
{
    private string $apiKey;

    public function __construct(string $apiKey)
    {
        $this-&gt;apiKey = $apiKey;
    }

    public function vatRateCheck(
        string $rateType,
        string $countryCode,
        ?string $filter
    ): array {
        $curl = curl_init();

        $url = 'https://eu.vatapi.com/v2/vat-rate-check?' .
            http_build_query(
                [
                    'rate_type' =&gt; $rateType,
                    'country_code' =&gt; $countryCode,
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0158_original/original_page.png" alt="Original Page 158">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<pre><code class="language-php">
'filter' =&gt; $filter
            ]
        );

    curl_setopt_array(
        $curl,
        [
            // ...
            CURLOPT_HTTPHEADER =&gt; [
                'x-api-key: ' . $this-&gt;apiKey
            ]
        ]
    );

    // ...
    $responseData = json_decode($response, true);
    // ...
    return $responseData;
}
</code></pre>
<p>ما می‌توانیم این نوع <strong>object</strong> را یک <code>Facade2</code> بنامیم. این "یک <strong>interface</strong> سطح بالاتر را تعریف می‌کند که استفاده از زیرسیستم را آسان‌تر می‌کند". شما اغلب کلاس‌هایی مانند <code>VatApi</code> را در یک <strong>SDK</strong> (<strong>software development kit</strong>) پیدا خواهید کرد. یک فروشنده <strong>API</strong> گاهی اوقات اینها را به عنوان کتابخانه‌هایی خاص زبان برنامه‌نویسی ارائه می‌دهد. آنها به توسعه‌دهندگان اجازه می‌دهند تا از یک <strong>API</strong> طوری استفاده کنند که گویی یک <strong>service</strong> محلی است.</p>
<p>متد جدید <code>vatRateCheck()</code> به اندازه کافی عمومی است که در کلاس <code>EbookOrderService</code> ما قابل استفاده باشد، اما در حال حاضر خیلی کاربرپسند نیست. <strong>Clients</strong> داده‌های پاسخ خام را به عنوان یک <strong>array</strong> دریافت می‌کنند و باید نرخ <strong>VAT</strong> را به صورت دستی از این <strong>array</strong> استخراج کنند. مشکل <strong>arrays</strong> این است که شکل آنها تعریف نشده است. <strong>Clients</strong> نمی‌دانند چگونه می‌توانند اطلاعات مورد نیاز خود را از آن استخراج کنند. در <strong>application</strong> ما کدی شبیه این را پیدا می‌کنیم:</p>
<p><code>$responseData = $this-&gt;vatApi-&gt;vatRateCheck(</code></p>
<p>2John Vlissides; Erich Gamma; Ralph Johnson; Richard HelmDesign, “Patterns: Elements of Reusable Object-Oriented Software”, Addison-Wesley Professional (1994)</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0159_original/original_page.png" alt="Original Page 159">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<pre><code class="language-php">
'TBE',
            'NL',
            'ebooks'
        );

    if ($responseData['filter_match']) {
        // use $responseData['rate']
    } else {
        // use $responseData['rates']['electronic']['rate']
    }
</code></pre>
<p>این کد فقط برای <strong>API</strong> از راه دور خاصی که ما اکنون از آن استفاده می‌کنیم، کار می‌کند. یک مشکل بزرگتر این است که این کد ممکن است خطاهای <strong>PHP</strong> ایجاد کند. هیچ چیز در مورد نوع بازگشتی <strong>array</strong> وجود ندارد که به ما تضمین دهد که این کلیدها در واقع تعریف شده‌اند. بنابراین کاری که باید انجام دهیم این است که یک طرح کلی واضح از پاسخ تعریف کنیم و یک <strong>object</strong> را برگردانیم که این پاسخ را نشان می‌دهد. استفاده از <strong>objects</strong> آسان‌تر از یک <strong>array</strong> از داده‌ها است زیرا آنها مجموعه‌ای از متدهای از پیش تعریف شده دارند که می‌توانند بدون ترس استفاده شوند. <strong>Objects</strong> همچنین می‌توانند ورودی خود را پس از ساخت، اعتبارسنجی کنند، که استفاده از آنها را ایمن‌تر می‌کند.</p>
<p>بنابراین بیایید متد <code>vatRateCheck()</code> را با بازگرداندن به عنوان مثال یک <strong>object VatRateCheckResult</strong> بهبود بخشیم. این <strong>object</strong>، داده‌های پاسخ خام را به عنوان یک آرگومان <strong>constructor</strong> دریافت می‌کند، و <strong>getters</strong> را ارائه می‌دهد که می‌دانند چگونه اطلاعات درخواستی را از آن داده‌های پاسخ استخراج کنند (به <strong>Listing</strong> 6.4 مراجعه کنید).</p>
<p><strong>Listing</strong> 6.4. <code>vatRateCheck()</code> یک <strong>object VatRateCheckResult</strong> تخصصی را برمی‌گرداند.</p>
<pre><code class="language-php">
final class VatRateCheckResult
{
    private array $responseData;

    public function __construct(array $responseData)
    {
        $this-&gt;responseData = $responseData;
    }

    public function rate(string $fallbackType): int
    {
        if ($this-&gt;responseData['filter_match']) {
            return (int)$this-&gt;responseData['rate'];
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0160_original/original_page.png" alt="Original Page 160">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<pre><code class="language-php">
    return (int)$this-&gt;responseData['rates']
        [$fallbackType]['rate'];
}
</code></pre>
<p>من هنوز این کد را عالی نمی‌دانم. مسئله این است که از انواع <strong>primitive</strong> استفاده فراوان می‌کند (شما می‌توانید بگویید این کد، وسواس <strong>Primitive</strong>3 دارد). این کار استفاده از آن را واقعاً سخت می‌کند. <strong>Clients</strong> از <code>VatApi::vatRateCheck()</code> باید حدس بزنند که یک مقدار معتبر برای <code>$fallbackType</code>، <code>$rateType</code>، <code>$countryCode</code>، و <code>$filter</code> می‌تواند باشد. این یک سناریوی کلاسیک است که در آن معرفی برخی از <strong>value objects</strong> بسیار مفید خواهد بود. آنها به <strong>client</strong> کمک می‌کنند در حالی که مقادیر ممکن را که می‌توانند ارائه دهند، کشف می‌کنند. به عنوان مثال، <code>$rateType</code> می‌تواند به یک <strong>object Value</strong> از نوع <code>RateType</code>، با دو <strong>constructor</strong> نام‌گذاری شده ارتقا یابد، که آن را به یک نوع داده شبیه به <strong>enum</strong> تبدیل می‌کند (<strong>Listing</strong> 6.5).</p>
<p><strong>Listing</strong> 6.5. A <strong>value object</strong> for representing “rate types”.</p>
<pre><code class="language-php">
final class RateType
{
    private const GOODS = 'GOODS';
</code></pre>
<p>3Martin Fowler, “Refactoring: Improving the Design of Existing Code”, Addison-Wesley Pro- fessional (2018)</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0161_original/original_page.png" alt="Original Page 161">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<pre><code class="language-php">
private const TBE = 'TBE';
    private string $rateType;

    private function __construct(string $rateType)
    {
        $this-&gt;rateType = $rateType;
    }

    public static function goods(): self
    {
        return new self(self::GOODS);
    }

    /**
     * TBE stands for "Telecommunications, broadcasting,
     * and electronic services"
     */
    public static function tbe(): self
    {
        return new self(self::TBE);
    }
</code></pre>
<p>اما قبل از اینکه ما به طور تصادفی یک <strong>SDK</strong> کامل برای <code>vatapi.com</code> ایجاد کنیم، باید یک قدم به عقب برگردیم و به طراحی کلی در حال حاضر نگاهی بیندازیم. ما یک کلاس <code>VatApi</code> ایجاد کرده‌ایم که یک <strong>wrapper</strong> کم و بیش <strong>object-oriented</strong> را برای <code>vatapi.com</code> از راه دور ارائه می‌دهد. در واقع، ما اکنون می‌توانیم از <code>VatApi</code> به عنوان یک وابستگی در <code>EbookOrderService</code> استفاده کنیم و بیشتر جزئیات سطح پایین را به کلاس <code>VatApi</code> واگذاریم (به <strong>Listing</strong> 6.6 مراجعه کنید).</p>
<p><strong>Listing</strong> 6.6. The <strong>EbookOrderService</strong> could use the <strong>VatApi service</strong>.</p>
<pre><code class="language-php">
final class EbookOrderService
{
    // ...
    private VatApi $vatApi;

    public function __construct(
        // ...
        VatApi $vatApi
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0162_original/original_page.png" alt="Original Page 162">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<pre><code class="language-php">
) {
        // ...
        $this-&gt;vatApi = $vatApi;
    }
    public function create(/* ... */): OrderId
    {
        // ...
        $rateCheckResult = $this-&gt;vatApi-&gt;vatRateCheck(
            RateType::tbe(),
            'NL',
            'ebooks'
        );

        $vatRate = VatRate::fromInt(
            $rateCheckResult-&gt;rate('electronics')
        );
        // ...
    }
}
</code></pre>
<p>ما دیگر فراخوانی‌های <code>curl_*()</code> را در اطراف کد نمی‌بینیم. اما ما هنوز کلماتی مانند <code>vatRateCheck()</code>، <code>rateCheckResult</code> و یک <strong>constant string</strong> از نوع <code>'electronics'</code> در کد خود داریم، که برای <strong>business domain</strong> ما بیگانه هستند. تنها چیزی که ما در واقع به آن اهمیت می‌دهیم، نرخ <strong>VAT</strong> برای سفارش کتاب الکترونیکی ما است. بنابراین نسخه فعلی کد به واضح‌ترین شکل ممکن ارتباط برقرار نمی‌کند که کاری که ما در اینجا انجام می‌دهیم تعیین نرخ <strong>VAT</strong> صحیح برای سفارش است.</p>
<p>علاوه بر این، <code>EbookOrderService</code> مستقیماً به کلاس <code>VatApi</code> وابسته است (شکل 6.1).</p>
<p>شکل 6.1. <strong>EbookOrderService</strong> به <strong>VatApi</strong> وابسته است.</p>
<p>حتی اگر ما بیشتر جزئیات پیاده‌سازی را پشت این کلاس پنهان کرده‌ایم، خود کلاس <code>VatApi</code> هنوز بسیار خاص <strong>service</strong> از راه دور است</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 163" src="page_0163/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0163_original/original_page.png" alt="Original Page 163">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<p>که ما در اینجا استفاده می‌کنیم. تصور کنید به یک <strong>service API VAT</strong> متفاوت تغییر می‌کنید. این کار بدون دست زدن به کد در <code>EbookOrderService</code> غیرممکن خواهد بود. به احتمال زیاد، <strong>endpoints</strong> متفاوتی دارد که انواع مختلف پارامترهای <strong>query</strong> را با نام‌های مختلف می‌پذیرند.</p>
<p>این وضعیت در <strong>applications</strong> که با سیستم‌های خارجی صحبت می‌کنند، بسیار رایج است. بله، جزئیات پیاده‌سازی به خوبی در داخل <strong>objects</strong> دیگر پنهان شده‌اند. اما این <strong>objects</strong> دارای سطح مناسبی از <strong>abstraction</strong> نیستند، و این باعث می‌شود که تغییر پیاده‌سازی‌ها، خواه برای اهداف آزمایشی باشد، یا زمانی که شما واقعاً می‌خواهید به یک <strong>API</strong> از راه دور متفاوت تغییر دهید، غیرممکن شود.</p>
<h4> 6.2. Introducing an abstraction</h4>
<p>یک تکنیک بسیار قدرتمند برای اطمینان از صحیح بودن سطوح <strong>abstraction</strong>، جایگزینی وابستگی به یک کلاس واقعی با وابستگی به یک <strong>interface</strong> است. با این حال، <strong>interface</strong> نباید به سادگی از کلاس استخراج شود. اگر تنها کاری که ما انجام دادیم این بود که همه متدهای <code>VatApi</code> را در یک <strong>interface</strong> تعریف کنیم، وضعیت خیلی بهتر نمی‌شد. در واقع، هیچ چیز در مورد <code>EbookOrderService</code> و نحوه استفاده از نمونه <code>VatApi</code> تزریق شده (به <strong>Listing</strong> 6.7 مراجعه کنید) تغییر نخواهد کرد.</p>
<p><strong>Listing</strong> 6.7. استخراج یک <strong>interface</strong> از کلاس <code>VatApi</code> راه‌حل نیست.</p>
<pre><code class="language-php">
interface VatApi
{
    public function vatRateCheck(
        string $rateType,
        string $countryCode,
        ?string $filter
    ): VatRateCheckResult;
}

final class ActualVatApi implements VatApi
{
    public function vatRateCheck(
        string $rateType,
        string $countryCode,
        ?string $filter
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0164_original/original_page.png" alt="Original Page 164">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<pre><code class="language-php">
): VatRateCheckResult {
        // Connect to the remote API...
    }
}

final class EbookOrderService
{
    // Although VatApi is an interface now...
    private VatApi $vatApi;

    // ...
    public function create(/* ... */): OrderId
    {
        // ... Nothing changes here:
        $rateCheckResult = $this-&gt;vatApi-&gt;vatRateCheck(
            RateType::tbe(),
            'NL',
            'ebooks'
        );

        $vatRate = VatRate::fromInt(
            $rateCheckResult-&gt;rate('electronics')
        );
        // ...
    }
}
</code></pre>
<p>یک راه‌حل بهتر این است که نیاز خود را دوباره بیان کنیم و نشان دهیم که واقعاً در این مرحله به دنبال چه چیزی هستیم. اساساً، ما از یک <strong>service</strong> می‌خواهیم نرخ <strong>VAT</strong> صحیح را برای یک کتاب الکترونیکی برقرار کند. باید یک <strong>object</strong> دیگر وجود داشته باشد که بتواند آن اطلاعات را در اختیار ما قرار دهد. بیایید آن <strong>object</strong> را "<strong>VAT rate provider</strong>" بنامیم. به <strong>Listing</strong> 6.8 برای مثالی از نحوه استفاده <strong>EbookOrderService</strong> از چنین <strong>object</strong> مراجعه کنید.</p>
<p><strong>Listing</strong> 6.8. How <strong>EbookOrderService</strong> would use a “<strong>VAT rate provider</strong>”.</p>
<p><code>$vatRate = $this-&gt;vatRateProvider</code></p>
<p><code>-&gt;vatRateForSellingEbooksInCountry('NL');</code></p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0165_original/original_page.png" alt="Original Page 165">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<p>با تصور <strong>object</strong> و رفتار دقیقی که از آن می‌خواهیم، به سطح <strong>abstraction</strong> مناسب برای <code>EbookOrderService</code> رسیده‌ایم. این نشان می‌دهد که این <strong>service</strong> به چه چیزی نیاز دارد، با اصطلاحات خودش، نه بیشتر، و نه کمتر. اکنون که ما استفاده مورد نظر از این <strong>object vatRateProvider</strong> را تعریف کرده‌ایم، می‌توانیم یک <strong>interface</strong> برای آن تعریف کنیم. و از آنجایی که ما در حال حاضر یک پیاده‌سازی داریم که از <strong>service</strong> <code>vatapi.com</code> استفاده می‌کند، می‌توانیم یک پیاده‌سازی استاندارد برای <strong>interface</strong> نیز ارائه دهیم (به <strong>Listing</strong> 6.9 مراجعه کنید). آن پیاده‌سازی از <strong>façade VatApi</strong> موجود استفاده خواهد کرد، که آن را به عنوان یک آرگومان <strong>constructor</strong> دریافت می‌کند (همچنین به شکل 6.2 مراجعه کنید).</p>
<p><strong>Listing</strong> 6.9. The <strong>VatRateProvider interface</strong> and its standard implementa-tion.</p>
<pre><code class="language-php">
interface VatRateProvider
{
    public function vatRateForSellingEbooksInCountry(
        string $countryCode
    ): VatRate;
}

final class VatRateProviderUsingVatApiDotCom
    implements VatRateProvider
{
    private VatApi $vatApi;

    public function __construct(VatApi $vatApi)
    {
        $this-&gt;vatApi = $vatApi;
    }

    public function vatRateForSellingEbooksInCountry(
        string $countryCode
    ): VatRate {
        $rateCheckResult = $this-&gt;vatApi-&gt;vatRateCheck(
            RateType::tbe(),
            $countryCode,
            'ebooks'
        );

        return VatRate::fromInt(
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0166_original/original_page.png" alt="Original Page 166">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<pre><code class="language-php">
$rateCheckResult-&gt;rate('electronics')
        );
    }
}
</code></pre>
<p>شکل 6.2. <strong>EbookOrderService</strong> به <strong>VatRateProvider</strong> وابسته است.</p>
<p>تفاوت بزرگ بین <code>VatApi::vatRateCheck()</code> و <code>VatRateProvider::vatRateForSellingEbooksInCountry()</code> مقدار بازگشتی است. اولی یک <strong>object VatRateCheckResult</strong>، و دومی یک <strong>object VatRate</strong> را برمی‌گرداند. همیشه یک <strong>object</strong> از نوع <code>VatRate</code> وجود داشته است که ما واقعاً به دنبال آن بودیم، و تاکنون، ما فقط توانستیم آن را پس از عبور از موانع زیاد ایجاد کنیم. اکنون ما می‌توانیم نمونه مناسب <code>VatRate</code> را در یک فراخوانی واحد، با یک آرگومان واحد دریافت کنیم.</p>
<p>به جای وابستگی مستقیم به کلاس <code>VatApi</code>، <code>EbookOrderService</code> اکنون به "هر چیزی که می‌تواند نرخ <strong>VAT</strong> صحیح را برای اعمال هنگام فروش کتاب‌های الکترونیکی در کشور X به ما ارائه دهد" وابسته است. تا زمانی که وابستگی <strong>interface</strong> از نوع <code>VatRateProvider</code> را پیاده‌سازی کند، <strong>service</strong> باید خوشحال باشد. <code>EbookOrderService</code> فقط به "آنچه" که نیاز دارد اهمیت می‌دهد، نه به "چگونه" وابستگی واقعی آن را دریافت می‌کند. این بدان معناست که ما با موفقیت یک <strong>abstraction</strong> معرفی کرده‌ایم.</p>
<h4> 6.3. Architectural advantages</h4>
<p>معرفی یک <strong>abstraction</strong> یک تکنیک بسیار مفید است، زمانی که شما می‌خواهید جزئیات پیاده‌سازی سطح پایین را از دید خارج کنید، و در عوض بر مراحل سطح بالاتر یک سناریو تمرکز کنید. این یک تکنیکی است که شما اغلب از آن استفاده خواهید کرد</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 167" src="page_0167/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0167_original/original_page.png" alt="Original Page 167">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<p>شما می‌خواهید کد اصلی را از زیرساخت <strong>decouple</strong> کنید. معرفی <strong>abstractions</strong> چگونه به معماری <strong>application</strong> حاصل سود می‌رساند؟</p>
<p>در وهله اول، وابستگی به یک وابستگی که برای آن <strong>interface</strong> خاص خودمان را تعریف کرده‌ایم، به ما این امکان را می‌دهد که پیاده‌سازی پیش‌فرض آن را با حداقل مقدار کار جایگزین کنیم. اگر می‌خواهیم به یک <strong>API</strong> نرخ <strong>VAT</strong> جایگزین، شاید <code>taxtools.io</code>، تغییر دهیم، می‌توانیم به راحتی این کار را انجام دهیم. ما فقط <strong>SDK</strong> آنها را در پروژه خود قرار می‌دهیم (یا <strong>client API</strong> کوچکی را خودمان می‌نویسیم)، و ما یک پیاده‌سازی جدید از یک <code>VatRateProvider</code> را ارائه می‌کنیم که از آن <strong>client</strong> جدید استفاده می‌کند (به <strong>Listing</strong> 6.10 و شکل 6.3 مراجعه کنید).</p>
<p><strong>Listing</strong> 6.10. Switching to <code>taxtools.io</code> is easy.</p>
<pre><code class="language-php">
final class TaxTools
{
    public function rates(string $countryCode): Rates
    {
        // ...
    }
}
final class VatRateProviderUsingTaxToolsIO
    implements VatRateProvider
{
    private TaxTools $taxTools;

    public function __construct(TaxTools $taxTools)
    {
        $this-&gt;taxTools = $taxTools;
    }

    public function vatRateForSellingEbooksInCountry(
        string $countryCode
    ): VatRate {
        return $this-&gt;taxTools-&gt;rates($countryCode)
            -&gt;rateFor('ebooks');
    }
}
</code></pre>
<p>ما حتی نیازی به دست زدن به <code>EbookOrderService</code> نداریم. آن متوجه هیچ چیزی در مورد تغییر در پس‌زمینه نمی‌شود، زیرا به <strong>interface</strong> وابسته است، و</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0168_original/original_page.png" alt="Original Page 168">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<p>شکل 6.3. افزودن یک پیاده‌سازی جایگزین برای <code>VatRateProvider</code>.</p>
<p><strong>interface</strong> هنوز هم یکسان است (<strong>Listing</strong> 6.11).</p>
<p><strong>Listing</strong> 6.11. اگر ما به یک <strong>provider VAT rate</strong> متفاوت تغییر دهیم، هیچ چیز در داخل <code>EbookOrderService</code> تغییر نمی‌کند.</p>
<pre><code class="language-php">
final class EbookOrderService
{
    // ...
    private VatRateProvider $vatRateProvider;

    public function __construct(
        // ...
        VatRateProvider $vatRateProvider
    ) {
        // ...
        $this-&gt;vatRateProvider = $vatRateProvider;
    }

    public function create(/* ... */): OrderId
    {
        // ...
</code></pre>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 169" src="page_0169/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0169_original/original_page.png" alt="Original Page 169">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<pre><code class="language-php">
$vatRate = $this-&gt;vatRateProvider
            -&gt;vatRateForSellingEbooksInCountry('NL');
        // ...
    }
}
</code></pre>
<p>این ممکن است در لحظه‌ای که متوجه می‌شویم <strong>service</strong> که در حال حاضر از آن استفاده می‌کنیم در واقع خیلی خوب نیست، یا وقتی معلوم می‌شود که نمی‌تواند تمام پاسخ‌هایی را که ما نیاز داریم به ما بدهد، مفید باشد. یا شاید، شما متوجه شوید که فراخوانی یک <strong>service</strong> خارجی یک خطر واقعی برای <strong>responsiveness</strong> از <strong>application</strong> شما است، و شما می‌خواهید یک لیست محلی از نرخ‌های <strong>VAT</strong> را نگه دارید. به این معنا، معرفی <strong>abstractions</strong> یک ابزار معماری است. با استفاده از آن، شما می‌توانید انعطاف‌پذیری را برای سال‌های آینده ایجاد کنید. شما می‌توانید با یک راه‌حل ارزان برای پیاده‌سازی شروع کنید، خواه یک <strong>service</strong> خارجی باشد که در حال حاضر این کار را انجام می‌دهد، یا یک فایل <strong>JSON</strong> که به صورت محلی ذخیره شده است. شما همیشه می‌توانید در زمان مناسب "ارتقا" دهید.</p>
<p>به پیاده‌سازی‌های ممکن دیگر فکر کنید</p>
<p>هنگامی که شما <strong>abstractions</strong> را برای وابستگی‌های <strong>service</strong> خود معرفی می‌کنید، مطمئن شوید که در واقع پیاده‌سازی‌های جایگزین ممکن را در نظر می‌گیرید. گاهی اوقات <strong>interface</strong> که در نظر دارید، هنوز هم به پیاده‌سازی که قبلاً برای آن دارید، بیش از حد وابسته است. در نظر بگیرید که آیا <strong>interface</strong> هنوز هم در صورت تغییر به یک <strong>web service</strong> متفاوت یا زمانی که شروع به استفاده از یک جدول <strong>database</strong> به جای یک <strong>service</strong> از راه دور می‌کنید، مفید خواهد بود یا خیر. اغلب جزئیات کمی در مورد پیاده‌سازی اساسی به یک <strong>interface</strong> نفوذ می‌کنند و آن را به یک <strong>abstraction</strong> کمتر قدرتمند تبدیل می‌کنند. به عنوان مثال <strong>interface VatRateProvider</strong> جایگزین در <strong>Listing</strong> 6.12 را در نظر بگیرید.</p>
<p><strong>Listing</strong> 6.12. This <strong>interface</strong> offers a leaky <strong>abstraction</strong>.</p>
<pre><code class="language-php">
interface VatRateProvider
{
    public function vatRateForCountry(
        string $countryCode,
        string $filter
    ): VatRate;
}
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0170_original/original_page.png" alt="Original Page 170">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<p>این یک متد عمومی‌تر، احتمالاً قابل استفاده مجددتر نسبت به متدی است که قبلاً پیشنهاد کردیم. این جنبه خاص "کتاب الکترونیکی" را از متد اصلی حذف می‌کند: <code>vatRateForSellingEbooksInCountry()</code>. اما یک پارامتر اضافی معرفی می‌کند که آن را به پیاده‌سازی مبتنی بر <code>vatapi.com</code> ما متصل می‌کند. به احتمال زیاد، پارامتر <code>$filter</code> پس از اینکه ما از <code>vatapi.com</code> دور شدیم و شروع به استفاده از یک <strong>API</strong> دیگر کردیم، هیچ استفاده‌ای نخواهد داشت. شاید ما حتی باید نتیجه بگیریم که خاص بودن کتاب الکترونیکی یک مزیت از <strong>interface</strong> بود، زیرا جنبه فیلترینگ را در خود نام متد کدگذاری کرده بود. این به کلاس پیاده‌سازی اجازه می‌دهد تا خود از فیلترینگ واقعی مراقبت کند، بدون اینکه <strong>client</strong> نگران آن باشد.</p>
<h4> 6.4. Testing</h4>
<p>تا کنون ما چندین نمونه از تقسیم کد اصلی و کد زیرساخت را دیده‌ایم. ما همچنین دیده‌ایم که چگونه انجام این کار بر <strong>tests</strong> که برای کد خود ایجاد می‌کنید، تأثیر می‌گذارد. کد اصلی کدی است که از <strong>IO</strong> (شبکه، سیستم فایل و غیره) استفاده نمی‌کند. بنابراین، کد را می‌توان به طور کامل در انزوا آزمایش کرد. شما به هیچ راه‌اندازی خاصی نیاز ندارید. کافی است <strong>object</strong> را نمونه‌سازی کنید، یک متد را روی آن فراخوانی کنید و نتیجه را با آنچه انتظار دارید مقایسه کنید. این <strong>tests</strong> بازخورد سریع را در حین توسعه کد به شما می‌دهند. آنها به دلایل عجیب و غریب شکست نمی‌خورند، مانند مشکلات <strong>concurrency</strong>، یا یک <strong>service</strong> از راه دور که از کار افتاده است یا به روش‌های غیرمنتظره‌ای پاسخ می‌دهد. شما فقط در حال انجام دستکاری روی داده‌ها در حافظه هستید، که یک فرآیند قطعی است.</p>
<p>این ویژگی‌های <strong>tests</strong> جدا شده بسیار مطلوب هستند. شما می‌خواهید تعداد کلاس‌هایی را که می‌توانند مانند این آزمایش شوند، به حداکثر برسانید. جدا کردن کد اصلی از کد زیرساخت بهترین راه برای انجام این کار است. همیشه به دنبال آن بخش از منطق باشید که می‌توانید آن را به طور جداگانه آزمایش کنید و آن را به کلاس خود استخراج کنید. ما این فصل را با از بین بردن گزینه‌های خود برای آزمایش شروع کردیم، زیرا ما همه آن فراخوانی‌های <code>curl_*()</code> را درست در داخل <code>EbookOrderService</code> داشتیم. استخراج آن فراخوانی‌ها به یک کلاس جداگانه، <strong>service VatApi</strong>، ایده خوبی بود، اما هنوز چیزهای بیشتری برای آزمایش به صورت مجزا به ما نداد. تنها زمانی که ما یک <strong>abstraction</strong> برای ارائه نرخ <strong>VAT</strong> معرفی کردیم، ما به یک <code>EbookOrderService</code> قابل آزمایش بازگشتیم. هنگام آزمایش این کلاس، اکنون می‌توانیم به راحتی یک <strong>test double</strong> برای <strong>interface VatRateProvider</strong> ارائه دهیم. <strong>Listing</strong> 6.13 نشان می‌دهد که این چگونه خواهد بود. این از یک <strong>ac-</strong></p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0171_original/original_page.png" alt="Original Page 171">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<p>ایجاد اتصال شبکه واقعی را از ایجاد در حین آزمایش رفتار <code>EbookOrderService</code> جلوگیری می‌کند.</p>
<p><strong>Listing</strong> 6.13. When testing <code>EbookOrderService</code> we can easily define a test double for <code>VatRateProvider</code>.</p>
<pre><code class="language-php">
final class EbookOrderServiceTest extends TestCase
{
    /**
     * @test
     */
    public function it_creates_an_ebook_order(): void
    {
        $vatRateProvider = $this-&gt;createMock(VatRateProvider::class);
        $vatRateProvider
            -&gt;expects($this-&gt;any())
            -&gt;method('vatRateForSellingEbooksInCountry')
            -&gt;with('NL')
            -&gt;willReturn(VatRate::fromInt(21));
        $service = new EbookOrderService(
            /* ... */
            $vatRateProvider
        );
        $service-&gt;create(/* ... */);
        // ...
    }
}
</code></pre>
<p>این عالی است، اما اکنون تمام کد در کلاس‌های <code>VatRateProviderUsingVatApiDotCom</code> و <code>VatApi</code> آزمایش نشده باقی می‌ماند (شکل 6.4).</p>
<p>این یک وضعیت بد است، زیرا ما دیگر نمی‌توانیم مطمئن باشیم که کد صحیح است، و به خوبی با <strong>API endpoint</strong> از <code>vatapi.com</code> واقعی همکاری می‌کند. با این حال، ما نمی‌توانیم یک <strong>unit test</strong> برای ادغام <code>vatapi.com</code> بنویسیم، زیرا ما به اینترنت نیاز داریم، به این معنی که <strong>test</strong> از <strong>IO</strong> استفاده می‌کند و بنابراین دیگر نمی‌توان آن را یک <strong>unit test</strong> نامید.</p>
<p>بیایید نوع تستی را که برای کلاس <code>VatRateProviderUsingVatApiDotCom</code> می‌نویسیم، یک <strong>integration test</strong> بنامیم. چنین <strong>integration test</strong> می‌تواند ثابت کند که ما کدی نوشته‌ایم که:</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0172_original/original_page.png" alt="Original Page 172">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<p>شکل 6.4. معرفی یک <strong>abstraction</strong>، <strong>EbookOrderService</strong> را به صورت مجزا قابل آزمایش می‌کند، اما <code>VatApi</code> را آزمایش نشده باقی می‌گذارد.</p>
<ol>
<li>یک پیاده‌سازی صحیح و کامل از <strong>interface</strong> که برای آن تعریف کرده‌ایم</li>
<li>به درستی با <strong>service</strong> خارجی ادغام می‌شود</li>
</ol>
<p>هنگامی که ما می‌توانیم این را ثابت کنیم، می‌توانیم مطمئن باشیم که هر <strong>client</strong> که به یک <code>VatRateProvider</code> نیاز دارد می‌تواند با خیال راحت از کلاس <code>VatRateProviderUsingVatApiDotCom</code> ما استفاده کند (شکل 6.5). <strong>Listing</strong> 6.14 یک <strong>test</strong> را نشان می‌دهد که نشان می‌دهد که یک <strong>object VatRateProviderUsingVatApiDotCom</strong> قادر است نرخ <strong>VAT</strong> صحیح را برای کتاب‌های الکترونیکی فروخته شده در هلند ارائه دهد.</p>
<p><strong>Listing</strong> 6.14. An integration test for <strong>VatRateProviderUsingVatApiDotCom</strong>.</p>
<pre><code class="language-php">
final class VatRateProviderUsingVatApiDotComTest extends TestCase
{
    /**
     * @test
     */
    public function it_provides_the_dutch_vat_rate(): void
    {
        $provider = new VatRateProviderUsingVatApiDotCom(
            new VatApi('TEST_API_KEY')
</code></pre>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 173" src="page_0173/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0173_original/original_page.png" alt="Original Page 173">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<pre><code class="language-php">
        );
        self::assertEquals(
            VatRate::fromInt(21),
            $provider-&gt;vatRateForSellingEbooksInCountry('NL')
        );
    }
}
</code></pre>
<p>شکل 6.5. آزمایش هر دو <code>EbookOrderService</code> و پیاده‌سازی <strong>interface VatRateProvider</strong>.</p>
<p>هنوز هم شبیه به یک <strong>unit test</strong> به نظر می‌رسد زیرا این همان <strong>test framework</strong> است که این تست را اجرا می‌کند. اما به دلیل نوع کدی که اجرا می‌کند، این قطعاً یک <strong>integration test</strong> است. من توصیه می‌کنم که <strong>test</strong> را به این شکل علامت‌گذاری کنید، یا با افزودن یک <strong>annotation</strong> به کلاس <strong>test</strong> (به عنوان مثال. <code>@group integration</code>) یا با تعریف یک <strong>test suite</strong> اختصاصی برای <strong>integration tests</strong> (به <strong>Listing</strong> 6.15 مراجعه کنید).</p>
<p><strong>Listing</strong> 6.15. Define a separate test suite for <strong>integration tests</strong> in <code>phpunit.xml</code>.</p>
<pre><code class="language-xml">
<?xml version="1.0" encoding="UTF-8"?>
<phpunit>
    <testsuites>
        <testsuite name="Unit tests">
            <directory>./test/unit</directory>
        </testsuite>
        <testsuite name="Integration tests">
</testsuite></testsuites></phpunit></code></pre>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 174" src="page_0174/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0174_original/original_page.png" alt="Original Page 174">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<pre><code class="language-xml">
<directory>./test/integration</directory>
        
    

</code></pre>
<p><strong>test</strong> برای <code>VatRateProviderUsingVatApiDotCom</code> نشان می‌دهد که به عنوان یک پیاده‌سازی مناسب از <strong>interface VatProvider</strong> عمل می‌کند. این متد، فراخوانی آن تابع را با نوع پاسخ صحیح برمی‌گرداند. ممکن است جنبه‌های دیگری وجود داشته باشد که شما مایل به تأیید آنها در یک <strong>integration test</strong> مانند این باشید. شاید <strong>interface</strong> یک نوع <strong>exception</strong> خاص را تعریف کند که در صورت شکست پرتاب می‌شود.</p>
<p>در این صورت، شما باید یک تست اضافی اضافه کنید که آن شکست را شبیه‌سازی می‌کند، و تأیید می‌کند که <strong>exception</strong> مورد انتظار در واقع پرتاب خواهد شد.</p>
<p>همانطور که ممکن است متوجه شده باشید، ما یک <strong>integration test</strong> اختصاصی برای کلاس <code>VatApi</code> نداریم. ما فقط رفتار آن را به عنوان یک وابستگی از کلاس <code>VatRateProviderUsingVatApiDotCom</code> آزمایش می‌کنیم. اینکه آیا شما باید یک <strong>integration test</strong> برای <code>VatApi</code> به تنهایی بنویسید، بستگی به موارد زیر دارد:</p>
<ul>
<li>اینکه آیا کلاس <code>VatApi</code> توسط <strong>clients</strong> دیگر نیز استفاده می‌شود یا خیر.</li>
<li>اینکه آیا کلاس <code>VatApi</code> متدها یا مسیرهای اجرای دیگری دارد که مشکل‌ساز هستند که فقط به طور غیرمستقیم از طریق تست <code>VatRateProviderUsingVatApiDotCom</code></li>
</ul>
<p>این موارد معمولاً با هم مرتبط هستند: اگر <code>VatApi</code> بیشتر شبیه یک کلاس <strong>library</strong> است، که توسط <strong>clients</strong> مختلف استفاده می‌شود، رفتارهای دیگری خواهد داشت که نباید فقط از طریق <code>VatRateProviderUsingVatApiDotCom</code> آزمایش شوند. در مورد ما، کلاس <code>VatApi</code> احتمالاً منطق خاصی برای رسیدگی به خرابی‌های اتصال، اعتبارسنجی پاسخ <strong>API</strong> و غیره دارد. آزمایش <strong>edge cases</strong> و شاخه‌های اجرای عجیب و غریب‌تر از طریق یک کلاس دیگر غیر از خود <code>VatApi</code> احتمالاً ناخوشایند است. به همین دلیل نوشتن یک <strong>integration test</strong> جداگانه برای <code>VatApi</code> به تنهایی منطقی است. در این صورت، <strong>integration test</strong> برای <code>VatRateProviderUsingVatApiDotCom</code> می‌تواند بسیار کوچک باشد، فقط با یک یا دو متد <strong>test</strong>، و <strong>integration test</strong> برای <code>VatApi</code> می‌تواند مفصل‌تر باشد. به <strong>Listing</strong> 6.16 برای یک مثال مراجعه کنید.</p>
<p><strong>Listing</strong> 6.16. An integration test for the <strong>VatApi class</strong>.</p>
<pre><code class="language-php">
final class VatApiTest extends TestCase
{
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0175_original/original_page.png" alt="Original Page 175">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<pre><code class="language-php">
/**
     * @test
     */
    public function it_does_a_vat_check_for_TBE_sold_in_NL(): void
    {
        $vatApi = new VatApi('TEST_API_KEY');

        $result = $vatApi-&gt;vatRateCheck(
            RateType::tbe(),
            'NL',
            null
        );

        self::assertEquals(
            VatRate::fromInt(21),
            $result-&gt;rate('telecom')
        );
    }
}
</code></pre>
<p><strong>test</strong> برای <code>VatApi</code> سطح پایین‌تری دارد، زیرا به تماس <strong>API</strong> واقعی نزدیک‌تر است. این به شما امکان می‌دهد تغییرات بیشتری را آزمایش کنید. به عنوان مثال، در اینجا می‌توانید آرگومان‌های مختلفی را برای <code>$countryCode</code> یا <code>$rateType</code> امتحان کنید. شما می‌توانید مکانیسم برای "نوع نرخ <strong>fallback</strong>" را آزمایش کنید. و شما می‌توانید <code>VatApi</code> را با جلوگیری از آرگومان‌های نامعتبر، مانند یک کد کشور ناشناخته یا یک <strong>API key</strong> بد، قوی‌تر کنید.</p>
<p>“آیا این <strong>tests</strong> کند و شکننده نخواهند بود؟”</p>
<p>مشکل <strong>integration tests</strong> این است که آنها به دلایلی که خارج از کنترل شما هستند، شکست می‌خورند. شبکه ممکن است قابل اعتماد نباشد، <strong>servers</strong> از <code>vatapi.com</code> گاهی اوقات آفلاین می‌شوند، ممکن است یک روز کسی یک نسخه خراب از <strong>API</strong> را مستقر کند و غیره. این بار دیگر نیاز به <strong>tests</strong> (<strong>unit</strong>) پایدار تا حد امکان را ثابت می‌کند. اما شما هنوز هم باید این <strong>integration tests</strong> را داشته باشید که گاهی اوقات شکست می‌خورند. گزینه‌های مختلفی وجود دارد، که برخی از آنها ممکن است جایگزین کردن <strong>service</strong> خارجی واقعی با یک <strong>service</strong> مشابه باشد که به صورت محلی و با قابلیت اطمینان بیشتری اجرا می‌شود. یک گزینه دیگر این است که این <strong>tests</strong> را به طور خودکار دوباره امتحان کنید، یا به آنها اجازه دهید بدون شکست کل <strong>build</strong> شکست بخورند. شما می‌توانید</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0176_original/original_page.png" alt="Original Page 176">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<p>این را با برچسب‌گذاری یا گروه‌بندی آنها، یا نگه داشتن آنها در یک <strong>test suite</strong> جداگانه، انجام دهید. اطمینان حاصل کنید که خود کد، گزارش‌های دقیقی در مورد شکست‌ها ارائه می‌دهد، بنابراین شما به طور تصادفی مسائل مهمی را نادیده نخواهید گرفت، مانند زمانی که یک <strong>service</strong> خارجی یک تغییر <strong>breaking</strong> را در <strong>API</strong> خود معرفی کرده است. شما پیشنهادات بیشتری را برای بهبود <strong>tests</strong> غیرقابل اعتماد در "<strong>xUnit Test Patterns: Refactoring Test Code</strong>" اثر <strong>Gerard Meszaros</strong>، <strong>Addison-Wesley Professional</strong> (2007) پیدا خواهید کرد.</p>
<p>مشاوره برای استخراج تا حد امکان کد قابل آزمایش <strong>unit</strong> نیز در اینجا صدق می‌کند. به عنوان مثال، متد <code>VatApi::vatRateCheck()</code> را در نظر بگیرید. مقدار بازگشتی آن یک <strong>object VatRateCheckResult</strong> است. این شامل تمام منطق برای تفسیر داده‌های پاسخ و بازگرداندن مقادیر درخواستی از آن است (به <strong>Listing</strong> 6.17 مراجعه کنید)</p>
<p><strong>Listing</strong> 6.17. <code>VatRateCheckResult</code> again.</p>
<pre><code class="language-php">
final class VatRateCheckResult
{
    private array $responseData;

    public function __construct(array $responseData)
    {
        $this-&gt;responseData = $responseData;
    }

    public function rate(string $fallbackType): int
    {
        if ($this-&gt;responseData['filter_match']) {
            return (int)$this-&gt;responseData['rate'];
        }

        return (int)$this-&gt;responseData['rates']
            [$fallbackType]['rate'];
    }
}
</code></pre>
<p>مسیرهای اجرای مختلف در <code>rate()</code> نباید از طریق یک <strong>integration test</strong> آزمایش شوند. شما برای تأیید اینکه این منطق کار می‌کند، به یک اتصال شبکه نیاز ندارید. در عوض، یک <strong>unit test</strong> کافی خواهد بود (به <strong>Listing</strong> 6.18 مراجعه کنید).</p>
<p><strong>Listing</strong> 6.18. A unit test for <strong>VatRateCheckResult</strong>.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0177_original/original_page.png" alt="Original Page 177">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<pre><code class="language-php">
final class VatRateCheckResultTest extends TestCase
{
    /**
     * @test
     */
    public function it_uses_the_filter_rate(): void
    {
        $result = new VatRateCheckResult(
            [
                'filter_match' =&gt; true,
                'rate' =&gt; 21.0,
                'rates' =&gt; [
                    'telecom' =&gt; [
                        'rate' =&gt; 6.0
                    ]
                ]
            ]
        );

        self::assertEquals(
            21.0,
            $result-&gt;rate('telecom')
        );
    }

    /**
     * @test
     */
    public function it_uses_the_fallback(): void
    {
        $result = new VatRateCheckResult(
            [
                'filter_match' =&gt; false,
                'rates' =&gt; [
                    'telecom' =&gt; [
                        'rate' =&gt; 6.0
                    ]
                ]
            ]
        );
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0178_original/original_page.png" alt="Original Page 178">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<pre><code class="language-php">
        self::assertEquals(
            6.0,
            $result-&gt;rate('telecom')
        );
    }
}
</code></pre>
<p>این، دوباره، یک <strong>test</strong> با جزئیات بیشتر را معرفی می‌کند که به شما امکان می‌دهد تغییرات زیادی را در آرگومان‌های <strong>constructor</strong> و متد آزمایش کنید. <strong>Tests</strong> با <strong>course-grained</strong> بیشتر مانند <strong>test</strong> برای خود <code>VatApi</code>، فقط باید یک یا دو مورد از رایج‌ترین مسیرهای اجرا را آزمایش کنند. جزئیات در یک <strong>unit test</strong> تأیید می‌شود. مطمئن شوید که همیشه به دنبال فرصت‌هایی مانند این هستید، که در آن می‌توانید بخشی از کد زیرساخت را استخراج کنید و <strong>unit tests</strong> را برای آن بنویسید.</p>
<p>“اگر <code>VatApi</code> در واقع بخشی از <strong>SDK API</strong> رسمی، یا برخی <strong>library</strong> دیگر بود چطور؟”</p>
<p>آیا هنوز هم باید <strong>integration tests</strong> خود را برای آن بنویسید؟ برای یافتن پاسخ، شما باید به کد آنها نگاه کنید. آیا خوب نوشته شده است؟ آیا به خوبی آزمایش شده است؟ سپس، البته، شما نیازی به نوشتن <strong>tests</strong> خود برای کلاس‌های آنها ندارید. اگر شما به موارد خاصی متکی هستید که توسط <strong>tests</strong> آنها پوشش داده نشده است، یا اگر آنها هیچ <strong>tests</strong> ندارند، خودتان آنها را بنویسید. به این ترتیب، شما می‌توانید فرضیات خود را در مورد کد آنها تأیید کنید. و هر زمان که آنها کد خود را تغییر دهند، شما خواهید دانست که آیا آنها چیزی را برای شما خراب کرده‌اند یا خیر.</p>
<p>بنابراین ممکن است لازم باشد <strong>integration tests</strong> خود را برای کد <strong>client API</strong> مانند <code>VatApi</code> بنویسید یا نه. اما برای کلاس‌هایی که پیاده‌سازی‌های <strong>abstractions</strong> خودتان هستند، شما همیشه باید <strong>integration tests</strong> ارائه دهید. چه این پیاده‌سازی از یک وابستگی شخص ثالث استفاده کند یا نه، شما همیشه باید نشان دهید که پیاده‌سازی شما یک پیاده‌سازی مناسب برای <strong>interface</strong> است که شما تعریف کرده‌اید.</p>
<h4> 6.5. Summary</h4>
<p>در این فصل ما به ادغام <strong>use case</strong> خود با یک <strong>service</strong> خارجی برای تعیین نرخ‌های <strong>VAT</strong> نگاه کردیم. چسباندن کد <strong>integration</strong> به طور مستقیم در</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0179_original/original_page.png" alt="Original Page 179">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> External services</h3>
<p><code>EbookOrderService</code> آن را کارآمد کرد، اما ما را با یک طراحی بد رها کرد. ما جزئیات ارتباط سطح پایین را به یک کلاس <strong>service</strong> جداگانه منتقل کردیم. این ما را با یک <strong>client API</strong>، یا <strong>Facade</strong>، به نام <code>VatApi</code> رها کرد، که می‌توانست به عنوان یک وابستگی تزریق شود، اما نمی‌توانست با چیز دیگری جایگزین شود. وابستگی مستقیم به یک کلاس، آینده <strong>service</strong> را به خطر می‌اندازد، اما <strong>testability</strong> آن را نیز کاهش می‌دهد. ما یک <strong>abstraction</strong> مناسب را معرفی کردیم تا بر این مشکلات غلبه کنیم، و ما را با یک <strong>interface VatRateProvider</strong> و یک پیاده‌سازی استاندارد، که از <strong>client VatApi</strong> که از قبل داشتیم، استفاده می‌کند. وضعیت آزمایش بسیار بهتر است، زیرا <strong>clients</strong> از <code>VatRateProvider</code> اکنون می‌توانند به راحتی یک <strong>test double</strong> برای آن تنظیم کنند. این بدان معناست که <code>EbookOrderService</code> یک بار دیگر به صورت مجزا قابل آزمایش است. هر پیاده‌سازی از <strong>interface</strong> هنوز به <strong>integration test</strong> خود نیاز دارد.</p>
<p>به عنوان بخشی از اجرای چنین تستی، پیاده‌سازی یک تماس واقعی با <strong>service</strong> از راه دور برقرار می‌کند تا تأیید کند که فرضیات آن در مورد <strong>service</strong> خارجی درست است، و اینکه کلاس یک پیاده‌سازی صحیح از <strong>interface</strong> است.</p>
<p><strong>Exercises</strong></p>
<p>1. روش صحیح برای انتزاع فراخوانی <strong>services</strong> خارجی چیست؟a</p>
<ol>
<li>به جای توابع <code>curl_*</code> از یک <strong>abstraction client HTTP</strong> استفاده کنید.</li>
<li>یک کلاس <strong>abstract</strong> معرفی کنید که می‌توانید به آن وابسته باشید. زیر کلاس می‌تواند کار واقعی را انجام دهد.</li>
<li>یک <strong>interface</strong> و یک پیاده‌سازی معرفی کنید که تماس واقعی را برقرار می‌کند.</li>
</ol>
<p>2. یک <strong>test</strong> خوب برای فهمیدن اینکه آیا شما به سطح مناسب <strong>abstraction</strong> برای یک وابستگی <strong>service</strong> رسیده‌اید، چیست؟b</p>
<ol>
<li>اگر بتوانید یک <strong>test double</strong> برای آن ایجاد کنید، یک <strong>abstraction</strong> خوب است.</li>
<li>اگر جزئیات پیاده‌سازی به طور اساسی تغییر کند، یک <strong>abstraction</strong> خوب است.</li>
</ol>
<p>3. اگر یک <strong>object</strong> با یک <strong>service</strong> خارجی ارتباط برقرار می‌کند، شما باید چه نوع تستی برای آن بنویسید؟c</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0180_original/original_page.png" alt="Original Page 180">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3>6. External services</h3>
<p>
<strong>1. A unit test</strong>
</p>
<p>
<strong>2. An integration test</strong>
</p>
<p>
   a. Correct answer: 3. An HTTP client abstraction is useful, but still forces the client
   to deal with low-level details, like where to make the request to, or what the
   response looks like. An abstract class is a step in the right direction, but only an
   interface is abstract enough to give you the flexibility you need.
  </p>
<p>
   b. Correct answer: 2. Being able to create a test double is a requirement for test-
   ing the client of the abstraction in isolation. Often the need for isolated testing
   is actually the reason we introduce an abstraction. But the true test for an ab-
   straction is when you imagine or actually write an alternative implementation
   where the underlying technology is a completely different one. For instance
   when you switch from a remote service to a locally stored JSON file. If the ab-
   straction survives such a switch and still works, it’s a good one.
  </p>
<p>
   c. Correct answer: 2. A unit test is an isolated test. Given that the object connects to
   an external service, if you write a unit test for it, you somehow have to prevent
   it from actually communicating with the external service. But then you don’t
   know if your code works well with the actual service. You need an integration
   test to prove that.
  </p>
<p>
   161
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0181_original/original_page.png" alt="Original Page 181">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<p>این فصل شامل موارد زیر است:</p>
<ul>
<li>ارائه زمان فعلی و داده‌های تصادفی به عنوان آرگومان‌های متد</li>
<li>معرفی <strong>abstractions</strong> برای ایجاد زمان فعلی و داده‌های تصادفی</li>
<li>تنظیم یک مکان مرکزی برای تعیین زمان فعلی</li>
</ul>
<p>تا کنون ما به راه‌های آشکاری نگاه می‌کردیم که در آن یک <strong>application</strong> به چیزی در دنیای بیرون دسترسی پیدا می‌کند. اتصال به یک <strong>database</strong>، سیستم فایل یا یک <strong>web service</strong> خارجی؛ کدی که تمام این کارها را انجام می‌دهد بدون شک کد زیرساخت است. اما راه‌های ظریف‌تری برای "دسترسی" وجود دارد که ما در این فصل آن را پوشش خواهیم داد: بازیابی زمان فعلی و تولید یک مقدار تصادفی.</p>
<p>به <strong>Listing</strong> 7.1 نگاهی بیندازید. آیا این کد اصلی است؟</p>
<p><strong>Listing</strong> 7.1. The <strong>Order</strong> class.</p>
<pre><code class="language-php">
final class Order
{
    private Uuid $id;
    private DateTimeImmutable $orderDate;

    private function __construct()
    {
    }

    public static function create(): self
    {
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0182_original/original_page.png" alt="Original Page 182">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<pre><code class="language-php">
    $order = new self();
        $order-&gt;id = Uuid::uuid4();
        $order-&gt;orderDate = new DateTimeImmutable('now');
        $order-&gt;recordThat(
            new OrderWasCreated($order-&gt;id, $order-&gt;orderDate)
        );
        return $order;
    }
    // ...
}
</code></pre>
<p>این کد بخشی از یک <strong>entity</strong> است، که قرار است کد اصلی باشد. با این حال، این را نمی‌توان کد اصلی در نظر گرفت. هنگامی که شما یک <code>Order</code> را با استفاده از <strong>constructor</strong> نام‌گذاری شده آن از نوع <code>create()</code>، <strong>instantiate</strong> می‌کنید، دو <strong>object</strong> دیگر ایجاد می‌کند: یک <strong>object Uuid</strong> و یک <strong>object DateTimeImmutable</strong>. هر دو <strong>objects</strong> در طول فاز ساخت خود، به یک دستگاه سیستم دسترسی پیدا می‌کنند. <code>Uuid::uuid4()</code> با دستگاه تصادفی سیستم صحبت می‌کند تا بایت‌های تصادفی را برای ایجاد یک شناسه منحصر به فرد بازیابی کند. <code>new DateTimeImmutable('now')</code> از ساعت سیستم می‌پرسد که تاریخ و زمان فعلی چیست. بنابراین اجرای این کد به این معنی است که این وابستگی‌های خارجی باید در دسترس باشند، که این کد را به کد زیرساخت تبدیل می‌کند (شکل 7.1).</p>
<p>شکل 7.1. <strong>Order</strong> و وابستگی‌های خارجی ضمنی آن.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 183" src="page_0183/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0183_original/original_page.png" alt="Original Page 183">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<p>هنگامی که شما یک <strong>unit test</strong> برای <code>Order</code> می‌نویسید، مانند آنچه در <strong>Listing</strong> 14.1 آمده است، با برخی از مشکلات ناشی از ترکیب کد اصلی و زیرساخت، مواجه خواهید شد.</p>
<p><strong>Listing</strong> 7.2. A test for Order.</p>
<pre><code class="language-php">
final class OrderTest extends TestCase
{
    /**
     * @test
     */
    public function it_can_be_created(): void
    {
        $order = Order::create();

        self::assertEquals(
            [
                new OrderWasCreated(
                    Uuid::uuid4(),
                    new DateTimeImmutable('now')
                )
            ],
            $order-&gt;releaseEvents();
        );
    }
}
</code></pre>
<p>مشکل این است که این تست هرگز پاس نمی‌شود. هنگامی که <code>Order::create()</code> یک نمونه <code>Uuid</code> و <code>DateTimeImmutable</code> را <strong>instantiate</strong> می‌کند، قطعاً با نمونه‌ای که ما در متد <strong>test</strong> ایجاد می‌کنیم برابر نخواهد بود. داده‌هایی که در این <strong>unit test</strong> درگیر هستند، هر بار که <strong>test</strong> را اجرا می‌کنید متفاوت خواهند بود. این بسیار ناخوشایند است و آزمایش را بسیار دشوار می‌کند. ما می‌خواهیم همه چیز قطعی و قابل پیش‌بینی باشد.</p>
<p>بله، ما می‌توانستیم تغییرات را نادیده بگیریم، و فقط تأیید کنیم که <strong>array</strong> از <strong>events</strong> شامل یک نمونه از <code>OrderWasCreated</code> است. این باعث می‌شد که <strong>test</strong> پاس شود، اما همچنان ما را با یک <strong>entity</strong> غیرقابل پیش‌بینی باقی می‌گذاشت. همچنین، از آنجایی که <code>Order::create()</code> از <strong>IO</strong> استفاده می‌کند، واقعاً نباید یک <strong>unit test</strong> در نظر گرفته شود. این هنوز هم به وابستگی‌های خارجی برای اجرا متکی است، اگرچه آنها به طور ضمنی استفاده می‌شوند، و در داخل فراخوانی به <code>Uuid::uuid()</code> و در جایی در <strong>constructor</strong> از نوع <code>DateTimeImmutable</code> پنهان شده‌اند. این بدان معناست که تستی که ما فقط نوشتیم، در واقع یک <strong>integration test</strong> است. یک <strong>integration test</strong> همچنان یک واحد کد را آزمایش می‌کند، اما از آنجایی که از <strong>IO</strong> استفاده می‌کند، می‌تواند نشان دهد که</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0184_original/original_page.png" alt="Original Page 184">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<p>کد شما به خوبی با کتابخانه‌های شخص ثالث یا استاندارد ادغام می‌شود و قادر به اتصال به دستگاه‌های سیستم مربوطه است. برای <strong>domain objects</strong> ما <strong>unit tests</strong> می‌خواهیم، که سریع، قطعی هستند، به وابستگی‌های خارجی متکی نیستند، و برای اجرا به یک <strong>context</strong> خاص نیاز ندارند.</p>
<p>چگونه می‌توانیم این تست را به یک <strong>unit test</strong> تبدیل کنیم؟ با دوباره "خالص" کردن <code>Order</code>. ما باید مطمئن شویم که رفتار آن به هیچ چیز دیگری به جز آرگومان‌های <strong>constructor</strong> آن، پیاده‌سازی خودش، و آرگومان‌های متدی که به آن ارائه می‌شود، بستگی ندارد. ما باید <strong>object</strong> را از استفاده از زمان فعلی واقعی یا یک عدد کاملاً تصادفی متوقف کنیم. در عوض، ما باید به <strong>clients</strong> اجازه دهیم تا زمان فعلی یا داده‌های تصادفی را به عنوان آرگومان‌های متد به آن منتقل کنند.</p>
<h4> 7.1. Passing current time and random data as method arguments</h4>
<p>مثال در <strong>Listing</strong> 7.3 نتیجه انتقال تصادفی بودن و زمان فعلی را به عنوان آرگومان‌های <strong>constructor</strong> نشان می‌دهد، به جای اینکه به <code>Order</code> اجازه دهیم این اطلاعات را خودش بازیابی کند.</p>
<p><strong>Listing</strong> 7.3. Time and random data are passed to Order as constructor argu- ments.</p>
<pre><code class="language-php">
final class Order
{
    private Uuid $id;
    private DateTimeImmutable $orderDate;

    private function __construct()
    {
    }

    public static function create(
        Uuid $id,
        DateTimeImmutable $orderDate
    ): self {
        $order = new self();
        $order-&gt;id = $id;
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0185_original/original_page.png" alt="Original Page 185">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3>7. Time and randomness</h3>
<pre><code class="language-php">
   $order-&gt;orderDate = $orderDate;
   $order-&gt;recordThat(
    new OrderWasCreated($order-&gt;id, $order-&gt;orderDate)
   );
   return $order;
  </code></pre>
<p>
   // ...
  </p>
<p>
   This change allows us once again to write an actual unit test (see Listing 7.4).
  </p>
<p>
<strong>Listing 7.4.</strong> The test itself provides the current time and random data.
  </p>
<pre><code class="language-php">
   final class OrderTest extends TestCase
   {
    /**
     * @test
     */
    public function it_can_be_created(): void
    {
     $id = Uuid::uuid4();
     $orderDate = new DateTimeImmutable('now');
     $order = Order::create($id, $orderDate);
     self::assertEquals(
      [
       new OrderWasCreated(
        $id,
        $orderDate
       )
      ],
      $order-&gt;releaseEvents();
     );
    }
   }
  </code></pre>
<p>
   The situation has improved a lot: taking control over the creation of these val-
   166
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0186_original/original_page.png" alt="Original Page 186">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<p>ارائه زمان فعلی و داده‌های تصادفی به عنوان آرگومان‌ها، در ایجاد موضوع تحت آزمایش (<strong>SUT</strong>) کمک‌کننده خواهد بود.</p>
<p><code>Order</code> دیگر به زمان فعلی واقعی یا داده‌های واقعاً تصادفی متکی نیست. شکل 7.2 روابط وابستگی جدید را نشان می‌دهد.</p>
<p>شکل 7.2. <code>Order</code> به طور صریح به <code>Uuid</code> و <code>DateTimeImmutable</code> وابسته است، که هنوز وابستگی‌های خارجی ضمنی دارند.</p>
<h4> 7.2. Introducing factories</h4>
<p>برخی از مسائل طراحی باقی مانده در این کد وجود دارد. یک مسئله این است که تولید زمان فعلی یا یک مقدار تصادفی در واقع مسئولیت <strong>service</strong> است. اگرچه <code>Uuid</code> و <code>DateTimeImmutable</code> شبیه <strong>value objects</strong> به نظر می‌رسند، اما واقعاً اینطور نیستند. آنها هرگز نمی‌توانند به تنهایی داده‌های تصادفی یا زمان فعلی را ارائه دهند. تصور کنید که شما مجبور باشید <strong>constructor</strong> از نوع <code>DateTimeImmutable</code>، یا <strong>constructor</strong> نام‌گذاری شده <code>Uuid::uuid4()</code> را بنویسید. چه چیزی باید در آنجا قرار گیرد؟ در مقطعی شما باید "دسترسی پیدا کنید" و از سیستم میزبان برای برخی از ورودی‌ها درخواست کنید. کد شما هرگز نمی‌تواند به تصادفی بودن واقعی یا زمان فعلی واقعی برسد. این با ماهیت یک <strong>object value</strong> مطابقت ندارد، که قرار است یک <strong>object</strong> خالص باشد، که رفتار آن منحصراً توسط ورودی ارائه شده و منطق خود تعیین می‌شود.</p>
<p>وقتی یک <strong>object</strong> با سیستم‌های خارجی صحبت می‌کند، این <strong>object</strong> باید یک <strong>service</strong> باشد تا بتواند این را به وضوح منتقل کند. و هنگامی که ما یک کلاس <strong>service</strong> را برای چیزی که با دنیای بیرون صحبت می‌کند ایجاد می‌کنیم، همیشه باید یک <strong>interface</strong> برای آن ارائه دهیم. این به ما امکان می‌دهد تا <strong>service</strong> را به عنوان یک <strong>depen-</strong></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 187" src="page_0187/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0187_original/original_page.png" alt="Original Page 187">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<p>به جای استفاده از آن به صورت <strong>ad hoc</strong>، هر زمان که به زمان فعلی یا یک <strong>ID</strong> منحصر به فرد نیاز داریم.</p>
<p>برای ایجاد یک <strong>UUID</strong>، یک <strong>abstraction</strong> می‌تواند یک <strong>interface</strong> به نام <code>UuidFactory</code> باشد، مانند موردی که در <strong>Listing</strong> 7.5 آمده است.</p>
<p><strong>Listing</strong> 7.5. The abstract <strong>UuidFactory</strong> and a standard implementation.</p>
<pre><code class="language-php">
use Ramsey\Uuid;

interface UuidFactory
{
    public function create(): Uuid;
}

final class UuidFactoryUsingRamseyUuid
    implements UuidFactory
{
    public function create(): Uuid
    {
        return Uuid::uuid4();
    }
}
</code></pre>
<p>برای ایجاد یک نمونه <code>DateTimeImmutable</code> ما ممکن است معرفی یک <code>TimeFactory</code> را در نظر بگیریم، اما این به هر حال معمولاً به عنوان یک <code>Clock</code> شناخته می‌شود. <strong>Listing</strong> 7.6 مثالی از چنین <strong>abstraction</strong> را نشان می‌دهد.</p>
<p><strong>Listing</strong> 7.6. The abstract <strong>Clock</strong> and a standard implementation.</p>
<pre><code class="language-php">
interface Clock
{
    public function currentTime(): DateTimeImmutable;
}

final class ClockUsingSystemClock
    implements Clock
{
    public function currentTime(): DateTimeImmutable
    {
        return new DateTimeImmutable('now');
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0188_original/original_page.png" alt="Original Page 188">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<pre><code class="language-php">
    }
}
</code></pre>
<p>ما هنوز هم از <strong>objects</strong> اصلی ارائه شده توسط <strong>library ramsey/uuid1</strong> و <strong>library</strong> استاندارد <strong>PHP</strong> استفاده می‌کنیم. اما اکنون ما <strong>interfaces</strong> داریم که به ما امکان می‌دهد از آن <strong>objects</strong> بدون تکیه بر مسئولیت‌های <strong>service</strong> آنها استفاده کنیم. هر زمان که ما به یک نمونه <code>DateTimeImmutable</code> نیاز داریم، از <code>Clock</code> استفاده می‌کنیم. هنگامی که به یک <code>Uuid</code> نیاز داریم، از <code>UuidFactory</code> استفاده می‌کنیم. ما هرگز مجبور نیستیم خودمان این <strong>objects</strong> را <strong>instantiate</strong> کنیم و هنگامی که از <strong>abstractions service</strong> جدید استفاده می‌کنیم، کاملاً واضح خواهد بود که ما انتظار داریم که پیاده‌سازی‌های آنها به سیستم‌های خارجی دسترسی پیدا کنند. شکل 7.3 نشان می‌دهد که وضعیت اکنون چگونه است.</p>
<p>شکل 7.3. نمودار وابستگی پس از معرفی <strong>abstractions service</strong>.</p>
<p>در <strong>test</strong> ما اکنون می‌توانیم از <strong>services</strong> جدید استفاده کنیم (به <strong>Listing</strong> 7.7 مراجعه کنید).</p>
<p><strong>Listing</strong> 7.7. Using the new services inside a test.</p>
<pre><code class="language-php">
</code></pre>
<p>1 https://advwebapparch.com/ramsey-uuid</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 189" src="page_0189/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0189_original/original_page.png" alt="Original Page 189">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<pre><code class="language-php">
final class OrderTest extends TestCase
{
    /**
     * @test
     */
    public function it_can_be_created(): void
    {
        $id = (new UuidFactoryUsingRamseyUuid())-&gt;create();
        $orderDate = (new ClockUsingSystemClock())-&gt;currentTime();

        $order = Order::create($id, $orderDate);

        self::assertEquals(
            [
                new OrderWasCreated(
                    $id,
                    $orderDate
                )
            ],
            $order-&gt;releaseEvents();
        );
    }
}
</code></pre>
<p>اگرچه کمی پرمحتواتر است، این قطعاً یک روش صادقانه برای نشان دادن این است که زمان فعلی و <strong>ID</strong> منحصر به فرد از کجا می‌آیند.</p>
<h4> 7.3. Introducing value objects</h4>
<p>به جای استفاده از <strong>services</strong> در حین آزمایش، آیا ما نمی‌توانستیم فقط از مقادیر <strong>hard-coded</strong> استفاده کنیم، مانند <strong>Listing</strong> 7.8؟ ما می‌توانستیم یک <strong>UUID</strong> را یک بار تولید کنیم و آن را برای هر اجرای <strong>test</strong> دوباره استفاده کنیم. همین کار را برای <strong>timestamp</strong> نیز انجام دهید: ما باید بتوانیم آن را به یک لحظه ثابت در زمان تنظیم کنیم. و ما حتی به یک <strong>hack</strong> زشت مانند <strong>overrid-</strong> توابع یا کلاس‌های داخلی <strong>PHP</strong> نیاز نداریم. ما فقط می‌توانیم یک آرگومان <strong>string</strong> را به <strong>constructor</strong> از نوع <code>DateTimeImmutable</code> ارائه دهیم (<strong>Listing</strong> 7.8).</p>
<p><strong>Listing</strong> 7.8. Using hard-coded values for <strong>Uuid</strong> and <strong>DateTimeImmutable</strong></p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0190_original/original_page.png" alt="Original Page 190">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<pre><code class="language-php">
/**
     * @test
     */
    public function it_can_be_created(): void
    {
        $id = Uuid::fromString('77d69702-e3b4-4af5-b40a-c9981d483880');
        $orderDate = new DateTimeImmutable('2020-06-03 09:53');
</code></pre>
<p>بله، من فکر می‌کنم این راه درستی است. مزیت این است که اکنون خود <strong>test</strong> دیگر از <strong>IO</strong> استفاده نمی‌کند. این به ما یک بهبود عملکرد کوچک می‌دهد، که در درازمدت <strong>test suite</strong> شما را سریع نگه می‌دارد. ما همچنین با انجام این کار، کنترل کاملی بر وضعیت <code>Order</code> به دست می‌آوریم. وضعیت آن همیشه یکسان خواهد بود، و بنابراین <strong>object</strong> همیشه به یک روش یکسان رفتار خواهد کرد.</p>
<p>ما با <code>Uuid</code> و کلاس‌های <code>DateTimeImmutable</code> به عنوان <strong>value objects</strong> به جای <strong>factory services</strong> رفتار می‌کنیم. رفتار آنها اکنون فقط توسط آرگومان‌های ورودی تعیین می‌شود. یا، شاید نه... معلوم می‌شود که <code>DateTimeImmutable</code> هنگام <strong>instantiate</strong> کردن آن با یک آرگومان <strong>string</strong>، رفتار جالبی دارد. اگر شما برخی از قسمت‌های تاریخ را ارائه ندهید، مقادیر مربوطه را از زمان فعلی واقعی کپی می‌کند. در مورد ما، ما ثانیه‌ها و میکروثانیه‌ها را ارائه نمی‌دهیم، بنابراین نمونه <code>DateTimeImmutable</code>، تعداد ثانیه‌ها و تعداد میکروثانیه‌ها را از زمان فعلی خواهد داشت. در نتیجه، ما هنوز کنترل کاملی بر تمام وضعیت درگیر در اجرای <strong>test</strong> خود نداریم. و این بدان معناست که <strong>test</strong> کاملاً قطعی نیست، و نمی‌توان آن را یک <strong>unit test</strong> نامید.</p>
<p>علاوه بر این واقعیت که این <strong>objects</strong> <strong>value objects</strong> واقعی نیستند، و اینکه آنها می‌توانند به روش‌های نامعینی رفتار کنند که ما ممکن است در مورد آن ندانیم، یک مشکل طراحی دیگر نیز وجود دارد. کلاس‌های شخص ثالث مانند <code>DateTimeImmutable</code> و <code>Uuid</code> برای مفید بودن در بسیاری از پروژه‌ها و موقعیت‌های مختلف طراحی شده‌اند. بنابراین آنها یک <strong>API</strong> دارند که با <strong>use case</strong> خاص شما در نظر گرفته نشده است، بلکه با هر <strong>use case</strong> دیگری در نظر گرفته شده است. به عنوان مثال، <code>DateTimeImmutable</code> فقط یک راه برای نشان دادن یک <strong>timestamp</strong> به عنوان یک <strong>object</strong> نیست، بلکه متدهایی مانند <code>sub()</code>، <code>setDate()</code>، <code>getTimezone()</code> و غیره نیز دارد. این متدها ممکن است در <strong>use case</strong> شما کاملاً نامربوط باشند، اما با این وجود، با معرفی کلاس به <strong>domain model</strong> خود، رفتار آن</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0191_original/original_page.png" alt="Original Page 191">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<p>بخش از <strong>domain</strong> شما می‌شود. در برخی موارد، رفتار ممکن است در واقع شما را به دردسر بیندازد، زیرا ایده‌های نویسنده با ایده‌ها یا انتظارات شما در مورد همان مفهوم مطابقت ندارد. بنابراین یک قانون سرانگشتی خوب این است که کلاس‌هایی که شما به عنوان وابستگی‌ها (آرگومان‌های <strong>constructor</strong>، آرگومان‌های متد و انواع بازگشتی) در <strong>domain model</strong> خود استفاده می‌کنید، باید توسط شما نیز طراحی شوند. این یک چیز خوب است که هر جنبه‌ای از طراحی <strong>domain model</strong> خود را صریح و مناسب برای <strong>use case</strong> خاص خود کنید.</p>
<p>در مورد استفاده ما از <code>Uuid</code> و <code>DateTimeImmutable</code>، راه‌حل تعریف <strong>value objects</strong> خودمان خواهد بود. این دو مشکل را همزمان حل می‌کند:</p>
<ol>
<li>ما کنترل کاملی بر <strong>API</strong> از <strong>objects domain</strong> خود خواهیم داشت.</li>
<li>ما به طور تصادفی از <strong>IO</strong> در <strong>objects domain</strong> خود، و نه در <strong>unit tests</strong> که برای آنها ایجاد می‌کنیم، استفاده نخواهیم کرد.</li>
</ol>
<p>دو <strong>value objects</strong> که ما نیاز داریم باید "شناسه یک سفارش" و "تاریخ ایجاد یک سفارش" را نشان دهند. بیایید با شناسه سفارش شروع کنیم و یک <strong>object value OrderId</strong> را معرفی کنیم که می‌تواند این <strong>ID</strong> را نشان دهد. در پشت صحنه ما همچنان از یک <strong>UUID</strong> استفاده خواهیم کرد. ما یک نمونه <strong>OrderId</strong> را از یک <strong>string</strong> که شامل یک <strong>UUID</strong> است ایجاد می‌کنیم، به جای از یک <strong>object Uuid</strong> که از قبل <strong>instantiated</strong> شده است. <strong>Listing</strong> 7.9 یک <strong>object value OrderId</strong> ساده را نشان می‌دهد که باید استفاده‌های موجود از <code>Uuid</code> را در یک نوع پارامتر جایگزین کند.</p>
<p><strong>Listing</strong> 7.9. The <strong>OrderId value object class</strong>.</p>
<pre><code class="language-php">
final class OrderId
{
    private string $id;

    private function __construct(string $id)
    {
        Assertion::uuid($id);
        $this-&gt;id = $id;
    }

    public static function fromString(string $id): self
    {
        return new self($id);
    }
}
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0192_original/original_page.png" alt="Original Page 192">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<pre><code class="language-php">
final class Order
{
    private OrderId $orderId;
    // ...

    public function __construct(
        OrderId $orderId,
        // ...
    ) {
        $this-&gt;orderId = $orderId;
        // ...
    }
}
</code></pre>
<p>هنگام <strong>construction</strong>، <code>OrderId</code> یک <strong>string</strong> را می‌پذیرد که شبیه به یک <strong>UUID</strong> است. این را با استفاده از یک <strong>assertion</strong> از <strong>package</strong> از نوع <code>beberlei/assert2</code> تأیید می‌کند. این واقعیت که نه <code>OrderId</code> و نه خود <code>Order</code>، هرگز یک نمونه <code>Uuid</code> را از ابتدا ایجاد نمی‌کنند، به ما این امکان را می‌دهد که از تکیه بر <strong>IO</strong> در کلاس <strong>test</strong> جلوگیری کنیم. کافی است یک <strong>UUID</strong> واقعی را یک بار تولید کنید (به عنوان مثال با استفاده از ابزار خط فرمان <code>uuidgen</code>، یا با استفاده از یک <strong>script PHP</strong> ساده که نتیجه فراخوانی <code>Uuid::uuid4()</code> را نشان می‌دهد). سپس می‌توانیم <strong>UUID</strong> تولید شده را کپی کرده و در <strong>unit test</strong> خود استفاده کنیم، همانطور که در <strong>Listing</strong> 7.10 نشان داده شده است.</p>
<p><strong>Listing</strong> 7.10. Providing a hard-coded string to <code>OrderId::fromString()</code>.</p>
<pre><code class="language-php">
/**
     * @test
     */
    public function it_can_be_created(): void
    {
        $order = new Order(
            OrderId::fromString('77d69702-e3b4-4af5-b40a-c9981d483880'),
            // ...
        );
</code></pre>
<p>2 https://advwebapparch.com/beberlei-assert</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0193_original/original_page.png" alt="Original Page 193">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3>7. Time and randomness</h3>
<p>
   OrderId یک class ساده است که تنها متدهایی را ارائه می‌دهد که ما واقعاً در
   domain code خود به آنها نیاز داریم، بر خلاف class از نوع Uuid. در حال حاضر، این فقط یک
   wrapper برای UUID string است.
  </p>
<p>
   برای creation date ما می‌توانیم همین کار را انجام دهیم: یک date string را در یک
   format مشخص بپذیریم. در پشت صحنه، ما هنوز هم می‌توانیم به DateTimeImmutable
   تکیه کنیم تا تعیین کنیم آیا string داده شده نشان دهنده یک تاریخ واقعی است و فقط
   شبیه یک تاریخ به نظر نمی رسد (به عنوان مثال 2019-02-29). Listing 7.11 نحوه استفاده Date
   از DateTimeImmutable را در constructor خود نشان می‌دهد.
  </p>
<p>
<strong>Listing 7.11.</strong> Date از DateTimeImmutable برای اعتبارسنجی constructor argu-
   ment خود استفاده می‌کند.
  </p>
<pre><code class="language-php">
   final class Date
   {
    private const DATE_FORMAT = 'Y-m-d';
    private string $date;
    private function __construct(string $date)
    {
     if (! DateTimeImmutable::createFromFormat(
      self::DATE_FORMAT,
      $date
     )) {
      throw new InvalidArgumentException(
       sprintf(
        'Invalid date provided: %s. Expected format: %s',
        $date,
        self::DATE_FORMAT
       )
      );
     }
     $this-&gt;date = $date;
    }
    public static function fromString(string $date): self
    {
     return new self($date);
    }
   }
  </code></pre>
<p>
   174
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0194_original/original_page.png" alt="Original Page 194">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<pre><code class="language-php">
final class Order
{
    private Date $orderDate;

    public function __construct(
        // ...
        Date $orderDate,
        // ...
    ) {
        // ...
        $this-&gt;orderDate = $orderDate;
    }
}
</code></pre>
<p>برای اعتبارسنجی رشته تاریخ ارائه شده، ما همچنین می‌توانستیم از <code>Assertion::date(self::FORMAT, $date)</code> استفاده کنیم. با این حال، من می‌خواستم در این مثال به این نکته اشاره کنم که شما همچنان می‌توانید از <strong>objects</strong> پشتیبانی‌کننده از کتابخانه‌های شخص ثالث برای انجام کارهای سنگین برای شما استفاده کنید. تکیه بر کلاس‌های دیگران در داخل <strong>object value</strong> شما کاملاً خوب است، تا زمانی که آنها برخی از مشکلاتی را که ما سعی در اجتناب از آنها داشته‌ایم، دوباره معرفی نکنند:</p>
<ol>
<li><strong>Value objects</strong> نباید شامل کد زیرساخت باشند. به عبارت دیگر:</li>
<li><strong>Value objects</strong> نباید مسئولیت‌های <strong>service</strong> داشته باشند.</li>
<li><strong>Value objects</strong> نباید هیچ رفتاری را ارائه دهند که صریحاً فعال نشده و برای <strong>use case</strong> شما طراحی شده است.</li>
</ol>
<p>این بدان معناست که شما می‌توانید از <strong>value objects</strong> از کتابخانه‌های دیگر استفاده کنید، اگر آنها رفتار (کم و بیش) دقیقی را که نیاز دارید ارائه می‌دهند. اگر اینطور نیست، شما باید آنها را با پیچیدن آنها در داخل <strong>value objects</strong> خود، تطبیق دهید. فقط یک یادداشت سریع: هنگام استفاده از ابزارهای شخص ثالث مانند <code>DateTimeImmutable</code>، شما هنوز هم باید فرضیات خود را بررسی کنید. یک <strong>unit test</strong> مفصل برای آن مفید خواهد بود. به عنوان مثال، من از کشف این موضوع بسیار شگفت‌زده شدم که <strong>instantiating</strong> یک تاریخ آشکارا بی‌معنی مانند <code>2019-02-29</code> هیچ <strong>exception</strong> ایجاد نمی‌کند. <strong>constructor</strong> از نوع <code>DateTimeImmutable</code> به سادگی آن را به <code>2019-03-01</code> تبدیل می‌کند...</p>
<p>گذشته از مسائل مربوط به تاریخ/زمان، معرفی <strong>value objects</strong> خودتان برای تاریخ‌ها و زمان‌ها راهی برای به دست آوردن مالکیت طراحی بر روی انواع <strong>objects</strong> است که</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0195_original/original_page.png" alt="Original Page 195">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<p>درگیر هستند، و <strong>APIs</strong> که آنها به <strong>clients</strong> خود ارائه می‌دهند.3 این <strong>value objects</strong>، رفتارهای مفیدی را که مختص <strong>domain</strong> از <strong>application</strong> شما هستند، جذب خواهند کرد.4</p>
<h4> 7.4. Improving the factories</h4>
<p>نتیجه معرفی <strong>value objects</strong> با <strong>constructors</strong> نام‌گذاری شده که یک <strong>string</strong> را می‌پذیرند و به <strong>IO</strong> نیاز ندارند این است که <strong>unit test</strong> و موضوع تحت تست (<strong>SUT</strong>) دیگر از <strong>IO</strong> استفاده نمی‌کنند، همانطور که در <strong>Listing</strong> 7.12 نشان داده شده است.</p>
<p><strong>Listing</strong> 7.12. Now that we have custom value objects, <strong>OrderTest</strong> no longer needs <strong>IO</strong>.</p>
<pre><code class="language-php">
/**
     * @test
     */
    public function it_can_be_created(): void
    {
        $order = new Order(
            OrderId::fromString('77d69702-e3b4-4af5-b40a-c9981d483880'),
            Date::fromString('2019-07-09')
        );
</code></pre>
<p>با این حال، هنگامی که <strong>entity Order</strong> قرار است در تولید استفاده شود، <strong>application service</strong> که آن را ایجاد می‌کند، باید یک <strong>ID</strong> واقعاً منحصر به فرد و زمان فعلی واقعی را ارائه دهد. از آنجایی که، دوباره، تعیین زمان فعلی یا تولید تصادفی بودن مسئولیت‌های <strong>service</strong> هستند، ما باید <strong>services</strong> داشته باشیم که بتوانند <strong>objects OrderId</strong> و <strong>Date</strong> را برای <strong>application service</strong> ایجاد کنند. در فصل 2 ما قبلاً دیدیم که چگونه می‌توان این را برای <code>OrderId</code> حل کرد: با اضافه کردن متد <code>nextIdentity()</code> به <strong>interface OrderRepository</strong>. <strong>Listing</strong> 7.13 بار دیگر نشان می‌دهد که چگونه این کار انجام می‌شود.</p>
<p>3Read more about object design techniques, like using named constructors, in my book “Object Design Style Guide”, Manning, 2019.</p>
<p>4Ross Tuck provides some more suggestions regarding the use of value objects for dates and times in “Precision Through Imprecision: Improving Time Objects”, https://advwebapparch.com/precision-through-imprecision.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0196_original/original_page.png" alt="Original Page 196">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<p><code>OrderRepository</code> می‌تواند نمونه‌های جدید <code>OrderId</code> را تولید کند.</p>
<pre><code class="language-php">
interface OrderRepository
{
    // ...
    public function nextIdentity(): OrderId;
}

final class OrderRepositoryUsingSql
    implements OrderRepository
{
    private UuidFactory $uuidFactory;

    public function __construct(UuidFactory $uuidFactory)
    {
        $this-&gt;uuidFactory = $uuidFactory;
    }

    public function nextIdentity(): OrderId
    {
        return OrderId::fromString(
            $this-&gt;uuidFactory-&gt;create()-&gt;toString()
        );
    }
}
</code></pre>
<p>این یک جداسازی تمیز بین کد اصلی و زیرساخت ارائه می‌دهد. کد زیرساخت، کدی است که یک <strong>UUID</strong> جدید را بر اساس داده‌هایی که دستگاه تصادفی سیستم ارائه می‌دهد، ایجاد می‌کند. کد اصلی، خود کلاس <code>OrderId</code>، و <strong>interface</strong> است که می‌توانید یک نمونه جدید <code>OrderId</code> را از آن بازیابی کنید.</p>
<p>برای بازیابی یک نمونه <code>Date</code> ما می‌توانیم کار مشابهی را انجام دهیم. ما یک <strong>interface</strong> را با یک متد تعریف می‌کنیم که یک نمونه <code>Date</code> را برای تماس‌گیرنده ایجاد می‌کند. ما می‌توانیم آن را <code>DateFactory</code> بنامیم، اما شاید یک <code>Calendar</code> با متد <code>today()</code> مناسب‌تر باشد. این متد یک نمونه <code>Date</code> را برمی‌گرداند که تاریخ واقعی امروز را به درستی نشان می‌دهد. پیاده‌سازی استاندارد این <strong>interface</strong> می‌تواند از <strong>abstraction Clock</strong> که قبلاً تعریف کرده‌ایم برای دریافت زمان فعلی و ایجاد یک نمونه <code>Date</code> بر اساس آن استفاده کند (به <strong>Listing</strong> 7.14 مراجعه کنید).</p>
<p><strong>Listing</strong> 7.14. The <strong>Calendar interface</strong> and its standard implementation.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0197_original/original_page.png" alt="Original Page 197">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<pre><code class="language-php">
interface Calendar
{
    public function today(): Date;
}

final class CalendarUsesClock
    implements Calendar
{
    private Clock $clock;

    public function __construct(Clock $clock)
    {
        $this-&gt;clock = $clock;
    }

    public function today(): Date
    {
        return Date::fromString(
            $this-&gt;clock-&gt;currentTime()
                -&gt;format('Y-m-d')
        );
    }
}
</code></pre>
<p>ما قطعاً باید <code>Date::fromDateTimeImmutable()</code> را معرفی کنیم تا از همه این نوع <strong>juggling</strong> جلوگیری کنیم، و برای حفظ دانش از <code>DateTimeImmutable</code> و قالب رشته تاریخ پشتیبانی شده در داخل خود <code>Date</code>. <strong>Listing</strong> 7.15 نشان می‌دهد که چگونه می‌توانید این <strong>constructor</strong> جایگزین را برای <strong>objects Date</strong> پیاده‌سازی کنید.</p>
<p><strong>Listing</strong> 7.15. Instantiating <code>Date</code> based on an already existing <code>DateTimeImmutable</code> instance.</p>
<pre><code class="language-php">
final class Date
{
    private const DATE_FORMAT = 'Y-m-d';
    private string $date;

    private function __construct(string $date)
    {
        // ...
    }
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0198_original/original_page.png" alt="Original Page 198">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<pre><code class="language-php">
public static function fromDateTimeImmutable(
        DateTimeImmutable $dateTimeImmutable
    ): self {
        return new self(
            $dateTimeImmutable-&gt;format(self::DATE_FORMAT)
        );
    }
    // ...
}
</code></pre>
<p>افزودن یک <strong>constructor</strong> نام‌گذاری شده مانند این، برخی از جزئیات پیاده‌سازی داخلی <strong>object</strong> را در معرض دید قرار می‌دهد. اما مزایای اجازه دادن به این اتفاق (تبدیل آسان‌تر بین انواع مختلف مقادیر) ممکن است بیشتر از هزینه‌ها باشد (نگه داشتن همه چیز در داخل <strong>object</strong>).</p>
<p><strong>Listing</strong> 7.16 نشان می‌دهد که چگونه می‌توان از <code>Calender</code> و <code>OrderRepository</code> در داخل <code>EbookOrderService</code> استفاده کرد.</p>
<p><strong>Listing</strong> 7.16. Using <strong>Calendar</strong> and <strong>OrderRepository</strong>.</p>
<pre><code class="language-php">
final class EbookOrderService
{
    private Calendar $calendar;
    private OrderRepository $orderRepository;

    // ...
    public function __construct(
        Calendar $calendar,
        OrderRepository $orderRepository,
        // ...
    ) {
        $this-&gt;calendar = $calendar;
        $this-&gt;orderRepository = $orderRepository;
        // ...
    }

    public function create(/* ... */): OrderId
    {
        $order = Order::create(
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0199_original/original_page.png" alt="Original Page 199">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<pre><code class="language-php">
        $this-&gt;orderRepository-&gt;nextIdentity(),
        $this-&gt;calendar-&gt;currentDate(),
        // ...
    );
    // ...
    return $order-&gt;orderId();
}
</code></pre>
<p>به ما این امکان را می‌دهد که در یک <strong>Test</strong> <strong>ID</strong> منحصر به فرد و تاریخ را دریافت کنیم. ما اکنون <strong>entity Order</strong> را بازنویسی کردیم تا از این <strong>services</strong> جدید استفاده کند. اکنون در مورد <strong>UUID</strong> و <code>DateTimeImmutable</code>، ما <strong>IO</strong> را از <strong>test</strong> خارج کردیم. در اینجا یک قدم دیگر برمی‌داریم.</p>
<h4> 7.5. Manipulating the current time</h4>
<p>اکنون که ما <strong>interface Clock</strong> و یک پیاده‌سازی استاندارد را داریم، ما می‌توانیم هر <strong>instantiation</strong> از <code>DateTimeImmutable</code> را در <strong>application</strong> خود به عنوان یک فراخوانی به <code>Clock::currentTime()</code> بازنویسی کنیم. این به ما یک مکان واحد می‌دهد تا زمان فعلی را تعیین کنیم، که هنگام شروع نوشتن <strong>acceptance tests</strong> در ادامه (به فصل 14 مراجعه کنید) بسیار مفید خواهد بود. <strong>Listing</strong> 7.17 نشان می‌دهد که ما می‌توانیم در یک <strong>test</strong> انجام دهیم تا بر زمان فعلی تأثیر بگذاریم، زیرا <strong>application</strong> ما آن را درک خواهد کرد.</p>
<p><strong>Listing</strong> 7.17. In a test, you can easily configure the “current” time.</p>
<pre><code class="language-php">
final class CreateOrderTest extends TestCase
{
    public function it_creates_an_order(): void
    {
        $clock = new class implements Clock {
            public function currentTime(): DateTimeImmutable
            {
                return new DateTimeImmutable('2019-07-09');
            }
        };

        $service = new EbookOrderService(
            new CalendarUsesClock($clock),
            // ...
        );
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0200_original/original_page.png" alt="Original Page 200">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<pre><code class="language-php">
    }
}
</code></pre>
<p>این احتمالاً مفیدتر خواهد بود اگر به جای یک کلاس ناشناس، ما یک کلاس واقعی (مثلاً <code>FakeClock</code>) تعریف کنیم که فرآیند ارائه "زمان فعلی" را که می‌خواهیم، تسهیل می‌کند. شما ممکن است بخواهید <code>FakeClock</code> را <strong>mutable</strong> کنید، و به زمان اجازه دهید در حین اجرای یک <strong>test</strong> "بگذرد" (به <strong>Listing</strong> 7.18 مراجعه کنید).</p>
<p><strong>Listing</strong> 7.18. A <strong>FakeClock</strong> and how to use it in a test.</p>
<pre><code class="language-php">
final class FakeClock implements Clock
{
    private ?DateTimeImmutable $currentTime;

    public function setCurrentTime(
        DateTimeImmutable $currentTime
    ): void {
        $this-&gt;currentTime = $currentTime;
    }

    public function currentTime(): DateTimeImmutable
    {
        if ($this-&gt;currentTime === null) {
            return new DateTimeImmutable('now');
        }
        return $this-&gt;currentTime;
    }
}
</code></pre>
<p><code>$clock = new FakeClock();</code></p>
<p><code>$currentTime = new DateTimeImmutable('2020-06-03 09:53');</code></p>
<p><code>$clock-&gt;setCurrentTime($currentTime);</code></p>
<p><code>// Do something</code></p>
<p><code>$clock-&gt;setCurrentTime($currentTime-&gt;modify('+1 day'));</code></p>
<p><code>// Do something else, the code will think it's one day later mpw</code></p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0201_original/original_page.png" alt="Original Page 201">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<p>شکل 7.4 یک نمودار از وضعیت فعلی است. ما چندین <strong>abstraction</strong> "<strong>domain-specific</strong>" داریم که اکنون می‌توانیم از آنها استفاده کنیم. همه مفاهیم مهم به عنوان کد اصلی نشان داده شده‌اند، و کد زیرساخت واقعاً فقط برای پشتیبانی از آنها وجود دارد.</p>
<p>حتی اگر نیات ما خوب بود، اکنون ما تعداد نسبتاً زیادی عناصر اضافی داریم. ما با سه کلاس شروع کردیم، اکنون 9 کلاس و <strong>interface</strong> اضافی داریم. همانطور که می‌دانید، معرفی <strong>abstractions</strong> معمولاً منجر به دو عنصر اضافی (یک <strong>interface</strong> و یک پیاده‌سازی استاندارد) یا سه <strong>elements</strong> می‌شود، زمانی که شما یک نوع بازگشتی جدید را نیز معرفی می‌کنید. بنابراین <strong>abstractions</strong> هزینه‌ای دارند، اما همانطور که قبلاً بحث کردیم: آنها مزایای زیادی دارند. هم برای قابلیت نگهداری طولانی مدت <strong>application</strong> شما و هم برای <strong>testability</strong> امروزی کد. با این حال، مهم است که شما سعی کنید تعداد عناصر یا بخش‌ها را در <strong>application</strong> خود محدود کنید.</p>
<p>با نگاهی به شکل 7.4 یک سرنخ مهم که ما می‌توانیم یک بخش را حذف کنیم این است که <code>OrderRepositoryUsingSql</code> از <strong>interface UuidFactory</strong> برای دریافت یک نمونه <code>Uuid</code> استفاده می‌کند. ما این <strong>interface</strong> را معرفی کردیم زیرا ایجاد یک <strong>UUID</strong> یک مسئولیت <strong>service</strong> است که برای کار به وابستگی‌های خارجی نیاز دارد. ما نمی‌خواستیم یک <strong>UUID</strong> را در کد اصلی ایجاد کنیم. اما از آنجایی که <code>OrderRepositoryUsingSql</code> در حال حاضر کد زیرساخت است، نیازی نیست با وابستگی به <code>UuidFactory</code> به کد اصلی برگردد. این فقط می‌تواند از متد <code>Uuid::uuid4()</code> مستقیماً استفاده کند (به <strong>Listing</strong> 7.19 مراجعه کنید).</p>
<p><strong>Listing</strong> 7.19. Skipping the <strong>UuidFactory</strong>.</p>
<pre><code class="language-php">
final class OrderRepositoryUsingSql
    implements OrderRepository
{
    public function nextIdentity(): OrderId
    {
        return OrderId::fromString(
            Uuid::uuid4()-&gt;toString()
        );
    }
}
</code></pre>
<p>این به ما امکان می‌دهد تا <strong>interface UuidFactory</strong> و کلاس <code>UuidFactoryUsingRamseyUuid</code> را حذف کنیم.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0202_original/original_page.png" alt="Original Page 202">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<p>یک استدلال مشابه برای <strong>interface Calendar</strong> اعمال می‌شود، اما در آنجا برعکس است. تنها کاری که <code>CalenderUsingClock</code> انجام می‌دهد، صحبت با <strong>interface Clock</strong> و استفاده از زمان فعلی برای ایجاد یک نمونه <code>Date</code> جدید است. استفاده از <code>Calendar</code> به ما کد "پرشی" می‌دهد، جایی که ما از <strong>application service</strong> به <strong>abstraction</strong>، به کلاس <strong>concrete</strong>، به <strong>abstraction</strong>، به کلاس <strong>concrete</strong> می‌رویم. در عوض، یک <strong>application service</strong> می‌تواند مستقیماً از <code>Clock</code> استفاده کند، و یک <code>Date</code> از آن ایجاد کند، با استفاده از متد <strong>factory</strong> از نوع <code>fromDateTimeImmutable()</code>. <strong>Listing</strong> 7.20 <strong>application service</strong> را پس از حذف <code>Calender</code> (و <code>CalenderUsingSystemClock</code>) نشان می‌دهد.</p>
<p><strong>Listing</strong> 7.20. Using <strong>Clock</strong> and <strong>OrderRepository</strong>.</p>
<pre><code class="language-php">
final class EbookOrderService
{
    private Clock $clock;
    private OrderRepository $orderRepository;
    // ...
    public function __construct(
        Clock $clock,
        OrderRepository $orderRepository,
        // ...
    ) {
        $this-&gt;clock = $clock;
        $this-&gt;orderRepository = $orderRepository;
        // ...
    }
    public function create(/* ... */): OrderId
    {
        $order = Order::create(
            $this-&gt;orderRepository-&gt;nextIdentity(),
            Date::fromDateTimeImmutable($this-&gt;clock-&gt;currentTime()),
            // ...
        );
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0203_original/original_page.png" alt="Original Page 203">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<p>برای بهبود زبان مورد استفاده در این کد، ما باید <code>Date::fromDateTimeImmutable()</code> را به <code>Date::fromCurrentTime()</code> تغییر نام دهیم. این تمرکز را از نوع داده استفاده شده، دور می‌کند، و تمرکز را به داستان بازمی‌گرداند: ما یک تاریخ را بر اساس زمان فعلی می‌سازیم، که همچنین منطقی است.</p>
<p>شکل 7.5 عناصری را که پس از پاکسازی باقی مانده‌اند، نشان می‌دهد.</p>
<p>“آیا شما توصیه می‌کنید با عناصر بیشتری نسبت به نیاز شروع کنید؟”</p>
<p>سوال عالی؛ این دقیقاً همان چیزی نیست که من می‌خواستم در این فصل نشان دهم. من فکر نمی‌کنم که باید هدف شما این باشد که عناصر بیشتری از حد نیاز ایجاد کنید، اما می‌دانم که گاهی اوقات این اتفاق می‌افتد. به همین دلیل است که فکر کردم مفید خواهد بود که نشان دهم نشانه‌های عناصر زیاد (کد "پرشی") چیست، و همچنین نحوه کاهش تعداد عناصر.</p>
<h4> 7.6. Integration tests again</h4>
<p>آزمایش کد اصلی آسان است زیرا کد اصلی طبق تعریف به خوبی در انزوا اجرا می‌شود. شما به <strong>context</strong> خاصی نیاز ندارید، و به وابستگی‌های خارجی نیاز ندارید. با کد زیرساخت، داستان متفاوت است. آنها معمولاً به راه‌اندازی ویژه نیاز دارند و وابستگی‌های خارجی باید واقعاً در دسترس باشند. همانطور که قبلاً ذکر شد، <strong>tests</strong> برای کد زیرساخت <strong>integration tests</strong> نامیده می‌شوند. آنها نشان می‌دهند که کد با کتابخانه‌های شخص ثالث و وابستگی‌های خارجی که کد به آنها متکی است، به خوبی کار می‌کند. در بخش 6.4 ما دیدیم که چگونه کدی را که با <strong>services</strong> از راه دور ارتباط برقرار می‌کند، آزمایش کنیم. ساعت سیستم و دستگاه تصادفی سیستم نیز به نوعی <strong>services</strong> از راه دور هستند، اگرچه ما به یک <strong>client HTTP</strong> برای اتصال به این دستگاه‌ها نیاز نداریم. با این حال، ما می‌خواهیم در یک <strong>test</strong> نشان دهیم که <strong>application</strong> ما هنگام استفاده از این دستگاه‌های خارجی به درستی کار می‌کند.</p>
<p>نکته این است که ما کد زیادی برای آزمایش نداریم. ما قبلاً یک <code>UuidFactory- UsingRamseyUuid</code> داشتیم اما آن را از قبل حذف کردیم. ما هنوز یک کلاس <code>ClockUsingSystemClock</code> بدون <strong>tests</strong> داریم. این بسیار ساده است که من وسوسه می‌شوم که برای آن یک <strong>test</strong> ننویسم. اما اگر تیم شما قانونی داشته باشد مبنی بر اینکه هر کلاس باید یک <strong>test</strong> داشته باشد چه؟</p>
<p>پس از شر این قانون خلاص شوید (شوخی نیست). به عنوان یک آزمایش سرگرم‌کننده، بیایید دریابیم چه</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0204_original/original_page.png" alt="Original Page 204">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<p>می‌شود اگر ما یک <strong>test</strong> برای <code>ClockUsingSystemClock</code> بنویسیم. <strong>Listing</strong> 7.21 یک تلاش اول را نشان می‌دهد:</p>
<p><strong>Listing</strong> 7.21. A test for <strong>ClockUsingSystemClockTest</strong>.</p>
<pre><code class="language-php">
final class ClockUsingSystemClockTest extends TestCase
{
    /**
     * @test
     */
    public function it_returns_the_current_time(): void
    {
        $clock = new ClockUsingSystemClock();
        $actualCurrentTime = new DateTimeImmutable('now');

        self::assertEquals(
            $actualCurrentTime,
            $clock-&gt;currentTime()
        );
    }
}
</code></pre>
<p>متأسفانه، این <strong>test</strong> هرگز پاس نمی‌شود. این به این دلیل است که بخشی از <strong>timestamp</strong> ایجاد شده توسط نمونه <code>DateTimeImmutable</code>، تعداد میکروثانیه‌هایی است که در ثانیه فعلی سپری شده است. و بین ایجاد یک نمونه در داخل <strong>test</strong> و ایجاد یک نمونه دیگر در کلاس <code>ClockUsingSystemClock</code> همیشه یک اختلاف کوچک وجود خواهد داشت. بنابراین این دو نمونه هرگز برابر نخواهند بود. با این حال، برای مفید بودن کلاس، واقعاً مهم نیست که بخش میکروثانیه‌ها چه باشد. بنابراین به جای انجام یک مقایسه کامل، ما ممکن است فقط <strong>timestamp</strong> را به ثانیه‌ها "گرد" کنیم، همانطور که در <strong>Listing</strong> 7.22 نشان داده شده است.</p>
<p><strong>Listing</strong> 7.22. Comparing timestamps rounded to seconds</p>
<p><code>$clock = new ClockUsingSystemClock();</code></p>
<p><code>$actualCurrentTime = new DateTimeImmutable('now');</code></p>
<p><code>self::assertEquals(</code></p>
<p><code>$actualCurrentTime-&gt;format('U'),</code></p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0205_original/original_page.png" alt="Original Page 205">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<pre><code class="language-php">
        $clock-&gt;currentTime()-&gt;format('U')
    );
</code></pre>
<p>این <strong>test</strong> بیشتر احتمال دارد که پاس شود، اما همچنان ممکن است در زمانی که <strong>test</strong>، نمونه <code>DateTimeImmutable</code> را در پایان ثانیه فعلی ایجاد می‌کند، و <code>Clock- UsingSystemClock</code> آن را در ثانیه بعد ایجاد می‌کند، شکست بخورد. یک راه‌حل رایج برای این سناریوها این است که تفاوت بین دو <strong>timestamp</strong> را محاسبه کرده و <strong>assert</strong> کنید که تفاوت کمتر از یک مقدار مجاز خاص است. این مقدار تفاوت زمانی بر حسب میکروثانیه بین دو <strong>instantiations</strong> از نوع <code>DateTimeImmutable</code> را نشان می‌دهد که فکر می‌کنید قابل قبول خواهد بود. <strong>Listing</strong> 7.23 نشان می‌دهد که چگونه این کار را انجام دهید.</p>
<p><strong>Listing</strong> 7.23. Comparing the difference between timestamps.</p>
<pre><code class="language-php">
final class ClockUsingSystemClockTest extends TestCase
{
    /**
     * @test
     */
    public function it_returns_the_current_time(): void
    {
        $clock = new ClockUsingSystemClock();
        $actualCurrentTime = new DateTimeImmutable('now');

        self::assertEqualsWithDelta(
            self::secondsWithMicroseconds($actualCurrentTime)),
            self::secondsWithMicroseconds($clock-&gt;currentTime()),
            0.1
        );
    }

    private static function secondsWithMicroseconds(
        DateTimeImmutable $timestamp
    ): float {
        /*
         * We concatenate the number of seconds, a decimal separator,
         * and the number of microseconds within this second which
         * already has leading 0s. We then cast it to a float.
         */
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0206_original/original_page.png" alt="Original Page 206">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<pre><code class="language-php">
        return (float) $timestamp-&gt;format('U.u');
    }
}
</code></pre>
<p>این باید کار کند، و ممکن است یک <strong>integration test</strong> صحیح باشد، اما من شک دارم که یک <strong>test</strong> بسیار مفیدی باشد.</p>
<h4> 7.7. Summary</h4>
<p>ما این فصل را با یک <strong>entity</strong> شروع کردیم که به طور ضمنی از ساعت سیستم و دستگاه تصادفی برای جمع‌آوری بخشی از داده‌های مربوطه خود استفاده می‌کرد. به جای اینکه به <strong>object</strong> اجازه دهیم خود اطلاعات را بازیابی کند، ما آن را تغییر دادیم تا اطلاعات را به عنوان آرگومان‌های <strong>constructor</strong> بپذیرد. با پیچیدن داده‌ها در داخل <strong>value objects</strong> سفارشی، ما توانستیم کد اصلی را بیشتر از کد زیرساخت جدا کنیم. ما <strong>abstractions</strong> را برای ایجاد نمونه‌هایی از این <strong>value objects</strong> ارائه کردیم. در نهایت، برای تولید <strong>value objects</strong> بر اساس زمان فعلی، ما یک <strong>abstraction Clock</strong> عمومی تنظیم کردیم.</p>
<p><strong>Exercises</strong></p>
<p>1. با استفاده از توابع داخلی <strong>PHP</strong>، کد شما فوراً تبدیل به کد زیرساخت می‌شود. این مورد برای کدام یک از عملکردهای زیر صدق می‌کند؟a</p>
<ol>
<li><code>time()</code>b</li>
<li><code>date(string $format, int $timestamp = null)</code>c فقط اولین آرگومان را ارائه می‌دهد</li>
<li><code>date(string $format, int $timestamp = null)</code> ارائه هر دو آرگومان</li>
<li><code>checkdate(int $month, int $day, int $year)</code>d</li>
</ol>
<p>2. یک <strong>object</strong> نمی‌تواند داده‌های واقعاً تصادفی را به تنهایی ارائه دهد. این نیاز دارد که به دستگاه تصادفی سیستم دسترسی پیدا کند. در مورد این <strong>value object</strong>،</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0207_original/original_page.png" alt="Original Page 207">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<p>که از <code>mt_rand()</code>e استفاده می‌کند. این تابع اعدادی را از یک توالی از پیش تعریف شده تولید می‌کند. اگر شما تابع را با استفاده از <code>mt_srand()</code>f "بذر" ندهید، اعداد به ظاهر تصادفی تولید می‌کند. اگر شما این کار را انجام دهید، همیشه همان توالی را تولید می‌کند. به نظر شما، آیا این کد باید کد زیرساخت در نظر گرفته شود؟g</p>
<pre><code class="language-php">
final class PseudoRandomNumber
{
    private int $number;

    private function __construct(int $number)
    {
        $this-&gt;number = $number;
    }

    public static function create(int $seed): self
    {
        mt_srand($seed);
        return new self(
            mt_rand()
        );
    }
}
</code></pre>
<p>aپاسخ صحیح: 1 (زیرا زمان فعلی را از ساعت سیستم بازیابی می‌کند) و 2 (به همین دلیل). هنگامی که شما یک مقدار خاص را برای آرگومان دوم <code>date()</code> ارائه می‌دهید، از آن مقدار به جای مقدار بازگشتی از <code>time()</code> استفاده می‌کند. <code>checkdate()</code> نیز برای تعیین اینکه آیا یک تاریخ داده شده صحیح است، نیازی به زمان فعلی ندارد.</p>
<p>b https://advwebapparch.com/php-time-function</p>
<p>c https://advwebapparch.com/php-date-function</p>
<p>d https://advwebapparch.com/php-checkdate-function</p>
<p>e https://advwebapparch.com/php-mt_rand-function</p>
<p>f https://advwebapparch.com/php-mt_srand-function</p>
<p>gپذیرفته شده است، این یک منطقه خاکستری است. من می‌گویم که این کد زیرساخت نیست، زیرا برای اجرا به یک <strong>context</strong> خاصی نیاز ندارد، و نه به وابستگی‌های خارجی متکی است. یک مسئله این است که کد با فراخوانی <code>mt_srand()</code>، حالت <strong>global</strong> را تغییر می‌دهد، که بر فراخوانی‌های دیگر به <code>mt_rand()</code> تأثیر می‌گذارد. با این حال، خود <strong>object</strong> به روشی کاملاً قابل پیش‌بینی رفتار می‌کند، زیرا بذردهی در اینجا صریح است. با توجه به اینکه بذر یکسان است، آن نیز <strong>object</strong> یکسانی را تولید خواهد کرد.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0208_original/original_page.png" alt="Original Page 208">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<p>شکل 7.4. نمودار وابستگی برای وضعیت فعلی.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 209" src="page_0209/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0209_original/original_page.png" alt="Original Page 209">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Time and randomness</h3>
<p>شکل 7.5. نتیجه پاکسازی.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 210" src="page_0210/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0210_original/original_page.png" alt="Original Page 210">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Validation</h3>
<p>این فصل شامل موارد زیر است:</p>
<ul>
<li>رسیدگی به نگرانی‌های مربوط به <strong>validation</strong> در کدی که هسته را از زیرساخت جدا می‌کند</li>
<li>ایجاد تمایز بین <strong>validation</strong> کاربرمحور و حفاظت از داده‌ها در سطح <strong>entity</strong></li>
<li>استفاده از <strong>exceptions</strong> به جای <strong>validating up-front</strong></li>
<li>کاهش مقدار کد <strong>validation</strong></li>
</ul>
<p>من مدتی بود که کد اصلی را از کد زیرساخت جدا می‌کردم. با این حال، یک چیز وجود داشت که جای مشخصی در این ساختار جدید نداشت: <strong>validation</strong>. من ابتدا سعی کردم تصمیم بگیرم که آیا منطق <strong>validation</strong> چیزی است که باید از تغییرات در زیرساخت جان سالم به در ببرد یا خیر. انجام همان آزمایش فکری که قبلاً انجام دادیم: اگر من از یک <strong>application web</strong> به یک <strong>application CLI</strong> مهاجرت کنم، آیا داده‌های ورودی هنوز باید <strong>validated</strong> شوند؟ خوب، البته. باید نوعی مکانیسم حفاظتی وجود داشته باشد تا اطمینان حاصل شود که <strong>application</strong> داده‌های بد یا ناسازگار را نمی‌پذیرد. همچنین، اگر راه‌حل فنی خود را برای ذخیره داده‌های خود تغییر دهم (به عنوان مثال زمانی که به یک <strong>database document</strong> تغییر می‌دهم)، آیا هنوز هم می‌توانم از ثبات این داده‌ها محافظت کنم؟ تصور کنید نتوانید به محدودیت‌های <strong>foreign key</strong> یا <strong>indexes</strong> منحصر به فرد تکیه کنید. در این صورت، باید راه دیگری وجود داشته باشد که هسته <strong>application</strong> بتواند ثبات داده‌ها را تضمین کند.</p>
<p>باز هم، اگر <strong>application web</strong> من به یک <strong>application CLI</strong> تبدیل می‌شد، حدس می‌زنم تعاملات کاربر کاملاً متفاوت می‌شد. به جای نشان دادن یک فرم <strong>HTML</strong> با پیام‌های خطا برای هر ورودی بد، احتمالاً کافی است که فقط اولین خطا را نشان دهید، به کاربر اجازه دهید تا <strong>arguments</strong> خط فرمان را اصلاح کند و دوباره امتحان کند. اگر در عوض <strong>controllers web</strong> خود را دوباره بنویسم تا <strong>API endpoints</strong> شوند، یک درخواست <strong>JSON</strong> را می‌پذیرم، و یک لیست از <strong>JSON-</strong></p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0211_original/original_page.png" alt="Original Page 211">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Validation</h3>
<p>به نظر می‌رسید که <strong>errors encoded</strong> شود. با این تفاوت که این <strong>errors</strong> به زبان کاربر ترجمه نمی‌شوند، بلکه قابل خواندن برای ماشین خواهند بود. شاید من فقط یک کد <strong>error</strong> مستند شده را برگردانم و نام <strong>field</strong> که خطای <strong>validation</strong> را تولید کرده است، ذکر کنم.</p>
<p>بنابراین اینکه کاربر یک ماشین است یا یک انسان، تفاوت زیادی در نحوه اطلاع‌رسانی ما در مورد <strong>validation errors</strong> ایجاد می‌کند. همچنین این تفاوت ایجاد می‌کند که از چه فناوری برای برقراری ارتباط با <strong>application</strong> ما استفاده می‌کنند. صرف نظر از اینکه چه کسی به <strong>application</strong> ما به چه روشی صحبت می‌کند، داده‌های ورودی که ما در داخل <strong>application</strong> خود می‌پذیریم و ذخیره می‌کنیم، باید طبق همان قوانین <strong>validated</strong> شوند (به شکل 8.1 مراجعه کنید).</p>
<p>شکل 8.1. انواع مختلفی از کاربران، انواع مختلفی از ورودی را ارائه می‌کنند و انواع مختلفی از <strong>validation errors</strong> را دریافت می‌کنند. با این حال، در هسته <strong>application</strong>، داده‌ها باید معتبر باشند، صرف نظر از اینکه چه کسی آن را ارائه کرده است.</p>
<p>خواه این یک کاربر باشد که یک فرم را در یک <strong>web browser</strong> پر می‌کند، یا یک ماشین در حال ارسال یک درخواست <strong>POST JSON</strong>، هنگامی که ما سفارشی برای کتاب‌های الکترونیکی می‌پذیریم، همیشه باید جنبه‌های خاصی از آن را تأیید کنیم:</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 212" src="page_0212/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0212_original/original_page.png" alt="Original Page 212">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Validation</h3>
<p>1. آدرس ایمیل ارائه شده باید شبیه یک آدرس ایمیل واقعی باشد.</p>
<p>2. تعداد نسخه‌های یک کتاب الکترونیکی سفارش داده شده باید حداقل 1 باشد.</p>
<p>3. <strong>IDs</strong> کتاب‌های الکترونیکی ارائه شده باید به کتاب‌های الکترونیکی که در واقع در کاتالوگ ما موجود هستند، اشاره داشته باشد.</p>
<p>این یک مجموعه قوانین خوب است که به من کمک می‌کند جنبه‌های مختلفی را نشان دهم که چگونه یک فرآیند <strong>validation</strong> باید در پروژه‌ای که کد اصلی را از زیرساخت جدا می‌کند، پیاده‌سازی شود. در این فصل ما هر قانون را بررسی می‌کنیم و متوجه می‌شویم که چگونه و کجا باید تأیید شود.</p>
<h4> 8.1. Protecting entity state</h4>
<p>در نهایت، داده‌های ارائه شده توسط یک کاربر از <strong>application</strong> ما، در داخل یک <strong>entity</strong> قرار می‌گیرند. سپس یک <strong>application service</strong>، <strong>entity</strong> را در <strong>database</strong> ذخیره می‌کند. همانطور که احتمالاً می‌دانید، اگر <strong>database</strong> شما حاوی داده‌های بد، ناقص یا ناسازگار باشد، می‌توانید خود را در دردسر زیادی بیندازید. بنابراین ما باید مطمئن شویم که هیچ چیز در <strong>entity</strong> ما ختم نمی‌شود، که هنگام ذخیره در <strong>database</strong>، منجر به یک <strong>database</strong> خراب شود.</p>
<p>با این حال، یک رویکرد بسیار رایج برای <strong>validation</strong>، که من سال‌هاست از آن استفاده می‌کنم، به هیچ وجه از این امر جلوگیری نمی‌کند. <strong>Listing</strong> 8.1 نشان می‌دهد که این سبک قدیمی <strong>validation</strong> چگونه به نظر می‌رسد: ما <strong>object</strong> سفارش را ایجاد می‌کنیم و به تدریج <strong>fields</strong> آن را با داده‌ها از <strong>request</strong> پر می‌کنیم. سپس ما یک <strong>validator</strong> را فراخوانی می‌کنیم تا <strong>object</strong> را <strong>validate</strong> کند. اگر <strong>validator</strong> هیچ <strong>error validation</strong> را برنگرداند، همه چیز خوب است، و ما می‌توانیم به جلو برویم و سفارش را ذخیره کنیم.</p>
<p><strong>Listing</strong> 8.1. Validating an <strong>object</strong> after populating its <strong>fields</strong></p>
<pre><code class="language-php">
final class OrderController
{
    // ...
    public function createOrder(Request $request): Response
    {
        $order = new Order();
        $order-&gt;setEmailAddress($request-&gt;get('email'));
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0213_original/original_page.png" alt="Original Page 213">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Validation</h3>
<pre><code class="language-php">
$line = new Line();
        $line-&gt;setEbookId($request-&gt;get('ebook_id'));
        $line-&gt;setQuantity($request-&gt;get('quantity'));

        $errors = $this-&gt;validator-&gt;validate($order);

        if (count($errors) === 0) {
            $this-&gt;orderRepository-&gt;save($order);
            /*
             * Redirect to the "thank you" page
             */
        } else {
            /*
             * Render the form again including the validation errors
             */
        }
</code></pre>
<p><strong>validator</strong> باید وارد <strong>object</strong> شود، داده‌های آن را بررسی کند، و قوانین خاصی را تأیید کند. این بدان معناست که <strong>validator</strong> دانش زیادی در مورد اینکه یک سفارش معتبر چیست، خواهد داشت. این باید آدرس ایمیل، تعداد خطوط، مقدار سفارش داده شده، اینکه آیا <strong>ID</strong> کتاب الکترونیکی ارائه شده به یک کتاب الکترونیکی واقعی اشاره دارد، و غیره را <strong>validate</strong> کند. کتابخانه‌های <strong>validator</strong> وجود دارند که می‌توانند این کار را با اجازه دادن به شما برای استفاده از <strong>configuration</strong> به جای کد، برای شما آسان کنند. من شک دارم که این بهتر باشد، زیرا به راحتی می‌توان در <strong>configuration validator</strong> اشتباه کرد، که اجازه می‌دهد داده‌های بد از آن عبور کنند. چه شما خودتان کد را بنویسید یا از یک <strong>library validator</strong> استفاده کنید، در واقع یکسان است. <strong>validator</strong> باید متدهای <strong>getter</strong> را بر روی <strong>object Order</strong> فراخوانی کند تا داده‌ها را از <strong>object</strong> خارج کند و آن را تجزیه و تحلیل کند. اگر مشکلی پیش بیاید، یک پیام به لیستی از <strong>validation errors</strong> اضافه می‌کند. اگر شما مجبور بودید این کد را خودتان بنویسید، چیزی شبیه به <strong>Listing</strong> 8.2 خواهد بود.</p>
<p>توجه داشته باشید که من از کلیدهای ترجمه (به عنوان مثال <code>create_order.invalid_email_address</code>) به جای پیام‌های متنی کامل استفاده می‌کنم، بنابراین می‌توانم بعداً این پیام‌ها را به زبان کاربر ترجمه کنم.</p>
<p><strong>Listing</strong> 8.2. Validating an order by inspecting its data from the outside</p>
<pre><code class="language-php">
final class OrderValidator
{
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0214_original/original_page.png" alt="Original Page 214">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Validation</h3>
<pre><code class="language-php">
/**
     * @return array&lt;string,array&lt;string&gt;&gt;
     */
    public function validate(Order $order): array
    {
        $errors = [];

        if (!filter_var($order-&gt;getEmail(), FILTER_VALIDATE_EMAIL)) {
            $errors['email'][] = 'create_order.invalid_email_address';
        }

        foreach ($order-&gt;getLines() as $line) {
            try {
                $this-&gt;ebookRepository-&gt;getById($line-&gt;getEbookId());
            } catch (CouldNotFindEbook $exception) {
                $errors['ebook_id'][] = 'create_order.could_not_find_ebook'
                    . $line-&gt;getEbookId();
            }
        }
        // ...
        return $errors;
    }
}
</code></pre>
<p>من اصلاً این کد را دوست ندارم، زیرا تمام آن <strong>getters</strong> روی <strong>object Order</strong> فقط برای این هستند که <strong>validator</strong> داده‌ها را دوباره بیرون بیاورد. ما قبلاً در فصل 3 نتیجه گرفته بودیم که این نامطلوب است. یک مشکل بزرگتر این است که <strong>object Order</strong> ما همچنین دارای <strong>setters</strong> است که می‌توانید از آنها برای تنظیم هر مقدار به صورت جداگانه استفاده کنید. خود <strong>setter</strong> فقط می‌تواند نوع داده ارائه شده را با افزودن انواع به پارامترهای آن اعمال کند. اما <strong>setter</strong> به هیچ وجه به مقدار ارائه شده نزدیک‌تر نگاه نمی‌کند. مقدار را <strong>validate</strong> نمی‌کند، اگر کسی یک آدرس ایمیل بد ارائه دهد، یک <strong>exception</strong> را پرتاب نمی‌کند. این بدان معناست که داده‌های بد می‌توانند در داخل <strong>entity Order</strong> قرار گیرند. و اگر هیچ کس <code>OrderValidator::validate()</code> را برای <strong>validate</strong> کردن <code>Order</code> فراخوانی نکند، داده‌های نامعتبر آن می‌تواند مستقیماً در <strong>database</strong> ذخیره شود.</p>
<p>رابطه بین این دو <strong>objects</strong>، <strong>validator</strong> و <strong>entity</strong>، این است</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0215_original/original_page.png" alt="Original Page 215">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Validation</h3>
<p>یک <strong>healthy</strong> نیست. آنها همیشه باید با هم استفاده شوند و با هم تکامل می‌یابند، به عبارت دیگر: آنها به یکدیگر متصل هستند. <strong>Coupling</strong> به خودی خود بد نیست، اما وقتی قانونی وجود دارد که یک <strong>object</strong> (<strong>validator</strong>) باید قبل از <strong>object</strong> دیگر (<strong>entity</strong>) استفاده شود، یک مشکل است. در این مورد، این بدان معناست که استفاده از <strong>entity</strong> اصلاً ایمن نیست، زیرا چه کسی می‌داند آیا <strong>validated</strong> شده است یا خیر.</p>
<p>این مشکل را می‌توان بسیار آسان حل کرد. ما می‌توانیم <strong>entity</strong> را خود <strong>validating</strong> کنیم. هر زمان که یک <strong>client</strong> سعی می‌کند یک نمونه جدید از <strong>entity</strong> را ایجاد کند، می‌تواند حداقل داده‌های مورد نیاز را به عنوان آرگومان‌های <strong>constructor</strong> اعمال کند. هر زمان که یک <strong>client</strong> می‌خواهد داده‌های بیشتری ارائه دهد یا داده‌های موجود را اصلاح کند، <strong>entity</strong> می‌تواند دوباره آرگومان‌های ارائه شده را قبل از اختصاص هر مقدار جدیدی به <strong>properties</strong> خود، <strong>validate</strong> کند. شما می‌توانید بگویید که این <strong>validation</strong> نیست، بیشتر شبیه حفاظت است. ما یک مقدار را به یک <strong>property</strong> اختصاص نمی‌دهیم، سپس آن را <strong>validate</strong> می‌کنیم. ما از <strong>object</strong> در برابر قرار گرفتن در یک حالت نادرست محافظت می‌کنیم.</p>
<p>این ما را از استفاده از یک <strong>validator</strong> قبل از ذخیره <strong>entity</strong> رها می‌کند. هر متدی (شامل <strong>constructor</strong>) که مقادیر را به <strong>properties</strong> اختصاص می‌دهد، اطمینان حاصل می‌کند که حالت حاصل از <strong>entity</strong> همیشه معتبر است. ما نمی‌توانیم مرتکب اشتباهی مانند فراخوانی این متدها با آرگومان‌های از دست رفته یا نامعتبر شویم، زیرا <strong>entity</strong> با صدای بلند به ما خواهد گفت که چه اشتباهی انجام داده‌ایم. <strong>Listing</strong> 8.3 نشان می‌دهد که این در مورد <strong>entity Order</strong> چگونه کار می‌کند. هر متدی که داده‌ها را می‌پذیرد، این داده‌ها را <strong>validate</strong> می‌کند و <strong>exceptions</strong> را پرتاب می‌کند تا هر مشکلی را در اسرع وقت نشان دهد.</p>
<p><strong>Listing</strong> 8.3. The <strong>Order entity</strong> only accepts valid data.</p>
<pre><code class="language-php">
final class Order
{
    private string $emailAddress;

    /**
     * @var array&lt;Line&gt;
     */
    private array $lines;

    public function __construct(string $emailAddress)
    {
        // Before assigning, we verify that the email address is valid
        if (!filter_var($emailAddress, FILTER_VALIDATE_EMAIL)) {
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0216_original/original_page.png" alt="Original Page 216">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Validation</h3>
<pre><code class="language-php">
// We don't return an error, but throw an exception
        throw new InvalidArgumentException(
            sprintf('Invalid email address: ' . $emailAddress)
        );
    }
    $this-&gt;emailAddress = $emailAddress;
}

public function addLine(EbookId $ebookId, int $quantity): void
{
    // We delegate the validation of $quantity to the Line constructor
    $this-&gt;lines[] = new Line($ebookId, $quantity);
}
</code></pre>
<p><code>exceptions</code> هستند. در واقع، آنها نباید</p>
<pre><code class="language-php">
final class Line
{
    private EbookId $ebookId;
    private int $quantity;

    public function __construct(EbookId $ebookId, int $quantity)
    {
        if ($quantity &lt;= 0) {
            throw new InvalidArgumentException(
                sprintf('Line quantity should be at least 1')
            );
        }
        $this-&gt;ebookId = $ebookId;
        $this-&gt;quantity = $quantity;
    }
}
</code></pre>
<p>“<strong>Exceptions</strong> خیلی کاربرپسند نیستند، درست است؟”</p>
<p>شما کاملاً درست می‌گویید، <strong>exceptions</strong> کاربرپسند نیستند. در واقع، آنها باید</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0217_original/original_page.png" alt="Original Page 217">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Validation</h3>
<p>هرگز در صفحه کاربر نشان داده نشود. پیام <strong>exception</strong> و ردیابی <strong>stack</strong> همراه آن، فقط باید برای توسعه‌دهندگان قابل مشاهده باشد. آنها باید بدانند که چه زمانی یک <strong>validation exception</strong> اتفاق می‌افتد، زیرا اغلب فرصتی برای بهبود تجربه کاربری است. ما در بخش 8.4 در مورد این موضوع صحبت خواهیم کرد، زمانی که در مورد نحوه استفاده از <strong>exceptions</strong> برای صحبت با کاربر پس از آن بحث می‌کنیم.</p>
<p>وقتی صحبت از کاربردوستی می‌شود، ما ممکن است نوع دیگری از <strong>validation</strong> ارائه دهیم. موردی که <strong>exceptions</strong> را پرتاب نمی‌کند، بلکه یک لیست خوب از <strong>errors form</strong> دوستانه را به زبان کاربر تولید می‌کند. ما این رویکرد را در بخش 8.3 پوشش خواهیم داد.</p>
<h4> 8.2. Using value objects to validate separate values</h4>
<p>هنگام صحبت در مورد <strong>objects</strong> که از خود در برابر داده‌های بد محافظت می‌کنند، مفهوم یک <strong>object Value</strong> ممکن است به ذهن خطور کند. یک <strong>object value</strong>، <strong>object</strong>ی است که یک یا چند مقدار دیگر را در بر می‌گیرد. این مقادیر می‌توانند مقادیر از نوع <strong>primitive</strong> مانند رشته‌ها، اعداد صحیح، بولی‌ها یا اعداد ممیز شناور باشند، یا می‌توانند خودشان <strong>value objects</strong> باشند. مزایای متعددی برای پیچیدن یک مقدار در داخل یک <strong>object value</strong> وجود دارد. در زمینه <strong>validation</strong>، <strong>value objects</strong> مفید هستند زیرا هرگز نیازی به <strong>validated</strong> شدن ندارند. <strong>constructor</strong> یک <strong>object value</strong>، مقدار خام ارائه شده به آن را تجزیه و تحلیل می‌کند و در صورت نامعتبر بودن، یک <strong>exception</strong> را پرتاب می‌کند.</p>
<p>بازنویسی مثال قبلی با استفاده از <strong>value objects</strong>، ما می‌توانیم <strong>validation</strong> آدرس ایمیل ارائه شده و مقدار خط سفارش را به <strong>objects EmailAddress</strong> و <code>Quantity</code> تخصصی واگذار کنیم. <strong>Listing</strong> 8.4 نشان می‌دهد که کلاس‌های این <strong>value objects</strong> چگونه ممکن است به نظر برسند. ما اساساً می‌توانیم عبارت‌های <code>if</code> و <code>throw</code> موجود را از <strong>entity Order</strong> به این کلاس‌های جدید منتقل کنیم.</p>
<p><strong>Listing</strong> 8.4. <strong>Value objects</strong> wrapping and validating primitive-type values.</p>
<pre><code class="language-php">
final class EmailAddress
{
    private string $emailAddress;

    public function __construct(string $emailAddress)
    {
        if (!filter_var($emailAddress, FILTER_VALIDATE_EMAIL)) {
            // We don't return an error, but throw an exception
            throw new InvalidArgumentException(
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0218_original/original_page.png" alt="Original Page 218">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Validation</h3>
<pre><code class="language-php">
throw new InvalidArgumentException(
            sprintf('Invalid email address: ' . $emailAddress)
        );
</code></pre>
<p>زمانی که یک آرگومان متد از نوع <code>EmailAddress</code> یا <code>Quantity</code> است، شما می‌دانید که مقدار داخل آن قبلاً <strong>validated</strong> شده است. نیازی به <strong>validate</strong> کردن مجدد مقدار نیست، بنابراین شما اکنون می‌توانید با خیال راحت این <strong>object</strong> را بپذیرید. این کد را در <code>Order</code> به میزان زیادی ساده می‌کند، همانطور که در <strong>Listing</strong> 8.5 می‌بینید.</p>
<p><strong>Listing</strong> 8.5. <strong>Value objects</strong> simplify validation inside the entity.</p>
<pre><code class="language-php">
final class Order
{
    private EmailAddress $emailAddress;

    /**
     * @var array&lt;Line&gt;
     */
    private array $lines;

    public function __construct(EmailAddress $emailAddress)
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0219_original/original_page.png" alt="Original Page 219">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Validation</h3>
<pre><code class="language-php">
{
        $this-&gt;emailAddress = $emailAddress;
    }

    public function addLine(EbookId $ebookId, Quantity $quantity): void
    {
        $this-&gt;lines[] = new Line($ebookId, $quantity);
    }
}

final class Line
{
    private EbookId $ebookId;
    private Quantity $quantity;

    public function __construct(EbookId $ebookId, Quantity $quantity)
    {
        $this-&gt;ebookId = $ebookId;
        $this-&gt;quantity = $quantity;
    }
}
</code></pre>
<p>درباره <strong>objects</strong> و اینکه چگونه آنها باید از حالت خود محافظت کنند، چیزهای بیشتری برای گفتن وجود دارد. من در کتاب دیگری به نام <strong>Object Design Style Guide</strong> (<strong>Manning</strong>, 2019) در مورد آن نوشته‌ام. در حال حاضر، اجازه دهید آن را به این صورت خلاصه کنیم: یک <strong>object</strong> باید اطمینان حاصل کند که داده‌های آن هرگز ناقص، نامعتبر یا ناسازگار نیستند.</p>
<ul>
<li>ناقص به این معنی است که داده‌های از دست رفته وجود دارد که واقعاً باید برای انجام حتی اساسی‌ترین وظایف وجود داشته باشند. به عنوان مثال داده‌ها ناقص خواهند بود اگر ما یک مقدار داشته باشیم، اما هیچ ارزی نداشته باشیم.</li>
<li>نامعتبر به این معنی است که داده‌ها از نوع مناسبی هستند، اما مقدار آن، کیفیت‌های مورد نظر را ندارد. به عنوان مثال: ما یک ارز (<strong>string</strong>) داریم، اما یک ارز شناخته شده نیست (موارد معتبر عبارتند از: <code>'EUR'</code>، <code>'USD'</code> و غیره).</li>
<li>ناسازگار به این معنی است که دو یا چند قطعه داده وجود دارد که نمی‌توانند با هم وجود داشته باشند. به عنوان مثال، سفارش برای پرداخت از طریق انتقال بانکی علامت‌گذاری شده است، اما همچنین مقداری برای صاحب کارت اعتباری دارد.</li>
</ul>
<p>علاوه بر محافظت از حالت فعلی خود، یک <strong>object</strong> همچنین مسئولیتی در قبال</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0220_original/original_page.png" alt="Original Page 220">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Validation</h3>
<p>جلوگیری از وقوع <strong>state transitions</strong> بد. اگر سفارشی پرداخت و تحویل داده شده باشد، دیگر نمی‌توان آن را لغو کرد. فقط یک سفارش در حال انتظار را می‌توان لغو کرد. در موقعیت‌های دیگر، شما ابتدا باید درخواست بازپرداخت کنید، یا به نوعی تحویل را برگردانید.</p>
<p>هنگامی که شما تمام این اقدامات را اضافه کردید تا به <strong>objects</strong> اجازه دهید از حالت خود محافظت کنند، آنها کاملاً ایمن خواهند بود. هر <strong>client</strong> می‌تواند <strong>object</strong> را <strong>instantiate</strong> کند، هر متدی را روی آن فراخوانی کند، و اگر داده‌های اشتباه را ارائه دهند، یا <strong>state transition</strong> درخواستی مجاز نباشد، شکست می‌خورد و به <strong>client</strong> در مورد آنچه که اشتباه انجام داده است، اطلاع می‌دهد. این را با مثال اصلی که در آن ما از یک <strong>validator</strong> برای <strong>validate</strong> کردن <strong>object</strong> استفاده می‌کردیم، مقایسه کنید. در آن مثال، ما لیستی از <strong>errors</strong> را از <strong>validator</strong> دریافت کردیم، اما <strong>entity</strong> با این وجود در یک حالت بد قرار می‌گرفت. اکنون که <strong>entity</strong> با اولین علامت چیزی که اشتباه است با صدای بلند شکست می‌خورد، ما به آنچه می‌خواستیم دست یافتیم. ما اکنون می‌توانیم مطمئن باشیم که هر داده‌ای که به یک <strong>property</strong> از <strong>entity</strong> اختصاص داده می‌شود، صحیح و سازگار است. بنابراین اگر ما (تصادفاً یا عمداً) آن را در <strong>database</strong> ذخیره کنیم، به داده‌های خراب ختم نخواهیم شد.</p>
<p>خب، یک سناریو وجود دارد که ما آن را پوشش ندادیم که ممکن است هنوز به ما داده‌های خراب بدهد. یک <strong>entity</strong> می‌تواند بیشتر داده‌هایی را که به عنوان آرگومان‌های <strong>constructor</strong> یا متد به آن منتقل می‌شود، <strong>validate</strong> کند. اما نمی‌تواند همه چیز را <strong>validate</strong> کند، زیرا نمی‌تواند فراتر از خودش و داده‌های ارائه شده به آن نگاه کند. یک مثال، پارامتر <code>EbookId</code> متد <code>addLine()</code> است (<strong>Listing</strong> 8.6): <code>Order</code> نمی‌تواند به تنهایی تشخیص دهد که آیا یک <code>EbookId</code> داده شده به یک کتاب الکترونیکی واقعی در کاتالوگ ما اشاره دارد یا خیر.</p>
<p><strong>Listing</strong> 8.6. Does the provided <code>EbookId</code> refer to an actual e-book?</p>
<pre><code class="language-php">
final class Order
{
    // ...
    public function addLine(EbookId $ebookId, int $quantity): void
    {
        /*
         * There's no way to verify that the provided ID refers to
         * an actual e-book from our catalog...
         */
</code></pre>
<p>حتی این واقعیت که ما از یک <strong>object value</strong> برای نشان دادن شناسه‌ کتاب الکترونیکی استفاده می‌کنیم</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0221_original/original_page.png" alt="Original Page 221">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Validation</h3>
<p>به این معنی نیست که یک <code>EbookId</code> معتبر است. تنها کاری که خود <code>EbookId</code> می‌تواند انجام دهد، <strong>validate</strong> کردن داده‌های ورودی خود، تأیید اینکه <strong>string</strong> ارائه شده به آن هنگام <strong>instantiated</strong> شدن با الگوی یک <strong>UUID</strong> مطابقت دارد، است.</p>
<p>از آنجایی که خود <strong>entity Order</strong> نمی‌تواند <code>EbookId</code> ارائه شده را <strong>validate</strong> کند، <strong>service</strong> که <code>addLine()</code> را فراخوانی می‌کند، باید به جای آن این کار را انجام دهد. یک راه خوب برای انجام این کار استفاده از <strong>repository entity</strong> برای <strong>entity</strong> مربوطه و واکشی <strong>entity</strong> از آن است. اگر وجود نداشته باشد، <strong>repository</strong> یک <strong>exception</strong> را پرتاب می‌کند و ما را از استفاده از <strong>ID</strong> یک <strong>entity</strong> که وجود ندارد، باز می‌دارد.</p>
<p>در بسیاری از موارد، رابطه به دلیلی وجود دارد، و ما در واقع به اطلاعات بیشتری از <strong>entity</strong> مربوطه، بیش از این واقعیت که وجود دارد، نیاز داریم. در وضعیت فعلی ما، ما باید بدانیم که <strong>Ebook</strong> وجود دارد، و ما همچنین به قیمت کتاب الکترونیکی نیاز داریم. بنابراین منطقی است که رابطه بین خط سفارش و کتاب الکترونیکی را با واکشی <strong>read model Ebook</strong> از <strong>repository read model</strong> آن <strong>validate</strong> کنیم، همانطور که در فصل 3 انجام دادیم.</p>
<p><strong>Listing</strong> 8.7 نشان می‌دهد که چگونه این در یک <strong>application service</strong> کار می‌کند. با واکشی <strong>read model Ebook</strong> توسط <strong>ID</strong> ارائه شده، ما وجود آن را تأیید می‌کنیم. اگر وجود نداشته باشد، <code>getById()</code> یک <strong>exception CouldNotFindEbook</strong> را پرتاب می‌کند.</p>
<p><strong>Listing</strong> 8.7. Validating the e-book ID by loading a corresponding read model.</p>
<pre><code class="language-php">
$ebook = $this-&gt;ebookRepository-&gt;getById(
        EbookId::fromString($ebookId)
    );

    $order = new Order(/* ... */);
    $order-&gt;addLine(
        $ebook-&gt;ebookId(),
        $quantity,
        $ebook-&gt;price()
    );
</code></pre>
<p>آیا ما نمی‌توانیم کل <strong>object Ebook</strong> را به عنوان یک آرگومان به متد <code>addLine()</code> منتقل کنیم؟ بله، من فکر می‌کنم می‌توانیم. این به <code>addLine()</code> اجازه می‌دهد که کمتر منفعل باشد. به جای ارائه فقط مقادیر جداگانه (<code>EbookId</code> و قیمت)، ما می‌توانیم <strong>read model Ebook</strong> را به آن بدهیم. این تضمین می‌کند که قیمت و <code>EbookId</code> در خط، واقعاً به یک کتاب الکترونیکی تعلق دارند. به عنوان یک پاداش، کد از نوع <code>addLine()</code></p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0222_original/original_page.png" alt="Original Page 222">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Validation</h3>
<p>متد اکنون نشان می‌دهد که این مقادیر از کجا می‌آیند و اینکه آنها به هم تعلق دارند (<strong>Listing</strong> 8.8).</p>
<p><strong>Listing</strong> 8.8. Passing the <strong>Ebook read model</strong> to the <strong>Order entity</strong>.</p>
<pre><code class="language-php">
// ...
        $order-&gt;addLine($ebook, $quantity);

    // inside the Order class:
    public function addLine(Ebook $ebook, int $quantity): void
    {
        $this-&gt;lines[] = new Line(
            $ebook-&gt;ebookId(),
            $ebook-&gt;price(),
            $quantity
        );
    }
</code></pre>
<p>با این حال، ما باید آگاه باشیم که با انجام این کار ممکن است به <code>Order</code> در مورد جزئیات زیادی در مورد <code>Ebooks</code> اجازه دهیم. این به میزان داده‌هایی که <strong>Ebook read model</strong> نشان می‌دهد، بستگی دارد. اگر <strong>read model</strong> فقط برای این <strong>use case</strong> خاص طراحی شده باشد، هیچ خطر واقعی وجود ندارد. در این صورت، <strong>read model</strong> فقط آنچه را که این <strong>client</strong> خاص به آن نیاز دارد، نشان می‌دهد. اگر <strong>read model</strong> در مکان‌های دیگر نیز استفاده شود، ممکن است اطلاعات بی‌ربط زیادی را در معرض دید قرار دهد. این ممکن است هنوز هم یک مشکل بزرگ نباشد، اما به خاطر داشته باشید که هر چه متدهای کمتری را به یک <strong>client</strong> در معرض دید قرار دهید، طراحی شما انعطاف‌پذیرتر خواهد بود.</p>
<p>یک کاری که شما نباید انجام دهید این است که یک <strong>entity</strong> کامل را به یک <strong>object</strong> دیگر منتقل کنید. روابط باید بر اساس <strong>ID</strong>، و نه بر اساس <strong>object reference</strong>، ایجاد شوند. به اشتراک گذاشتن یک <strong>entity</strong>، تمام متدهای تعدیل‌کننده <strong>entity</strong> را برای <strong>clients</strong> که قصد ایجاد تغییراتی در آن را ندارند (یا نباید قصد آن را داشته باشند) در معرض دید قرار می‌دهد.</p>
<h4> 8.3. Form validation</h4>
<p>تا کنون ما به راه‌هایی برای جلوگیری از ورود داده‌های بد به <strong>domain objects</strong> خود نگاه می‌کردیم. در حال حاضر ما می‌توانیم مطمئن باشیم که تمام داده‌هایی که در</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0223_original/original_page.png" alt="Original Page 223">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Validation</h3>
<p><strong>side entities</strong> و <strong>value objects</strong> معتبر خواهد بود. ما همچنین این واقعیت را مشخص کردیم که <strong>entities</strong> مرتبط در واقع وجود دارند، بنابراین ما دیگر نیازی به نگرانی در مورد آن نداریم.</p>
<p>با این حال، روشی که ما از <strong>domain model</strong> خود در برابر ورودی بد محافظت می‌کنیم، بررسی هر مقدار ورودی در آخرین لحظه ممکن است. درست قبل از اینکه مقدار ارائه شده را به یک <strong>property object</strong> اختصاص دهیم، اگر چیزی اشتباه به نظر برسد، یک <strong>exception</strong> را پرتاب می‌کنیم. <strong>Exceptions</strong> زمانی عالی هستند که شما می‌خواهید یک عملیات را مسدود کنید و از اجرای بیشتر جلوگیری کنید. برای اهداف دیگر، این کار چندان مفید نیست.</p>
<p>اگر ما بخواهیم یک پیام <strong>error</strong> را به زبان کاربر ارائه دهیم، یک <strong>exception</strong> خیلی مفید نیست. <strong>Exceptions</strong> فقط برای مشاهده برای نگهدارندگان <strong>application</strong> در نظر گرفته شده‌اند، بنابراین آنها می‌توانند متوجه شوند که چه چیزی اشتباه شده است. قرار دادن آنها به طور مستقیم در معرض دید کاربر اغلب یک خطر امنیتی است. بنابراین ما واقعاً نمی‌توانیم یک <strong>exception</strong> را به یک پیام <strong>error</strong> کاربرپسند تبدیل کنیم.</p>
<p>اگر به جای یک پیام <strong>error</strong> واحد، ما بخواهیم لیستی از پیام‌های <strong>error</strong> ارائه دهیم، نمی‌توانیم این کار را انجام دهیم. ما فقط در مورد اولین چیزی که اشتباه پیش رفت، مطلع خواهیم شد. هنگامی که کاربر فرم را دوباره ارسال می‌کند، ما فقط می‌توانیم در مورد مشکل بعدی به آنها بگوییم. این کاربرپسند نیست. کاربر نباید بارها و بارها فرم را ارسال کند تا در نهایت درست شود. آنها باید بتوانند ببینند که چه چیزی در هر یک از <strong>fields</strong> در فرم در اولین بار که آن را ارسال می‌کنند، اشتباه است.</p>
<p>بنابراین برای <strong>form validation</strong> ما نمی‌توانیم به <strong>exceptions entity-level</strong> تکیه کنیم. ما می‌خواهیم تمام مشکلات را جمع‌آوری کنیم و آنها را به عنوان مجموعه‌ای از <strong>errors form</strong> به کاربر نشان دهیم. ما همچنین نمی‌خواهیم تا زمانی که داده‌ها قبلاً در داخل <strong>entity</strong> قرار گرفته‌اند، صبر کنیم. آیا ما باید <strong>errors form</strong> را در داخل <strong>application service</strong> خود جمع‌آوری کنیم؟ ما نمی‌توانیم این کار را انجام دهیم، زیرا <strong>application service</strong> از منشاء داده‌ها آگاه نیست. این نمی‌تواند لیستی از <strong>errors form</strong> ارائه دهد زیرا یک فرم یک چیز بسیار خاص وب است. ما باید این کار را قبل از استفاده از داده‌ها در داخل <strong>application service</strong> انجام دهیم، یعنی در <strong>web controller</strong>. یک پیاده‌سازی بیش از حد ساده‌شده چیزی شبیه به <strong>Listing</strong> 8.9 خواهد بود.</p>
<p><strong>Listing</strong> 8.9. Validating form data inside the controller.</p>
<pre><code class="language-php">
public function createOrderAction(Request $request): Response
    {
        $formErrors = [];

        if (!filter_var($request-&gt;get('email'), FILTER_VALIDATE_EMAIL)) {
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0224_original/original_page.png" alt="Original Page 224">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3> Validation</h3>
<pre><code class="language-php">
$formErrors['email'][] = 'create_order.invalid_email_address';
        }

        // More validation...

        if (count($formErrors) === 0) {
            /*
             * Call the application service that creates the Order
             *
             * Redirect to "thank you" page
             */
        } else {
            /*
             * Render the form again including the validation errors
             */
        }
    }
}
</code></pre>
<p>این منطقی است که داده‌های ورودی را در داخل <strong>controller</strong> <strong>validate</strong> کنید. <strong>errors validation</strong> باید به <strong>fields form</strong> مربوطه مرتبط شوند، و این دانش در داخل یا نزدیک به <strong>controller</strong> در دسترس است (در واقع، در داخل <strong>template</strong>). در عین حال، این رویکرد از <strong>validating form data</strong> در داخل <strong>controller</strong> کاملاً منطقی نیست، زیرا ما در حال تکرار منطق <strong>validation</strong> هستیم. ما دیده‌ایم که دقیقاً همان فراخوانی به <code>filter_var()</code> چندین بار اکنون. این همان موردی است که در <strong>object value EmailAddress</strong> که در بخش 8.2 معرفی کردیم. است</p>
<p>برای جلوگیری از تکرار و حفظ دانش در مورد اینکه یک آدرس ایمیل معتبر چیست در یک مکان واحد، ما باید از <strong>value object</strong> در حین <strong>validating</strong> ورودی فرم استفاده کنیم. حذف تکرار و نگه داشتن دانش در یک مکان واحد دارای یک مزیت مهم است. هر زمان که چیزی در مورد منطق <strong>validation</strong> تغییر می‌کند، ما مجبور نیستیم کد را در دو مکان به‌روزرسانی کنیم.</p>
<p><strong>Listing</strong> 8.10 نشان می‌دهد که چگونه می‌توانید از یک <strong>object value</strong> هنگام انجام <strong>form vali- dation</strong> استفاده کنید. شما سعی می‌کنید <strong>object value</strong> را به روش عادی ایجاد کنید، و هنگامی که این <strong>exception</strong> را ایجاد می‌کند، شما می‌دانید که مشکلی وجود داشته است.</p>
<p><strong>Listing</strong> 8.10. Reusing the <strong>EmailAddress</strong> class for validation</p>
<pre><code class="language-php">
public function createOrderAction(Request $request): Response
    {
        $formErrors = [];
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0225_original/original_page.png" alt="Original Page 225">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<p>
    در این قسمت، به بررسی اعتبار سنجی داده‌ها می‌پردازیم.
  </p>
<p>
<pre><code class="language-php">
try {
    new EmailAddress($request-&gt;get('email'));
} catch (InvalidArgumentException $exception) {
    $formErrors['email'][] = 'create_order.invalid_email_address';
}
// ...
</code></pre>
</p>
<p>
    حال، در مورد اعتبار سنجی <strong>E-book ID</strong> که کاربر ارسال کرده است، چه می‌توان گفت؟ ما می‌توانیم
    یک کار مشابه انجام دهیم، به این صورت که: تلاش کنیم تا <strong>Ebook</strong> را از <strong>repository</strong> خود fetch کنیم و اگر
    این کار ناموفق بود، یک <strong>form error</strong> اضافه کنیم (به <strong>Listing 8.11</strong> مراجعه کنید).
  </p>
<p>
<strong>Listing 8.11.</strong> Validating an ID using the repository.
  </p>
<p>
<pre><code class="language-php">
public function createOrderAction(Request $request): Response
{
    $formErrors = [];
    try {
        new EmailAddress($request-&gt;get('email'));
    } catch (InvalidArgumentException $exception) {
        $formErrors['email'][] = 'create_order.invalid_email_address';
    }
    try {
        $this-&gt;ebookRepository-&gt;getById(
            EbookId::fromString($request-&gt;get('ebook_id'))
        );
    } catch (CouldNotFindEbook $exception) {
        $formErrors['ebook_id'][] = 'create_order.could_not_find_ebook';
    }
    // ...
}
</code></pre>
</p>
<p>
    اگر من این کد را در یک <strong>real project</strong> پیدا می‌کردم، دو نظر داشتم:
  </p>
<ol>
<li>
      تمام این کد <strong>validation</strong>، <em>view</em> را در مورد کاری که این <strong>controller</strong> واقعاً انجام می‌دهد،
      شلوغ می‌کند. بیایید آن را از <strong>controller</strong> خارج کنیم.
    </li>
</ol>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0226_original/original_page.png" alt="Original Page 226">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<p>
    2. ما با استفاده مجدد از <strong>validation logic</strong>، <em>duplication</em> را حذف کردیم، اما همچنان
    <em>effort</em> را <em>duplicate</em> می‌کنیم. همه چیز دو بار بررسی می‌شود. آیا مطمئن هستید که
    نمی‌توانیم یکی از این <em>checks</em> را <em>skip</em> کنیم؟
  </p>
<p>
    پیشنهاد اول بسیار رایج است. اگر یک <strong>method</strong> بیش از حد بزرگ شود، بخشی از آن را از
    سر راه بردارید و از منظره لذت ببرید. با این حال، اگر از پیشنهاد دوم پیروی کنیم،
    شاید بتوانیم از شر همه این کد <strong>validation</strong> خلاص شویم.
  </p>
<p>
    سوال این بود: آیا باید همه چیز را دو بار بررسی کنیم؟ پاسخ: خیر.
  </p>
<p>
    اعتبار سنجی <strong>email address</strong> را در نظر بگیرید. آیا می‌توانیم آن را از <strong>value object</strong> یا از
    <strong>controller</strong> حذف کنیم؟ فکر می‌کنم واضح است که ما هرگز نباید اعتبار سنجی را از
    <strong>value object</strong> حذف کنیم. ما قبلاً مشخص کرده‌ایم که به آن نیاز داریم تا از اشیاء خود در برابر
    شامل <strong>invalid state</strong> محافظت کنیم. بنابراین آیا می‌توانیم آن را از <strong>controller</strong> حذف کنیم؟ بله،
    کاملاً.
  </p>
<p>
    در واقع، ما باید هر کاری که می‌توانیم انجام دهیم تا اطمینان حاصل کنیم که هیچ
    کاربری که رفتار خوبی دارد، هرگز خطای <strong>validation</strong> را نمی‌بیند. فقط مطمئن شوید که به کاربر
    کمک می‌کنید تا داده‌های صحیح را هنگام پر کردن <strong>form</strong> ارائه دهد. از <strong>frontend validation</strong> و
    <strong>assistance</strong>، به هر طریقی که منطقی باشد، استفاده کنید. در حالی که کاربر در حال وارد کردن
    <strong>email address</strong> خود است، <strong>frontend</strong> می‌تواند در صورت نادرست بودن <strong>email address</strong>،
    <em>warning</em> ارائه دهد. <strong>Form submission</strong> می‌تواند تا زمانی که <strong>email address field</strong>
    شامل یک <strong>value</strong> صحیح نیست، غیرفعال شود. همه اینها احتمال ارائه داده‌های بد به
    <strong>application</strong> توسط کاربر را کاهش می‌دهد. حتی تا جایی که فقط یک کاربر <em>malevolent</em> که
    به صورت دستی یک <strong>POST request</strong> را جعل می‌کند، می‌تواند داده‌های <strong>invalid</strong> را
    ارسال کند. در آن مرحله، ما واقعاً نیازی به نگرانی در مورد نمایش <strong>form error messages</strong>
    دوستانه به زبان کاربر نداریم. یک پیام وضعیت 400 <strong>Bad Request</strong> کافی خواهد بود.
  </p>
<p>
    همین امر در مورد اعتبار سنجی <strong>e-book ID</strong> نیز صدق می‌کند. آیا واقعاً باید این کار را انجام دهیم؟
    منبع این <strong>value</strong> هر عنصر در <strong>user interface</strong> است که به کاربر اجازه می‌دهد <strong>e-book</strong>
    مورد نظر خود را انتخاب کند. این می‌تواند یک عنصر &lt;select&gt; باشد، یا نوعی
    دکمه که فشار می‌دهند، که منجر به پر شدن یک <strong>hidden field</strong> با <strong>value</strong> صحیح می‌شود.
    اگر <strong>value</strong>ای که در نهایت ارسال می‌شود نادرست باشد، این تقصیر کاربر نیست. این
    می‌تواند یک اشتباه <strong>programming</strong> باشد (شاید <strong>hidden input value</strong> به درستی تنظیم نشده
    باشد، یا هنگام <strong>rendering</strong> عنصر <strong>select</strong> اشتباهی مرتکب شدیم). هیچ خطای
    <strong>validation</strong> نمی‌تواند در این صورت به کاربر کمک کند، و امیدوارید که این مشکل را قبل از
    انتشار کد در <strong>production</strong> گرفته باشید.
    یا می‌تواند دوباره یک کاربر <em>malevolent</em> باشد، اما آنها همچنان نیازی به یک
    دوستدار 207
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0227_original/original_page.png" alt="Original Page 227">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<p>validation error.</p>
<p>
        پس برای e-book ID validation، من همان strategy را پیشنهاد می‌کنم: حتی validate نکنید. به سادگی فرض کنید که کاربر از user interface به روش صحیح استفاده کرده و با request data دستکاری نکرده است. اگر این کار را کرده باشند، همه چیز باید خوب پیش برود زمانی که data برای instantiate و manipulate domain objects استفاده می‌شود. اگر این کار را نکرده باشند، ما هنوز protection در سطح entity را داریم و به سادگی صفحه خطای عمومی را نمایش می‌دهیم.
    </p>
<p>
        از آنجایی که throwing یک exception در سطح entity فقط یک مکانیسم protection است، شما باید آن‌ها را پیگیری کنید. اگر این exceptions را در server logs خود پیدا کردید، معمولاً به این معنی است که:
    </p>
<ol>
<li>
<p>کسی در حال سوء استفاده از application شما است، یا</p>
</li>
<li>
<p>شما باید user interface را بهبود بخشید تا users نتوانند دوباره همان اشتباه را مرتکب شوند.</p>
</li>
</ol>
<p>
        با نگاهی به داده‌های ارسال شده، باید انتخاب بین این دو گزینه آسان باشد. همچنین، اکثر users افراد خوبی هستند، بنابراین می‌توانیم فرض کنیم که بیشتر اوقات این فقط یک مسئله با user interface است که users را قادر می‌سازد تا data بد را ارسال کنند. اقدام کنید تا اطمینان حاصل شود که exception هرگز دوباره نمایش داده نمی‌شود.
    </p>
<h4><strong>8.4. Using exceptions to talk to users</strong></h4>
<p>
        منصفانه است که بگوییم، همه exceptions در سطح entity در دسته‌بندی‌های قبلی قرار نمی‌گیرند. یک دسته‌بندی سوم وجود دارد. برخی از موارد را نمی‌توان در user interface validate کرد، یا حداقل، انجام این کار بسیار ناکارآمد خواهد بود. و در برخی از موقعیت‌ها شما فقط دیر در process می‌دانید که آیا request می‌تواند به طور کامل پردازش شود یا خیر.
    </p>
<p>
        به عنوان مثال، اگر علاوه بر e-books، ما کتاب‌های فیزیکی نیز بفروشیم چه می‌شود. ما فقط supply محدودی از هر عنوان داریم و پیگیری می‌کنیم که چه تعداد کتاب هنوز در stock داریم. از آنجایی که ما فقط آنچه داریم می‌فروشیم و نمی‌توانیم re-stock کنیم، تعداد کتاب‌های هنوز در دسترس، تعداد کتاب‌هایی است که می‌توانیم به customers خود ارائه دهیم.
    </p>
<p>
        آیا باید validation را در لحظه‌ای که request می‌آید انجام دهیم؟ Listing 8.12 shows
    </p>
<p>208</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0228_original/original_page.png" alt="Original Page 228">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<p>
        چگونه این کار را انجام دهیم، که توسط یک repository که می‌تواند به ما بگوید چه تعداد کتاب موجود است، پشتیبانی می‌شود.
    </p>
<p>
        Listing 8.12. Validating the ordered quantity by checking stock levels.
    </p>
<pre><code class="language-php">
public function orderPhysicalBookAction(Request $request): Response
{
    $formErrors = [];
    $quantityAvailable = $this-&gt;stockRepository
        -&gt;numberOfAvailableBooks($request-&gt;get('book_id'));
    if ($quantityAvailable &lt; $request-&gt;get('quantity')) {
        $formErrors['quantity'][] =
            'create_order.insufficient_quantity_in_stock';
    }
    // ...
}
</code></pre>
<p>
        یک بار دیگر تصور کنید که این application دیگر یک web application نیست. اکنون یک CLI application است که system administrators می‌توانند از آن برای خرید کتاب‌های خود استفاده کنند. این بدان معناست که ما دیگر از web controller موجود استفاده نخواهیم کرد، بنابراین این validation code نیز فراخوانی نمی‌شود. اکنون مردم می‌توانند کتاب‌هایی را سفارش دهند که حتی در دسترس نیستند. بنابراین باز هم، ما باید نتیجه بگیریم که core application است که باید از این اتفاق جلوگیری کند. به این ترتیب، business rules ما همیشه اعمال می‌شود، صرف نظر از زیرساخت‌های اطراف.
    </p>
<p>
        با توجه به اینکه یک entity فقط می‌تواند input data را بر اساس state فعلی خود validate کند، ما نمی‌توانیم انتظار داشته باشیم که quantity داده شده را validate کند. بنابراین تنها مکان منطقی برای validate کردن order quantity، داخل یک application service است. Listing 8.13 نشان می‌دهد که اگر منطق validation را به application service که physical book orders را پردازش می‌کند، منتقل کنیم، چگونه به نظر می‌رسد.
    </p>
<p>
        Listing 8.13. Checking availability in the application service.
    </p>
<pre><code class="language-php">
final class OrderPhysicalBookService
{
    private StockRepository $stockRepository;
    // ...
}
</code></pre>
<p>209</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0229_original/original_page.png" alt="Original Page 229">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<pre><code class="language-php">
public function order(
    string $bookId,
    int $quantity,
    /* ... */
): OrderId {
    $quantityAvailable = $this-&gt;stockRepository
        -&gt;numberOfAvailableBooks($bookId);
    if ($quantityAvailable &lt; $quantity) {
        // What to do here?
    }
    // ...
}
</code></pre>
<p>
        این اساساً همان کد است، با این تفاوت که ما واقعاً نمی‌دانیم اگر متوجه شدیم که quantity موجود کافی نیست، چه کاری باید انجام دهیم. ما نمی‌توانیم یک form error از نوعی را برگردانیم. application service قرار است حتی در یک نوع application متفاوت نیز مفید باشد.
    </p>
<p>
        ما ممکن است بازگرداندن نوعی object "result" مستقل از زیرساخت را در نظر بگیریم. هنگامی که هر نوع مشکلی وجود داشته باشد، می‌توانیم یک object از نوع Error را برگردانیم و زمانی که همه چیز خوب است، یک OrderId را برمی‌گردانیم. اگرچه در برخی از زبان‌های برنامه‌نویسی می‌توانید این کار را به راحتی انجام دهید، اما زبان‌های شیءگرا عموماً برای این کار مناسب نیستند. روش سنتی برای نشان دادن موفقیت‌آمیز بودن یک متد این است که هیچ چیز (یا یک value object مانند OrderId در این مثال) را برنگردانید، و زمانی که مشکلی پیش می‌آید یک exception پرتاب کنید.
    </p>
<p>
        ما می‌توانیم exception را در controller catch کنیم و آن را به صورت دستی به یک form error map کنیم. یا می‌توانیم از قدرت objects برای انجام این کار به صورت نیمه اتوماتیک استفاده کنیم. ابتدا، ما یک راه برای تمایز exceptions معمولی از exceptions که می‌خواهیم به کاربر در مورد آنها بگوییم معرفی می‌کنیم: رابط UserErrorMessage. هر زمان که بخواهیم در مورد چیزی که اشتباه شده است با user صحبت کنیم، یک class exception سفارشی ایجاد می‌کنیم که رابط UserErrorMessage را پیاده‌سازی می‌کند.
    </p>
<p>
        ما همچنین می‌توانیم یک base class معرفی کنیم که می‌تواند مقداری کد boilerplate را برای ما ذخیره کند (BaseUserErrorMessage). Listing 8.14 رابط و base class را نشان می‌دهد.
    </p>
<p>210</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0230_original/original_page.png" alt="Original Page 230">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<p>
        Listing 8.14. UserErrorMessage and BaseUserErrorMessage,
    </p>
<pre><code class="language-php">
interface UserErrorMessage extends Throwable
{
    public function translationKey(): string;
}

abstract class BaseUserErrorMessage
extends RuntimeException
implements UserErrorMessage
{
    private string $translationKey;

    public function __construct(
        string $translationKey
    ) {
        $this-&gt;translationKey = $translationKey;
        parent::__construct($translationKey);
    }

    public function translationKey(): string
    {
        return $this-&gt;translationKey;
    }
}
</code></pre>
<p>
        اکنون ما یک class exception سفارشی معرفی می‌کنیم و اجازه می‌دهیم از BaseUserErrorMessage گسترش یابد. با استفاده از یک constructor نام‌گذاری شده، می‌توانیم exception را به روشی که intent را نشان می‌دهد، ایجاد کنیم. Listing 8.15 کلاس exception سفارشی و نحوه پرتاب آن توسط application service را نشان می‌دهد.
    </p>
<p>
        Listing 8.15. The application service throws a UserErrorMessage exception.
    </p>
<pre><code class="language-php">
final class CouldNotOrderPhysicalBook
extends BaseUserErrorMessage
{
    public static function becauseInsufficientStockLevels(): self
    {
        return new self(
            'create_order.insufficient_quantity_in_stock'
</code></pre>
<p>211</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0231_original/original_page.png" alt="Original Page 231">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<pre><code class="language-php">
);
    }
}

final class OrderPhysicalBookService
{
    private StockRepository $stockRepository;

    public function order(
        string $bookId,
        int $quantity
        /* ... */
    ): OrderId {
        // ...
        if ($quantityAvailable &lt; $quantity) {
            throw CouldNotOrderPhysicalBook
                ::becauseInsufficientStockLevels();
        }
        // ...
    }
}
</code></pre>
<p>
        در نهایت ما می‌خواهیم error message را به user نشان دهیم. برای انجام این کار، ما باید آن را در جایی catch کنیم که بدانیم user کیست و چگونه می‌خواهیم با آنها صحبت کنیم. این بدان معناست که ما باید exception را داخل controller catch کنیم و error message را به یک form error تبدیل کنیم. Listing 8.16 نحوه انجام این کار را نشان می‌دهد.
    </p>
<p>
        Listing 8.16. Turning the exception into a form error.
    </p>
<pre><code class="language-php">
public function orderPhysicalBookAction(Request $request): Response
{
    $formErrors = [];
    // ...
    try {
        $this-&gt;orderPhysicalBook-&gt;order(
            $request-&gt;get('book_id'),
</code></pre>
<p>212</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0232_original/original_page.png" alt="Original Page 232">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<pre><code class="language-php">
$request-&gt;get('quantity')
    /* .. */
);
    } catch (UserErrorMessage $exception) {
        $formErrors['general'][] = $exception-&gt;translationKey();
    }
    // ...
}
</code></pre>
<p>
        هنگامی که شما توانایی ارائه feedback به users را با استفاده از exceptions دارید، ممکن است شروع به حذف برخی از validation code کنید و به جای آن یک UserErrorMessage پرتاب کنید. با این حال، همه exceptions در سطح domain نیازی به روبرو شدن با user ندارند. همانطور که در بخش‌های قبلی مورد بحث قرار دادیم، اکثر مسائل مربوط به validation را می‌توان با ارائه یک user experience خوب، پیشگیری کرد. کمک به user هنگام کار با user interface بهترین راه برای برقراری ارتباط با user است. استفاده از یک exception برای این کار باید آخرین راه‌حل باشد. به عنوان مثال، وقتی از StockRepository تعداد کتاب‌های موجود را درخواست می‌کنیم، و نتواند یک record را در جدول stock_levels پیدا کند، آیا باید یک UserErrorMessage پرتاب کند؟
    </p>
<p>
        برای پاسخ به این سوال؛ چه دلیلی وجود دارد که این ممکن است شکست بخورد؟ من فقط می‌توانم به دلایلی فکر کنم که یا ما مرتکب یک اشتباه برنامه‌نویسی شده‌ایم، یا user با request data دستکاری کرده است. در هر دو این موقعیت‌ها، منطقی نیست که به user در مورد مشکل بگوییم. ما باید از مشکل مطلع شویم و آن را برطرف کنیم. یا در حالت دوم، آن را نادیده بگیریم، زیرا نمی‌توانیم در مورد آن کاری انجام دهیم.
    </p>
<p>
        "آیا نباید exceptions فقط در شرایط استثنایی استفاده شوند؟"
    </p>
<p>
        من این catchphrase را اغلب شنیده‌ام، و اگرچه به طور شهودی ممکن است منطقی به نظر برسد، اما در عمل، این یک advice بسیار مفید نیست. ابتدا باید "exceptional" را تعریف کنید. ما می‌توانیم با "معمولاً اتفاق نمی‌افتد" پیش برویم. اما، چند بار "معمولاً"؟ CouldNotOrderPhysicalBook در مثال بالا در واقع یک مثال عالی از یک exception است که ما فقط در موقعیت‌های استثنایی پرتاب می‌کنیم. فقط زمانی که ما در لحظه انتخاب کتاب توسط user و ارسال فرم، stock خود را تمام می‌کنیم، باید این exception
    </p>
<p>213</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0233_original/original_page.png" alt="Original Page 233">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<p>
        thrown. Depending on how many concurrent users the application has,
        the chance that this happens should be really small. If it turns out that
        an exception is no longer exceptional, that is, it gets thrown a lot, this is a
        strong sign that we need to improve the user experience somehow.
    </p>
<p>
        تعریف دیگری از "exceptional" می‌تواند این باشد: "زمانی که اوضاع واقعاً اشتباه است".
        به عنوان مثال، شبکه قطع است، ما نمی‌توانستیم در یک فایل بنویسیم و غیره. البته،
        اینها موقعیت‌هایی هستند که در آنها باید احساس کنیم که می‌توانیم یک exception پرتاب کنیم. اما
        فکر نمی‌کنم این تنها موردی باشد که در آن مجاز به استفاده از آنها باشیم.
    </p>
<p>
        Exceptions یک راه برای متوقف کردن اجرای یک function است، و ما می‌خواهیم
        این کار را زمانی انجام دهیم که می‌دانیم نباید ادامه دهیم. جلوگیری از اتفاقات بد برای
        domain objects ما یک دلیل عالی برای پرتاب exceptions است.
    </p>
<h4><strong>8.5. When validation is not the answer</strong></h4>
<p>
        بیایید کمی بیشتر با وضعیت insufficient-stock-level بمانیم. عنوان
        بالای این بخش، غافلگیری را خراب می‌کند: شاید validation در این
        مورد پاسخگو نباشد. البته، یک بررسی ابتدایی که ما چیزی را نمی‌فروشیم
        که نداریم یک ایده خوب است. اما پاسخی که ما از StockRepository
        numberOfAvailableBooks() دریافت می‌کنیم، ممکن است به دقیقی که می‌خواهیم نباشد. ما
        این متد را در آخرین لحظه ممکن فراخوانی می‌کنیم، اما از نظر تئوری ممکن است
        هنوز پاسخ اشتباهی از آن دریافت کنیم. شاید بین فراخوانی numberOfAvailableBooks()
        و ذخیره order، system نیز order دیگری را برای همان book ذخیره می‌کند
        اما از یک customer متفاوت. اگر فقط یک کتاب باقی‌مانده از
        stock وجود داشت، customer هرگز کتابی را که سفارش داده است دریافت نخواهد کرد، زیرا customer دیگر آن را دریافت می‌کند (به هر حال، آنها اول بودند!). آیا StockRepository به ما پاسخ اشتباهی داد؟ خیر، پاسخی که ارائه داد همیشه پاسخ صحیح در لحظه‌ای است که
        پاسخ را محاسبه می‌کند. فقط این است که پاسخ همیشه در حال تغییر است.
    </p>
<p>
        از نظر functional programming، numberOfAvailableBooks() یک function impure است. چنین function، referentially transparent نیست، به این معنی که می‌تواند
        اگر دوباره function را فراخوانی کنید، پاسخ‌های متفاوتی بدهد. اما در حالی که پاسخ
        به طور مداوم در حال تغییر است، ما هنوز می‌خواهیم هنگام validation form
        data ارسال شده به application، به آن تکیه کنیم. خب، متاسفم، اما ما نمی‌توانیم به
        یک query function impure تکیه کنیم.
    </p>
<p>
        این ممکن است برای system و users شما مشکل‌ساز نباشد.
        شاید
    </p>
<p>214</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0234_original/original_page.png" alt="Original Page 234">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<p>
        numberOfAvailableBooks() یک پاسخ مفید را در 99.9999٪ از تمام موارد ارائه می‌دهد و در کار شما اختلال ایجاد نمی‌کند. اگر system شما با مشتریان زیادی سروکار دارد که همزمان از system استفاده می‌کنند و همان چیز را از آن سفارش می‌دهند، ممکن است مشکل‌ساز شود. اگر اینطور است، مقایسه دقیق بین
        دو quantity مانند کاری که تاکنون انجام می‌دادیم، رویکرد درستی نیست.
    </p>
<p>
        البته گزینه‌های بهتری هم وجود دارد. برخی از systems یک fuzzy comparison را پیاده‌سازی می‌کنند. آنها فرض نمی‌کنند که یک query function مانند numberOfAvailableBooks() قادر به ارائه یک پاسخ دقیق باشد. systemsهای دیگر هر order که وارد می‌شود را می‌پذیرند و بعداً آن را پردازش می‌کنند. البته این بر user experience تأثیر می‌گذارد.
    </p>
<p>
        User فقط یک پاسخ مقدماتی دریافت می‌کند: "بله، ما order شما را پردازش می‌کنیم، لطفاً منتظر بمانید تا پاسخ قطعی را برای شما داشته باشیم." اگر احتمال بسیار کمی وجود داشته باشد که یک order به دلیل اینکه مردم همزمان چیز یکسانی را سفارش می‌دهند، شکست بخورد، system ممکن است به هر حال به customer "بله" بدهد، فقط برای اینکه آنها را خوشحال کند. در صورت بعید بودن اینکه محصول اصلاً تحویل داده نشود، آنها با customer صحبت می‌کنند و نحوه ادامه کار را پیدا می‌کنند. شاید customer تخفیفی را در خرید بعدی خود دریافت کند، شاید یک محصول جایگزین پیدا کنند و غیره. در این موارد، بهتر است با users خود دوستانه و یاری‌رسان باشید تا اینکه زمانی که user انتظار آن را نداشت، errors پرتاب کنید.
    </p>
<p>
        با توجه به اینکه استفاده از impure query functions ممکن است در یک process validation به خوبی کار نکند، فکر می‌کنم یک قاعده خوب این است: هنگام validating input
        data، فقط از pure functions استفاده کنید. این بدان معنی است که validation خود، اگر به عنوان یک function دیده شود، خود به یک pure function تبدیل می‌شود. اگر داده‌ها را اکنون validate می‌کنید و معتبر است، باید زمانی که دوباره آن را validate می‌کنید، هنوز هم معتبر باشد. به همین ترتیب، اگر نامعتبر است، دفعه بعد که data را validate می‌کنید، باید نامعتبر باشد.
    </p>
<p>
        در تمام موقعیت‌های دیگر، ممکن است یا به validation پایبند باشید و از این واقعیت آگاه باشید که ایده‌آل نیست. یا می‌توانید system را دوباره طراحی کنید تا با مسائل به روش‌های دیگر مقابله کنید. strategy شما می‌تواند این باشد که به جای جلوگیری از موقعیت‌های خاص، هدف شما بازیابی از آنها باشد.
    </p>
<h4><strong>8.6. Creating and validating command objects</strong></h4>
<p>
        در ابتدای این فصل، ما به راه‌های مختلف برای validation input data با نگاه کردن به آن، نگاه کردیم. ما هنوز این سوال را در نظر نگرفتیم: اگر data
    </p>
<p>215</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0235_original/original_page.png" alt="Original Page 235">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<p>
        isn’t there or isn’t of the right type? When processing forms, a known issue
        is that empty input fields may not be submitted by the browser. So if we ask
        the Request object to give us the value of field X, we may find out that field
        X wasn’t even in the request body. Another issue is that we can’t distinguish
        between an empty string and null when it comes to serialized data like a
        request body. So before we know it, we’re passing around an empty string,
        where it would make more sense to use null. If not the browser, then your
        JS framework may do weird things to form data, so we need to improve the
        situation either way.
    </p>
<p>
        آنچه من پیشنهاد می‌کنم این است که ابتدا به input data مقداری shape ارائه دهید. به جای
        گرفتن مقادیر جداگانه از Request، می‌توانیم این values را بسته‌بندی کنیم
        و آنها را در یک object قرار دهیم. ما به object یک class name خوب می‌دهیم، که به
        reader می‌گوید که چگونه از data داخل آن استفاده می‌شود. ما قبلاً چنین ob-
        ject را در Section 4.4 دیده‌ایم: این یک Command object است. در آنجا آن را معرفی کردیم
        به عنوان یک راه برای گروه بندی پارامترهای یک application service call. یک command
        object همچنین به عنوان یک shape قابل تشخیص برای input data در application شما عمل می‌کند.
    </p>
<p>
        Object یک data holder است و data را از یک controller به یک appli-
        cation service منتقل می‌کند، به همین دلیل یک command object نیز یک Data Transfer Object
        (DTO) است.
    </p>
<p>
        مزایای متعددی برای دسترسی به properties یا getters یک ob-
        ject سفارشی نسبت به دسترسی به request data key by key وجود دارد.
    </p>
<ol>
<li>
<p>یک object سفارشی یک لیست کامل از تمام "keys" موجود (یعنی
                properties یا getters) را ارائه می‌دهد. یک Request object نمی‌تواند چنین لیستی را ارائه دهد و فقط
                یک lookup در request data برای هر key که شما ارائه می‌کنید هنگام فراخوانی
                get() انجام می‌دهد.</p>
</li>
<li>
<p>یک client بالقوه از یک application service می‌تواند به command ob-
                ject نگاه کند و متوجه شود چه data را باید ارائه دهد. نمی‌توانست آن را پیدا کند
                با نگاه کردن به ساختار request body، زیرا ممکن است in-
                complete باشد یا fields بیشتری نسبت به آنچه لازم است، داشته باشد، که توسط
                application نادیده گرفته می‌شود.</p>
</li>
<li>
<p>یک Request object ذاتاً از data types خاصی استفاده نمی‌کند. Values که
                از یک Request object استخراج می‌شوند یا از نوع string هستند یا unde-
                fined (null). استفاده از یک object سفارشی ما را قادر می‌سازد تا types را صریحاً تعریف کنیم
                و مشخص کنیم که آیا یک value "nullable" است یا خیر.</p>
</li>
</ol>
<p>216</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0236_original/original_page.png" alt="Original Page 236">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<ol>
<li>
<p>در داخل یک object سفارشی، ما می‌توانیم مقادیر پیش‌فرض را برای request dataهای از دست رفته با تنظیم مقادیر property پیش‌فرض تعریف کنیم.</p>
</li>
</ol>
<p>
        از آنجایی که request data از نوع string است، ما معمولاً قبل از اینکه بتوانیم از آن استفاده کنیم، باید مقداری casting انجام دهیم. من راحت می‌دانم که این کار را در داخل یک constructor نام‌گذاری شده در خود command class انجام دهم.
    </p>
<p>
        به این ترتیب دانش در مورد
        fields و آنچه در آنها وجود دارد، در داخل یک class واحد قرار دارد. Listing 8.17 یک
        مثال ساده را نشان می‌دهد. object command از نوع OrderEbook باید شامل e-
        book ID، یک quantity، یک email address، و به صورت اختیاری نام خریدار باشد.
        OrderEbook::fromRequestData() به آرایه کاملی از request data متکی است،
        بنابراین کد می‌تواند از framework خاصی که استفاده می‌کنیم جدا بماند.
    </p>
<p>
        Listing 8.17. A command gets instantiated based on request data.
    </p>
<pre><code class="language-php">
final class OrderEbook
{
    private string $emailAddress;
    private int $ebookId;
    private int $quantity;
    private ?string $buyerName;

    public function __construct(
        string $emailAddress,
        int $ebookId,
        int $quantity,
        ?string $buyerName
    ) {
        $this-&gt;emailAddress = $emailAddress;
        $this-&gt;ebookId = $ebookId;
        $this-&gt;quantity = $quantity;
        $this-&gt;buyerName = $buyerName;
    }

    /**
     * @param array&lt;string,string|null&gt; $data
     */
    public static function fromRequestData(array $data): self
</code></pre>
<p>217</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0237_original/original_page.png" alt="Original Page 237">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<pre><code class="language-php">
{
    return new self(
        $data['email'],
        $data['ebook_id'],
        $data['quantity'],
        $data['buyer_name']
    );
}
</code></pre>
<p>
        همانطور که متوجه شده‌اید، نسخه فعلی fromRequestData() قادر به رسیدگی به request dataهای از دست رفته نیست. اگر keys خاصی وجود نداشته باشند، ما برای آنها PHP notices دریافت خواهیم کرد. این متد همچنین هیچ نوع casting انجام نمی‌دهد و اگرچه ما هم نمی‌خواهیم notices را نادیده بگیریم، مطمئناً نمی‌توانیم type errors را نادیده بگیریم.
    </p>
<p>
        چگونه از یک array از request data (که احتمالاً حتی خالی است) به یک object از نوع OrderEbook که حاوی مقادیری از نوع صحیح است، برسیم؟ در مثال ما، هر value به یک رویکرد متفاوت نیاز دارد:
    </p>
<ul>
<li>
<p>
                property $emailAddress به یک string نیاز دارد، اما ممکن است key از نوع email در $data تعریف نشده باشد.
            </p>
</li>
<li>
<p>
                property $ebookId به یک int نیاز دارد، اما ممکن است key از نوع ebook_id در $data تعریف نشده باشد.
            </p>
</li>
<li>
<p>
                property $quantity به یک int نیاز دارد، اما ممکن است key از نوع quantity در $data تعریف نشده باشد.
            </p>
</li>
<li>
<p>
                property $buyerName به یک string نیاز دارد، اما nullable است. ممکن است key از نوع buyer_name در $data تعریف نشده باشد، یا ممکن است یک رشته خالی باشد، که در این صورت باید آن را به null تبدیل کنیم.
            </p>
</li>
</ul>
<p>
        Listing 8.18 نحوه بهبود متد fromRequestData() را برای رسیدگی به هر یک از این موارد نشان می‌دهد.
    </p>
<p>
        Listing 8.18. Dealing with undefined keys and type casting.
    </p>
<pre><code class="language-php">
public static function fromRequestData(array $data): self
{
    return new self(
</code></pre>
<p>218</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0238_original/original_page.png" alt="Original Page 238">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<pre><code class="language-php">
{
    return new self(
        isset($data['email']) ? (string)$data['email'] : '',
        isset($data['ebook_id']) ? (int)$data['ebook_id'] : 0,
        isset($data['quantity']) ? (int)$data['quantity'] : 0,
        isset($data['buyer_name']) &amp;&amp; $data['buyer_name'] !== ''
            ? (string)$data['buyer_name']
            : null
    );
}
</code></pre>
<p>
        این تضمین می‌کند که در جایی که application ما یک integer را انتظار دارد، یک integer وجود خواهد داشت (حتی اگر یک integer بی‌معنی مانند 0 باشد). اگر یک string وجود داشته باشد، یک string وجود خواهد داشت، حتی اگر یک string خالی باشد. Listing 8.19 این را برای email address نشان می‌دهد. Clients می‌توانند متد emailAddress() از command
        object را فراخوانی کنند تا email address را از آن دریافت کنند. value بازگشتی همیشه یک
        string خواهد بود، اما می‌تواند یک string خالی باشد. این واقعاً مهم نیست، زیرا
        در ادامه، همیشه مقداری domain object وجود خواهد داشت که داخل
        متغیر را بررسی می‌کند و آن را validate می‌کند. حداقل ما دیگر generic type errors دریافت نخواهیم کرد. ما exceptions مناسبی را دریافت خواهیم کرد که یک مشکل خاص را با محتوای یک متغیر نشان می‌دهد.
    </p>
<p>
        Listing 8.19. The type of input data will always be correct, but the value has
        to be validated.
    </p>
<pre><code class="language-php">
final class OrderEbook
{
    private string $emailAddress;
    // ...
    public function emailAddress(): string
    {
        return $this-&gt;emailAddress;
    }
}

final class EmailAddress
{
    public static function fromString(string $emailAddress): self
    {
        // Validate the string
</code></pre>
<p>219</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0239_original/original_page.png" alt="Original Page 239">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<pre><code class="language-php">
}
$command = OrderEbook::fromRequestData($emptyRequestData = []);
/*
 * emailAddress() returns an empty string.
 * fromString() will throw an exception.
 */
$emailAddress = EmailAddress::fromString($command-&gt;emailAddress());
</code></pre>
<p>
        راه‌هایی وجود دارد که ما می‌توانیم این کد را حتی بیشتر بهبود بخشیم. به عنوان مثال،
        متدهایی مانند fromRequestData() واقعاً خواندن آنها سخت است و همچنین اشتباهات برنامه‌نویسی
        نیز بسیار آسان است. به همین دلیل است که من دوست دارم چند
        helper function معرفی کنم که می‌تواند به ما کمک کند مقداری از duplication را حذف کنیم و
        مقداری معنی به تمام این isset() calls و ternary operators اضافه کنیم. Listing 8.20
        نشان می‌دهد که چگونه می‌توانید از یک trait برای این کار استفاده کنید، اما اگر دوست دارید، می‌توانید از یک utility class
        با متدهای public static نیز استفاده کنید.
    </p>
<p>
        Listing 8.20. A trait that helps with mapping.
    </p>
<pre><code class="language-php">
trait Mapping
{
    private static function getString(array $data, string $key): string
    {
        if (!isset($data[$key])) {
            return '';
        }
        return (string)$data[$key];
    }

    private static function getInt(array $data, string $key): int
    {
        if (!isset($data[$key])) {
            return 0;
        }
        return (int)$data[$key];
    }

    private static function getNonEmptyStringOrNull(
</code></pre>
<p>220</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0240_original/original_page.png" alt="Original Page 240">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<pre><code class="language-php">
array $data,
    string $key
): ?string {
    if (!isset($data[$key])) {
        return null;
    }
    if (isset($data[$key]) &amp;&amp; $data[$key] === '') {
        return null;
    }
    return (string)$data[$key];
}
</code></pre>
<p>
    }
    </p>
<pre><code class="language-php">
final class OrderEbook
{
    use Mapping;
    // ...
    public static function fromRequestData(array $data): self
    {
        return new self(
            self::getString($data, 'email'),
            self::getInt($data, 'ebook_id'),
            self::getInt($data, 'quantity'),
            self::getNonEmptyStringOrNull($data, 'buyer_name')
        );
    }
}
</code></pre>
<p>
        آیا باید یک unit test برای fromRequestData() بنویسیم؟ من فکر می‌کنم نیازی به این کار نیست. fromRequestData() یک متد بسیار ساده با یک execution path است. پیچیدگی به helper functions منتقل شده است و آن موارد قطعاً باید unit-tested شوند. از آنجایی که بسیاری از class ها قرار است به این helper functions تکیه کنند، باید استفاده از آنها ایمن باشد و در تمام موارد ممکن کار کند.
    </p>
<p>
        خلاصه‌ای از رویکرد در این بخش: ما با داده‌های request بدون شکل یا حداقل، request data با یک shape نامشخص شروع کردیم. ما یک
    </p>
<p>221</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0241_original/original_page.png" alt="Original Page 241">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<p>
        command object با یک لیست صریح از تمام fields، types، و اینکه آیا
        مقادیر خاصی اختیاری هستند (به عنوان مثال، nullable) یا خیر. سپس ما یک متد ایجاد کردیم
        که قادر به کپی کردن request data در object بود. هنگامی که request data داخل
        object قرار دارد، getters object و types بازگشتی آنها تضمین می‌کنند که هر client در
        داخل application ما می‌تواند با اطمینان از request data استفاده کند، با دانستن اینکه هر value
        تعریف شده و از type مورد انتظار است. این یک مزیت اصلی استفاده از
        command objects به جای مقادیر جداگانه است.
    </p>
<p>
        اما چیزهای بیشتری هم وجود دارد! در بخش 8.3 ما در مورد form validation و نحوه
        validation data از request صحبت کردیم. ما نباید data را در یک entity قرار دهیم و
        سپس entity را validate کنیم، ما باید request data را قبل از دادن آن
        به entity validate کنیم. یک entity زمانی یک exception پرتاب خواهد کرد که input data نامعتبر باشد.
        وقتی request data را validate می‌کنیم، هیچ exception پرتاب نمی‌شود و این به ما اجازه می‌دهد
        تا یک لیست از validation errors ایجاد کنیم.
    </p>
<p>
        همین امر در مورد یک command object نیز صدق می‌کند. ما می‌توانیم command object را پر کنیم
        و هیچ exception دریافت نخواهیم کرد. تنها کاری که ما انجام می‌دهیم این است که request data array را
        به یک object تبدیل می‌کنیم، dataهای از دست رفته را پر می‌کنیم، و به آرامی data را به انواع صحیح
        cast می‌کنیم.
    </p>
<p>
        ما ممکن است به همان خوبی ابتدا command object را پر کنیم، و سپس
        values آن را validate کنیم، به جای validate کردن request data. Listing 8.21 یک custom
        validator class را نشان می‌دهد که request یا request data را validate نمی‌کند، اما
        یک command object را validate می‌کند.
    </p>
<p>
        Listing 8.21. Validating a command object.
    </p>
<pre><code class="language-php">
final class OrderEbookValidator
{
    /**
     * @return array&lt;string,array&lt;string&gt;&gt;
     */
    public function validate(OrderEbook $command): array
    {
        $formErrors = [];
        try {
            EmailAddress::fromString($command-&gt;emailAddress());
        } catch (InvalidArgumentException $exception) {
            $formErrors['email'][] = 'invalid_email_address';
        }
</code></pre>
<p>222</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0242_original/original_page.png" alt="Original Page 242">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<pre><code class="language-php">
// ...
    }
}
// Inside the controller:
$createOrder = CreateOrder::fromRequestData(
    $request-&gt;request-&gt;all()
);
$errors = $this-&gt;validator-&gt;validate($createOrder);
if (count($errors) === 0) {
    // Create the order
} else {
    // Render the form again
}
</code></pre>
<p>
        اگر از Symfony و component Validator آن استفاده می‌کنید1، می‌توانید مقداری
        configuration را به command object و properties آن اضافه کنید. سپس می‌توانید از
        validator service عمومی برای ایجاد لیستی از validation errors برای شما استفاده کنید. این
        واقعاً مفید است اگر شما از component فرم Symfony2 نیز استفاده می‌کنید، و نمی‌خواهید
        خودتان validator و کد integration با form rendering را بنویسید.
    </p>
<p>
        در این صورت ممکن است مجبور شوید مقداری کار اضافی انجام دهید، مانند افزودن setters با
        nullable parameters، که ممکن است برای شما کمی "impure" به نظر برسد. اما اگر شما
        به رابطه بین زمانی که سرمایه‌گذاری می‌کنید و ارزشی که ارائه می‌دهد توجه کنید، فکر می‌کنم
        این چیزی است که باید در نظر بگیرید.
    </p>
<h4><strong>8.7. Summary</strong></h4>
<p>
        هنگام جداسازی core از زیرساخت‌ها، همانطور که در فصل‌های قبل انجام می‌دادیم،
        فعالیت validation user input نیز باید به دو
        بخش تقسیم شود. در وهله اول، domain objects مانند entities باید از خود در برابر
        پایان یافتن در یک state نامعتبر محافظت کنند. یک entity یک exception پرتاب می‌کند
        به محض اینکه هر بخش از input نامعتبر، ناقص، یا منجر به incon-
        1 https://advwebapparch.com/symfony-validator-component
    </p>
<p>
        2 https://advwebapparch.com/symfony-form-component
    </p>
<p>223</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0243_original/original_page.png" alt="Original Page 243">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<p>
        sistent state. Validating روابط بین entities را می‌توان با بازیابی
        entity مرتبط از repository (read model) انجام داد.
    </p>
<p>
        هنگامی که می‌توانیم مطمئن باشیم که یک entity همیشه معتبر است، ما هنوز هم نیاز داریم
        تا به user در ارائه داده‌های صحیح کمک کنیم. ما باید به خاطر داشته باشیم که user کیست،
        و چگونه با application ما ارتباط برقرار می‌کند. این بخش خاص زیرساخت-
        validation است، جایی که ما HTML form errors را به زبان user ارائه می‌کنیم، یا
        یک لیست با کد JSON از validation er-
        rorsهای machine-readable ارائه می‌دهیم.
    </p>
<p>
        گاهی اوقات validation پاسخگو نیست، زیرا داده‌های درگیر در val-
        process idation ممکن است منسوخ شده باشند، مانند زمانی که سطح stock یک
        محصول خاص را قبل از پذیرش order برای آن بررسی می‌کنید. هنگامی که validation ممکن است
        قادر به ارائه پاسخ صحیح نباشد، به دنبال گزینه‌های طراحی دیگر باشید.
    </p>
<h4><strong>Exercises</strong></h4>
<ol>
<li>
<p>
                کدام یک از انواع object زیر مجاز به پرتاب exceptions در
                صورتی که ورودی ارائه شده نامعتبر باشد؟a
            </p>
<ol type="a">
<li>Value objects</li>
<li>Entities</li>
<li>Application services</li>
<li>Controllers</li>
<li>Validators</li>
</ol>
</li>
<li>
<p>
                در کجا باید لیستی از validation errorsها را برای داده‌های form ارسال شده جمع آوری کنیم؟b
            </p>
<ol>
<li>In the entity</li>
<li>In the application service</li>
<li>In the controller</li>
</ol>
</li>
<li>
<p>
                کدام یک از این جملات در مورد command objects و command ob-
            </p>
</li>
</ol>
<p>224</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0244_original/original_page.png" alt="Original Page 244">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>8. Validation</strong></h3>
<p>در مورد validation چه مواردی صحیح هستند؟</p>
<p>
        1.  یک command object باید فقط properties از نوع string داشته باشد و همه آن‌ها باید null باشند.
    </p>
<p>
        2.  هر چیزی که خود entity اعتبار سنجی می‌کند، باید توسط command object validator نیز اعتبارسنجی شود.
    </p>
<p>
        3.  یک command object ساختار ارائه می‌دهد و اطمینان حاصل می‌کند که تمام input data به انواع مورد انتظار cast شده‌اند.
    </p>
<p>
        4.  شما می‌توانید از منطق validation و value objects مربوط به entity در هنگام validating یک command object استفاده کنید.
    </p>
<p>
        a. پاسخ صحیح: همه موارد، به جز validators. A validator باید یک list از errors ارائه دهد به جای اینکه به محض برخورد با یک issue، اجرا را متوقف کند.
    </p>
<p>
        b. پاسخ صحیح: در controller. The application service قرار است نسبت به زیرساخت‌های اطراف خود بی‌اطلاع باشد، بنابراین چیزی در مورد وب یا فرم‌های HTML نمی‌داند. A controller در مورد کاربر و نحوه ارائه errors validation به آن‌ها، اطلاعات دارد.
    </p>
<p>
        c. پاسخ صحیح: 3 و 4. A command object باید properties داشته باشد که از قبل به type primitive صحیح cast شده‌اند و لازم نیست همه آن‌ها nullable باشند. همچنین، نیازی نیست همه چیز را اعتبار سنجی کنید. اگر یک user interface خوب دارید، نیازی به اعتبار سنجی بیشتر input ندارید. Entity به هر حال از خود در برابر data نامناسب محافظت می‌کند.
    </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0245_original/original_page.png" alt="Original Page 245">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>9. Conclusion</strong></h3>
<p>این فصل موارد زیر را پوشش می‌دهد:</p>
<ul>
<li>بحث عمیق‌تری در مورد تمایز بین core و infrastructure code</li>
<li>یک summary از strategy برای push کردن infrastructure به کناره‌ها</li>
<li>توصیه‌ای برای استفاده از یک domain- و test-first approach برای توسعه نرم‌افزار</li>
<li>نگاهی نزدیک‌تر به مفهوم "pure" object-oriented programming</li>
</ul>
<h4><strong>9.1. Core code و infrastructure code</strong></h4>
<p>در فصل 1، ما به تعاریفی برای اصطلاحات core code و infrastructure code نگاهی انداختیم. چیزی که من شخصاً در مورد این تعاریف مفید می‌دانم این است که شما می‌توانید به یک قطعه کد نگاه کنید و متوجه شوید که آیا این تعاریف به آن صدق می‌کنند یا خیر. سپس می‌توانید تصمیم بگیرید که آیا این core code است یا infrastructure code. اما راه‌های دیگری نیز برای اعمال این اصطلاحات در نرم‌افزار وجود دارد. یک راه این است که به تصویر بزرگ‌تری از application و interactions آن با actors توجه کنید. شما اصطلاح actor را در کتاب‌هایی درباره user stories و use cases توسط نویسندگانی مانند Ivar Jacobson و Alistair Cockburn پیدا خواهید کرد، که تمایزی بین موارد زیر قائل می‌شوند:</p>
<ol>
<li>Primary actors، که بر روی system ما عمل می‌کنند</li>
<li>Secondary یا supporting actors، که system ما بر روی آن‌ها عمل می‌کند</li>
</ol>
<p>به عنوان مثال، یک primary actor می‌تواند شخصی باشد که از web browser خود استفاده می‌کند</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0246_original/original_page.png" alt="Original Page 246">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>9. Conclusion</strong></h3>
<p>برای ارسال یک HTTP POST request به application ما. A supporting actor می‌تواند relational database باشد که application ما یک SQL INSERT query به آن ارسال می‌کند. برقراری ارتباط با هر دو actor نیازمند عناصر زیرساختی زیادی است که در جای خود قرار گیرند. The web server باید up and running باشد و باید از اینترنت قابل دسترسی باشد. The server باید requests ورودی را به application منتقل کند، که احتمالاً از یک web framework برای پردازش HTTP messages و dispatch کردن آن‌ها به controllers صحیح استفاده می‌کند. در انتهای دیگر application، ممکن است برخی از داده‌ها در database ذخیره شوند. PHP باید یک PDO driver نصب شده داشته باشد تا بتواند به database متصل شده و با آن ارتباط برقرار کند. به احتمال زیاد شما به کدهای پشتیبانی زیادی نیاز دارید تا mapping از domain objects به database records انجام دهید. تمام کدهای درگیر در این process، از جمله بسیاری از third-party libraries و frameworks، و همچنین نرم‌افزاری که توسط خودتان نگهداری نمی‌شود (مانند web server)، باید infrastructure code در نظر گرفته شوند.</p>
<p>بیشتر زمان بین primary actor که یک HTTP request به server شما ارسال می‌کند، و database که داده‌های اصلاح‌شده را ذخیره می‌کند، صرف اجرای infrastructure code می‌شود و بیشتر این کد را می‌توان در PHP extensions، frameworks، و libraries یافت. اما در جایی بین ingoing و outgoing communication، the server کدی از خود شما را فراخوانی می‌کند، که به آن user code می‌گویند.</p>
<p>User code چیزی است که application شما را خاص می‌کند: چه کارهایی می‌توانید با application خود انجام دهید؟ شما می‌توانید یک e-book سفارش دهید. شما می‌توانید برای آن پرداخت کنید. چه نوع چیزهایی را می‌توانید از application خود یاد بگیرید؟ شما می‌توانید ببینید چه e-books در دسترس هستند. و پس از خرید یکی، می‌توانید آن را دانلود کنید. Frameworks، libraries و PHP extensions هرگز نمی‌توانند در این نوع کد به شما کمک کنند، زیرا domain-specific است: این business logic شما است.</p>
<p>
<img alt="Figure 9.1. User code is in the middle, with infrastructure code to the left and right." src="https://via.placeholder.com/300"/>
<figcaption>شکل 9.1. User code در وسط قرار دارد، با infrastructure code در سمت چپ و راست.</figcaption>
</p>
<p>شکل 9.1 نشان می‌دهد که user code در وسط بسیاری از infrastructure code قرار دارد. حتی اگر سعی کنیم در هنگام کار بر روی و تست user code، بیشتر infrastructure اطراف را نادیده بگیریم، اغلب متوجه می‌شویم که کار کردن با این کد دشوار است.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 247" src="page_0247/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0247_original/original_page.png" alt="Original Page 247">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        با. این به این دلیل است که کد هنوز شامل جزئیات infrastructure زیادی است. A use case ممکن است از web controller که آن را فراخوانی می‌کند، جدا نشود. استفاده از service locators و موارد مشابه، از اجرای کد در isolation یا در یک context متفاوت جلوگیری می‌کند. فراخوانی‌ها به external services نیازمند هستند که external service در زمانی که ما می‌خواهیم کد خود را به صورت local تست کنیم، در دسترس باشد. و غیره...
    </p>
<p>
<img alt="Figure 9.2. Core code is not strictly separated from infrastructure code." src="https://via.placeholder.com/300"/>
<figcaption>شکل 9.2. Core code به طور دقیق از infrastructure code جدا نشده است.</figcaption>
</p>
<p>
        اگر اینطور است، user code شامل ترکیبی از infrastructure code و core code است. شکل 9.2 نشان می‌دهد که این چگونه به نظر می‌رسد. وقتی به این diagram نگاه می‌کنم، فوراً احساس می‌کنم که باید بیت‌های infrastructure code را به کناره‌ها ببرم. من می‌گویم، جایی که آن‌ها به آن تعلق دارند، زیرا infrastructure code کدی است که core code را به دنیای بیرون متصل می‌کند، بنابراین ممکن است تا حد امکان نزدیک به دنیای بیرون زندگی کند.
    </p>
<p>
<img alt="Figure 9.3. After defragmenting the user code, we can push even more infrastructure code to the sides, and keep only core code in the middle." src="https://via.placeholder.com/300"/>
<figcaption>شکل 9.3. پس از "defragmenting" the user code، می‌توانیم infrastructure code بیشتری را به کناره‌ها ببریم و فقط core code را در middle نگه داریم.</figcaption>
</p>
<p>
        آنچه در middle باقی می‌ماند، پس از "defragmenting" the user code، فقط core code است (شکل 9.3). این کدی است که می‌تواند بدون تکیه بر هیچ infrastructure واقعی و بدون ایجاد هیچ ارتباطی با دنیای اطراف application اجرا شود. No network, no database, no file system, etc. همانطور که در فصل‌های قبلی دیده‌ایم، این برای testing عالی است (همچنین به فصل 14 مراجعه کنید).
    </p>
<p>
        Core code کاملاً ایزوله به شما امکان می‌دهد تا use cases application خود را در یک مرحله بسیار اولیه از توسعه تست کنید. شما می‌توانید ثابت کنید که application به درستی سناریوهای use case خود را پیاده‌سازی می‌کند، بدون راه‌اندازی routing برای web application خود و بدون اجرای schema migrations بر روی هر database. این عالی است زیرا به شما امکان می‌دهد از همان ابتدای پروژه روی use cases خود کار کنید و بازخورد طراحی را جمع‌آوری کنید، user stories را بهبود بخشید و غیره.
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 248" src="page_0248/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 248" src="page_0248/image_2.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0248_original/original_page.png" alt="Original Page 248">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>9. Conclusion</strong></h3>
<p>شما مجبور نخواهید بود کل Sprint Zero را صرف انتخاب و راه‌اندازی تمام infrastructure کنید. شما مجبور نخواهید بود بفهمید که وقتی بیشتر بودجه توسعه قبلاً خرج شده است، چیز اشتباهی ساخته‌اید. شما پشیمان نخواهید شد که MongoDB را به جای MySQL انتخاب کرده‌اید، زیرا مجبور نیستید در روز اول پروژه تصمیم بگیرید.</p>
<h4><strong>9.2. A summary of the strategy</strong></h4>
<p>فشار دادن infrastructure code به کناره‌ها به چه معناست؟ در فصل‌های قبل، ما قبلاً بسیاری از مراحل refactoring را دیده‌ایم که به ما در انجام این کار کمک کردند. همه آن تکنیک‌های refactoring "تاکتیکی" را می‌توان با یک strategy ساده خلاصه کرد. جداسازی core code از infrastructure code را می‌توان با اعمال اصول زیر به دست آورد:</p>
<ul>
<li>
            از dependency injection در همه جا استفاده کنید، بگذارید services فقط به abstractions وابسته باشند.
        </li>
<li>
            Use cases را مستقل از مکانیزم تحویل input آن‌ها کنید.
        </li>
</ul>
<p>نتیجه این خواهد بود که هیچ‌یک از core code به infrastructure code در هیچ‌کدام از طرفین وابسته نیست. در عین حال، هر infrastructure code قادر خواهد بود core code را فراخوانی کند. هیچ الزامات ویژه‌ای برای انجام این کار وجود ندارد. هر دو عنصر با هم ترکیب می‌شوند و کدی را ایجاد می‌کنند که کاملاً قابل حمل است. این یک دید واضح از use cases application را بدون هیچ گونه distortion ناشی از نگرانی‌های زیرساختی ارائه می‌دهد. این می‌تواند به راحتی و در isolation کامل، بدون هیچ setup خاصی تست شود.</p>
<h4><strong>9.2.1. Use dependency injection و inversion در همه جا</strong></h4>
<p>Dependency injection به این معنی است که services هر چیزی را که به آن وابسته هستند (سایر services و همچنین مقادیر configuration) را به عنوان constructor arguments تزریق می‌کنند. Dependency inversion به این معنی است که services به جای concrete classes، به abstractions وابسته هستند.</p>
<p><sup>1</sup>Robert C. Martin, “Agile Software Development, Principles, Patterns, and Practices”, Prentice Hall (2003).</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0249_original/original_page.png" alt="Original Page 249">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        بخش "inversion" از dependency inversion نشان می‌دهد که جهت dependency معمولی معکوس می‌شود. شکل 9.4 جهت dependency معمولی را قبل از اعمال dependency inversion نشان می‌دهد. EbookOrderService به OrderRepositoryUsingSql وابسته است. این یک concrete class است که می‌داند چگونه سفارش‌ها را در یک relational database ذخیره کند. فلش dependency از چپ به راست است، زیرا service به repository وابسته است.
    </p>
<p>
<img alt="Figure 9.4. EbookOrderService uses OrderRepositoryUsesSql as a depen-
dency, and gets it injected as a constructor argument." src="https://via.placeholder.com/300"/>
<figcaption>شکل 9.4. EbookOrderService از OrderRepositoryUsesSql به عنوان یک dependency استفاده می‌کند و آن را به عنوان یک constructor argument تزریق می‌کند.</figcaption>
</p>
<p>
        شکل 9.5 نشان می‌دهد که وقتی یک abstraction مناسب برای concrete OrderRepositoryUsingSql class معرفی می‌کنیم، چه اتفاقی می‌افتد.
    </p>
<p>
        Abstraction، OrderRepository نامیده می‌شود و یک interface است. اگر OrderRepositoryUsingSql به منظور پیاده‌سازی OrderRepository interface، EbookOrderService می‌تواند به جای concrete class، شروع به وابستگی به interface کند. در diagram می‌بینید که دیگر فلشی از EbookOrderService به OrderRepositoryUsingSql وجود ندارد. ما با موفقیت این dependency را معکوس کرده‌ایم.
    </p>
<p>
<img alt="Figure 9.5. After applying Dependency inversion, EbookOrderService no longer depends on OrderRepositoryUsingSql." src="https://via.placeholder.com/300"/>
<figcaption>شکل 9.5. پس از اعمال Dependency inversion، EbookOrderService دیگر به OrderRepositoryUsingSql وابسته نیست.</figcaption>
</p>
<p>
        این به ما انعطاف‌پذیری زیادی می‌دهد.
        ما می‌توانیم implementation از OrderRepository را بدون ایجاد مزاحمت برای EbookOrderService تغییر دهیم. تا زمانی که implementation اصلاح شده به درستی contract تعریف شده توسط interface را پیاده‌سازی کند، همه چیز خوب خواهد بود. در واقع، ما حتی می‌توانیم به طور کامل...
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 250" src="page_0250/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 250" src="page_0250/image_2.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0250_original/original_page.png" alt="Original Page 250">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        implementation از OrderRepository را جایگزین کنید. ما می‌توانیم با یک repository که از MongoDB برای ذخیره سفارش‌ها استفاده می‌کند، آزمایش کنیم. و ما می‌توانیم به راحتی یک جایگزین سریع‌تر را هنگام نوشتن تست‌ها برای service تعریف کنیم.
    </p>
<p>
        شکل 9.6 نشان می‌دهد که dependency inversion از نظر core code در مقابل infrastructure code چگونه به نظر می‌رسد. The repository interface و service، core code هستند. The repository implementation، infrastructure code است. فلش‌های dependency در داخل ناحیه core باقی می‌مانند (از EbookOrderService به OrderRepository)، یا
        آن‌ها
        از
        ناحیه
        infrastructure
        به
        ناحیه
        core
        (از OrderRepositoryUsingSql به OrderRepository) می‌روند.
    </p>
<p>
<img alt="Figure 9.6. This diagram shows how applying dependency inversion helps separating core from infrastructure code." src="https://via.placeholder.com/300"/>
<figcaption>شکل 9.6. این diagram نشان می‌دهد که چگونه اعمال dependency inversion به جداسازی core از infrastructure code کمک می‌کند.</figcaption>
</p>
<p>
        از آنجا که core code هرگز به infrastructure code وابسته نیست، ما می‌توانیم infrastructure code را به طور کامل جایگزین کنیم و core تحت تأثیر آن قرار نخواهد گرفت.
    </p>
<h4><strong>9.2.2. Make use cases universally invokable</strong></h4>
<p>بسیاری از applications use cases مهم را در controllers خود پنهان می‌کنند. همانطور که در فصل 4 دیدیم، با چند مرحله اضافی می‌توانید کدی را که نشان دهنده use case واقعی است، مستقل از infrastructure code استخراج کنید. ما در آن شروع کردیم</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 251" src="page_0251/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0251_original/original_page.png" alt="Original Page 251">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        فصل را با متد OrderController::orderEbookAction() شروع کردیم که شامل تمام مراحل سناریوی "order an e-book" بود. شکل 9.7 وضعیت اولیه را نشان می‌دهد. اگرچه controller به یک abstraction ارائه شده توسط core وابسته است، خود use case متاسفانه بخشی از infrastructure است. این بدان معنی است که ما نمی‌توانیم به راحتی آن را فراخوانی کنیم، بدون اینکه infrastructure code دیگری را راه‌اندازی و اجرا کنیم.
    </p>
<p>
<img alt="Figure 9.7. The use case is currently tied to a particular infrastructure, mak-ing it hard to invoke in other situations." src="https://via.placeholder.com/300"/>
<figcaption>شکل 9.7. The use case در حال حاضر به یک infrastructure خاص گره خورده است و فراخوانی آن را در موقعیت‌های دیگر دشوار می‌کند.</figcaption>
</p>
<p>
        پس از چند مرحله refactoring، ما توانستیم یک use case service را از controller استخراج کنیم. این service اکنون به عنوان core code محسوب می‌شود، زیرا دیگر به هیچ عنصر زیرساختی وابسته نیست. input آن داده‌های ساده است، نه یک شیء HTTP Request یا چیزی شبیه به آن. این فقط data را در حافظه دستکاری می‌کند و فقط با abstractions مانند OrderRepository صحبت می‌کند. شکل 9.8 نتیجه عملیات را نشان می‌دهد.
    </p>
<p>
        باز هم، فلش‌های dependency فقط به سمت core code اشاره می‌کنند. این بدان معناست که علاوه بر اینکه می‌توانیم infrastructure code را در سمت راست به طور کامل جایگزین کنیم، اکنون می‌توانیم کد را در سمت چپ نیز جایگزین کنیم. ما می‌توانیم از همان use case با یک "front-end" متفاوت، مانند یک API endpoint یا یک batch importer، استفاده مجدد کنیم. شاید ما حتی CLI commands بسازیم که به ما امکان می‌دهد برخی از use cases application را از terminal تست کنیم. test suite application اساساً یک infrastructure جایگزین برای core code ما نیز خواهد بود.
        این ورودی را برای use cases فراهم می‌کند و نتایج فراخوانی را تأیید می‌کند
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 252" src="page_0252/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0252_original/original_page.png" alt="Original Page 252">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
<img alt="Figure 9.8. The use case is now fully represented as core code." src="https://via.placeholder.com/300"/>
<figcaption>شکل 9.8. The use case اکنون به طور کامل به عنوان core code نشان داده شده است.</figcaption>
</p>
<p>
        آن‌ها. شکل 9.9 نشان می‌دهد که تنها کاری که یک test runner باید انجام دهد، فراخوانی use case service و استفاده از stand-in dependencies است، تا از ذخیره داده‌ها در database توسط test جلوگیری شود. با انجام این کار، test می‌تواند تأیید کند که سناریوهای use case، هنگامی که به domain objects، domain invariants که از آن‌ها محافظت می‌کنند، تعامل بین آن‌ها و نحوه ارتباط use case با چیزهای خارج از core می‌آید، به درستی پیاده‌سازی شده‌اند.
    </p>
<h4><strong>9.3. Focus on the domain</strong></h4>
<p>
        کد base یک application، یک codification از دانش جمعی تیم است. این درک آن‌ها از business domain را نشان می‌دهد. همچنین درک آن‌ها از ابزارهایی که با آن‌ها کار می‌کنند را نشان می‌دهد. تفاوت زیادی بین این دو وجود دارد: ابزارها (frameworks, libraries, protocols و غیره) طول عمر بسیار کوتاه‌تری نسبت به خود business domain دارند. یک framework که امروز عالی است، در یک سال، شاید دو سال منسوخ می‌شود. یک ORM ممکن است امروز "rad" باشد، اما تنها در چند ماه از این به بعد یک دردسر در نظر گرفته می‌شود. شما می‌خواهید از همه چیز خلاص شوید، اما نمی‌خواهید دانش domain را که توسط کد شما نشان داده می‌شود، دور بریزید. اگر جزئیات infrastructure را با domain model خود ترکیب کنید، واقعاً سخت خواهد بود که به هر دو اجازه دهید در جهت‌های مختلف یا با سرعت متفاوتی تکامل یابند.
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 253" src="page_0253/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0253_original/original_page.png" alt="Original Page 253">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
<img alt="Figure 9.9. Because the use case is now represented by core code, it’s easy to invoke it in other situations. It’s also easy to run it in a testing environment." src="https://via.placeholder.com/300"/>
<figcaption>شکل 9.9. از آنجا که use case اکنون توسط core code نشان داده می‌شود، فراخوانی آن در موقعیت‌های دیگر آسان است. همچنین اجرای آن در یک testing environment آسان است.</figcaption>
</p>
<p>
        البته، domain model شما باید خود به خود تکامل یابد. شما می‌خواهید قطعات جدیدی از دانش را که در طول مسیر به دست آورده‌اید، در آن بگنجانید. اما infrastructure نباید در انجام این کار مانع شود. تست کردن رفتار یک domain model باید در یک حلقه واقعاً سریع اتفاق بیفتد و در حالی که هنوز روی آن طراحی کار می‌کنید، بازخورد در مورد طراحی به شما ارائه دهد. شما نباید مجبور شوید رفتار core را با یک functional test تست کنید، که application را از جمله تمام لایه‌های stack فراخوانی می‌کند.
    </p>
<h4><strong>9.4. Focus on testability</strong></h4>
<p>
        Production code نیاز به تست‌هایی دارد که دانش توسعه‌دهنده را از نظر انتظارات در مورد رفتار runtime کد توصیف می‌کند. کد به تنهایی، بدون هیچ تستی، قادر به حفظ دانش مربوطه نخواهد بود. وقتی به کدی بدون تست برخورد می‌کنید، باید کد را بخوانید تا بفهمید چرا آنجاست. و حتی در آن صورت، بسیار سخت خواهد بود که بفهمید چرا کاری به این روش انجام می‌شود. به همین دلیل است که مایکل فیدرز می‌گوید:
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 254" src="page_0254/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0254_original/original_page.png" alt="Original Page 254">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        برای من، legacy code به سادگی کد بدون تست است.<sup>2</sup>
        شما به تکنیک‌های خاصی برای رسیدگی به این نوع کد نیاز دارید. زودتر از کد تست شده، احساس نیاز به بازنویسی بخش‌هایی از آن خواهید کرد. با این حال، تغییر هر چیزی در مورد آن، کار بسیار ترسناکی خواهد بود، زیرا احتمال زیادی وجود دارد که شما چیزها را خراب کنید. همانطور که مارتین فاولر می‌گوید:
    </p>
<p>
        هر زمان که من refactoring انجام می‌دهم، اولین قدم همیشه یکسان است. من باید اطمینان حاصل کنم که مجموعه کاملی از تست‌ها برای آن بخش از کد دارم. تست‌ها ضروری هستند، زیرا اگرچه من refactorings را دنبال خواهم کرد که ساختار یافته‌اند تا از بیشتر فرصت‌ها برای معرفی اشکالات جلوگیری کنند، اما من هنوز انسان هستم و همچنان اشتباه می‌کنم.<sup>3</sup>
</p>
<p>
        این عدم تقارن جالبی در مورد تست‌ها وجود دارد، همانطور که رابرت مارتین اشاره می‌کند:
    </p>
<p>
        من می‌دانم که این مسخره به نظر می‌رسد. اما در نظر بگیرید. اگر به نوعی تمام production code شما حذف شود، اما شما یک backup از تست‌های خود داشته باشید، در این صورت می‌توانید system production را با کمی کار دوباره ایجاد کنید.<sup>4</sup>
</p>
<p>
        اگر شما فقط production code دارید، در این صورت نوشتن تست برای آن واقعاً سخت خواهد بود. اگر فقط تست دارید، نوشتن production code که باعث می‌شود آن‌ها پاس شوند، بسیار آسان‌تر خواهد بود. این ارزش تست‌ها را نشان می‌دهد: آن‌ها مشخص می‌کنند که production code قرار است چه کاری انجام دهد و، اگر تست‌های خوبی بنویسید، آن‌ها همچنین توضیح خواهند داد که چرا.
    </p>
<p>
        البته، من می‌دانم که تست کردن گاهی اوقات می‌تواند سخت باشد. این آزاردهنده خواهد بود، گاهی اوقات احساس می‌کنید که کار اضافه است. اما در تجربه من، همه اینها را می‌توان با صرف زمان بیشتر در آن حل کرد. مطمئن شوید که هر روز در تست کردن بهتر می‌شوید. یک قانون وجود دارد که مردم برای این نوع مشکل استفاده می‌کنند: "اگر صدمه می‌زند، بیشتر انجامش بده". فاولر این را "frequency reduces difficulty" می‌نامد<sup>5</sup>.
        این فقط تکرار نیست که آن را آسان‌تر می‌کند. ترفند واقعی این است که تکرار به طور خودکار شما را به دنبال راه‌های بهتری برای انجام آن وا می‌دارد. به عبارت دیگر،
    </p>
<p>
<sup>2</sup> Michael Feathers, “Working Effectively with Legacy Code”, First Edition, Prentice Hall (2004)
    </p>
<p>
<sup>3</sup> Martin Fowler, “Refactoring: Improving the Design of Existing Code”, Addison-Wesley Professional (2018)
    </p>
<p>
<sup>4</sup> Robert C. Martin, “Test First”, https://advwebapparch.com/test-first
    </p>
<p>
<sup>5</sup> Martin Fowler, https://advwebapparch.com/frequency-reduces-difficulty
    </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0255_original/original_page.png" alt="Original Page 255">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>9. Conclusion</strong></h3>
<p>من فکر می‌کنم قانون باید این باشد: "اگر testing آسان نیست، آن را آسان کنید".</p>
<p>
        بنابراین تمرکز بر روی testability، هم کیفیت کد application شما را افزایش می‌دهد و هم طول عمر آن را بهبود می‌بخشد. ترکیب این با یک domain-first approach، تکنیک‌های معماری ارائه شده در این کتاب باید به شما در ساخت applications بلندمدت کمک کند.
    </p>
<h4><strong>9.5. Pure object-oriented code</strong></h4>
<p>در فصل‌های قبل، من چندین بار از کلمه "pure" به عنوان یک qualifier برای انواع خاصی از objects استفاده کرده‌ام. فکر می‌کنم مفید خواهد بود که با جزئیات بیشتری توضیح دهم منظور من از pure objects چیست. دانستن اینکه چه زمانی کد pure است یا نیست، تفاوت ایجاد می‌کند، زیرا pure code می‌تواند unit-tested شود و بیشتر آن می‌تواند در core application شما قرار گیرد.</p>
<p>
        "Pure" به عنوان یک qualifier برای کد از functional programming سرچشمه می‌گیرد. یک pure function، تابعی است که مقدار بازگشتی آن کاملاً به آرگومان‌های ارائه شده به آن بستگی دارد. Listing 9.1 نمونه‌ای از چنین pure function را نشان می‌دهد. هیچ چیز دیگری وجود ندارد که بتواند بر نتیجه فراخوانی sum() به جز آرگومان‌های ارائه شده و خود کد function تأثیر بگذارد.
    </p>
<p>
        Listing 9.1. sum() یک pure function است.
    </p>
<pre><code class="language-php">function sum(int $a, int $b): int
{
return $a + $b;
}
</code></pre>
<p>
        از طرف دیگر، Listing 9.2 تابعی را نشان می‌دهد که نتیجه آن به چیزی غیر از آرگومان‌ها و کد، وابسته است.
    </p>
<p>
        Listing 9.2. secondsPassed() یک impure function است.
    </p>
<pre><code class="language-php">function secondsPassed(int $previousTimestamp): int
{
return time() - $previousTimestamp;
}
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0256_original/original_page.png" alt="Original Page 256">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        چنین تابعی "impure" نامیده می‌شود زیرا مقدار بازگشتی آن به زمان فعلی واقعی بستگی دارد. دلایل زیادی وجود دارد که یک function impure باشد. به عنوان مثال، اگر سعی کند یک فایل را بارگیری کند، یک network connection برقرار کند، داده‌های تصادفی تولید کند و غیره. ما این موقعیت‌ها را در فصل‌های قبل دیده‌ایم و به کدی که این نوع کار را انجام می‌دهد، infrastructure code گفته‌ایم.
    </p>
<p>
        اکنون، راه‌هایی وجود دارد که بتوان دوباره impure code را pure کرد، یا بهتر است بگوییم، impure code را به یک بخش pure و یک بخش impure تقسیم کرد. Listing 9.3 نشان می‌دهد که چگونه این کار را در مورد secondsPassed() انجام دهیم: شما فقط باید بخشی را که function را impure کرده است "push" کنید.
    </p>
<p>
        Listing 9.3. secondsPassed() اکنون دوباره pure شده است.
    </p>
<pre><code class="language-php">function secondsPassed(
int $currentTimestamp,
int $previousTimestamp
): int {
return $currentTimestamp - $previousTimestamp;
}
</code></pre>
<p>
        با objects، یک approach مشابه می‌تواند برای pure کردن دوباره methods impure استفاده شود. به Listing 9.4 نگاهی بیندازید که کلاس Stopwatch نسبتاً احمقانه را با یک method impure نشان می‌دهد، که اساساً همان function impure secondsPassed() است که ما به تازگی دیدیم.
    </p>
<p>
        Listing 9.4. secondsPassed() یک method object impure است.
    </p>
<pre><code class="language-php">final class Stopwatch
{
    public function secondsPassed(int $previousTimestamp): int
    {
        return time() - $previousTimestamp;
    }
}
</code></pre>
<p>
        اگر می‌خواهیم method را دوباره pure کنیم، باید از فراخوانی time() خلاص شویم. در مثال functional، ما function را تغییر دادیم تا به جای واکشی زمان، زمان فعلی را به عنوان یک argument بپذیرد. این مطمئناً یک option در اینجا نیز هست (به Listing 9.5 مراجعه کنید).
    </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0257_original/original_page.png" alt="Original Page 257">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        Listing 9.5. One way of making secondsPassed() pure.
    </p>
<pre><code class="language-php">final class Stopwatch
{
    public function secondsPassed(
        int $currentTimestamp,
        int $previousTimestamp
    ): int {
        return $currentTime - $previousTimestamp;
    }
}
</code></pre>
<p>
        یک option دیگر وجود دارد که منحصر به objects است. ما می‌توانیم یک dependency را تزریق کنیم که متد secondsPassed() می‌تواند از آن برای بازیابی زمان فعلی استفاده کند. Listing 9.6 نشان می‌دهد که چگونه می‌توانید نوعی object Timer را تزریق کنید. Timer یک متد time() دارد که می‌توان از آن برای جایگزینی فراخوانی‌های time() استفاده کرد.
    </p>
<p>
        Listing 9.6. راه دیگری برای pure کردن secondsPassed().
    </p>
<pre><code class="language-php">final class Timer
{
    public function currentTimestamp(): int
    {
        return time();
    }
}
final class Stopwatch
{
    private Timer $timer;
    public function __construct(Timer $timer)
    {
        $this-&gt;timer = $timer;
    }
    public function secondsPassed(int $previousTimestamp): int
    {
        return $this-&gt;timer-&gt;currentTimestamp()
            - $previousTimestamp;
    }
}
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0258_original/original_page.png" alt="Original Page 258">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        این متد secondsPassed() را بدون تغییر باقی می‌گذارد: clients مجبور نخواهند بود خودشان current timestamp را ارائه دهند. این به ما اجازه می‌دهد تا از فراخوانی‌های time() خلاص شویم و آن‌ها را با فراخوانی‌های Timer::currentTimestamp() جایگزین کنیم. اما این هنوز Stopwatch را pure نمی‌کند. اگرچه فراخوانی time() اکنون فقط در داخل Timer اتفاق می‌افتد، فراخوانی Stopwatch::secondsPassed() به ناچار Timer::currentTimestamp() را فراخوانی می‌کند، که impure است. این به طور غیرمستقیم، Stopwatch::secondsPassed() را نیز impure می‌کند.
    </p>
<p>
        ما می‌توانیم این را با اعمال تکنیکی که قبلاً چندین بار دیده‌ایم، درست کنیم: dependency inversion. ما باید یک abstraction مناسب برای "retrieving the current time" معرفی کنیم. ما قبلاً یک object جداگانه برای آن داریم (Timer)، اکنون فقط به یک interface برای آن نیاز داریم. بیایید Timer را به یک interface تبدیل کنیم و یک implementation استاندارد برای آن تعریف کنیم که از ساعت system برای دریافت current timestamp استفاده می‌کند (به Listing 9.7 مراجعه کنید).
    </p>
<p>
        Listing 9.7. The Timer interface و implementation استاندارد آن.
    </p>
<pre><code class="language-php">interface Timer
{
    public function currentTimestamp(): int;
}
final class TimerUsesSystemClock implements Timer
{
    public function currentTimestamp(): int
    {
        return time();
    }
}
final class Stopwatch
{
    private Timer $timer;
    public function __construct(Timer $timer)
    {
        $this-&gt;timer = $timer;
    }
    public function secondsPassed(int $previousTimestamp): int
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0259_original/original_page.png" alt="Original Page 259">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
{
    return $this-&gt;timer-&gt;currentTimestamp()
    - $previousTimestamp;
}
</code></pre>
<p>
        با معرفی interface Timer، ما با موفقیت امکان فراخوانی secondsPassed() را بدون فراخوانی غیرمستقیم time() ایجاد کرده‌ایم. ما می‌توانیم به راحتی یک object Stopwatch را با یک object Timer stand-in نمونه‌سازی کنیم، که به سادگی یک timestamp سخت‌کد شده را برمی‌گرداند (به Listing 9.8 مراجعه کنید)
    </p>
<p>
        Listing 9.8. A FakeTimer که می‌تواند هنگام testing Stopwatch استفاده شود.
    </p>
<pre><code class="language-php">final class FakeTimer implements Timer
{
    private int $timestamp;
    public function __construct(int $timestamp)
    {
        $this-&gt;timestamp = $timestamp;
    }
    public function currentTimestamp(): int
    {
        return $this-&gt;timestamp;
    }
}
$stopwatch = new Stopwatch(new FakeTimer(1562845845));
</code></pre>
<p>
        با دیدن مکانیزم pure کردن object methods impure، ما همچنین می‌توانیم "pure" را به صورت: deterministic دوباره بیان کنیم. از آنجایی که آن‌ها فقط به arguments متد و dependencies انتزاعی تزریق شده در constructor متکی هستند، client کنترل کاملی بر object دارد. این منجر به objects deterministic می‌شود که برای testability عالی است. هیچ setup خاصی لازم نیست. تنها کاری که یک test باید انجام دهد، نمونه‌سازی خود object، ارائه هر dependency مورد نیاز و فراخوانی یک متد بر روی آن است، که هر argument مورد نیاز را ارائه می‌دهد.
    </p>
<p>
        با نگاهی به کد StopWatch می‌توانیم نتیجه بگیریم که اکنون pure است: از هر class infrastructure جدا شده است. اما وقتی application در حال اجرا است
    </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0260_original/original_page.png" alt="Original Page 260">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        Stopwatch در production، البته currentTimestamp() را روی TimerUsesSystemClock به جای FakeTimer فراخوانی می‌کند. یک dependency injection container معمولاً از setup واقعی object service شما مراقبت می‌کند، از جمله هر یک از dependencies آن. شکل 9.10 تفاوت بین هر دو perspective را نشان می‌دهد.
    </p>
<p>
<img alt="Figure 9.10. The code of Stopwatch depends only on the Timer inter-face, but at runtime the Stopwatch will use an object of type TimerUsesSystemClock, without being aware of that." src="https://via.placeholder.com/300"/>
<figcaption>شکل 9.10. کد Stopwatch فقط به interface Timer وابسته است، اما در runtime، Stopwatch از یک object از نوع TimerUsesSystemClock استفاده می‌کند، بدون اینکه از آن آگاه باشد.</figcaption>
</p>
<p>
        من متوجه شدم که وقتی از یک سطح پایین، سطح classes و methods شروع می‌کنید و هدف شما این است که تا حد امکان کد object-pure بنویسید، در حالی که تمام موارد مرتبط با infrastructure را به کناره‌ها می‌برید، در نهایت به یک طراحی بسیار بهتر در یک سطح بالاتر نیز خواهید رسید. به همین دلیل است که من این کتاب را فقط با تمرکز بر core در مقابل infrastructure به جای مفاهیم معماری مانند layering و ports و adapters شروع کرده‌ام. البته ما در بخش دوم در مورد این مفاهیم بحث خواهیم کرد، اما برد بزرگ، جداسازی core از infrastructure code است. بقیه موارد خوب هستند و شما بقیه را کم و بیش رایگان دریافت خواهید کرد.
    </p>
<h4><strong>9.6. Summary</strong></h4>
<p>در این فصل، ما تعریف core code را به عنوان کدی که use cases یک application را نشان می‌دهد، دوباره بیان کردیم. Infrastructure code کدی است که این use cases را به actors خارجی آن متصل می‌کند. Actors می‌تواند primary actors (users application) یا secondary/supporting actors (سیستم‌های دیگری که application ما از آن‌ها استفاده می‌کند) باشد. برای decoupling از primary actors، ما باید use cases خود را بدون توجه به مکانیزم تحویلی که یک نوع خاص از actor پشتیبانی می‌کند، به طور universal invokable کنیم. برای decoupling از secondary actors، ما</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 261" src="page_0261/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0261_original/original_page.png" alt="Original Page 261">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h4><strong>9.6. Summary</strong></h4>
<p>باید dependency inversion را اعمال کنیم و هر dependencyای را که مستقیماً با یک secondary actor ارتباط برقرار می‌کند، abstract کنیم. یک domain-first approach که با یک test-first approach ترکیب شده است، کیفیت core code application را بهبود می‌بخشد و احتمال بقای آن را در تغییرات زیرساختی در دنیای اطرافش افزایش می‌دهد. Core code باید object-oriented code باشد که "object-pure" است، که بسیار شبیه به مفهوم functionally pure است. همه dependencies صریح هستند و برای هر dependency که به چیزی خارج از application متصل می‌شود، یک abstraction معرفی شده است. Object-pure code آسان است برای test کردن زیرا، طبق تعریف، به روشی کاملاً deterministic رفتار می‌کند.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0262_original/original_page.png" alt="Original Page 262">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>Part II.</strong></h3>
<h3><strong>Organizing principles</strong></h3>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0263_original/original_page.png" alt="Original Page 263">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>10. Introduction</strong></h3>
<p>این بخش موارد زیر را پوشش می‌دهد:</p>
<ul>
<li>Framework-independent object types</li>
<li>Architectural layering</li>
<li>Hexagonal architecture، یا: ports and adapters</li>
</ul>
<p>در بخش قبل، ما تکنیک‌های زیادی را برای جداسازی core از infrastructure code پوشش دادیم. انجام این کار برای آینده application شما عالی است. با این حال، پس از مدتی، نگهداری از این حجم زیاد کد همچنان مشکل‌ساز خواهد بود. ما به اصول سازماندهی دقیق‌تری نیاز داریم. در این بخش ما در مورد برخی از این اصول بحث خواهیم کرد که بسیار مؤثر بوده‌اند.</p>
<p>ترکیب این اصول، منجر به یک application می‌شود که:</p>
<ol>
<li>بر اساس یک کاتالوگ استاندارد و قابل تشخیص از object types ساخته شده است (فصل 11)،</li>
<li>از لایه‌ها برای جداسازی concerns در یک سطح بالاتر استفاده می‌کند، که به developer در تصمیم‌گیری در مورد محل قرار دادن چیزها کمک می‌کند (فصل 12)، و</li>
<li>use cases application را از نحوه اتصال clients به application با استفاده از یک architectural pattern به نام Ports and Adapters، decoupled می‌کند (فصل 13).</li>
</ol>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0264_original/original_page.png" alt="Original Page 264">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>11. Key design patterns</strong></h3>
<p>این فصل موارد زیر را پوشش می‌دهد:</p>
<ul>
<li>یک catalog از design patterns</li>
<li>Implementation suggestions</li>
<li>یک high-level design process مبتنی بر این design patterns</li>
</ul>
<h4><strong>11.1. Framework-inspired structural elements</strong></h4>
<p>هر framework با مجموعه خود از element types های شناخته شده همراه است. به عنوان مثال، توسعه‌دهندگان Symfony یاد می‌گیرند که controllers, entities, form types, Twig templates, Yaml configuration files و غیره ایجاد کنند. توسعه‌دهندگان Laravel همچنین controllers ایجاد می‌کنند، اما آن‌ها علاوه بر موارد دیگر به: models, Blade templates و PHP configuration files نیاز دارند. هنگامی که به ساختار directory اکثر پروژه‌های web application نگاه می‌کنید، فوراً framework مورد استفاده را متوجه خواهید شد. Frameworks ساختار پروژه شما را دیکته می‌کنند. و frameworks همچنین کد شما را اشغال می‌کنند. به نظر می‌رسد که frameworks یک دشمن هستند، نه یک دوست مفید، اما این یک تناقض نادرست است. در infrastructure code، frameworks دوست شما هستند. در core code، نیستند.</p>
<p>اگر frameworks ساختار core code شما را تعیین می‌کنند، در نهایت به موارد زیر خواهید رسید:</p>
<ol>
<li>use cases ضمنی در داخل controllers,</li>
<li>یک domain model که به زیرساخت‌های اساسی خود متصل است، و به طور کلی</li>
</ol>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0265_original/original_page.png" alt="Original Page 265">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>11. Key design patterns</strong></h3>
<p>
        3.  کدی که به framework متصل است.
    </p>
<p>
        در قسمت اول، ما قبلاً تکنیک‌های زیادی را برای غلبه بر این مشکلات دیده‌ایم.
        ما توانستیم با مدل‌سازی use case به عنوان یک service مستقل از framework، یک use case را از یک controller استخراج کنیم. ما یک entity را از کد تعامل database استخراج کردیم. و ما کد را با استفاده از dependency injection در همه جا و با ارسال اطلاعات context به عنوان method arguments از framework جدا کردیم.
    </p>
<p>در این فصل، ما نگاهی دقیق‌تر به انواع objects که نتیجه decoupling از infrastructure بوده‌اند، می‌اندازیم. دانستن بیشتر در مورد جنبه‌های typical این objects به شما کمک می‌کند تا از آن‌ها به عنوان building blocks به جای صرفاً نتیجه فعالیت‌های refactoring استفاده کنید. با استفاده از این objects به عنوان "primitives" می‌توانید تمام use cases application را پیاده‌سازی کنید، بدون اینکه حتی یک framework را انتخاب کنید. framework فقط the finishing touch، the bridge بین core application شما و دنیای بیرون خواهد بود.</p>
<h4><strong>11.2. Entities</strong></h4>
<p>اولین pattern که باید پوشش داده شود، pattern Entity است. در این کتاب مفهوم یک entity، همان مفهوم یک aggregate در ادبیات Domain-Driven Design است. یک aggregate یک entity است، از جمله هر یک از child entities آن، و هر یک از value objects که در داخل آن استفاده می‌شود. در تجربه من اصطلاح "aggregate" منجر به سردرگمی زیادی می‌شود، بنابراین تصمیم گرفتم در این کتاب از کلمه "entity" استفاده کنم.</p>
<p>ما در مورد طراحی entity در فصل 2 صحبت کردیم و من قبلاً چندین قانون طراحی را برای آن در آنجا ذکر کردم. با این حال، من می‌خواهم این فصل یک راهنمای مرجع برای design patterns استانداردی باشد که در توسعه application های decoupled به آن نیاز دارید، بنابراین من به طور خلاصه قوانین را در اینجا خلاصه می‌کنم. من فقط قوانین را بدون دفاع از آن‌ها با جزئیات اعلام خواهم کرد<sup>1</sup></p>
<p>Entities، objects هستند که state application شما را حفظ می‌کنند. آن‌ها تنها نوع objects در application شما هستند که دارای persistent state هستند. بیشتر از</p>
<p><sup>1</sup>شما همیشه می‌توانید استدلال را در “Domain-Driven Design – Tackling complexity in the heart of software” نوشته Eric Evans، Addison-Wesley Professional (2003) جستجو کنید. یک primer سریع و دقیق در این موضوع، سری مقالات Vaughn Vernon به نام "Effective Aggregate Design" است، https://advwebapparch.com/effective-aggregate-design.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0266_original/original_page.png" alt="Original Page 266">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>11. Key design patterns</strong></h3>
<p>سایر objects باید به گونه‌ای طراحی شوند که immutable و stateless باشند. با توجه به اینکه mutable هستند، entities نباید به client هایی که قصد تغییر state آن‌ها را ندارند، منتقل شوند. هنگامی که یک client نیاز به بازیابی اطلاعات از یک entity دارد، در بیشتر موارد باید به نوع متفاوتی از object، یعنی یک Read model (به بخش 11.6 مراجعه کنید)، تکیه کند. تنها نوع client که قرار است یک entity را تغییر دهد، یک Application service است (به بخش 11.4 مراجعه کنید).</p>
<p>شما نباید بتوانید از یک entity به دیگری traverse کنید، به عنوان مثال:</p>
<pre><code class="language-php">$this-&gt;getLine(1)-&gt;getProduct()-&gt;getProductGroup()-&gt;getProducts();
</code></pre>
<p>تغییرات همیشه باید به یک entity واحد محدود شوند. اگر نیاز به اصلاح entity دیگری دارید، آن را از repository خود fetch کنید. تغییرات را در multiple entities در همان transaction ایجاد نکنید. یک تمایز واضح بین primary change و secondary effects ایجاد کنید. این effects را با استفاده از Event subscribers مدیریت کنید (به بخش 11.5 مراجعه کنید).</p>
<h4><strong>11.2.1. Protect invariants</strong></h4>
<p>یک entity همیشه باید domain invariants خود (چیزهایی که همیشه در مورد آن صادق هستند) را محافظت کند و اطمینان حاصل کند که در یک state consistent است. هرگز نباید حاوی داده‌های نامعتبر، ناقص یا بی‌معنی باشد. Entities به منظور ایجاد یک سطح اساسی از consistency برای application شما و همچنین محافظت از آن در برابر data corruption در نظر گرفته شده‌اند.</p>
<p>constructor یک entity باید یک named constructor باشد و باید clients را مجبور کند که حداقل مجموعه داده‌های مورد نیاز را ارائه دهند (به Listing 11.1 مراجعه کنید). The constructor باید تأیید کند که data ارائه شده valid است، به عنوان مثال مقادیر در محدوده مجاز هستند، حداقل طول را دارند و غیره. شما می‌توانید از مجموعه استانداردی از assertions استفاده کنید یا در صورت وجود مشکل، exceptions خود را throw کنید.</p>
<p>یک entity از ابتدا دارای هویت منحصر به فردی است. آن را هنگام فراخوانی constructor ارائه دهید (همانطور که در بخش 2.6 مورد بحث قرار گرفت).</p>
<p>روابط بین entities باید توسط IDs آن‌ها ایجاد شود، نه با ارائه کل object reference.</p>
<p>Listing 11.1. یک Order همیشه یک ID و یک relation با یک entity Customer دارد.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0267_original/original_page.png" alt="Original Page 267">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
final class Order
{
    // ...
    private function __construct(/* ... */)
    {
        // ...
    }
    public static function create(
        OrderId $orderId,
        CustomerId $customerId
    ): Order {
        return new self(/* ... */);
    }
}
</code></pre>
<h4><strong>11.2.2. Constrain updates</strong></h4>
<p>فقط به clients اجازه دهید fields را که واقعاً می‌توانند اصلاح شوند، update کنند. clients را مجبور کنید هنگامی که منطقی است، fields را با هم update کنند (به عنوان مثال، هنگامی که شما delivery address را تغییر می‌دهید، clients باید street, number, postal code و city را یکجا ارائه دهند). همیشه data ورودی را اعتبار سنجی کنید و هنگامی که مشکلی وجود دارد، exceptions را throw کنید. تأیید کنید که change درخواستی با توجه به state فعلی entity امکان‌پذیر است و entity به یک state نامعتبر ختم نخواهد شد (به Listing 11.2 مراجعه کنید).</p>
<p>Listing 11.2. changeDeliveryAddress() محدودیت‌هایی را در مورد زمان واقعی تغییر delivery ad-
ress قرار می‌دهد.</p>
<pre><code class="language-php">final class Order
{
    private bool $wasCancelled = false;
    // ...
    public function changeDeliveryAddress(
        DeliveryAddress $deliveryAddress
    ): void {
        if ($this-&gt;wasCancelled) {
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0268_original/original_page.png" alt="Original Page 268">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
throw new LogicException(
    sprintf(
        'Order %s was already cancelled',
        $this-&gt;id-&gt;asString()
    )
);
</code></pre>
<p>
        }
    </p>
<p>
        }
    </p>
<h4><strong>11.2.3. Model state changes as actions with state transitions</strong></h4>
<p>هنگامی که یک update به یک فیلد خاص در واقع نشان دهنده یک action انجام شده بر روی object است، یک متد برای آن تعریف کنید. وظیفه این متد، باز هم، اعتبار سنجی arguments ارائه شده به آن است. همچنین باید تأیید کند که action با توجه به state فعلی object مجاز است. به عنوان مثال، یک order ممکن است لغو شود، اما فقط در صورتی که هنوز تحویل داده نشده باشد. به جای یک متد setCancelled()، یک entity Order یک متد cancel() خواهد داشت، که بررسی‌های مورد نیاز را انجام می‌دهد (به Listing 11.3 مراجعه کنید).</p>
<p>Listing 11.3. action cancel() فقط زمانی در دسترس است که object در یک state خاص باشد.</p>
<pre><code class="language-php">final class Order
{
    // ...
    private bool $wasCancelled;
    private bool $wasDelivered;
    public function cancel(): void
    {
        if ($this-&gt;wasDelivered) {
            throw new LogicException(
                sprintf(
                    'Order %s has already been delivered',
                    $this-&gt;id-&gt;asString()
                )
            );
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0269_original/original_page.png" alt="Original Page 269">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
$this-&gt;wasCancelled = true;
        }
    }
}
</code></pre>
<p>
        Methods که state از entity را تغییر می‌دهند، یا یک action را روی آن انجام می‌دهند، باید هر دو Command methods باشند، یعنی باید یک return type از نوع void داشته باشند.
    </p>
<p>در حالی که تغییر delivery address یک order یک update ساده خواهد بود، لغو یک order تأثیری بر آنچه شما می‌توانید با order انجام دهید، دارد. همانطور که دیدیم، همین امر در مورد تحویل آن نیز صدق می‌کند. هنگامی که یک order در state "cancelled" قرار دارد، دیگر نمی‌توان آن را تحویل داد. هنگامی که یک order در state "delivered" قرار دارد، دیگر نمی‌توان آن را لغو کرد. هنگامی که یک entity را طراحی می‌کنید، ایجاد یک state machine diagram برای آن مفید خواهد بود، که states ممکن یک entity و actions (state transitions) موجود برای هر state داده شده را مستند می‌کند (به شکل 11.1 مراجعه کنید). unit tests را برای entity خود ایجاد کنید تا ثابت کنید که به درستی state machine را که در نظر داشتید، پیاده‌سازی می‌کند.</p>
<p>
<img alt="Figure 11.1. Entity states and state transitions" src="https://via.placeholder.com/300"/>
<figcaption>شکل 11.1. Entity states و state transitions</figcaption>
</p>
<h4><strong>11.2.4. Don’t think too much about tables</strong></h4>
<p>object خود، methods و properties خود را بدون نگرانی در مورد persistence طراحی کنید. Mapping داده‌ها به هر نوع database باید یک task جداگانه باشد. entity شما در وهله اول باید یک object با طراحی خوب باشد، صرف نظر از database که در نهایت از ذخیره آن پشتیبانی می‌کند. شما همیشه باید بتوانید یک mapping از object خود به database که می‌خواهید استفاده کنید، تعریف کنید. در واقع، شما می‌توانید اجازه دهید طراحی object شما تعیین کند که کدام storage model بهترین عملکرد را خواهد داشت.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 270" src="page_0270/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0270_original/original_page.png" alt="Original Page 270">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h4><strong>11.2.5. Record domain events</strong></h4>
<p>یک record داخلی از رویدادهای Domain که برای entity اتفاق افتاده است، مانند "Order was created"، "Order was cancelled" و غیره، نگه دارید. Domain events، object های immutable ساده‌ای هستند که پس از رویدادی که نشان می‌دهند نامگذاری شده‌اند، به عنوان مثال OrderWasCreated, OrderWasCancelled و غیره. پس از ذخیره entity، باید امکان بازیابی مجموعه‌ای از این event objects وجود داشته باشد تا بتوانید آن‌ها را dispatch کنید و به سایر بخش‌های application اجازه دهید به آن‌ها پاسخ دهند. Listing 11.4 یک setup ساده برای recording events و release کردن آن‌ها را نشان می‌دهد.</p>
<p>Listing 11.4. Keeping track of internally recorded domain events در یک array خصوصی.</p>
<pre><code class="language-php">
final class OrderWasCancelled
{
    private OrderId $orderId;
    public function __construct(OrderId $orderId)
    {
        $this-&gt;orderId = $orderId;
    }
}
final class Order
{
    private array $events = [];
    // ...
    public function cancel(): void
    {
        // ...
        $this-&gt;events[] = new OrderWasCancelled($this-&gt;id);
    }
    public function releaseEvents(): array
    {
        $events = $this-&gt;events;
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0271_original/original_page.png" alt="Original Page 271">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
    $this-&gt;events = [];
    return $events;
}
</code></pre>
<h4><strong>11.3. Repositories</strong></h4>
<p>هر entity به یک repository نیاز دارد. از آنجایی که یک repository از مرز application عبور می‌کند تا entities را ذخیره و بارگیری کند، باید یک service abstraction باشد. این بدان معناست که repository باید به عنوان یک interface تعریف شود (به عنوان مثال OrderRepository). همچنین به یک implementation استاندارد نیاز دارد که interface و contract توصیف شده توسط آن را پیاده‌سازی کند. چندین design جایگزین برای repositories وجود دارد، اما من ساده‌ترین آن‌ها را ترجیح می‌دهم. این تمایزی بین اضافه کردن و update کردن entities قائل نمی‌شود (به Listing 11.5 مراجعه کنید).</p>
<p>Listing 11.5. یک repository interface دارای متد save() و getById() است.</p>
<pre><code class="language-php">interface OrderRepository
{
    /**
     * @throws CouldNotSaveOrder
     */
    public function save(Order $order): void;
    /**
     * @throws CouldNotFindOrder
     */
    public function getById(OrderId $orderId): Order;
}
</code></pre>
<p>
        The contract که این interface نشان می‌دهد این است که وقتی شما یک Order را با یک OrderId خاص ذخیره کرده‌اید، می‌توانید در هر زمان یک کپی از آن را با ارائه همان OrderId به عنوان یک argument به getById() بازیابی کنید. پس از ایجاد تغییر در Order (در واقع، پس از تغییر آن به هر یک از روش‌هایی که اجازه می‌دهد)، object را می‌توان دوباره با استفاده از save() ذخیره کرد. و همچنین می‌توان آن را با فراخوانی getById() بازیابی کرد. object که شما از OrderRepository دریافت می‌کنید، می‌تواند
    </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0272_original/original_page.png" alt="Original Page 272">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>the exact same instance، یا یک object که به روشی مشابه با object ذخیره شده، رفتار می‌کند.</p>
<p>برای پیاده‌سازی‌های OrderRepository که نمونه‌های Order را در یک database واقعی ذخیره می‌کنند، پیاده‌سازی این contract می‌تواند کمی تلاش ببرد. اما ایجاد یک test double برای این contract در واقع واقعاً ساده است (به Listing 11.6 مراجعه کنید).</p>
<p>Listing 11.6. یک test double برای OrderRepository</p>
<pre><code class="language-php">
final class InMemoryOrderRepository
    implements OrderRepository
    {
        /**
         * @var array&lt;string,Order&gt;
         */
        private array $orders = [];
        public function save(Order $order): void
        {
            $this-&gt;orders[$order-&gt;orderId()-&gt;asString()] = $order;
        }
        public function getById(OrderId $orderId): Order
        {
            if (!isset($this-&gt;orders[$orderId-&gt;asString])) {
                throw CouldNotFindOrder::withId($orderId);
            }
            return $this-&gt;orders[$orderId-&gt;asString()];
        }
    }
</code></pre>
<p>"That’s too easy!"</p>
<p>بله، پیاده‌سازی in-memory repository واقعاً ساده است. زمانی که شما repository را پیاده‌سازی کنید که entity را در database واقعی ذخیره می‌کند، اوضاع پیچیده‌تر خواهد شد. همانطور که در فصل 2 بحث کردیم، گزینه‌های مختلفی وجود دارد. شما هنوز هم می‌توانید از یک ORM استفاده کنید و مقداری از logic را با از دست دادن مقداری صراحت و همچنین کنترل واگذار کنید. اگر تصمیم دارید که خودتان بنویسید</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0273_original/original_page.png" alt="Original Page 273">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>implementation mapping خودتان، الزامات زیر را در نظر داشته باشید.</p>
<p>هنگامی که یک entity را ذخیره می‌کنید، باید بدانید که آیا یک entity جدید است یا یک entity موجود که در حال update شدن است. بر اساس این دانش، شما باید یک query از نوع INSERT یا UPDATE انجام دهید. شما می‌توانید چیزی را ایجاد کنید که به عنوان یک identity map شناخته می‌شود، جایی که شما entities را که از database بارگیری شده‌اند، پیگیری می‌کنید. دفعه بعد که application سعی می‌کند یک entity را save() کند، شما آن را در identity map جستجو می‌کنید. اگر آنجا بود، باید update شود، اگر آنجا نبود باید insert شود. پس از insert، شما entity را به identity map اضافه می‌کنید، بنابراین ذخیره آن یک بار دیگر باعث ایجاد یک update می‌شود. یک جایگزین (چیزی که من در TalisORMa استفاده کردم) این است که به خود entity اجازه دهیم تا پیگیری کند که آیا "new" است یا خیر.</p>
<p>اگر entity دارای child entities است، شما باید همان نوع change tracking را برای این entities نیز انجام دهید. Child entities اغلب می‌توانند حذف شوند، بنابراین باید راهی برای یافتن زمانی که یک query از نوع DELETE مورد نیاز است، وجود داشته باشد. و قبل از اینکه شما متوجه شوید، شما در حال پیاده‌سازی ORM خودتان خواهید بود، بنابراین خوب است که به نسبت هزینه/فایده توجه داشته باشید. در چند سال گذشته، من شخصاً از نوشتن mapping code خودم مزایای زیادی را تجربه کرده‌ام، اما قبل از پیمودن این مسیر، مطمئن شوید که context خود را به طور کامل در نظر گرفته‌اید.</p>
<p><sup>a</sup>https://advwebapparch.com/talis-orm</p>
<h4><strong>11.4. Application services</strong></h4>
<p>entity Order را می‌توان ایجاد کرد، شما می‌توانید delivery address آن را تغییر دهید، آن را لغو کنید و غیره. این رفتارها توسط command methods با یک name با intention-revealing نشان داده می‌شوند. فقط Application services باید به این methods دسترسی داشته باشند. یک application service، تغییر درخواستی را هماهنگ می‌کند. به عنوان مثال، order را ایجاد می‌کند و آن را در OrderRepository ذخیره می‌کند. یا یک entity Order را با ID آن بارگیری می‌کند، یک یا چند methods را روی آن فراخوانی می‌کند و دوباره آن را ذخیره می‌کند (برای برخی از مثال‌ها به Listing 11.7 مراجعه کنید).</p>
<p>Listing 11.7. برخی از application services.</p>
<pre><code class="language-php">
final class CreateOrderService
{
    private OrderRepository $orderRepository;
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0274_original/original_page.png" alt="Original Page 274">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
public function __construct(OrderRepository $orderRepository)
{
    $this-&gt;orderRepository = $orderRepository;
}
public function __invoke(/* ... */): OrderId
{
    $orderId = $this-&gt;orderRepository-&gt;nextIdentity();
    $order = Order::create(
        $orderId,
        /* ... */
    );
    $this-&gt;orderRepository-&gt;save($order);
    return $order-&gt;id();
}
</code></pre>
<pre><code class="language-php">
final class ChangeDeliveryAddressService
{
    private OrderRepository $orderRepository;
    public function __construct(OrderRepository $orderRepository)
    {
        $this-&gt;orderRepository = $orderRepository;
    }
    public function __invoke(OrderId $orderId /* ... */): void
    {
        $order = $this-&gt;orderRepository-&gt;getById($orderId);
        $order-&gt;changeDeliveryAddress(/* ... */);
        $this-&gt;orderRepository-&gt;save($order);
    }
}
</code></pre>
<p>یک application service می‌تواند یک متد واحد داشته باشد (مانند متد __invoke() در Listing 11.7). در این صورت service نشان دهنده یک use case واحد نیز است.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0275_original/original_page.png" alt="Original Page 275">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>اما از آنجایی که چندین uses cases ممکن است مجموعه یکسانی از dependencies را به اشتراک بگذارند، شما همچنین می‌توانید یک class واحد با multiple methods ایجاد کنید (به Listing 11.8 مراجعه کنید).</p>
<p>Listing 11.8. یک application service با multiple methods (use cases).</p>
<pre><code class="language-php">
final class OrderService
{
    private OrderRepository $orderRepository;
    public function __construct(
        OrderRepository $orderRepository
    ) {
        $this-&gt;orderRepository = $orderRepository;
    }
    public function createOrder(/* ... */): OrderId
    {
        $orderId = $this-&gt;orderRepository-&gt;nextIdentity();
        // ...
        return $orderId;
    }
    public function changeDeliveryAddress(/* ... */): void
    {
        // ...
    }
    public function markAsDelivered(/* ... */): void
    {
        // ...
    }
    public function cancel(/* ... */): void
    {
        // ...
    }
}
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0276_original/original_page.png" alt="Original Page 276">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h4><strong>11.4.1. Return the identifier of a new entity</strong></h4>
<p>متدهای Application service، command methods هستند: آن‌ها state entity را تغییر می‌دهند و نباید چیزی را برگردانند. با این حال، هنگامی که یک application service یک entity جدید ایجاد می‌کند (مانند متد createOrder() در Listing 11.7)، شما همچنان می‌توانید ID entity جدید را برگردانید. یک چیزی که یک application service قطعاً نباید برگرداند، کل entity است. همانطور که قبلاً توضیح داده شد، یک entity یک write model با رفتارهای built-in برای تغییر state آن است. نباید برای client هایی که نمی‌خواهند state آن را تغییر دهند، در دسترس باشد. Clients از application services معمولاً controllers هستند و قطعاً نباید state entity را تغییر دهند.</p>
<p>اگر می‌خواهید اطلاعاتی در مورد entity در response برگردانید، چه؟ در این صورت از ID که توسط application service برای fetch کردن یک view model از view model repository آن برگردانده شده است، استفاده کنید (Listing 11.9 را ببینید).</p>
<p>Listing 11.9. Fetching یک view model در داخل controller.</p>
<pre><code class="language-php">
final class OrderController
{
    // ...
    public function createOrderAction(Request $request): Response
    {
        $orderId = $this-&gt;orderService-&gt;createOrder(/* ... */);
        $order = $this-&gt;orderDetailsRepository-&gt;getById($orderId);
        return $this-&gt;templateRenderer-&gt;render(
            'order-details.html.twig',
            [
                'order' =&gt; $order
            ]
        );
    }
}
</code></pre>
<p>برای اطلاعات بیشتر در مورد view models، به بخش 3.5 مراجعه کنید.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0277_original/original_page.png" alt="Original Page 277">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h4><strong>11.4.2. Input should be defined as primitive-type data</strong></h4>
<p>client از یک application service معمولاً نوعی controller است، مانند یک web controller یا یک console command. یک client دیگر می‌تواند یک test باشد که service را فراخوانی می‌کند. ما نمونه‌ای از این را در فصل 14 خواهیم دید.</p>
<p>برای اینکه یک application service کاملاً قابل حمل باشد، و به هر نوع client اجازه استفاده از service را بدهد، شما باید input arguments را آسان کنید. بهترین راه برای انجام این کار این است که فقط از primitive-type parameters استفاده کنید (به Listing 11.10 مراجعه کنید).</p>
<p>Listing 11.10. این application service، arguments ساده و آسان برای ایجاد را می‌پذیرد.</p>
<pre><code class="language-php">
final class OrderService
{
    // ...
    public function changeDeliveryAddress(
        string $orderId,
        string $address,
        string $postalCode,
        string $city,
        string $country
    ): void {
        // ...
    }
}
</code></pre>
<h4><strong>11.4.3. Wrap input inside command objects</strong></h4>
<p>شما می‌توانید Parameter object را معرفی کنید که تمام پارامترها را در یک object واحد ترکیب می‌کند (به Listing 11.11 مراجعه کنید).</p>
<p>Listing 11.11. استفاده از یک parameter object.</p>
<pre><code class="language-php">
final class ChangeDeliveryAddress
{
    private string $orderId;
    private string $address;
    private string $postalCode;
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0278_original/original_page.png" alt="Original Page 278">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
private string $city;
    private string $country;
    public function __construct(
        string $orderId,
        string $address,
        string $postalCode,
        string $city,
        string $country
    ) {
        $this-&gt;orderId = $orderId;
        $this-&gt;address = $address;
        $this-&gt;postalCode = $postalCode;
        $this-&gt;city = $city;
        $this-&gt;country = $country;
    }
    public function orderId(): string
    {
        return $this-&gt;orderId;
    }
    public function address(): string
    {
        return $this-&gt;address;
    }
    // ...
}
final class OrderService
{
    public function changeDeliveryAddress(
        ChangeDeliveryAddress $command
    ): void {
        // ...
    }
}
</code></pre>
<p>یک parameter object برای یک application service، یک data-transfer object (DTO) است.
        در controller شما باید data را از request به DTO کپی کنید،
    </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0279_original/original_page.png" alt="Original Page 279">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>که سپس آن را به application service منتقل می‌کند. از نام class از DTO برای انتقال intent استفاده کنید. اگر قرار است از data برای تغییر delivery address یک order استفاده شود، نام آن باید ChangeDeliveryAddress باشد. این یک Command object2 می‌سازد و application service تبدیل به یک Command handler می‌شود.</p>
<p>هنگام کپی کردن data از request به command object، هنگامی که با input بد مواجه می‌شوید، exceptions را throw نکنید (همانطور که در بخش 8.6 مورد بحث قرار گرفت). تنها کاری که شما باید انجام دهید، اطمینان حاصل کردن از این است که data request به انواع صحیح cast شده است، همه fields یک مقدار به آن‌ها اختصاص داده شده است یا null هستند اگر این یک مقدار مجاز است (به Listing 11.12 مراجعه کنید).</p>
<p>Listing 11.12. استفاده از یک DTO برای تعریف یک shape برای input data.</p>
<pre><code class="language-php">
final class CreateOrder
{
    use Mapping;
    // ...
    public static function fromRequestData(array $data): self
    {
        return new self(
            self::getString($data, 'email'),
            self::getInt($data, 'ebook_id'),
            self::getInt($data, 'quantity'),
            self::getNonEmptyStringOrNull($data, 'buyer_name')
        );
    }
}
</code></pre>
<h4><strong>11.4.4. Translate primitive input to domain objects</strong></h4>
<p>یک application service باید مقادیر primitive-type را از DTO به value objects که entity می‌تواند با آن‌ها کار کند، ترجمه کند. Listing 11.13 نشان می‌دهد که چگونه application service input را می‌گیرد و یک value object ایجاد می‌کند که می‌تواند به متد Order::changeDeliveryAddress() ارسال شود.</p>
<p><sup>2</sup>با الگوی طراحی Command اشتباه نشود.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0280_original/original_page.png" alt="Original Page 280">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>Listing 11.13. ترجمه مقادیر primitive-type به rich domain objects.</p>
<pre><code class="language-php">
final class OrderService
{
    private OrderRepository $orderRepository;
    // ...
    public function changeDeliveryAddress(
        ChangeDeliveryAddress $command
    ): void {
        $order = $this-&gt;orderRepository-&gt;getById(
            OrderId::fromString($command-&gt;orderId())
        );
        // ...
        $order-&gt;changeDeliveryAddress(
            DeliveryAddress::fromScalars(
                $command-&gt;address(),
                $command-&gt;postalCode(),
                $command-&gt;city(),
                $command-&gt;country()
            )
        );
        // ...
    }
}
</code></pre>
<p>این به حفظ دانش در مورد نحوه برخورد با domain objects در داخل core application کمک می‌کند، و نه در infrastructure code مانند controller. همچنین تضمین می‌کند که entities و value objects فقط exceptions را یک بار پس از فراخوانی application service، throw می‌کنند. به این ترتیب، controller هنوز هم فرصتی برای اعتبار سنجی خود command object و نشان دادن form errors به کاربر دارد.</p>
<p>با این حال، application services تمایل دارند به لیست‌های طولانی از این primitive-value-to-value-object transformations تبدیل شوند، که view را بر روی use case واقعی که service نشان می‌دهد، مبهم می‌کند. به عنوان یک جایگزین، شما می‌توانید accessor methods را به command object اضافه کنید که instantiate می‌شوند و
        return می‌کنند
    </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0281_original/original_page.png" alt="Original Page 281">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>صحیح value objects خودشان (به Listing 11.14 مراجعه کنید).</p>
<p>Listing 11.14. Translating مقادیر primitive به domain objects های rich در داخل DTO.</p>
<pre><code class="language-php">
final class ChangeDeliveryAddress
{
    private string $orderId;
    private string $address;
    private string $postalCode;
    private string $city;
    private string $country;
    public function orderId(): OrderId
    {
        return OrderId::fromString($this-&gt;orderId);
    }
    public function deliveryAddress(): DeliveryAddress
    {
        return DeliveryAddress::fromScalars(
            $this-&gt;address,
            $this-&gt;postalCode,
            $this-&gt;city,
            $this-&gt;country
        );
    }
}
final class OrderService
{
    private OrderRepository $orderRepository;
    // ...
    public function changeDeliveryAddress(
        ChangeDeliveryAddress $command
    ): void {
        $order = $this-&gt;orderRepository-&gt;getById($command-&gt;orderId());
        // ...
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0282_original/original_page.png" alt="Original Page 282">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>این approach چندین مزیت دارد:</p>
<ol>
<li>نویز کمتری در داخل application service وجود دارد، زیرا نیازی نیست که خودش با تمام type conversions مقابله کند.</li>
<li>The getters روی command DTO می‌تواند چندین بار در داخل application service فراخوانی شود. نیازی به تکرار logic مربوط به instantiation نیست.</li>
</ol>
<p>یک downside احتمالی این است که شما می‌توانید به طور تصادفی یک domain-level exception را در داخل controller با فراخوانی یکی از آن getters فعال کنید. در عمل، من متوجه می‌شوم که این مسئله مانع ایجاد نمی‌کند و فقط چیزی است که باید از آن آگاه بود.</p>
<h4><strong>11.4.5. Add contextual information as extra arguments</strong></h4>
<p>data Contextual مانند ID کاربر فعلی، data از current HTTP request و غیره. نباید در صورت نیاز fetch شوند، و نه باید به عنوان constructor arguments از application service تزریق شوند. در عوض، contextual information همیشه باید به عنوان method arguments ارائه شود (همانطور که در بخش 5.5 مورد بحث قرار گرفت). اگر می‌خواهید ID کاربر فعلی را در entity Order ذخیره کنید، مطمئن شوید که آن را به عنوان یک argument به CreateOrderService منتقل می‌کنید (به Listing 11.15 مراجعه کنید).</p>
<p>Listing 11.15. Passing contextual information به عنوان بخشی از command DTO.</p>
<pre><code class="language-php">
final class OrderService
{
    // ...
    public function changeDeliveryAddress(
        ChangeDeliveryAddress $command
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0283_original/original_page.png" alt="Original Page 283">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
): void {
    // The current user ID is part of the command data:
    $userId = $command-&gt;userId();
    // ...
}
</code></pre>
<pre><code class="language-php">
// In the controller:
$this-&gt;orderService-&gt;changeDeliveryAddress(
    ChangeDeliveryAddress::fromRequestData(
        $request-&gt;request-&gt;all(),
        $user-&gt;userId()
    )
)
</code></pre>
<h4><strong>11.4.6. Save only one entity per application service call</strong></h4>
<p>یک application service باید فقط تغییراتی را در یک entity واحد ایجاد کند. این می‌تواند به بهبود عملکرد domain model کمک کند، هم از نظر پردازش تغییرات در database و هم از نظر جلوگیری از concurrent updates. این به حفظ use cases شما متمرکز بر یک ناحیه محدود از domain کمک می‌کند. فقط یک چیز وجود دارد که service باید انجام دهد.</p>
<h4><strong>11.4.7. Move secondary tasks to a domain event subscriber</strong></h4>
<p>یک تغییر در یک entity اغلب نیازمند انجام کارهای دیگری نیز هست. شاید entity دیگری نیز نیاز به update شدن داشته باشد. شاید شما مجبور شوید یک ایمیل در مورد تغییر به کسی ارسال کنید، یا یک پیام را به یک queue ارسال کنید. برای این secondary effects از domain events، یک event dispatcher و event subscribers استفاده کنید. شکل 11.2 نحوه عملکرد این عناصر را با هم نشان می‌دهد.</p>
<p>Events در داخل entity ایجاد می‌شوند و پس از ذخیره شدن خود entity، می‌توان آن‌ها را توسط application service بیرون آورد و به event dispatcher ارسال کرد (همانطور که در بخش 4.5 مورد بحث قرار گرفت). بنابراین، شما نباید events را تا زمانی که مطمئن نیستید تغییرات entity persist شده‌اند، dispatch کنید. به منظور dispatch events، یک application service باید event dispatcher را داشته باشد</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0284_original/original_page.png" alt="Original Page 284">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
<img alt="Figure 11.2. A client sends an event object to the event dispatcher. The dis-
patcher forwards the event to any subscriber that is known to
be interested in events of that type." src="https://via.placeholder.com/300"/>
<figcaption>شکل 11.2. یک client یک event object را به event dispatcher ارسال می‌کند. The dispatcher، event را به هر subscriber که شناخته شده است به رویدادهای آن type، علاقه‌مند است، منتقل می‌کند.</figcaption>
</p>
<p>service به عنوان یکی از dependencies آن (به Listing 11.16 مراجعه کنید). باید توسط interface آن تزریق شود.</p>
<p>Listing 11.16. Dispatching domain events که در داخل entity ثبت شده‌اند.</p>
<pre><code class="language-php">
final class OrderService
{
    private OrderRepository $orderRepository;
    private EventDispatcher $eventDispatcher;
    public function __construct(
        OrderRepository $orderRepository,
        EventDispatcher $eventDispatcher
    ) {
        $this-&gt;orderRepository = $orderRepository;
        $this-&gt;eventDispatcher = $eventDispatcher;
    }
    public function changeDeliveryAddress(
        OrderId $orderId,
        ChangeDeliveryAddress $command
    ): void {
        // ...
</code></pre>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 285" src="page_0285/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0285_original/original_page.png" alt="Original Page 285">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
$command-&gt;address(),
        $command-&gt;postalCode(),
        $command-&gt;city(),
        $command-&gt;country()
    )
);
    $this-&gt;orderRepository-&gt;save($order);
    $this-&gt;eventDispatcher-&gt;dispatchAll(
        $order-&gt;releaseEvents()
    );
}
</code></pre>
<p>این approach چندین مزیت دارد:</p>
<p>یک application service ممکن است چندین تغییر در یک entity ایجاد کند که باعث می‌شود multiple events ثبت و release شوند. یک entity ممکن است چندین event را برای یک action واحد نیز ثبت کند. این می‌تواند زمانی اتفاق بیفتد که یک تغییر در یک entity به معنی چیزهای مختلفی برای observers مختلف است. یا زمانی که یک update، entity را وارد یک state جدید می‌کند (به Listing 11.17 مراجعه کنید).</p>
<p>Listing 11.17. Recording multiple events.</p>
<pre><code class="language-php">
final class Order
{
    // ...
    public function markLineAsDelivered(int $lineNumber): void
    {
        $this-&gt;line($lineNumber)-&gt;markAsDelivered();
        $this-&gt;events[] = new LineDelivered($this-&gt;id, $lineNumber);
        if ($this-&gt;allLinesHaveBeenDelivered()) {
            $this-&gt;events[] = new OrderFullyDelivered($this-&gt;id);
        }
    }
}
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0286_original/original_page.png" alt="Original Page 286">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h4><strong>11.5. Event subscribers</strong></h4>
<p>بعد از ذخیره یک entity، event dispatcher باید تمام domain events های ثبت شده را دریافت کند. سپس event dispatcher به تمام event subscribers که برای آن event خاص ثبت شده‌اند، اطلاع می‌دهد. Listing 11.18 نشان می‌دهد که چگونه یک event dispatcher ساده این کار را انجام می‌دهد. تمام subscribers در این مثال به عنوان یک constructor argument ارائه شده‌اند. هر subscriber قرار است یک callable باشد.</p>
<p>Listing 11.18. یک EventDispatcher interface با یک implementation ساده.</p>
<pre><code class="language-php">
interface EventDispatcher
{
    public function dispatchAll(array $events): void;
}
final class SimpleEventDispatcher implements EventDispatcher
{
    private array $subscribers;
    public function __construct(array $subscribersByEventType)
    {
        $this-&gt;subscribers = $subscribersByEventType;
    }
    public function dispatchAll(array $events): void
    {
        foreach ($events as $event) {
            foreach (
                $this-&gt;subscribersForEvent($event) as $subscriber
            ) {
                $subscriber($event);
            }
        }
    }
    private function subscribersForEvent(object $event): array
    {
        return $this-&gt;subscribers[get_class($event)] ?? [];
    }
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0287_original/original_page.png" alt="Original Page 287">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
}
</code></pre>
<p>Listing 11.19 نشان می‌دهد که چگونه شما یک event subscriber را برای رویداد OrderFullyDelivered ثبت می‌کنید.</p>
<p>Listing 11.19. CreateInvoice یک event subscriber است که به service EventDispatcher ثبت می‌شود.</p>
<pre><code class="language-php">
final class CreateInvoice
{
    private InvoicingService $invoicingService;
    public function __construct(
        InvoicingService $invoicingService
    ) {
        $this-&gt;invoicingService = $invoicingService;
    }
    public function whenOrderFullyDelivered(
        OrderFullyDelivered $event
    ): void {
        $this-&gt;invoicingService-&gt;createInvoiceFromOrder(
            $event-&gt;orderId(),
            /* ... */
        );
    }
}
$eventSubscriber = new CreateInvoice(/* ... */);
$eventDispatcher = new SimpleEventDispatcher(
    [
        OrderFullyDelivered::class =&gt; [
            [$eventSubscriber, 'whenOrderFullyDelivered']
        ]
    ]
);
</code></pre>
<p>نمونه‌سازی services و تزریق آن‌ها به عنوان dependencies، کاری است که یک dependency injection container باید برای شما انجام دهد. این مثال فقط نشان می‌دهد که logic در داخل container چگونه به نظر می‌رسد.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0288_original/original_page.png" alt="Original Page 288">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h4><strong>11.5.1. Move subscribers to the module where they produce their effect</strong></h4>
<p>نام class از یک event subscriber باید آنچه را که قرار است انجام دهد، توصیف کند، به عنوان مثال "create an invoice" (Listing 11.19). متدهای event subscriber باید توصیف کنند که چه زمانی قرار است این کار را انجام دهد. انجام این کار به شما اجازه می‌دهد event subscribers را به ناحیه‌ای که در آن effect خود را ایجاد می‌کنند، منتقل کنید. به عنوان مثال، invoicing ممکن است در یک بخش کاملاً متفاوت از application رسیدگی شود. اگر order module به invoicing module دسترسی پیدا کند و شروع به فراخوانی methods در آنجا کند، به توانایی جدا کردن modules از یکدیگر آسیب می‌رساند. شکل 11.3 نشان می‌دهد که چگونه انجام این کار یک dependency از order module به invoicing module ایجاد می‌کند.</p>
<p>
<img alt="Figure 11.3. The CreateInvoice subscriber, which lives in the Orders mod-
ule, uses the the InvoicingService from the Invoicing module,
establishing a dependency from the Orders module to the In-
voicing module." src="https://via.placeholder.com/300"/>
<figcaption>شکل 11.3. CreateInvoice subscriber، که در ماژول Orders قرار دارد، از InvoicingService از ماژول Invoicing استفاده می‌کند، و یک dependency از ماژول Orders به ماژول Invoicing ایجاد می‌کند.</figcaption>
</p>
<p>
        The order ابتدا می‌آید و تعیین می‌کند که چه چیزی باید invoiced شود. invoice دوم می‌آید و بر اساس data از order است. بنابراین order module upstream است، the invoicing module downstream است. ما باید این را در نحوه تنظیم event subscribers نیز منعکس کنیم. The CreateInvoice subscriber باید در invoicing module قرار داشته باشد و خود را به رویدادهایی که در داخل order module تولید می‌شوند، مشترک کند. هر زمان که رویداد OrderFullyDelivered رخ می‌دهد، ایجاد invoice را شروع می‌کند، که یک entity است که توسط invoicing module مدیریت می‌شود. با مرتب کردن things به این ترتیب، the orders module مجبور نیست چیزی در مورد invoicing module بداند. the invoicing module
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 289" src="page_0289/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0289_original/original_page.png" alt="Original Page 289">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>نیازی نیست به صراحت به ایجاد یک invoice گفته شود. این به این واقعیت پاسخ خواهد داد که یک order، به طور کامل تحویل داده شده است. شکل 11.4 نشان می‌دهد که چگونه انتقال CreateInvoice subscriber به invoicing module، dependencies مورد نظر را بین این modules ایجاد می‌کند.</p>
<p>
<img alt="Figure 11.4. Moving the CreateInvoice subscriber to the Invoicing module,
establishes the correct dependency direction: the Invoicing now
depends on Orders instead of the other way around." src="https://via.placeholder.com/300"/>
<figcaption>شکل 11.4. انتقال CreateInvoice subscriber به Invoicing module، جهت dependency صحیح را ایجاد می‌کند: Invoicing اکنون به جای مسیر دیگر، به Orders وابسته است.</figcaption>
</p>
<h4><strong>11.5.2. Delegate to an application service</strong></h4>
<p>وظیفه برخی از event subscribers ممکن است این باشد که به تغییرات در یک entity با یک update از entity دیگر پاسخ دهند. این یک مورد کلاسیک از Eventual consistency خواهد بود: state system فقط پس از اتمام کار تمام event subscribers consistent خواهد بود. به جای ایجاد تغییر در داخل event subscriber، فراخوانی را به یک application service محول کنید. این application service باید از pattern استاندارد بازیابی یک entity، ایجاد تغییر در آن و ذخیره مجدد آن پیروی کند.</p>
<p>بیشتر event subscribers باید مستقل از infrastructure باشند و فقط شامل core code باشند زیرا آن‌ها بخش مهمی از use case هستند. اما ممکن است event subscribers مخصوص infrastructure نیز در application شما وجود داشته باشد. به عنوان مثال، subscribers که domain events را log می‌کنند، آن‌ها را به یک queue ارسال می‌کنند، ذخیره می‌کنند</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 290" src="page_0290/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0290_original/original_page.png" alt="Original Page 290">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>the current user ID is part of the command data:
    service را به عنوان یکی از dependencies آن (به Listing 11.16 مراجعه کنید). باید توسط interface آن تزریق شود.</p>
<p>Listing 11.19 نشان می‌دهد که چگونه شما یک event subscriber را برای رویداد OrderFullyDelivered ثبت می‌کنید.</p>
<p>آن‌ها را در یک database ذخیره کنید، یا چیزی شبیه به آن. infrastructure-specific event subscribers نیازی به واگذاری کار خود به یک application service ندارند. در واقع، نمی‌توانند، زیرا یک application service نمی‌تواند هیچ کار infrastructureای انجام دهد. قرار است core code باشد. بنابراین با event subscribers در سطح infrastructure شما فقط هر کاری را که باید در داخل خود event subscriber انجام دهید. البته، شما همیشه می‌توانید مقداری از کار را به سایر services (infrastructure) که به عنوان constructor arguments از event subscriber تزریق می‌کنید، واگذار کنید.</p>
<h4><strong>11.6. Read models</strong></h4>
<p>در حالی که application services با entities، که write models هستند، سروکار دارند، یک client که به اطلاعاتی از یک entity نیاز دارد، نباید خود entity را استفاده کند، بلکه باید از یک Read model اختصاصی استفاده کند. read models های داخلی و خارجی وجود دارد (که اغلب view models نامیده می‌شوند، به بخش 11.6.3 مراجعه کنید). بیایید با read models های داخلی شروع کنیم.</p>
<h4><strong>11.6.1. Use internal read models when you need information</strong></h4>
<p>با توجه به یک client و نیاز آن به اطلاعات، با تعریف یک نوع جدید از object شروع کنید که بتواند این اطلاعات را ارائه دهد. به عنوان مثال، InvoicingService قصد دارد یک invoice برای یک order ایجاد کند، بنابراین باید چند چیز در مورد order بداند. در InvoicingService طوری عمل کنید که گویی از قبل وجود دارد (به Listing 11.20 مراجعه کنید).</p>
<p>Listing 11.20. InvoicingService طوری عمل می‌کند که گویی یک Order read model از قبل وجود دارد.</p>
<pre><code class="language-php">
final class InvoicingService
{
    // ...
    public function createInvoiceForOrder(OrderId $orderId)
    {
        // ...
        $invoice = Invoice::create(
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0291_original/original_page.png" alt="Original Page 291">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
$order-&gt;customerId(),
        $order-&gt;billingAddress()
    );
    foreach ($order-&gt;lines() as $line) {
        $invoice-&gt;addLine(
            $line-&gt;productDescription(),
            $line-&gt;quantity(),
            $line-&gt;tariff()
        );
    }
    // ...
}
</code></pre>
<p>IDE شما به شما کمک می‌کند تا outline را برای object جدید با ایجاد خودکار classes و methods که هنوز وجود ندارند، تولید کنید (نتیجه را در Listing 11.21 ببینید).</p>
<p>Listing 11.21. The resulting Order read model.</p>
<pre><code class="language-php">
final class Order
{
    // ...
    public function customerId(): CustomerId
    {
        // ...
    }
    public function billingAddress(): string
    {
        // ...
    }
    /**
     * @return array&lt;Line&gt;
     */
    public function lines(): array
    {
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0292_original/original_page.png" alt="Original Page 292">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
// ...
}
</code></pre>
<pre><code class="language-php">
final class Line
{
    // ...
    public function productDescription(): string
    {
        // ...
    }
    public function quantity(): int
    {
        // ...
    }
    public function tariff(): Money
    {
        // ...
    }
}
</code></pre>
<p>توجه داشته باشید که Order read model بخشی از Invoicing module است. به این ترتیب، Invoicing مالک API object است، بنابراین می‌توان آن را به راحتی برای پاسخگویی به نیازهای آینده InvoicingService اصلاح کرد.
        InvoicingService باید بتواند یک نمونه از Order read model را از یک Repository، که باید متعلق به Invoicing module نیز باشد، بازیابی کند. برای جداسازی what از how از بازیابی یک object read model، ابتدا یک repository interface ایجاد کنید که InvoicingService می‌تواند به آن وابسته باشد (به Listing 11.22 مراجعه کنید).
    </p>
<p>Listing 11.22. The InvoicingService یک object Order را از interface OrderRepository دریافت می‌کند.</p>
<pre><code class="language-php">
interface OrderRepository
{
    public function getById(OrderId $orderId): Order;
}
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0293_original/original_page.png" alt="Original Page 293">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
final class InvoicingService
{
    private OrderRepository $orderRepository;
    public function __construct(OrderRepository $orderRepository)
    {
        $this-&gt;orderRepository = $orderRepository;
    }
    public function createInvoiceForOrder(OrderId $orderId)
    {
        $order = $this-&gt;orderRepository-&gt;getById($orderId);
        $invoice = Invoice::create(
            $order-&gt;customerId(),
            $order-&gt;billingAddress()
        );
        // ...
    }
}
</code></pre>
<p>جدا کردن interface و implementation، انعطاف‌پذیری زیادی به شما می‌دهد.
        در یک سناریوی تست، شما می‌توانید dependency OrderRepository از InvoicingService را با یک نسخه ساده‌تر و سریع‌تر جایگزین کنید. ما می‌توانیم به آن اجازه دهیم تا هر object از نوع Order read model را که نیاز داریم، برگرداند.
    </p>
<p>شکل 11.5 وابستگی‌ها را بین ماژول‌های Order و Invoicing نشان می‌دهد.</p>
<h4><strong>11.6.2. Choose a standard implementation for the repository</strong></h4>
<p>The read model repository implementation، داده‌های مورد نیاز را fetch کرده و object های read model از نوع Order مورد نظر را ایجاد می‌کند. این کار را می‌تواند به روش‌های مختلفی انجام دهد، به عنوان مثال:</p>
<ul>
<li>The repository می‌تواند از همان database استفاده کند که توسط write</li>
</ul>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0294_original/original_page.png" alt="Original Page 294">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
<img alt="Figure 11.5. In this example, there is no code-level dependency between
Invoicing and Orders.
However, both modules use the same
database to get their data." src="https://via.placeholder.com/300"/>
<figcaption>شکل 11.5. در این مثال، هیچ dependencyای در سطح کد بین Invoicing و Orders وجود ندارد.
            با این حال، هر دو ماژول از یک database برای دریافت data خود استفاده می‌کنند.
        </figcaption>
</p>
<ul>
<li>repository می‌تواند از همان database استفاده کند که توسط write</li>
</ul>
<p>model. در این صورت repository داده‌ها را از tables مربوطه کپی کرده و object read model را با آن پر می‌کند.</p>
<ul>
<li>
            application می‌تواند یک read model را بر اساس domain events از write model ایجاد کند. سپس repository state فعلی read model را برمی‌گرداند.
        </li>
</ul>
<p>ما قبلاً در مورد این options با جزئیات در فصل 3 بحث کرده‌ایم.</p>
<p>هر تغییری که در خارج از ماژول ایجاد شود، تا زمانی که پیاده‌سازی repository قادر به ارائه object های read model مناسب باشد، همه چیز باید خوب باشد. این مانند اصل Dependency Inversion است که برای models اعمال می‌شود. حتی اگر ماژول Orders توسط یک platform third-party برای فروش e-books جایگزین شود، ماژول Invoicing نیازی به رنج بردن ندارد. تنها کاری که باید انجام شود، بازنویسی پیاده‌سازی OrderRepository برای استفاده از API platform third-party برای بازیابی اطلاعات در مورد یک order است (به شکل 11.6 مراجعه کنید). این باعث می‌شود که استفاده از read models به عنوان representation های local از remote entities یک تکنیک معماری بسیار قدرتمند باشد.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 295" src="page_0295/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0295_original/original_page.png" alt="Original Page 295">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
<img alt="Figure 11.6. In this example, Orders has been completely replaced by a
third-party system. Invoicing’s OrderRepository implementa-
tion now uses that system’s API to fetch order information." src="https://via.placeholder.com/300"/>
<figcaption>شکل 11.6. در این مثال، Orders به طور کامل توسط یک system third-party جایگزین شده است. پیاده‌سازی OrderRepository از Invoicing اکنون از API آن system برای fetch کردن اطلاعات order استفاده می‌کند.</figcaption>
</p>
<h4><strong>11.6.3. For view models, prepare the data for rendering</strong></h4>
<p>علاوه بر internal read models، مدل‌های outward-facing نیز وجود دارند که data را به primary actors نشان می‌دهند. در مثال ما، Invoicing ممکن است یک HTTP API نیز داشته باشد و به clients اجازه می‌دهد یک representation از نوع JSON از یک invoice را fetch کنند. در این صورت، Invoicing data invoice را مدیریت می‌کند زیرا مالک entity Invoice است، اما همچنین یک view بر روی آن data ارائه می‌دهد. در واقع، چندین view ارائه می‌دهد زیرا همچنین یک list از unpaid invoices را در وب سایت ارائه می‌دهد و به کاربران اجازه می‌دهد یک invoice را به عنوان یک فایل PDF دانلود کنند. شکل 11.7 این view models های مختلف را نشان می‌دهد که Invoicing به actors خود ارائه می‌دهد.</p>
<p>The view models خودشان باید به طور کامل برای view که آن‌ها را به کاربر render می‌کند، آماده شوند. به عنوان مثال، اگر قرار است از view model برای render کردن یک template HTML استفاده شود، مطمئن شوید که template renderer نیازی به انجام کارهای بیشتری از جمله echo کردن چند properties، loop کردن بر روی برخی از properties، echo کردن چند properties دیگر و غیره ندارد. اگر قرار است view model به عنوان یک object JSON render شود، مطمئن شوید که object را می‌توان در یک مرحله به JSON encode کرد.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 296" src="page_0296/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0296_original/original_page.png" alt="Original Page 296">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
<img alt="Figure 11.7. Invoicing offers several ways for clients to learn more about the
data it manages." src="https://via.placeholder.com/300"/>
<figcaption>شکل 11.7. Invoicing راه‌های مختلفی را برای clients ارائه می‌دهد تا در مورد data که مدیریت می‌کند، اطلاعات بیشتری کسب کنند.</figcaption>
</p>
<h4><strong>11.7. Process modelling</strong></h4>
<p>ما این فصل را با بحثی در مورد معماری الهام گرفته از framework آغاز کردیم. Frameworks تعدادی element را پیشنهاد می‌کنند که باید برای ساخت application شما استفاده شوند: controllers, models, templates و غیره. در بخش‌های قبل ما در مورد مجموعه‌ای جایگزین از elements بحث کردیم که می‌توانند برای ساخت application شما نیز استفاده شوند: entities, repositories, application services, events, event subscribers, read models و view models. البته تفاوت این است که هنگام استفاده از elements مانند application services و entities به عنوان building blocks، طراحی شما نه به یک framework و نه به هیچ بخش دیگری از infrastructure وابسته نیست.</p>
<p>این مجموعه جدید از عناصر، به وضوح use cases application شما را توصیف می‌کند: آنچه شما می‌توانید با آن انجام دهید، عواقب آن چیست و چه اطلاعاتی را application نشان می‌دهد، بدون صحبت در مورد جزئیات implementation. توانایی کنار گذاشتن جزئیات implementation نشانه‌ای است که ما می‌توانیم از این elements در جلسات high-level modelling استفاده کنیم. شما این تکنیک modelling را پیدا خواهید کرد</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 297" src="page_0297/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0297_original/original_page.png" alt="Original Page 297">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>توضیح داده شده توسط Alberto Brandolini در "Introducing Event Storming"<sup>3</sup>. در آنجا او آن را "Process Modelling" می‌نامد. در تجربه من این یک تکنیک بسیار مفید است. این بین جلسات طراحی high-level که در آن تمرکز بر روی problem domain است و جلسات طراحی lower-level که در آن برنامه‌نویسان می‌خواهند یک قدم در جهت راه‌حل بردارند، خوب عمل می‌کند. در یک process modelling session، آن‌ها می‌توانند از مفاهیم domain و دانش در مورد process مورد نظر استفاده کرده و یک model مفید برای نرم‌افزار بر اساس design patterns که برای آن‌ها آشنا هستند، ایجاد کنند. شکل ?? را می‌توان به عنوان مرجعی برای چنین session استفاده کرد.</p>
<p>
<img alt="Figure 11.8. The picture that explains everything (copied with permission)." src="https://via.placeholder.com/300"/>
<figcaption>شکل 11.8. تصویری که همه چیز را توضیح می‌دهد (با اجازه کپی شده است).</figcaption>
</p>
<p>پس از سال‌ها توسعه نرم‌افزار، برای من این ایده بسیار انقلابی بود که کاربر را به عنوان کسی در نظر بگیرم که تحت تأثیر دنیای واقعی قرار می‌گیرد، به سیستم اجازه می‌دهد تا آن‌ها را از چیزی آگاه کند، و سپس بر اساس این اطلاعات تصمیم می‌گیرد. من متوجه شدم که بازیابی اطلاعات از یک system باید یک use case مهم در نظر گرفته شود، درست به اندازه یک use case که در آن کاربر تصمیم می‌گیرد کاری انجام دهد. من همچنین متوجه شدم که برای موفقیت در decoupling از infrastructure هر دو نوع use cases باید وجود داشته باشند</p>
<p><sup>3</sup>در Leanpub موجود است: https://advwebapparch.com/event-storming.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 298" src="page_0298/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0298_original/original_page.png" alt="Original Page 298">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>جایی در core code application.
        همانطور که در شکل ?? نشان داده شده است، در طول یک process modelling session شما commands، events، read models، effects و decisions (policies) را طراحی خواهید کرد. من شخصاً دوست دارم با زوم کردن بر روی آن کادر "System" یک قدم فراتر بروم. آنچه در داخل system اتفاق می‌افتد باید یک implementation detail باشد و برای process کلی مهم نیست. اما از آنجایی که ما برخی از design patterns های مفید، مانند application services و event subscribers را ایجاد کرده‌ایم، می‌توانیم آن elements را نیز به diagram اضافه کنیم. شکل 11.9 آنچه را که در داخل system است، نشان می‌دهد.</p>
<p>اگر دوست دارید، می‌توانید از یک process modelling session سازگار برای توصیف این elements نیز استفاده کنید.
        هنگامی که شما عناصر process را می‌شناسید، نحوه نامگذاری آن‌ها و نحوه تعامل آن‌ها را می‌دانید، همچنین یک ایده کلی در مورد نحوه پیاده‌سازی آن عناصر دارید، زیرا شما design patterns اساسی آن‌ها را می‌شناسید. بنابراین شما می‌توانید با ترس کمتر و شک و تردید کمتر کار بر روی implementation را شروع کنید. Implementing use cases بیشتر شبیه به دنبال کردن یک دستور غذا می‌شود. درک use cases
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 299" src="page_0299/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0299_original/original_page.png" alt="Original Page 299">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>implementation می‌شود.
        پیاده‌سازی آن‌ها توسط دیگران نیز آسان‌تر می‌شود، زیرا شما همان patterns را در کار آن‌ها تشخیص می‌دهید.
    </p>
<p>در نهایت، از آنجایی که این design patterns، با طراحی از infrastructure جدا شده‌اند، زمانی که شما شروع به مشخص کردن و تست کردن use cases خود با استفاده از scenarios می‌کنید، بسیار مفید خواهند بود. ما خواهیم دید که این در فصل 14 چگونه کار می‌کند.</p>
<h4><strong>11.8. Summary</strong></h4>
<p>در این فصل، ما نگاهی دقیق‌تر به برخی از design patterns که در قسمت اول کشف کردیم، داشتیم: entities, repositories, application services, read و view models, domain events و event subscribers. استفاده از این patterns در application شما به طور خودکار، جداسازی core و infrastructure code را آسان‌تر می‌کند. آن‌ها به شما اجازه می‌دهند تا تمام use cases application خود را به وضوح تعریف کنید، بدون اینکه هیچ گونه نگرانی زیرساختی را با هم ترکیب کنید. این use cases در کد توسط موارد زیر نشان داده می‌شوند:</p>
<ol>
<li>Application services، که یک entity را ایجاد یا دستکاری می‌کنند، آن را در repository entity ذخیره می‌کنند و domain events تولید شده توسط entity را dispatch می‌کنند.</li>
<li>View models، که یک representation مفید از داده‌های application ارائه می‌دهند.</li>
</ol>
<p>Event subscribers به عنوان یک bridge بین یک primary change و هر تعدادی از effects های مورد نظر آن change عمل می‌کنند.
        شما می‌توانید از این design patterns در یک process modelling session برای یافتن عناصری که برای ساخت نیاز دارید، استفاده کنید.
    </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0300_original/original_page.png" alt="Original Page 300">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>12. Architectural layers</strong></h3>
<p>این فصل موارد زیر را پوشش می‌دهد:</p>
<ul>
<li>The Domain, Application, و Infrastructure layer</li>
<li>The Dependency rule</li>
<li>استفاده از namespaces به عنوان راهی برای قابل مشاهده کردن layers</li>
<li>تأیید layer conventions با ابزارها</li>
</ul>
<h4><strong>12.1. MVC</strong></h4>
<p>Framework های وب اغلب چیزی شبیه به یک معماری "MVC" را برای web applications شما پیشنهاد می‌کنند. MVC مخفف Model View Controller است. بله، شما به هر یک از این موارد در یک web application معمولی نیاز دارید. شما به یک controller برای پردازش یک web request ورودی نیاز دارید و به یک view برای ارائه برخی اطلاعات به کاربر نیاز دارید. یک web framework خوب باید ابزارهای مناسبی برای انجام این کارها ارائه دهد. ممکن است راه‌های مناسبی برای استخراج data مربوطه از request ارائه دهد، ممکن است session را برای شما مدیریت کند، و ممکن است یک templating engine جالب ارائه دهد که render کردن HTML responses را آسان می‌کند.</p>
<p>این همه عالی است، و frameworks معمولاً در این کار عملکرد خوبی دارند. اما وقتی صحبت از جهش از controller به model می‌شود، احتمالاً اوضاع اشتباه پیش می‌رود. همانطور که در فصل 4 دیدیم، controllers در نهایت شامل تمام business logic برای یک use case داده شده می‌شوند، و model احتمالاً یک data holder ساده خواهد بود (به شکل 12.1 مراجعه کنید).</p>
<p>اغلب توسعه‌دهندگان به کاستی‌های این approach پی برده‌اند و شروع به انتقال business logic به services کرده‌اند. در چندین پروژه که تا کنون دیده‌ام</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0301_original/original_page.png" alt="Original Page 301">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
<img alt="Figure 12.1. Controllers contain all business logic and become too big. Mod-els are only simple data holders." src="https://via.placeholder.com/300"/>
<figcaption>شکل 12.1. Controllers شامل تمام business logic می‌شوند و بیش از حد بزرگ می‌شوند. Models فقط data holders ساده هستند.</figcaption>
</p>
<p>
        این حرکت چندان موفقیت‌آمیز نبوده است زیرا services استخراج شده، واقعاً از framework جدا نشده‌اند. آن‌ها هنوز به session یا current web request متکی هستند. methods در این services اغلب حول یک مفهوم domain خاص گروه‌بندی می‌شوند و سعی می‌کنند هم business logic و هم persistence logic را برای این مفهوم خاص مدیریت کنند. این services (گاهی اوقات حتی "managers" نامیده می‌شوند) سپس بیش از حد بزرگ می‌شوند و غیرقابل مدیریت می‌شوند. دلیل دیگر برای شکست در این زمینه این است که domain models هنوز هم data holders ساده باقی می‌مانند و نمی‌توانند از هیچ یک از invariants خود محافظت کنند، و نه هیچ قانون business را به تنهایی پیاده‌سازی کنند. این دوباره منجر به services می‌شود که کارهای زیادی برای انجام دادن دارند، و بیش از حد بزرگ می‌شوند که بتوانند با آن‌ها مقابله کنند (به شکل 12.2 مراجعه کنید). بنابراین دلیل شروع استفاده از services خوب است (ما نمی‌خواهیم controllers ما پر از business logic باشد)، اما معمولاً این implementation است که فاقد آن است. بدون decoupling service از framework، بدون جداسازی domain logic از persistence logic، و بدون برداشتن گام اضافی تعریف richer domain objects، نتیجه فاجعه‌بار خواهد بود.
    </p>
<p>بنابراین حتی پس از اختراع یک "service layer" اضافی، MVC هنوز هم کمبود دارد. به عنوان مثال، به ما کمک نمی‌کند تا یک use case را در یک primary action و effects های secondary آن جدا کنیم. Services معمولاً در نهایت methods بزرگی دارند که شروع به پردازش یک request می‌کنند و تمام tasks های secondary را در همان method انجام می‌دهند (یا اگر شما "خوش شانس" باشید، در methods خصوصی از همان class). این services ممکن است حتی به بخش‌های remote از code base دسترسی پیدا کنند تا کارهای مرتبط از راه دور را انجام دهند.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 302" src="page_0302/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0302_original/original_page.png" alt="Original Page 302">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
<img alt="Figure 12.2. Controllers are small, as they should be, but services become too big. Models are still simple data holders." src="https://via.placeholder.com/300"/>
<figcaption>شکل 12.2. Controllers کوچک هستند، همانطور که باید باشند، اما services بیش از حد بزرگ می‌شوند. Models هنوز هم data holders ساده هستند.</figcaption>
</p>
<p>در فصل قبل دیدیم که چگونه می‌توانیم این وضعیت را با اجازه دادن به یک application service برای برداشتن اولین قدم، سپس dispatch کردن events، که event subscribers می‌توانند با برداشتن گام‌های بیشتر به آن‌ها پاسخ دهند، بهبود بخشیم. اما MVC، با اضافه شدن service layer، نمی‌تواند در این مورد به ما کمک کند.</p>
<p>در این مرحله باید نتیجه بگیریم که MVC یک اصل سازمانی کافی برای web applications نیست. چیزهای زیادی وجود دارد که جایگاه طبیعی در دسته‌بندی‌های models، views و controllers ندارند.</p>
<h4><strong>12.2. A standard set of layers</strong></h4>
<p>در این فصل، من مجموعه‌ای از layers را پیشنهاد می‌کنم که شامل Domain, Application و Infrastructure layer است. آن‌ها دسته‌بندی‌های وسیعی را برای کد شما ارائه می‌دهند، و به شما کمک می‌کنند مکان مناسب را برای هر class در application خود پیدا کنید. همراه با The Dependency rule، آن‌ها حتی می‌توانند به شما کمک کنند تأیید کنید که به درستی core code را از infrastructure code جدا می‌کنید.</p>
<p>در فصل‌های قبل ما تمایزی بین core code و infrastructure code قائل شدیم. با توجه به مجموعه پیشنهادی از layers، infrastructure code به طور طبیعی</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 303" src="page_0303/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0303_original/original_page.png" alt="Original Page 303">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>به Infrastructure layer تعلق دارد. دو layer دیگر، Domain و Application، باید فقط شامل core code باشند (به شکل 12.3 مراجعه کنید).</p>
<p>
<img alt="Figure 12.3. The infrastructure layer contains infrastructure code, the do-main and application layer only core code." src="https://via.placeholder.com/300"/>
<figcaption>شکل 12.3. The infrastructure layer شامل infrastructure code است، the domain و application layer فقط core code را شامل می‌شود.</figcaption>
</p>
<h4><strong>12.2.1. The infrastructure layer</strong></h4>
<p>هر bit از infrastructure code که تا کنون با آن مواجه شده‌ایم، در نهایت در infrastructure layer قرار می‌گیرد. این شامل موارد زیر است:</p>
<ul>
<li>Web controllers</li>
<li>CLI commands</li>
<li>Write و read model repository implementations</li>
<li>Services که به سیستم‌های خارجی متصل می‌شوند، مانند یک API remote یا file system</li>
<li>Services که از زمان فعلی استفاده می‌کنند یا data تصادفی تولید می‌کنند</li>
</ul>
<p>اگر می‌خواهید تصمیم بگیرید که آیا کد به infrastructure layer تعلق دارد یا به یکی از layersهای دیگر، شما باید کد را با تعاریف ارائه شده در فصل 1 مقایسه کنید:</p>
<ol>
<li>Core code مستقیماً به سیستم‌های خارجی وابسته نیست، و نه به کدی که برای تعامل با یک نوع خاص از external system نوشته شده است، وابسته است.</li>
<li>Core code به یک environment خاص نیاز ندارد</li>
</ol>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 304" src="page_0304/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0304_original/original_page.png" alt="Original Page 304">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><center>12. Architectural layers</center></h3>
<p>
   برای اجرا، نیاز ندارد، همچنین وابستگی‌هایی ندارد که فقط برای اجرا در یک context خاص طراحی شده باشند.
  </p>
<p>
   و همانطور که می‌دانید: اگر کد، کد هسته نباشد، کد infrastructure است، و سپس
   باید به لایه infrastructure برود. اگر نمی‌خواهید که کد، کد infrastructure باشد، می‌توانید آن را با استفاده از هر یک از تکنیک‌های نشان داده شده در
   بخش اول refactor کنید. پس از انجام این کار، شما "مجاز" هستید که کد را به یکی از
   لایه‌های دیگر منتقل کنید.
  </p>
<h4><center>12.2.2. The application layer</center></h4>
<p>
   The application layer اولین لایه‌ای است که از کد infrastructure عاری است. این
   لایه شامل موارد زیر است:
  </p>
<ul>
<li>
    Application services/command handlers، و command DTOs
   </li>
<li>
    View model repository interfaces، و view model DTOs
   </li>
<li>
    Event subscribers که به domain events گوش می‌دهند و کارهای ثانویه را انجام
    می‌دهند
   </li>
<li>
    Interfaces برای infrastructure services
   </li>
</ul>
<p>
   با نگاهی به کلاس‌ها در the application layer باید بتوانید تشخیص دهید:
  </p>
<ul>
<li>
    چه کارهایی actors می‌توانند با application شما انجام دهند و چه داده‌هایی یک actor باید
    برای هر task ارائه دهد (که توسط application services و
    method parameters آنها نشان داده می‌شود، که می‌تواند command DTOs باشد).
   </li>
<li>
    یک actor می‌تواند از application شما چه چیزی یاد بگیرد (که توسط view
    model repository interfaces و view model objects نشان داده می‌شود).
   </li>
<li>
    چگونه موارد استفاده مختلف به یکدیگر متصل می‌شوند (که توسط
    event subscribers نشان داده می‌شود).
   </li>
<li>
    use cases شما به چه چیزهایی در دنیای بیرون بستگی دارد (که توسط
    interfaces برای infrastructure services نشان داده می‌شود).
   </li>
</ul>
<p>
   285
  </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0305_original/original_page.png" alt="Original Page 305">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h4><strong>12.2.3. The domain layer</strong></h4>
<p>The domain layer همچنین یک layer بدون هر گونه infrastructure code است. شامل موارد زیر است:</p>
<ul>
<li>Entities</li>
<li>Value objects</li>
<li>Domain events</li>
<li>Entity (write model) repository interfaces</li>
<li>Domain services</li>
</ul>
<p>این domain objects باید implementation details از application layer در نظر گرفته شوند. در واقع، بیشتر این جزئیات باید پشت application layer باقی بمانند. The infrastructure layer به طور کلی نباید نگران هیچ چیزی باشد که در domain layer در حال انجام است. Infrastructure code، مانند یک web controller، باید عمدتاً با data از نوع primitive (یا DTOهایی که حاوی data از نوع primitive هستند) سروکار داشته باشد، هنگامی که با application layer ارتباط برقرار می‌کند. The application layer از کد از domain layer برای انجام task خود استفاده می‌کند و در مورد rich domain objects که شامل می‌شود، اطلاعات خواهد داشت.</p>
<p>"آیا این extra subdivision از core code به Domain و Application code واقعاً ضروری است؟"</p>
<p>سوال عالی. به هر حال، بزرگترین برد از نظر testability و life expectancy application شما از جداسازی core از infrastructure code حاصل می‌شود. جداسازی بین application و domain code به شدت ضروری نیست و هیچ یک از این جنبه‌های کیفیتی را بهبود نمی‌بخشد. با این حال، من دوست دارم تمایز را حفظ کنم زیرا به من کمک می‌کند تا مشخص کنم use cases application من چیست. یک actor چه کاری می‌تواند با application انجام دهد؟ چه اطلاعاتی را می‌تواند از آن بازیابی کند؟ بدون یک application layer جداگانه، این موضوع فوراً مشخص نخواهد بود. خواننده entities را می‌بیند، اما نمی‌داند یک actor می‌تواند با آن‌ها چه کاری انجام دهد. آن‌ها یک repository را می‌بینند، اما نمی‌دانند که آیا اطلاعاتی که توسط آن ارائه می‌شود، در نهایت به یک کاربر ارائه می‌شود یا اینکه فقط برای استفاده داخلی است.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0306_original/original_page.png" alt="Original Page 306">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h4><strong>12.2.4. Up and down the layer stack</strong></h4>
<p>در بیشتر موارد، جریان داده‌ها از طریق این layers در یک application runtime به شرح زیر است (به شکل 12.4 مراجعه کنید):</p>
<ol>
<li>The web framework (infrastructure layer) یک HTTP request ورودی را می‌پذیرد.</li>
<li>
            request را تجزیه و تحلیل می‌کند و controller (infrastructure layer) مناسب را برای فراخوانی پیدا می‌کند.
        </li>
<li>
            controller یک DTO را بر اساس data از request ایجاد می‌کند و یک application service (application layer) را فراخوانی می‌کند.
        </li>
<li>
            application service یک entity را ایجاد یا اصلاح می‌کند (domain layer).
        </li>
<li>
            سپس application service، entity را به repository آن (infrastructure layer) تحویل می‌دهد تا آن را ذخیره کند.
        </li>
</ol>
<p>
<img alt="Figure 12.4. How data commonly flows through the layers." src="https://via.placeholder.com/300"/>
<figcaption>شکل 12.4. نحوه جریان معمول داده‌ها از طریق layers.</figcaption>
</p>
<p>بین جهت data در یک application و</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 307" src="page_0307/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0307_original/original_page.png" alt="Original Page 307">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>جهت وابستگی‌ها در کد است. به عنوان مثال، پیاده‌سازی repository از Infrastructure layer است. بنابراین وقتی یک application service یک entity را ذخیره می‌کند، داده‌ها از Application layer به Infrastructure layer جریان می‌یابند. اما کلاس application service به یک کلاس infrastructure وابسته نیست، بلکه به یک abstraction: the repository interface که در Domain layer قرار دارد، وابسته است/ شکل 12.5 diagram وابستگی حاصل را نشان می‌دهد.</p>
<p>
<img alt="Figure 12.5. A dependency diagram showing dependencies between layers." src="https://via.placeholder.com/300"/>
<figcaption>شکل 12.5. یک diagram dependency که وابستگی‌ها را بین layers نشان می‌دهد.</figcaption>
</p>
<h4><strong>12.3. The Dependency rule</strong></h4>
<p>برای وابستگی‌های در سطح class، ما اصل Dependency inversion<sup>1</sup> را داریم، که به ما می‌گوید به جای concretions، به abstractions وابسته باشیم. در فصل‌های قبل دیدیم که چگونه اعمال این اصل به ما کمک می‌کند تا core را از infrastructure code جدا کنیم. برای وابستگی‌های در سطح layer، ما The Dependency rule<sup>2</sup> را داریم. این قانون می‌گوید که "وابستگی‌های source code [بین layers] باید فقط به سمت داخل اشاره کنند". کلمه "inwards" به layer های رسم شده به عنوان concen اشاره دارد</p>
<p><sup>1</sup>Robert C. Martin, “Agile Software Development, Principles, Patterns, and Practices”, Prentice Hall (2003).
    </p>
<p><sup>2</sup>Robert C. Martin, “The Clean Architecture”, https://advwebapparch.com/clean-architecture</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 308" src="page_0308/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0308_original/original_page.png" alt="Original Page 308">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        در 12.5. استفاده کردیم، ما می‌توانیم ثابت کنیم که هیچ یک از dependencies به سمت داخل اشاره نمی‌کنند، بنابراین اگر dependency in-
        version را اعمال کنیم، the dependency rule نیز رعایت خواهد شد.
    </p>
<p>
<img alt="Figure 12.6. This modified dependency diagram using concentric circles
shows that dependencies only point inwards." src="https://via.placeholder.com/300"/>
<figcaption>شکل 12.6. این diagram dependency اصلاح شده با استفاده از دایره‌های متحدالمرکز نشان می‌دهد که dependencies فقط به سمت داخل اشاره می‌کنند.</figcaption>
</p>
<p>
        فلش‌های dependency فقط به سمت داخل اشاره می‌کنند: از Infrastructure به Application، از Application به Domain; هرگز به سمت دیگر. این یک ابزار طراحی عالی برای یک software architect مانند شما است، زیرا شما می‌توانید application خود را به انواع مختلفی از actors بدون تأثیر بر classes که در Application یا Domain layer قرار دارند، دوباره متصل کنید. اگر هیچ وابستگی به سمت بالا وجود نداشته باشد، این بدان معناست که ما می‌توانیم layers بالاتر را بدون تأثیر بر layers پایین‌تر بازنویسی یا جایگزین کنیم. این همچنین یک ابزار طراحی عالی برای یک software developer مانند شما است، زیرا تمام business logic نشان داده شده توسط Application و Domain layer را می‌توان به طور جداگانه از infrastructure اطراف آن تست کرد، تنها با جایگزینی چند infrastructure implementations با
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 309" src="page_0309/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0309_original/original_page.png" alt="Original Page 309">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>دوباره به test doubles سریع و قابل پیش‌بینی.</p>
<h4><strong>12.4. Making layers tangible</strong></h4>
<p>ما چیزها را در layers قرار داده‌ایم، ما یک dependency rule برای layers تعریف کرده‌ایم، اما ما هرگز واقعاً در مورد اینکه یک layer چیست، صحبت نکرده‌ایم. در واقع، شما می‌توانید بگویید یک layer هیچ چیز نیست. شما یک layer را در کد خود، و نه در application در حال اجرا خود، پیدا نخواهید کرد. این فقط یک راه برای گروه‌بندی چیزها است. ما می‌گوییم: این چیزها متعلق به این layer هستند، آن چیزها متعلق به layer دیگر هستند. اما هنگامی که ما این grouping را انجام دادیم، می‌توانیم properties مورد نظر این layers را بیان کنیم. به عنوان مثال: "این layer شامل هیچ infrastructure code نخواهد بود" یا "کد dependencies بین layers باید فقط به سمت داخل اشاره کند". به همین دلیل است که layering یک فعالیت architectural است. Layers یک راه high-level برای سازماندهی کد ما است و این روشی است که بر نحوه نوشتن کد ما تأثیر می‌گذارد.</p>
<h4><strong>12.4.1. Documenting the architecture</strong></h4>
<p>Layers به طور ذاتی esoteric هستند: ما نمی‌توانیم آن‌ها را در کد خود ببینیم. ما با آن‌ها کار می‌کنیم، تصمیمات را بر اساس آن‌ها می‌گیریم (چه چیزی را کجا قرار دهیم، چه چیزهایی می‌توانند به چیزهای دیگر وابسته باشند)، اما نمی‌توانیم آن‌ها را در code base خود نشان دهیم. این باعث می‌شود افرادی که به پروژه می‌پیوندند، سخت بتوانند بفهمند چه اتفاقی در حال رخ دادن است. The high-level design choices که ما در مورد architecture application خود می‌گیریم، انتخاب‌هایی هستند که ما باید منتقل کنیم. آن‌ها همچنین باید محافظت و تقویت شوند. اگر کسی از the dependency rule پیروی نکند، یا یک class را در layer اشتباه قرار دهد، یک code reviewer باید بتواند مشکل را بدون زحمت زیاد شناسایی کند. بهتر از این، همه اعضای تیم باید در مورد the layering system بدانند یا باید این فرصت را داشته باشند که در مورد آن اطلاعات کسب کنند. این بدان معناست که ما باید layers خود را قابل مشاهده و ملموس کنیم. البته، ما می‌توانیم یک صفحه مستندات در مورد آن بنویسیم و اعضای تیم را به آن ارجاع دهیم. اما این یک راه‌حل عملی نیست زیرا ما پاسخ‌های رضایت‌بخشی به این سؤالات نداریم:</p>
<ul>
<li>آیا همه واقعاً مستندات را می‌خوانند؟</li>
</ul>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0310_original/original_page.png" alt="Original Page 310">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<ul>
<li>آیا آن‌ها قادر خواهند بود آن را درک کنند و آن را در contributions خود اعمال کنند؟</li>
<li>چه کسی اطمینان حاصل می‌کند که مستندات در صورت نیاز update می‌شوند؟</li>
</ul>
<p>بهتر است system layering را جداگانه مستند نکنید. در عوض، اطمینان حاصل کنید که استفاده از layers از لحظه‌ای که شما اولین نگاه خود را به کد می‌اندازید، آشکار است.</p>
<h4><strong>12.4.2. Using namespaces for layering</strong></h4>
<p>Layers یک راه برای grouping چیزها هستند. آن چیزها عمدتاً classes هستند و classes می‌توانند در namespaces گروه‌بندی شوند. بنابراین استفاده از class namespaces به عنوان یک indicator برای حضور یک system layering، یک ایده خوب خواهد بود. به عنوان مثال، یک class Order در Domain namespace قرار می‌گیرد. The EbookOrderService class در Application namespace قرار می‌گیرد. The OrderRepositoryUsingSql class در Infrastructure namespace قرار می‌گیرد.</p>
<p>اگرچه یک راه‌حل خوب است، اما یک راه‌حل بسیار مقیاس‌پذیر نیست. با توجه به تعداد classes در هر namespace، ما باید یک subdivision در داخل هر layer namespace ایجاد کنیم.</p>
<p>برای شروع، Domain می‌تواند دو sub-namespaces داشته باشد، یعنی Model و Service. Model می‌تواند sub-namespaces را برای هر entity (یا در واقع، هر aggregate) داشته باشد (برای یک مثال به شکل 12.7 مراجعه کنید).</p>
<p>توجه داشته باشید که این فقط یک مثال است. این layout بر اساس کتاب "Implementing Domain-Driven Design"<sup>3</sup> نوشته Vaughn Vernon است و من نتایج خوبی از آن داشته‌ام. شما و تیمتان همیشه می‌توانید بر روی یک ساختار متفاوت توافق کنید.
        The Application namespace می‌تواند sub-namespaces را برای هر use case که پیاده‌سازی می‌کند، داشته باشد. شما می‌توانید عبارات واقعی را به عنوان نام برای هر use case ارائه دهید. اطمینان حاصل کنید که شامل use cases برای انجام tasks (به عنوان مثال CreateOrder) و همچنین use cases که در مورد بازیابی اطلاعات هستند (به عنوان مثال ListAvailableEbooks) نیز می‌شود.
    </p>
<p>در هر sub-namespace شما می‌توانید classes را که درگیر handling the use case هستند، مانند خود application service، command DTO، the</p>
<p><sup>3</sup>به فصل 4: Architecture، در Vaughn Vernon، "Implementing Domain-Driven Design"، Addison-Wesley Professional (2013) مراجعه کنید.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0311_original/original_page.png" alt="Original Page 311">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
<img alt="Figure 12.7. Subdividing the Domain namespace." src="https://via.placeholder.com/300"/>
<figcaption>شکل 12.7. Subdividing the Domain namespace.</figcaption>
</p>
<p>interface repository view model و view model object.</p>
<p>
<img alt="Figure 12.8. Subdividing the Application namespace." src="https://via.placeholder.com/300"/>
<figcaption>شکل 12.8. Subdividing the Application namespace.</figcaption>
</p>
<p>The Infrastructure namespace نیز به مقداری ساختار نیاز دارد. در آنجا ما می‌توانیم sub-namespaces را برای هر روشی که application به دنیای بیرون متصل است، داشته باشیم. ما در فصل 13 به این موضوع خواهیم پرداخت، که در پایان آن ما یک استاندارد کامل برای ساختاردهی داخلی هر layer خواهیم داشت.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 312" src="page_0312/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 312" src="page_0312/image_2.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0312_original/original_page.png" alt="Original Page 312">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h4><strong>12.4.3. Automated verification of design decisions</strong></h4>
<p>هنگامی که شما هر class را در یک namespace خاص قرار داده‌اید، می‌توانید شروع به تأیید این کنید که کد در واقع از layering conventions که ما ایجاد کرده‌ایم، پیروی می‌کند. به عنوان مثال، اگر شما یک entity را در Infrastructure layer پیدا کنید، در جای اشتباهی قرار دارد. این به Domain layer تعلق دارد. اگر Application layer حاوی یک class باشد که یک HTTP connection ایجاد می‌کند، شما می‌دانید که باید به جای آن به Infrastructure layer منتقل شود. همچنین، با نگاهی به source code dependencies بین classes مختلف، می‌توانید تأیید کنید که همه classes از The Dependency rule پیروی می‌کنند. به عنوان مثال، اگر شما یک class را در Domain layer پیدا کنید که از یک class از Infrastructure layer استفاده می‌کند، شما می‌دانید که Domain layer به Infrastructure layer وابسته است. این یک نقض از The Dependency rule است (به Listing 12.1 مراجعه کنید).</p>
<p>Listing 12.1. Based on the namespace و use statements of a class we can check if the code follows the layer conventions.</p>
<pre><code class="language-php">
namespace Infrastructure\Entity;
/*
 * An entity doesn't belong in the Infrastructure layer
 */
final class Order
{
    // ...
}
namespace Application\RegisterUser;
final class WelcomeEmail
{
    public function __construct(Client $httpClient)
    {
        /*
         * An HTTP client doesn't belong inside the
         * Application layer
         */
        $this-&gt;httpClient = $httpClient;
    }
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0313_original/original_page.png" alt="Original Page 313">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
}
namespace Domain\Service;
/*
 * A Domain class should not depend on a class from the
 * Infrastructure layer
 */
use Infrastructure\ExchangeRateProvider;
final class CurrencyConverter
{
    /**
     * @var ExchangeRateProvider
     */
    private $exchangeRateProvider;
    public function __construct(
        ExchangeRateProvider $exchangeRateProvider
    ) {
        $this-&gt;exchangeRateProvider = $exchangeRateProvider;
    }
}
</code></pre>
<p>انجام این کار، و ادامه دادن به بررسی آن برای هر تغییری که در آینده در code base ما ایجاد می‌شود، کار زیادی خواهد بود. با این حال، این کار از نظر تئوری می‌تواند خودکار شود. ما می‌توانیم به یک ابزار بگوییم که یک class در Domain, Application یا Infrastructure namespace باید در داخل layer مربوط به آن نام در نظر گرفته شود. سپس ابزار می‌تواند هر class را در پروژه اسکن کرده و statements 'namespace' و 'use' آن را تجزیه و تحلیل کند. بر اساس این اطلاعات، این ابزار می‌تواند یک warning را فعال کند اگر یک dependency بین layers در جهت اشتباهی قرار گیرد (به عنوان مثال از Domain به Infrastructure). اگر این ابزار همچنین به داخل کد نگاه کند، می‌تواند ما را در مورد استفاده از infrastructure code در داخل یک layer که قرار است فقط حاوی core code باشد، هشدار دهد (یعنی the Domain or Application layer).</p>
<p>تا آنجا که من می‌دانم، هیچ ابزاری وجود ندارد که بتواند بررسی "آیا این core code است یا infrastructure code" را انجام دهد، به این معنی که هیچ ابزاری برای تأیید اینکه کد در</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0314_original/original_page.png" alt="Original Page 314">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        correct layer.<sup>4</sup> با این حال، ابزاری وجود دارد که می‌تواند تأیید کند که کد از The Dependency rule پیروی می‌کند: deptrac<sup>5</sup> Listing 12.2 نشان می‌دهد که چگونه شما می‌توانید آن را پیکربندی کنید تا layering conventions را بر اساس namespaces تشخیص دهد. در زیر کلید ruleset، شما می‌توانید جهت‌های dependency مجاز بین layers را تعریف کنید.
    </p>
<p>Listing 12.2. Using this configuration deptrac can check if code follows the Dependency rule.</p>
<pre><code class="language-yaml">
paths:
    - ./src
layers:
    - name: Infrastructure
      collectors:
          - type: className
            regex: .*\\Infrastructure\\.*
    - name: Domain
      collectors:
          - type: className
            regex: .*\\Domain\\.*
    - name: Application
      collectors:
          - type: className
            regex: .*\\Application\\.*
ruleset:
    Infrastructure:
        - Application
        - Domain
    Application:
        - Domain
    Domain:
        # nothing
</code></pre>
<p>اجرای deptrac به عنوان بخشی از build پروژه شما می‌تواند به راحتی مشکلات layering را نشان دهد.</p>
<p><sup>4</sup>اگر در مورد چنین ابزاری اطلاع دارید، یا در حال ساخت آن هستید، لطفاً به من اطلاع دهید.
    </p>
<p><sup>5</sup>https://advwebapparch.com/deptrac</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0315_original/original_page.png" alt="Original Page 315">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h4><strong>12.5. Summary</strong></h4>
<p>در این فصل ما با بحثی در مورد معماری MVC برای web applications شروع کردیم و اینکه چگونه نمی‌تواند راهنمایی‌های لازم را در ساختاردهی application ما ارائه دهد. سپس من مجموعه‌ای از layers را پیشنهاد کردم که یک مکان طبیعی برای objects از همه types فراهم می‌کند:</p>
<ul>
<li>یک Domain layer، که عمدتاً شامل entities, value objects و domain events است.</li>
<li>یک Application layer، که شامل classes است که use cases application را نشان می‌دهند (یک actor چه کاری می‌تواند با آن انجام دهد و چه اطلاعاتی را می‌تواند از آن بازیابی کند).</li>
<li>یک Infrastructure layer، که شامل کد مورد نیاز برای اتصال application به primary و supporting actors آن است.</li>
</ul>
<p>ما The Dependency rule را مورد بحث قرار دادیم، که می‌گوید source code dependencies بین layers فقط می‌توانند به سمت داخل بروند.</p>
<p>با استفاده از namespaces می‌توانیم استفاده از layers را در خود code base قابل مشاهده کنیم. هنگامی که هر class یک namespace دارد که با یکی از layers های پیشنهادی مطابقت دارد، ما می‌توانیم به یک ابزار اجازه دهیم تا به طور خودکار تأیید کند که هر class از The Dependency rule پیروی می‌کند.</p>
<h4><strong>Exercises</strong></h4>
<p>1. The Dependency rule چه می‌گوید؟<sup>a</sup></p>
<ol>
<li>Services باید به abstractions وابسته باشند</li>
<li>Layersها باید فقط inward dependencies داشته باشند</li>
<li>Classesها باید برای extension باز و برای modification بسته باشند</li>
</ol>
<p>2. کدام یک از انواع classes زیر به Domain layer تعلق دارند؟<sup>b</sup></p>
<ol>
<li>Command DTO</li>
</ol>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0316_original/original_page.png" alt="Original Page 316">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>2. View model repository interface</p>
<p>3. Entity/write model repository interface</p>
<p>4. Entity</p>
<p>5. Application service</p>
<p>3. کدام یک از انواع classes زیر به Application layer تعلق دارند؟<sup>c</sup></p>
<ol>
<li>Application service</li>
<li>Service container</li>
<li>Symfony Console Application</li>
<li>View model repository implementation</li>
<li>View model repository interface</li>
</ol>
<p>4. کدام یک از انواع classes زیر به Infrastructure layer تعلق دارند؟<sup>d</sup></p>
<ol>
<li>Entity</li>
<li>Entity/write model repository implementation</li>
<li>Service container</li>
<li>Web controller</li>
<li>Command DTO</li>
</ol>
<p><sup>a</sup> پاسخ صحیح: 2. 1 بازنویسی اصل Dependency inversion است که در واقع به پیاده‌سازی 2، the Dependency rule کمک می‌کند. 3 اصل Open/Closed Principle است، که با این وجود بسیار مفید است.
    </p>
<p><sup>b</sup>3 و 4. سایر classes به Application layer تعلق دارند.
    </p>
<p><sup>c</sup> پاسخ صحیح: 1 و 5. سایر classes به Infrastructure layer تعلق دارند.
    </p>
<p><sup>d</sup> پاسخ صحیح: 2، 3 و 4. یک entity به Domain layer تعلق دارد، a Command DTO نوع پارامتر از یک application service است که به Application layer تعلق دارد.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0317_original/original_page.png" alt="Original Page 317">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>13. Ports and adapters</strong></h3>
<p>این فصل موارد زیر را پوشش می‌دهد:</p>
<ul>
<li>Hexagonal architecture</li>
<li>Ports and adapters</li>
<li>ساختاردهی the Infrastructure layer</li>
</ul>
<p>در فصل قبل، ما layers را به عنوان راهی برای گروه‌بندی انواع مختلف objects در یک application بررسی کردیم. در این فصل، ما به یک perspective متفاوت می‌پردازیم. ما به این نگاه می‌کنیم که چگونه یک application به دنیای بیرون متصل می‌شود و چگونه می‌توانیم آن اتصالات را به روشی منطقی گروه‌بندی کنیم. ما از ایده‌های Hexagonal architecture برای انجام این کار استفاده می‌کنیم.</p>
<h4><strong>13.1. Hexagonal architecture</strong></h4>
<p>Hexagonal architecture توسط Alistair Cockburn<sup>1</sup> ابداع شده است. Cockburn قصد این سبک معماری را به شرح زیر توصیف می‌کند:</p>
<p>به یک application اجازه دهید که به طور مساوی توسط کاربران، برنامه‌ها، automated test یا batch scripts هدایت شود، و اینکه در isolation از run-time devices و databases نهایی خود توسعه و تست شود.</p>
<p>من فکر می‌کنم این موضوع کاملاً روشن می‌کند که hexagonal architecture یک انتخاب نهایی مناسب است</p>
<p><sup>1</sup>در زمان نگارش، پست اصلی او آفلاین است، اما شما هنوز هم می‌توانید آن را در web archive https://advwebapparch.com/cockburn-hexagonal-architecture پیدا کنید. من همچنین تماشای ویدیوی سخنرانی او را در meetup DDD FR در پاریس، 2017 توصیه می‌کنم: https://advwebapparch.com/alistair-in-the-hexagone</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0318_original/original_page.png" alt="Original Page 318">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h4><strong>13. Ports and adapters</strong></h4>
<p>destination برای quest این کتاب از طراحی applications است که از infrastructure اطراف جدا شده‌اند.</p>
<p>یک نام جایگزین برای hexagonal architecture، Ports &amp; Adapters است. من فکر می‌کنم این نام در واقع بهتر است، زیرا ports و adapters مفاهیم اصلی هستند و تقریباً خود توضیحی هستند.</p>
<h4><strong>13.2. Ports</strong></h4>
<p>بیایید با مفهوم یک Port شروع کنیم، که فقط با استفاده از مفهوم یک Actor قابل توضیح است. در فصل 9 ما قبلاً در مورد actors و تمایز بین یک primary و یک secondary یا supporting actor صحبت کردیم، اما بیایید به سرعت تعاریف را در اینجا تکرار کنیم. A primary actor یک actor است که ابتکار عمل را برای communication بر عهده می‌گیرد. یک مثال از یک primary actor، کاربری است که از web page ما بازدید می‌کند، یا یک external system که با یکی از API endpoints ما صحبت می‌کند. هنگامی که application ما به یک external system، به عنوان مثال database یا یک mail server، دسترسی پیدا می‌کند، the external system باید یک secondary یا supporting actor در نظر گرفته شود.</p>
<p>با hexagonal architecture، تمام use cases، core code هستند و در داخل Hexagon زندگی می‌کنند. هر زمان که یک primary actor نیاز به فراخوانی یکی از use cases application داشته باشد، application باید یک Port برای آن تعریف کند. هر زمان که یک use case نیاز به برقراری ارتباط با یک supporting actor، مانند database داشته باشد، ما نیز باید یک Port برای آن تعریف کنیم. یک port، "intention of communication" است. به عنوان مثال: application ما ممکن است یک port "برای ایجاد یک order" داشته باشد که می‌تواند توسط primary actors برای ایجاد یک order استفاده شود. application ما همچنین یک port "برای ذخیره یک order" خواهد داشت که نشان می‌دهد application به یک supporting actor برای ذخیره orders نیاز دارد.</p>
<p>A port که توسط یک primary actor برای برقراری ارتباط با application ما استفاده می‌شود، می‌تواند یک Incoming port نامیده شود. A port که خود application ما از آن برای برقراری ارتباط با یک supporting actor استفاده می‌کند، می‌تواند یک Outgoing port نامیده شود. شکل 13.1 هگزاگون را با برخی از use cases از application e-book webshop ما نشان می‌دهد. هر طرف هگزاگون نشان‌دهنده یک port است. سمت چپ معمولاً برای incoming ports استفاده می‌شود، سمت راست برای outgoing ports.</p>
<p>Cockburn یک port را با یک interface برابر می‌داند. این روشی است که actors می‌توانند "in-</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0319_original/original_page.png" alt="Original Page 319">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
<img alt="Figure 13.1. A hexagon with some of its incoming and outgoing ports." src="https://via.placeholder.com/300"/>
<figcaption>شکل 13.1. یک هگزاگون با برخی از incoming و outgoing ports آن.</figcaption>
</p>
<p>terface" با application ما. هر port یک interface element مربوطه در داخل هگزاگون خواهد داشت. ما قبلاً port را برای ذخیره یک order دیده‌ایم (همانطور که یکی از outgoing ports در شکل 13.1 نامیده می‌شود): متد save() از OrderRepository (به Listing 13.1 مراجعه کنید).</p>
<p>Listing 13.1. The OrderRepository interface با port "for saving orders" از application مطابقت دارد.</p>
<pre><code class="language-php">
interface OrderRepository
{
    // ...
    public function save(Order $order): void;
}
</code></pre>
<p>یک port فقط intention of communication است. یک راه مفید برای یافتن کلمات خوب برای intention از یک port، تکمیل جمله "for ..." است. به عنوان مثال، فروشگاه e-book ما ports را "for listing the available e-books" دریافت می‌کند،</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 320" src="page_0320/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0320_original/original_page.png" alt="Original Page 320">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>“for creating an order” و “for saving an order”. برخی از توسعه‌دهندگانی که از hexagonal architecture استفاده می‌کنند، از این intentions به عنوان class یا method names واقعی در کد خود نیز استفاده می‌کنند، اما من شخصاً فکر می‌کنم استفاده از sentencesهای دستوری مانند "list available e-books"، "create order" و "save order" منطقی‌تر است.</p>
<p>یک هگزاگون با ports به تنهایی برای ساختن یک application کارآمد کافی نیست. A port فقط یک intention است، اکنون ما به یک implementation نیاز داریم. در اصطلاح Cockburn، implementation از یک port، یک Adapter نامیده می‌شود.</p>
<h4><strong>13.3. Adapters for outgoing ports</strong></h4>
<p>در مورد port خروجی "for saving an order"، adapter باید یک implementation برای interface OrderRepository ارائه دهد، که به نوعی database server برای persistence کردن entity Order می‌رسد. در فصل 2 ما قبلاً نمونه‌ای از چنین implementation را دیده‌ایم: class OrderRepositoryUsingSql (Listing 13.2). این به یک relational database متصل می‌شود و entity Order را در یک table orders ذخیره می‌کند، که properties از entity را به table columns نگاشت می‌کند.</p>
<p>Listing 13.2. The OrderRepositoryUsingSql یک implementation را برای port "for saving an order" ارائه می‌دهد.</p>
<pre><code class="language-php">
final class OrderRepositoryUsingSql implements OrderRepository
{
    private Connection $connection;
    public function __construct(Connection $connection)
    {
        $this-&gt;connection = $connection;
    }
    public function save(Order $order): void
    {
        // ...
    }
    // ...
}
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0321_original/original_page.png" alt="Original Page 321">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>یک adapter اغلب یک class واحد نیست. همه objects های همکار نیز باید بخشی از adapter در نظر گرفته شوند. به عنوان مثال، اگر پیاده‌سازی OrderRepository شما از Doctrine ORM برای ذخیره entity Order استفاده می‌کند، تمام Doctrine ORM باید بخشی از adapter در نظر گرفته شود. بدون آن، adapter به درستی کار نمی‌کند.</p>
<p>از آنجایی که یک outgoing port در کد شما توسط یک interface تعریف شده است، یک option طبیعی برای ارائه implementations جایگزین برای آن interface، یا از نظر hexagonal: ارائه یک adapter جایگزین برای port، وجود دارد. این همان چیزی است که hexagonal architecture در واقع به دنبال آن است: توانایی جایگزینی adapters به منظور آسان‌تر کردن testing از هگزاگون. یک implementation جایگزین برای OrderRepository که به‌طور خاص برای testing طراحی شده است، class InMemoryOrderRepository در Listing 13.3 خواهد بود. ما از آن در بخش 14.5 استفاده خواهیم کرد.</p>
<p>Listing 13.3. An in-memory implementation از OrderRepository.</p>
<pre><code class="language-php">
final class InMemoryOrderRepository implements OrderRepository
{
    /**
     * @var array&lt;string,Order&gt;
     */
    private array $orders = [];
    public function save(Order $order): void
    {
        $this-&gt;orders[$order-&gt;orderId()-&gt;asString()] = $order;
    }
    public function getById(OrderId $orderId): Order
    {
        if (!isset($this-&gt;orders[$orderId-&gt;asString()])) {
            throw new RuntimeException(
                'Could not find order with ID ' . $orderId-&gt;asString()
            );
        }
        return $this-&gt;orders[$orderId-&gt;asString()];
    }
}
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0322_original/original_page.png" alt="Original Page 322">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        شکل 13.2 diagram به روز شده را با دو adapter از port "for saving an order" نشان می‌دهد.
    </p>
<p>
<img alt="Figure 13.2. The hexagon with two adapters for the port “for saving an or-
der”." src="https://via.placeholder.com/300"/>
<figcaption>شکل 13.2. هگزاگون با دو adapter برای port "for saving an order".</figcaption>
</p>
<p>علاوه بر ارائه یک adapter جایگزین برای اهداف testing، ما همچنین می‌توانیم با technologies های جایگزین آزمایش کنیم. اگر می‌خواهید از یک relational database به یک document database مهاجرت کنید، می‌توانید همان interface OrderRepository را پیاده‌سازی کنید و ببینید که چگونه این کار بدون بازنویسی کل کد در داخل هگزاگون، کار می‌کند.
        برای نشان دادن اینکه two outgoing adapters (که گاهی اوقات "drivers" نامیده می‌شوند) کاملاً قابل تعویض هستند، شما باید یک contract test را برای port بنویسید. در چنین test شما مشخص می‌کنید که هر implementation از interface باید چگونه رفتار کند. سپس می‌توانید این test را در برابر هر یک از پیاده‌سازی‌هایی که دارید، اجرا کنید. ما یک مثال از یک contract test را در بخش 14.3 خواهیم دید.
    </p>
<h4><strong>13.4. Adapters for incoming ports</strong></h4>
<p>در سمت دیگر هگزاگون ports های incoming قرار دارند. این‌ها به منظور پذیرش پیام‌های ورودی از کاربران یا external systems هستند. آن‌ها به کدی نیاز دارند که این communication را تسهیل کند. در مورد port "for creating an order"، the web server باید request HTTP ورودی را بپذیرد، سپس آن را به PHP منتقل کند. PHP داده‌ها و context مربوطه را از request استخراج می‌کند و سپس web framework ما شروع به پردازش بیشتر آن می‌کند. در نهایت، آن یکی از</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 323" src="page_0323/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0323_original/original_page.png" alt="Original Page 323">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>controllers ما. تمام کدی که در پردازش request ورودی درگیر است، باید بخشی از adapter در نظر گرفته شود. در واقع، خود controller نیز بخشی از adapter است، زیرا controller به طور خاص برای HTTP com-
        munication طراحی شده است. از web-specific objects و services مانند request فعلی یا session کاربر استفاده می‌کند. به محض اینکه controller یک application service را فراخوانی می‌کند، ما از adapter خارج شده و وارد هگزاگون می‌شویم (به Listing 13.4 مراجعه کنید).</p>
<p>Listing 13.4. The controller is part of the adapter, the application service
        در داخل هگزاگون قرار دارد.
    </p>
<pre><code class="language-php">
final class OrderController
{
    private EbookOrderService $ebookOrderService;
    public function __construct(EbookOrderService $ebookOrderService)
    {
        $this-&gt;ebookOrderService = $ebookOrderService;
    }
    public function orderEbookAction(Request $request): Response
    {
        $orderId = $this-&gt;ebookOrderService-&gt;createOrder(
            CreateOrder::fromRequestData($request-&gt;request-&gt;all())
        );
        return new Response(/* ... */);
    }
}
</code></pre>
<p>این فقط تا زمانی درست است که خود application service واقعاً به طور کامل از مکانیزم تحویل و framework آن جدا شده باشد. باید امکان فراخوانی آن نه تنها از یک web controller، بلکه از یک CLI command handler نیز وجود داشته باشد، همانطور که در Listing 13.5 نشان داده شده است.</p>
<p>Listing 13.5. A CLI adapter از port برای ایجاد یک order.</p>
<pre><code class="language-php">
final class CreateOrderCommand extends Command
{
    private EbookOrderService $ebookOrderService;
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0324_original/original_page.png" alt="Original Page 324">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
public function __construct(EbookOrderService $ebookOrderService)
{
    $this-&gt;ebookOrderService = $ebookOrderService;
}
protected function execute(
    InputInterface $input,
    OutputInterface $output
): int {
    $orderId = $this-&gt;ebookOrderService-&gt;createOrder(
        new CreateOrder(
            (int)$input-&gt;getArgument('ebook_id'),
            (int)$input-&gt;getArgument('quantity'),
            $input-&gt;getArgument('email_address')
        )
    );
    $output-&gt;writeln(
        sprintf(
            '&lt;success&gt;Created a new order with ID %s',
            $orderId-&gt;asString()
        )
    );
    return 0;
}
</code></pre>
<p>این سطح از decoupling تضمین می‌کند که فراخوانی یک application service از یک test scenario، اساساً با فراخوانی آن از یک web controller متفاوت نیست. در واقع، خود کد تست باید به عنوان یک adapter در نظر گرفته شود، زیرا مستقیماً با port ارتباط برقرار می‌کند.
        شکل 13.3 هگزاگون را با چندین adapter از port "for creating an order" نشان می‌دهد.
    </p>
<p>ports های Incoming نشان‌دهنده intention یک actor برای تغییر چیزی در مورد state application یا ایجاد نوع دیگری از effect با آن هستند. یک intention دیگر می‌تواند بازیابی اطلاعاتی از application باشد.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0325_original/original_page.png" alt="Original Page 325">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
<img alt="Figure 13.3. The hexagon with three adapters of the port “for creating an
order”." src="https://via.placeholder.com/300"/>
<figcaption>شکل 13.3. هگزاگون با سه adapter از port "for creating an order".</figcaption>
</p>
<p>e-books در دسترس هستند. هر امکانی برای بازیابی اطلاعات از یک application نیز باید توسط یک port نشان داده شود. و باز هم، application باید حداقل یک adapter برای port ارائه دهد، تا communication با actor که می‌خواهد از اطلاعات استفاده کند را تسهیل کند. این باید در یک format خاص (HTML، JSON، CSV و غیره)، با استفاده از یک communication protocol خاص (HTTP، AMQP و غیره) ارائه شود.</p>
<p>به عنوان مثال، port "listing available e-books" از application ما می‌تواند توسط یک interface ListAvailableEbooksRepository و یک Ebook DTO که نشان‌دهنده هر e-book موجود است، نشان داده شود (به Listing 13.6 مراجعه کنید).</p>
<p>Listing 13.6. کدی که port "listing available e-books" را نشان می‌دهد.</p>
<pre><code class="language-php">
interface ListAvailableEbooksRepository
{
    /**
     * @return array&lt;Ebook&gt;
     */
    public function listAll(): array;
}
</code></pre>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 326" src="page_0326/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0326_original/original_page.png" alt="Original Page 326">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
final class Ebook
{
    private string $title;
    public function __construct(
        string $title
        // ...
    ) {
        $this-&gt;title = $title;
        // ...
    }
    public function title(): string
    {
        return $this-&gt;title;
    }
    // ...
}
</code></pre>
<p>به شرطی که یک implementation برای این interface وجود داشته باشد که بتواند e-book records را از database بازیابی کرده و یک list از object های Ebook را ایجاد کند، ما همچنین به یک controller نیاز داریم که بتواند آن objects را به فرمتی که یک actor می‌تواند با آن سروکار داشته باشد، تبدیل کند. بیایید فرض کنیم actor که به این اطلاعات نیاز دارد، یک application frontend JavaScript است. در این صورت، اگر adapter برای port “for listing available e-books” داده‌ها را از object های Ebook بگیرد و یک JSON response بر اساس آن تولید کند، مفید خواهد بود (به Listing 13.7 مراجعه کنید)</p>
<p>Listing 13.7. بخشی از adapter “for listing available e-books”.</p>
<pre><code class="language-php">
final class EbookController
{
    private ListAvailableEbooksRepository $ebooksRepository;
    public function __construct(
        ListAvailableEbooksRepository $ebooksRepository
    ) {
        $this-&gt;ebooksRepository = $ebooksRepository;
    }
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0327_original/original_page.png" alt="Original Page 327">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
public function listAvailableEbooksAction(): Response
{
    $ebooks = $this-&gt;ebooksRepository-&gt;listAll();
    return new JsonResponse(
        array_map(
            fn (Ebook $ebook) =&gt; [
                'title' =&gt; $ebook-&gt;title()
            ],
            $ebooks
        )
    );
}
</code></pre>
<p>علاوه بر ارائه یک JSON response، application ممکن است یک صفحه HTML منظم نیز ارائه دهد که یک لیست خوب از e-books را render کند. اگر این یک ویژگی مطلوب برای برخی از actors باشد، می‌تواند یک RSS feed از e-books را نیز ارائه دهد.
        هر مثال به یک adapter جداگانه از همان port "for listing available e-books" نیاز دارد.
    </p>
<h4><strong>13.5. The application as an interface</strong></h4>
<p>قبلاً گفتم که ports، interfaces هستند. برای outgoing ports مانند یکی "for saving an order" این فوراً منطقی است. هنگامی که شما می‌خواهید یک Order را ذخیره کنید، شما باید به خارج از application برسید و به یک database متصل شوید، بنابراین شما نمی‌توانید به یک class در آنجا وابسته باشید. شما به یک abstraction نیاز دارید. خود use case به port به عنوان یک interface تکیه خواهد کرد تا به هیچ implementation detail از adapter متصل نشود. برای تست کردن port adapter، ما مجبور نیستیم کل use case را فراخوانی کنیم. ما فقط باید متد save() را بر روی implementation OrderRepository فراخوانی کنیم.</p>
<p>برای یک incoming port مانند port "for creating an order" ممکن است فوراً مشخص نباشد که آیا به یک interface نیاز دارد یا خیر. و تا کنون یک interface نیز نبود. هم در web controller و هم در console command، ما مستقیماً به class concrete EbookOrderService وابسته بودیم. این بدان معناست که هنگامی که ما adapter port (به عنوان مثال در OrderController) را برای تست کردن آن، فراخوانی می‌کنیم، ما</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0328_original/original_page.png" alt="Original Page 328">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        همچنین the actual EbookOrderService را فراخوانی می‌کنیم، حتی اگر ما فقط به تست رفتار خود port adapter علاقه‌مند باشیم. برای جلوگیری از این کار، ما باید سعی کنیم EbookOrderService را با یک test double جایگزین کنیم. این در حال حاضر غیرممکن است زیرا EbookOrderService یک class final است که اجازه subclassing را نمی‌دهد. یک ضرورت هنگام ایجاد test doubles. یک راه‌حل سریع این است که class را non-final کنید تا بتوانید یک test-double برای آن ایجاد کنید، اما این برای من منطقی نیست. class قرار نیست گسترش یابد، بنابراین باید final<sup>2</sup> باقی بماند. یک راه‌حل بهتر این است که یک interface را برای port ورودی نیز تعریف کنیم. شما همیشه می‌توانید یک test-double برای یک interface ایجاد کنید، زیرا برای گسترش (در واقع: پیاده‌سازی) طراحی شده است. سوال این است: interface باید چگونه باشد؟ خوب، حداقل باید یک نسخه abstract از متد EbookOrderService::create() را شامل شود (به Listing 13.8 مراجعه کنید).
    </p>
<p>Listing 13.8. یک تلاش برای تعریف یک interface برای یک application service</p>
<pre><code class="language-php">
interface EbookOrderServiceInterface
{
    public function create(CreateOrder $command): OrderId;
}
final class EbookOrderService implements EbookOrderServiceInterface
{
    // ...
    public function create(CreateOrder $command): OrderId
    {
        // ...
    }
}
</code></pre>
<p>من فکر می‌کنم زمانی که شما همیشه مجبور باشید یک application service class و یک interface جداگانه که دقیقاً شبیه به class است، ایجاد کنید، بسیار آزاردهنده خواهد بود. بنابراین بیایید این راه را نرویم.</p>
<p>ما می‌توانیم یک راه‌حل عمومی‌تر با در نظر گرفتن تصویر بزرگتر پیدا کنیم. ما در تلاشیم تا incoming ports از هگزاگون خود را تعریف کنیم، بنابراین می‌توانیم فقط port adapters را بدون فراخوانی کد در داخل فراخوانی کنیم.</p>
<p><sup>2</sup>اطلاعات بیشتر در مورد علامت‌گذاری classes به عنوان final را در مقاله "Final classes by default, why?" بخوانید: https://advwebapparch.com/final-classes.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0329_original/original_page.png" alt="Original Page 329">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>hexagon. این بدان معناست که ما در تلاشیم تا یک abstraction را برای خود هگزاگون تعریف کنیم، که در واقع مجموعه‌ای از تمام use cases application ما است. این مجموعه از use cases می‌تواند به عنوان یک API واحد تعریف شود، که هم یک abstraction (port adapters نباید و نمی‌خواهند با آنچه در پشت صحنه می‌گذرد سروکار داشته باشند) و هم یک contract (port adapters به رفتارهای خاصی که توسط هگزاگون ارائه می‌شود، متکی هستند). ما می‌توانیم این API را به عنوان یک interface واحد تعریف کنیم و من فکر می‌کنم ما حتی ممکن است در اینجا suffix Interface را دریافت کنیم (همچنین به مقاله Mathias Verraes، "Sensible Interfaces" در https://advwebapparch.com/sensible-interfaces مراجعه کنید.) Listing 13.9 آنچه را که منظور من است، نشان می‌دهد.</p>
<p>Listing 13.9. The ApplicationInterface که API از application را تعریف می‌کند.</p>
<pre><code class="language-php">
interface ApplicationInterface
{
    public function createOrder(CreateOrder $command): OrderId;
    /**
     * @return array&lt;Ebook&gt;
     */
    public function listAvailableEbooks(): array;
    // ...
}
</code></pre>
<p>این ApplicationInterface تمام use cases را تعریف می‌کند که incoming port adapters ممکن است فراخوانی کنند. یک مزیت بزرگ این است که ApplicationInterface می‌تواند در هر controller که می‌خواهد یک use case را فراخوانی کند، استفاده شود (به Listing 13.10 مراجعه کنید).</p>
<p>Listing 13.10. Using the ApplicationInterface در یک controller.</p>
<pre><code class="language-php">
final class EbookController
{
    private ApplicationInterface $application;
    public function __construct(
        ApplicationInterface $application
    ) {
        $this-&gt;application = $application;
    }
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0330_original/original_page.png" alt="Original Page 330">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
public function listAvailableEbooksAction(): Response
{
    $ebooks = $this-&gt;application-&gt;listAvailableEbooks();
    return new JsonResponse(/* ... */);
}
</code></pre>
<pre><code class="language-php">
final class OrderController
{
    private ApplicationInterface $application;
    public function __construct(
        ApplicationInterface $application
    ) {
        $this-&gt;application = $application;
    }
    public function orderEbookAction(Request $request): Response
    {
        $orderId = $this-&gt;application-&gt;createOrder(
            CreateOrder::fromRequestData($request-&gt;request-&gt;all())
        );
        return new Response(/* ... */);
    }
}
</code></pre>
<p>اکنون که این port adapters به یک interface وابسته هستند، ما همچنین نیاز به ارائه یک implementation استاندارد داریم که می‌تواند TheActualApplication یا فقط Application نامیده شود. این class اساساً یک proxy برای services های موجود است، همانطور که در Listing 13.11 نشان داده شده است.</p>
<p>Listing 13.11. The standard implementation از ApplicationInterface.</p>
<pre><code class="language-php">
final class Application implements ApplicationInterface
{
    private EbookOrderService $ebookOrderService;
    private ListAvailableEbooksRepository $listAvailableEbooksRepository;
    public function __construct(
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0331_original/original_page.png" alt="Original Page 331">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
EbookOrderService $ebookOrderService,
        ListAvailableEbooksRepository $listAvailableEbooksRepository
    ) {
        $this-&gt;ebookOrderService = $ebookOrderService;
        $this-&gt;listAvailableEbooksRepository = $listAvailableEbooksRepository;
    }
    public function createOrder(CreateOrder $command): OrderId
    {
        return $this-&gt;ebookOrderService-&gt;createOrder($command);
    }
    public function listAvailableEbooks(): array
    {
        return $this-&gt;listAvailableEbooksRepository-&gt;listAll();
    }
}
</code></pre>
<p>اندازه این class ممکن است به سرعت از کنترل خارج شود و ما باید این را به عنوان design feedback در نظر بگیریم. شاید application شروع به انجام کارهای زیادی می‌کند و شما نیاز دارید آن را به modules تقسیم کنید. یک option دیگر این است که pattern Command bus را امتحان کنید. ایده این است که یک interface عمومی داشته باشیم، شما می‌توانید آن را CommandBus بنامید، که یک متد واحد دارد: handle(). این یک command object بدون نوع را می‌پذیرد، نوع command object را بررسی می‌کند و از آن برای یافتن یک service استفاده می‌کند که می‌تواند command را "handle" کند. معمولاً نوعی mapping از command class به service class وجود دارد. Listing 13.12 نشان می‌دهد که چگونه این می‌تواند کار کند.</p>
<p>Listing 13.12. A simple command bus برای application ما.</p>
<pre><code class="language-php">
interface CommandBus
{
    /**
     * @return mixed
     */
    public function handle(object $command);
}
final class HardWiredCommandBus implements CommandBus
{
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0332_original/original_page.png" alt="Original Page 332">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
private EbookOrderService $ebookOrderService;
    public function __construct(EbookOrderService $ebookOrderService)
    {
        $this-&gt;ebookOrderService = $ebookOrderService;
    }
    public function handle(object $command)
    {
        if ($command instanceof CreateOrder) {
            return $this-&gt;ebookOrderService-&gt;create($command);
        } elseif ($command instanceof /* ... */) {
            // and so on...
        }
        throw new RuntimeException(
            'Unknown command type: ' . get_class($command)
        );
    }
}
</code></pre>
<p>به Listing 13.13 برای controller اصلاح شده که اکنون از CommandBus interface استفاده می‌کند، مراجعه کنید.</p>
<p>Listing 13.13. The controller uses the CommandBus.</p>
<pre><code class="language-php">
final class OrderController
{
    private CommandBus $commandBus;
    public function __construct(
        CommandBus $commandBus
    ) {
        $this-&gt;commandBus = $commandBus;
    }
    public function orderEbookAction(Request $request): Response
    {
        $orderId = $this-&gt;commandBus-&gt;handle(
            CreateOrder::fromRequestData($request-&gt;request-&gt;all())
        );
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0333_original/original_page.png" alt="Original Page 333">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
return new Response(/* ... */);
}
</code></pre>
<p>ما مجبور نیستیم خودمان را به handling commands محدود کنیم. The “command” bus می‌تواند queriesهایی مانند listAvailableEbooks() را نیز handle کند. شاید در آن صورت باید فقط "bus" یا "message bus" نامیده شود.</p>
<p>The downside از استفاده از یک interface عمومی مانند CommandBus این است که ما the parameter و return types را که در Application-
        Interface خاص‌تر داریم، از دست می‌دهیم. اما وقتی صحبت از testing می‌شود، CommandBus همان مزیت را دارد که ApplicationInterface. همچنین این یک چیز واحد است که شما می‌توانید هنگام تست کردن incoming port adapters بدون فراخوانی کد در داخل هگزاگون، جایگزین کنید.</p>
<p>اکنون که ما interfaces را برای هر دو ports های incoming و outgoing داریم، و برخی از نمونه‌های هر دو incoming و outgoing port adapters را دیده‌ایم، روشن است که رابطه بین port و adapter در هر دو مورد متقارن نیست. برای outgoing ports، application (یا هگزاگون) شامل یک interface (OrderRepository, VatRateProvider) است که adapter باید یک implementation را با پیاده‌سازی interface ارائه دهد. برای incoming ports، application همچنین شامل یک interface (به عنوان مثال ApplicationInterface| یا CommandBus) است اما adapters این interface را پیاده‌سازی نمی‌کنند، بلکه از آن استفاده می‌کنند.</p>
<h4><strong>13.6. Combining ports and adapters with layers</strong></h4>
<p>در فصل 12 ما یک system layering را برای applications معرفی کردیم، که شامل یک Domain, Application و Infrastructure layer است. Hexagonal architecture با یک معماری لایه‌ای متعامد است. این بدان معناست که شما می‌توانید hexagonal architecture، یک معماری لایه‌ای، یا هر دو را اعمال کنید. هیچ کدام دیگری را القا نمی‌کنند. با این حال، آن‌ها ریشه یکسانی دارند: تمایل به جداسازی pure use cases از infrastructural concerns. به همین دلیل است که من فکر می‌کنم آن‌ها با هم خوب هستند.</p>
<p>یک application می‌تواند layers داشته باشد و در عین حال ports و adapters را به صراحت تعریف کند. شکل 13.4 نشان می‌دهد که چگونه layers، ports و adapters می‌توانند ترکیب شوند. هگزاگون داخلی شامل use cases application است که تقسیم شده است</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0334_original/original_page.png" alt="Original Page 334">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>به یک Application و Domain layer. در اطراف هگزاگون چیزی است که شما می‌توانید Outer hexagon نامید. این با Infrastructure layer همانطور که ما می‌دانیم مطابقت دارد. این شامل adapters برای ports از هگزاگون داخلی است، که به طور موثر امکان برقراری ارتباط بین هگزاگون داخلی و دنیای بیرون را فراهم می‌کند.</p>
<p>
<img alt="Figure 13.4. Layers, ports, and adapters combined." src="https://via.placeholder.com/300"/>
<figcaption>شکل 13.4. Layers، ports و adapters با هم ترکیب شده‌اند.</figcaption>
</p>
<h4><strong>13.7. Structuring the Infrastructure layer</strong></h4>
<p>در بخش 12.4.2 ما راهی برای تقسیم namespaces های Domain و Application و جلوگیری از تبدیل شدن این namespaces به کیسه‌های بزرگ از classes، پیدا کردیم. یک ریسک مشابه در مورد Infrastructure namespace وجود دارد، اگرچه من متوجه می‌شوم که در عمل اغلب یک مشکل بزرگ نیست. من اغلب خود را در حال مرور دایرکتوری Infrastructure نمی‌بینم. اگر نیاز به تغییر چیزی در مورد برخی از adapter code داشته باشم، معمولاً روی خود use case کار می‌کنم، به این معنی که من به کدی در Application یا Domain نگاه می‌کنم. به عنوان مثال، وقتی به یک application service یا یک repository interface نگاه می‌کنم، می‌توانم از عملکرد "Find usages" یا "Find implementations" از IDE استفاده کنم و سریعاً</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 335" src="page_0335/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0335_original/original_page.png" alt="Original Page 335">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>به code infrastructure مربوطه، jump کنید. با این حال، اغلب یک ایده خوب است که حداقل نوعی subdivision را در داخل Infrastructure namespace ایجاد کنید.
        اگر شما classes های متعددی دارید که مربوط به یک adapter واحد هستند، شما می‌توانید آن‌ها را در یک sub-namespace از Infrastructure گروه‌بندی کنید، درست همانطور که زمانی که یک use case به multiple classes وابسته است، این کار را انجام می‌دهید. اگر شما multiple adapters دارید که همگی از یک فناوری (framework، library، communication protocol و غیره) استفاده می‌کنند، شما همچنین می‌توانید آن‌ها را در یک sub-namespace از Infrastructure گروه‌بندی کنید. این مزیت اضافی را دارد که به خوانندگان کد یک overview واضح از راه‌هایی که این application به external systems متصل می‌شود، می‌دهد. چیزی که یک code base متوسط قادر به انجام آن نیست. شکل ?? چندین نمونه از classes در Infrastructure و sub-namespaces آن را نشان می‌دهد.
    </p>
<p>
<img alt="Figure 13.5. Sub-namespaces of the Infrastructure namespace." src="https://via.placeholder.com/300"/>
<figcaption>شکل 13.5. Sub-namespaces از Infrastructure namespace.</figcaption>
</p>
<p>گاهی اوقات sub-namespaces از Infrastructure به نظر می‌رسند که می‌توانند به یک package مناسب استخراج شوند. به عنوان مثال، classes های VatApiDotCom در شکل ?? یک client HTTP مستقل برای vatapi.com را تشکیل می‌دهند و همچنین ممکن است استخراج شوند. اگر کد مختص پروژه نیست، شما ممکن است حتی library را به صورت عمومی قابل دسترسی کنید.
        چیز دیگری که ممکن است در Infrastructure namespace اتفاق بیفتد، the
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 336" src="page_0336/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0336_original/original_page.png" alt="Original Page 336">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>accumulation از shared code. به عنوان مثال، اگر شما یک mapping utility دارید که توسط تمام repositories های SQL استفاده می‌شود، می‌توانید آن را آزادانه به sub-namespace Sql اضافه کنید. اگر بیشتر شبیه به یک utility عمومی است که می‌تواند توسط هر class در Infrastructure استفاده شود، شما همچنین می‌توانید یک sub-namespace عمومی برای آن ایجاد کنید (به عنوان مثال Shared یا Common). The advice در مورد shared code همیشه این است که آن را به حداقل برسانید. اگر شما مراقب آن نباشید، به سرعت رشد خواهد کرد تا اینکه همه چیز به "shared code" ختم شود.</p>
<h4><strong>13.8. Summary</strong></h4>
<p>در این فصل ما در مورد Hexagonal architecture بحث کردیم. این approach به application architecture یک تمایز واضح بین pure application use cases و نحوه اتصال آن‌ها به actors که آن‌ها را فراخوانی می‌کنند یا توسط آن‌ها فراخوانی می‌شوند، ایجاد می‌کند. ما با شناخت ports از یک application شروع می‌کنیم، که intentions of communication بین actors و application ما هستند. Ports، interfaces هستند و به همین ترتیب در کد نشان داده می‌شوند. برای هر port، ما به حداقل یک adapter نیاز داریم که communication واقعی را تسهیل می‌کند و از implementation details آن مراقبت می‌کند.
        Hexagonal architecture به خوبی با the layering system که در فصل قبل بررسی کردیم، مطابقت دارد. از نظر layers، هگزاگون داخلی از Domain و Application layer تشکیل شده است که با هم ترکیب شده‌اند. این layers شامل interfaces و application services است که ports از application را نشان می‌دهند. هگزاگون خارجی شامل Infrastructure layer است. این layer شامل port adapters است.
        با دانستن در مورد ports و adapters، ما می‌توانیم classes را در Infrastructure layer سازماندهی مجدد کنیم. به عنوان مثال، ما می‌توانیم classes را بر اساس نوع actor یا فناوری مورد استفاده، گروه‌بندی کنیم.
    </p>
<h4><strong>Exercises</strong></h4>
<p>1. در hexagonal architecture یک Port است:<sup>a</sup></p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0337_original/original_page.png" alt="Original Page 337">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>1. An intention of communication</p>
<p>2. An implementation of communication</p>
<p>2. در hexagonal architecture یک Adapter است:<sup>b</sup></p>
<ol>
<li>An intention of communication</li>
<li>An implementation of communication</li>
</ol>
<p>3. یک database است:<sup>c</sup></p>
<ol>
<li>Primary actor</li>
<li>Secondary/supporting actor</li>
</ol>
<p>4. A user است:<sup>d</sup></p>
<ol>
<li>Primary actor</li>
<li>Secondary/supporting actor</li>
</ol>
<p>5. آیا همه ports باید توسط یک interface تعریف شوند؟<sup>e</sup></p>
<ol>
<li>بله، همه ports باید یک interface داشته باشند.</li>
<li>خیر، فقط outgoing ports باید یک interface داشته باشند.</li>
</ol>
<p><sup>a</sup> پاسخ صحیح: 1.
    </p>
<p><sup>b</sup> پاسخ صحیح: 2.
    </p>
<p><sup>c</sup> پاسخ صحیح: 2.
    </p>
<p><sup>d</sup> پاسخ صحیح: 1.
    </p>
<p><sup>e</sup> پاسخ صحیح: 1. فقط در صورتی که تمام ports به عنوان interfaces تعریف شوند، امکان تست کردن port adapters بدون فراخوانی کد در داخل هگزاگون وجود خواهد داشت.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0338_original/original_page.png" alt="Original Page 338">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>14. A testing strategy for decoupled applications</strong></h3>
<p>این فصل موارد زیر را پوشش می‌دهد:</p>
<ul>
<li>انواع مختلف تست‌ها و نحوه پوشش دادن آن‌ها به تمام بخش‌های application</li>
<li>یک development workflow برای applications های decoupled</li>
</ul>
<p>چرا ما می‌خواستیم از infrastructure جدا شویم؟ زیرا این به ما اجازه می‌دهد تا به جای جزئیات implementation low-level، بر use cases high-level application تمرکز کنیم. زیرا این هسته application را قادر می‌سازد تا از انواع تغییرات بی‌ربط در محیط اطراف جان سالم به در ببرد. و به این دلیل که کد زیادی به ما می‌دهد که به طور پیش‌فرض قابل تست است. در این فصل، من می‌خواهم نگاهی دقیق‌تر به این جنبه داشته باشم: testability. و من می‌خواهم یک outline برای پاسخ به این سوال ارائه دهم: چه چیزی باید تست شود و چگونه باید آن را تست کنیم؟</p>
<p>Test terminology همیشه یک مشکل برای توسعه‌دهندگانی بوده است که در مورد تست صحبت می‌کنند و می‌نویسند. termsهایی که من در این فصل برای انواع مختلف تست‌ها استفاده می‌کنم، ممکن است termsهای استانداردی نباشند. اما من فکر می‌کنم که آن‌ها در context این کتاب مناسب هستند.</p>
<h4><strong>14.1. Unit tests</strong></h4>
<p>ساده‌ترین نوع تست، یک unit test است. این نام برای چنین test ساده‌ای کاملاً مشکل‌ساز است زیرا واقعاً مشخص نیست که "unit" چیست یا چقدر باید بزرگ باشد</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0339_original/original_page.png" alt="Original Page 339">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>باشند. یک unit می‌تواند یک function یا یک متد باشد، شاید یک class واحد، یا یک class و تمام classes که مستقیماً به آن متکی است. من فکر نمی‌کنم یک unit test باید روی هیچ یک از این موارد تمرکز کند. من می‌خواهم یک unit test رفتار یک object را تست کند. من نگران این نیستم که کدام classes در تست رفتار این object دخیل هستند. بنابراین من تست‌های unit خود را با annotations @covers نیز حاشیه‌نویسی نمی‌کنم. برای من این در مورد نحوه رفتار object است، اینکه کدام classes درگیر هستند تا حدودی بی‌ربط است.</p>
<p>نوشتن یک unit test، راهی برای بزرگنمایی بر روی رفتار برخی از عناصر کوچکتر system است. این تست‌ها، توسعه را با اجازه دادن به توسعه‌دهنده برای مشخص کردن رفتار عناصر کوچکتر، پشتیبانی می‌کنند و به آن‌ها اجازه می‌دهند در هنگام تست عناصر بزرگتر، برخی از آن رفتارها را نادیده بگیرند (به بخش 14.5 مراجعه کنید). بنابراین نوشتن unit tests می‌تواند به شما یک حس امنیت پیوسته و فزاینده بدهد. اگر building blocks استفاده از آن ایمن است، در این صورت شما مجبور نیستید نگران تمام جزئیات باشید، هنگامی که شما شروع به استفاده از blocks برای ساخت structures های بزرگتر می‌کنید.</p>
<p>در بیشتر پروژه‌هایی که تاکنون با آن‌ها مواجه شده‌ام، مشکلی در مورد unit test suite وجود دارد. تست‌های موجود در آن، همه unit tests نیستند. نه به این دلیل که unit بیش از حد بزرگ است، بلکه به این دلیل که تست‌ها به اندازه کافی ایزوله نیستند. آنچه این بدان معناست، به خوبی توسط Michael Feathers در تعریف خود از یک unit test<sup>1</sup> شرح داده شده است:</p>
<p>یک test، اگر موارد زیر را داشته باشد، یک unit test نیست:</p>
<ol>
<li>
            به database صحبت می‌کند
        </li>
<li>
            در سراسر network ارتباط برقرار می‌کند
        </li>
<li>
            به file system دست می‌زند
        </li>
<li>
            نمی‌تواند همزمان با هر یک از unit testsهای دیگر شما اجرا شود
        </li>
<li>
            شما باید کارهای خاصی را در environment خود انجام دهید (مانند
            ویرایش فایل‌های config) تا آن را اجرا کنید.
        </li>
</ol>
<p>اگر شما قسمت اول را خوانده‌اید، می‌دانید که سه مورد اول فقط بخشی از آنچه را که می‌توان "infrastructure" concerns در نظر گرفت، منعکس می‌کند. علاوه بر این، ما همچنین کدی را در نظر گرفته‌ایم که با the system clock یا the sys-</p>
<p><sup>1</sup>Michael Feathers, “A Set of Unit Testing Rules” (2005): https://advwebapparch.com/unit-test-definition</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0340_original/original_page.png" alt="Original Page 340">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>همچنین the system’s random device، to be infrastructure code. موارد 4 و 5 با کشف ما مطابقت دارند که کدی که به state سراسری یا statically accessible service و configuration locators متکی است، نباید core code در نظر گرفته شود. برای اجرا به setup خاصی نیاز دارد. بنابراین من فکر می‌کنم منطقی است که تعریف Feathers را تعمیم دهیم و بگوییم که:</p>
<p>یک test، یک unit test نیست اگر infrastructure code را فراخوانی کند.</p>
<p>این مطمئناً برای بسیاری از تست‌هایی که توسعه‌دهندگان "unit tests" می‌نامند، درست نیست. سردرگمی از این واقعیت ناشی می‌شود که unit tests و non-unit tests هر دو می‌توانند توسط PHPUnit اجرا شوند. test framework دارای "unit" در نام خود است، بنابراین تمام تست‌هایی که این framework اجرا می‌کند، معمولاً "unit tests" نامیده می‌شوند. اما خود test framework نمی‌تواند تضمین کند که تست‌هایی که شما می‌نویسید و اجرا می‌کنید، unit tests واقعی هستند. بنابراین یک بار دیگر، این مسئولیت شما خواهد بود که فقط core code را در یک unit test فراخوانی کنید. ممکن است کمک کند تا unit tests واقعی را "isolated tests" بنامیم و تست‌هایی را که infrastructure code را فراخوانی می‌کنند، به یک test suite متفاوت به نام "integration tests" منتقل کنیم (همچنین به بخش 14.2 مراجعه کنید).</p>
<p>در پروژه‌های من، من معمولاً فقط isolated tests را برای برخی از building blocks های کوچکتر مانند entities و value objects می‌نویسم. این domain objects کاندیداهای عالی برای isolated tests هستند زیرا آن‌ها باید از انواع domain invariants محافظت کنند، که همه شایسته تست جداگانه هستند. مناسب است که این invariantsها را نزدیک به object که از آن‌ها محافظت می‌کند، تست کنید، به جای تست‌های high-level. من برای objects که changes را در domain objects، مانند application services, event subscribers و repositories هماهنگ می‌کنند، unit tests نمی‌نویسم.
        این‌ها با Use case tests (بخش 14.5) و Adapter tests (بخش 14.2) تست می‌شوند.
    </p>
<p>Listing 14.1 چندین نمونه از unit tests برای entity Order را نشان می‌دهد. من سعی می‌کنم methods های تست را واقعاً کوچک نگه دارم. در حالت ایده‌آل، هر متد شامل سه statement است. هر جا که بتوانم از methods factory مانند aPaidOrder() استفاده می‌کنم. The method name می‌تواند برای توصیف آنچه در مورد object که برمی‌گرداند، خاص است، استفاده شود. این درک این را آسان‌تر می‌کند که test سعی می‌کند چه چیزی را ثابت کند.</p>
<p>Listing 14.1. Examples از unit tests برای یک entity.</p>
<pre><code class="language-php">
use PHPUnit\Framework\TestCase;
final class OrderTest extends TestCase
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0341_original/original_page.png" alt="Original Page 341">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
{
    // ...
    /**
     * @test
     */
    public function it_cant_be_cancelled_if_it_has_already_been_paid(): void
    {
        $order = $this-&gt;aPaidOrder();
        $this-&gt;expectException(CouldNotCancelOrder::class);
        $order-&gt;cancel();
    }
    // ...
    /**
     * @test
     */
    public function you_can_modify_the_external_reference(): void
    {
        $order = $this-&gt;aNewOrder();
        $order-&gt;setPaymentReference('ABC123');
        self::assertArrayContainsObjectOfType(
            ExternalReferenceWasModified::class,
            $order-&gt;releaseEvents()
        );
    }
    // ...
}
</code></pre>
<p>value objects نیز کاندیداهای خوبی برای unit-testing هستند. طبق تعریف آن‌ها objects های immutable بدون side-effects هستند. Listing 14.2 نمونه‌هایی را نشان می‌دهد.</p>
<p>Listing 14.2. Unit-testing یک value object</p>
<pre><code class="language-php">
use PHPUnit\Framework\TestCase;
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0342_original/original_page.png" alt="Original Page 342">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
final class UrlTest extends TestCase
{
    /**
     * @test
     */
    public function it_can_be_created_from_and_converted_back_to_a_string(): void
    {
        $string = 'https://matthiasnoback.nl';
        self::assertEquals(
            $string,
            Url::fromString($string)-&gt;asString()
        );
    }
    /**
     * @test
     */
    public function it_can_extract_the_top_level_domain(): void
    {
        self::assertEquals(
            'nl',
            Url::fromString('https://matthiasnoback.nl')-&gt;tld()
        );
    }
    // ...
}
</code></pre>
<h4><strong>14.2. Adapter tests</strong></h4>
<p>ما قبلاً تعیین کردیم که شما نمی‌توانید infrastructure code را unit-test کنید. اما شما هنوز هم می‌خواهید آن را به نوعی تست کنید، بنابراین ما می‌توانیم از چه نوع تستی برای infrastructure code استفاده کنیم؟ Infrastructure tests اغلب integration tests یا integrated tests نامیده می‌شوند. این تست‌ها نشان می‌دهند که infrastructure code شامل third-party code به درستی با external actors ادغام می‌شود. در فصل 13 ما از یک نام دیگر برای کدی که با external actors ادغام می‌شود استفاده کردیم: "port adapters" یا</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0343_original/original_page.png" alt="Original Page 343">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>فقط "adapters". به همین دلیل است که برای من منطقی است که این تست‌ها را Adapter tests بنامم. آن‌ها ثابت می‌کنند که یک adapter به درستی کار می‌کند. از آنجایی که دو نوع port وجود دارد، incoming و outgoing، جای تعجب نیست که دو نوع تست adapter نیز وجود دارد.</p>
<h4><strong>14.3. Contract tests for outgoing port adapters</strong></h4>
<p>Outgoing ports، ports هایی هستند که در آن application نیاز به ارتباط با برخی از external system ها، مانند یک database یا یک webservice remote دارد. Outgoing ports با interfaces جداگانه، مانند OrderRepository که می‌تواند یک entity را ذخیره کند، و VatRateProvider که ما قبلاً برای تعیین VatRate یک محصول استفاده کردیم، تعریف می‌شوند. این interfaces به عنوان یک abstraction معرفی شدند که به ما اجازه می‌داد تا core code را از infrastructure code جدا کنیم.
        The interface، communication با external system را با یک implementation fake آسان می‌کند که ما می‌توانیم در تست‌های use case خود از آن استفاده کنیم (به بخش 14.5 مراجعه کنید). اما interface همچنین یک contract را تعریف می‌کند که همه چیزهایی را که ما از یک implementation می‌خواهیم، توصیف می‌کند. The contract برای OrderRepository این است که می‌تواند یک entity Order را ذخیره کند و اگر شما متد getById() آن را فراخوانی کنید، شما می‌توانید یک object معادل را از آن دریافت کنید. این مفید است که contract را به وضوح مشخص و مستند کنید، زیرا خود interface نمی‌تواند این موارد را منتقل کند. تنها چیزی که می‌توان در مورد خود آن توصیف کرد، متدهایی است که دارد، return types آن‌ها و parameter types آن‌ها. یک option این است که رفتار را با استفاده از مستندات درون خطی مستند کنید، اما در واقع استفاده از یک contract test برای توصیف contract قدرتمندتر است. Listing 14.3 نشان می‌دهد که این چگونه به نظر می‌رسد.</p>
<p>Listing 14.3. بخشی از contract test برای OrderRepository.</p>
<pre><code class="language-php">
use PHPUnit\Framework\TestCase;
final class OrderRepositoryContractTest extends TestCase
{
    /**
     * @test
     * @dataProvider orders
     */
    public function it_can_save_and_load_order_entities(Order $order): void
    {
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0344_original/original_page.png" alt="Original Page 344">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
foreach ($this-&gt;orderRepositories() as $orderRepository) {
    $orderRepository-&gt;save($order);
    $fromRepository = $orderRepository-&gt;getById($order-&gt;orderId());
    self::assertEquals($order, $fromRepository);
}
</code></pre>
<pre><code class="language-php">
/**
 * @return Generator&lt;OrderRepository&gt;
 */
private function orderRepositories(): Generator
{
    yield new InMemoryOrderRepository();
    yield new OrderRepositoryUsingDoctrineDbal(/* ... */);
    // yield any other implementation you have
}
/**
 * @return Generator&lt;array&lt;Order&gt;&gt;
 */
public function orders(): Generator
{
    yield [Order::create(/* ... */)];
    yield [Order::create(/* ... */)-&gt;cancel()];
    yield [Order::create(/* ... */)-&gt;markAsPaid()];
    // yield any other Order entity that you might want to save
}
</code></pre>
<p>باید چندین بخش دیگر از contract را نیز تست کرد، مانند توانایی تمام implementations برای ارائه order IDs منحصر به فرد. یا توانایی ذخیره یک</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0345_original/original_page.png" alt="Original Page 345">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>entity پس از اصلاح آن.</p>
<p>اطمینان حاصل کنید که همه چیز در مورد setup از repository implementations تا حد امکان واقعی است. یعنی از یک database واقعی استفاده کنید، ترجیحاً همان database که شما در production استفاده می‌کنید. برای هیچ چیز test doubles ایجاد نکنید.
        اطمینان حاصل کنید که این test، هر مشکلی را در کد که در غیر این صورت فقط پس از اجرای کد در production نشان داده می‌شود، نشان می‌دهد. شکل 14.1 نتیجه این approach را نشان می‌دهد: یک contract test برای OrderRepository تمام عناصر نرم‌افزاری درگیر در استفاده از database واقعی را فراخوانی می‌کند. چنین تستی نشان می‌دهد که اگر یک application service در core application به interface OrderRepository وابسته باشد، و service container برای تزریق یک نمونه از OrderRepositoryUsingDoctrineDbal پیکربندی شده باشد، همه چیز به خوبی کار می‌کند.</p>
<p>
<img alt="Figure 14.1. Test coverage for the OrderRepository contract test." src="https://via.placeholder.com/300"/>
<figcaption>شکل 14.1. پوشش تست برای contract test OrderRepository.</figcaption>
</p>
<p>یک نکته در هنگام نوشتن یک contract test این است که شما نباید</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 346" src="page_0346/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0346_original/original_page.png" alt="Original Page 346">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>به رفتار خاصی از یک implementation متکی باشند. متدهای تست باید فقط متدهایی را فراخوانی کنند که در interface تعریف شده‌اند. این تضمین می‌کند که implementations از اصل Liskov Substitution، یعنی آن‌ها می‌توانند به ظاهر به عنوان جایگزین برای یکدیگر عمل کنند، پیروی می‌کنند.</p>
<p>برای repositories، یک contract test، نوع مناسبی از تست است که باید نوشته شود. برای سایر services ها، مانند VatRateProvider، ممکن است خیلی خوب کار نکند. تفاوت این است که این service فقط نیاز به ارائه نوعی پاسخ دارد، اما ما واقعاً نمی‌توانیم در یک contract تعریف کنیم که یک پاسخ خوب چیست، به غیر از اینکه باید یک پاسخ از نوع مناسب باشد، در این مورد VatRate. اما این قبلاً در سطح زبان تضمین شده است، بنابراین نوشتن یک تست برای تأیید اینکه implementations از VatRateProvider یک نمونه از VatRate را برمی‌گرداند، منطقی نیست. اگر آن‌ها این کار را نکنند، "compiler" شکایت خواهد کرد. آنچه در واقع مفید خواهد بود این است که تست کنیم که یک implementation خاص مانند VatRate-ProviderUsingVatApiDotCom قادر است به درستی و به طور موثر با API remote از vatapi.com ارتباط برقرار کند.
        ما قبلاً در مورد تست این class در بخش 6.4 صحبت کردیم، اما Listing 14.4 (کمی اصلاح شده) مثال را که در آنجا مورد بحث قرار دادیم تکرار می‌کند.
    </p>
<p>Listing 14.4. Integration tests برای VatRateProviderUsingVatApiDotCom.</p>
<pre><code class="language-php">
final class VatRateProviderUsingVatApiDotComTest extends TestCase
{
    /**
     * @test
     */
    public function it_provides_the_dutch_vat_rate(): void
    {
        $provider = new VatRateProviderUsingVatApiDotCom(
            new VatApi(
                'TEST_API_KEY',
                new HttpClient(
                    'https://vatapi.com'
                )
            )
        );
        self::assertEquals(
            VatRate::fromInt(21),
            $provider-&gt;vatRateForSellingEbooksInCountry('NL')
        );
    }
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0347_original/original_page.png" alt="Original Page 347">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
}
</code></pre>
<p>در فصل 6 ما به استفاده از function های curl_*() در داخل کلاس VatApi ادامه دادیم. یک approach واقعی‌تر این است که یک HTTP client را در کلاس VatApi تزریق کنیم، بنابراین خودش نیازی به رسیدگی به آن implementation details های low-level ندارد. تزریق یک HTTP client به عنوان یک dependency، این را روشن می‌کند که این class در حال برقراری یک network connection است. در Listing 14.4 حتی base URL را برای requests نشان می‌دهد. من این تغییر را در مثال ایجاد کرده‌ام تا نکته این adapter test را واضح‌تر کنم: همه چیز باید تا حد امکان واقعی باشد.</p>
<p>هنگام برقراری ارتباط با external services که توسط شما یا تیم شما مدیریت نمی‌شوند، انجام این کار بدون قربانی کردن مقداری از test stability می‌تواند واقعاً دشوار باشد. در اینجا کاری است که معمولاً انجام می‌دهم:</p>
<ol>
<li>تست را در برابر سرویس واقعی بنویسید</li>
<li>تست را در برابر یک sandbox environment که third party ارائه می‌دهد، بنویسید</li>
<li>تست را در برابر یک fake server که اجرا می‌کنم، بنویسید</li>
<li>تست را در برابر یک client HTTP fake یا mock که توسط library client که استفاده می‌کنم، ارائه شده است، بنویسید</li>
<li>تست را در برابر یک fake یا mock از interface HTTP client که من استفاده می‌کنم، بنویسید</li>
</ol>
<p>Option 1 و 2 به شما بیشترین اطمینان را می‌دهند، اما test ممکن است گاهی اوقات به دلایلی که شما نمی‌توانید در مورد آن‌ها کاری انجام دهید، شکست بخورد. Option 3 عالی است زیرا نشان می‌دهد که شما به درستی از client HTTP خود استفاده می‌کنید: می‌تواند requests های HTTP واقعی را ایجاد کند. شما می‌توانید در داخل fake server تأیید کنید که requestsهای مناسب ایجاد شده‌اند. Option 4 کمتر بهینه است، زیرا مقداری اعتماد به library شما دارد. شما فرض می‌کنید که آن قادر است با سرور خاصی که روی آن کار می‌کنید صحبت کند (اما ممکن است این فرض امن باشد). Option 5 حتی کمتر بهینه است، زیرا شما ممکن است برخی از فرض‌های بد را در مورد نحوه استفاده صحیح از library داشته باشید. این ارتباط نزدیکی با the testing rule دارد: "don’t mock what you don’t own". من فکر می‌کنم این می‌تواند به عنوان "don’t mock an interface whose contract is bigger than the interface itself can describe" تعمیم داده شود. اما این برای یک روز دیگر است.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0348_original/original_page.png" alt="Original Page 348">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        شکل 14.2 نشان می‌دهد که چه عناصر نرم‌افزاری، adapter test برای VatRateProviderUsingVatApiDotCom را پوشش می‌دهند. این adapter tests نشان می‌دهد که وقتی یک application service به interface VatRateProvider وابسته است و service container
        به
        تزریق
        یک
        نمونه
        از
        VatRateProviderUsingVatApiDotCom
        پیکربندی
        شده
        است،
        آن
        کار
        خواهد
        کرد
        و
        آنچه
        از
        آن
        انتظار
        می‌رود
        را
        فراهم
        می‌کند.
    </p>
<p>
<img alt="Figure 14.2. Test coverage for the VatRateProvider adapter test." src="https://via.placeholder.com/300"/>
<figcaption>شکل 14.2. پوشش تست برای the VatRateProvider adapter test.</figcaption>
</p>
<h4><strong>14.4. Driving tests for incoming port adapters</strong></h4>
<p>The implementation از یک outgoing port adapter در صورتی صحیح است که interface port و contract آن را به طور کامل پیاده‌سازی کند. آنچه کارایی یک</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 349" src="page_0349/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0349_original/original_page.png" alt="Original Page 349">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>adapter incoming port؟ چنین adapter، communication ورودی را پردازش می‌کند، مانند HTTP requests یا invocations از command line. در مورد یک request HTTP، کد زیادی درگیر پردازش آن است، از خود web server، تا PHP SAPI، تا web framework که شما در پروژه خود استفاده می‌کنید، تا controller که framework فراخوانی می‌کند. آنچه باعث می‌شود این کد از تست عبور کند این است که آیا port adapter در نهایت call صحیح را به application core انجام می‌دهد یا خیر. به عنوان مثال، به createOrderAction در Listing 14.5 نگاهی بیندازید. این controller action، request HTTP ورودی را با کپی کردن داده‌ها از request body به یک DTO پردازش می‌کند. سپس DTO را به متد createOrder() از ApplicationInterface منتقل می‌کند (به بخش 13.5 مراجعه کنید).</p>
<p>Listing 14.5. orderEbookAction() فراخوانی ApplicationInterface::createOrder().</p>
<pre><code class="language-php">
final class OrderController
{
    private ApplicationInterface $application;
    public function __construct(ApplicationInterface $application)
    {
        $this-&gt;application = $application
    }
    public function orderEbookAction(Request $request): Response
    {
        $orderId = $this-&gt;application-&gt;createOrder(
            CreateOrder::fromRequestData($request-&gt;request-&gt;all())
        );
</code></pre>
<p>یک adapter test برای این کد نیازی به تست logic واقعی ایجاد order ندارد. ما فقط باید نشان دهیم که این کد، با در نظر گرفتن یک request HTTP، call مناسب را به createOrder() انجام می‌دهد و یک object CreateOrder را که حاوی داده‌های مورد انتظار است، ارائه می‌دهد. این یک مورد عالی برای یک mock object است. در داخل یک test، ما می‌توانیم یک mock برای ApplicationInterface ایجاد کنیم و برخی را تعریف کنیم</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0350_original/original_page.png" alt="Original Page 350">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>expections برای آن. سپس ما یک request HTTP را آماده می‌کنیم و controller را فراخوانی می‌کنیم. اما آیا ما باید مستقیماً خودمان controller را فراخوانی کنیم، همانطور که در Listing 14.6 نشان داده شده است؟</p>
<p>Listing 14.6. Invoking the controller directly.</p>
<pre><code class="language-php">
public function it_correctly_invokes_createOrder(): void
{
    $application = $this-&gt;createMock(ApplicationInterface::class);
    $application-&gt;expects($this-&gt;once())
        -&gt;method('createOrder')
        -&gt;with(new CreateOrder(/* ... */));
    $request = new Request('/create-order', /* ... */);
    $controller = new OrderController($application);
    $controller-&gt;createOrderAction($request);
}
</code></pre>
<p>من فکر می‌کنم این باعث می‌شود که چیزهای زیادی تست نشده باقی بماند. ما به صورت دستی یک object از نوع Request را نمونه‌سازی می‌کنیم، اما احتمالاً object Request که توسط framework بر اساس یک request HTTP واقعی ایجاد شده است، بسیار متفاوت به نظر می‌رسد. ما به صورت دستی the OrderController را نمونه‌سازی می‌کنیم، اما ما نمی‌دانیم که آیا framework قادر به نمونه‌سازی آن نیز خواهد بود یا خیر. ما حتی نمی‌دانیم که آیا framework request را بر اساس '/create-order'
        request URI به درستی به OrderController dispatch خواهد کرد یا خیر. همه این‌ها در حال حاضر assumptions تأیید نشده هستند.</p>
<p>بنابراین به جای فراخوانی controller در isolation، ما باید آن را در محیط طبیعی خود تعبیه کنیم و آن را به روشی واقع‌بینانه‌تر فراخوانی کنیم. ما خوش شانس هستیم که بیشتر frameworksها ابزارهایی برای ایجاد controller tests ارائه می‌دهند که به ما اجازه می‌دهد این کار را انجام دهیم. من فقط تجربه با ابزارهای built-in از Symfony<sup>2</sup> و Panther<sup>3</sup> دارم. List-
        ing 14.7 یک مثال را با استفاده از WebTestCase از Symfony و ابزارهای مرتبط نشان می‌دهد که معادل تست در Listing 14.6 را نشان می‌دهد، در حالی که همچنین قسمت integration از framework را تست می‌کند.
    </p>
<p>Listing 14.7. Using the WebTestCase to test createOrderAction().</p>
<p><sup>2</sup> https://advwebapparch.com/symfony-testing
    </p>
<p><sup>3</sup> https://advwebapparch.com/panther</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0351_original/original_page.png" alt="Original Page 351">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
final class OrderControllerTest extends WebTestCase
{
    public function it_correctly_invokes_createOrder(): void
    {
        $application = $this-&gt;createMock(ApplicationInterface::class);
        $application-&gt;expects($this-&gt;once())
            -&gt;method('createOrder')
            -&gt;with(new CreateOrder(2, 1, 'matthiasnoback@gmail.com'))
            -&gt;will($this-&gt;returnValue(new OrderId(1001)));
        $client = self::createClient();
        $client-&gt;getContainer()-&gt;set(
            ApplicationInterface::class,
            $application
        );
        $client-&gt;request('POST', '/create-order', [
            'ebook_id' =&gt; '2',
            'quantity' =&gt; '1',
            'email_address' =&gt; 'matthiasnoback@gmail.com'
        ]);
        self::assertTrue(
            $this-&gt;client-&gt;getResponse()-&gt;isRedirect('/order-details/1001')
        );
    }
}
</code></pre>
<p>این test تأیید می‌کند که framework، the OrderController را نمونه‌سازی می‌کند و متد createOrderAction() را بر اساس '/create-order' URI فراخوانی می‌کند.
        این تأیید می‌کند که createOrderAction() قادر به استخراج data ارسال شده از request body و کپی کردن آن در CreateOrder DTO است، که سپس به عنوان یک argument به ApplicationInterface::createOrder() منتقل می‌شود. و به عنوان یک bonus، این test همچنین تأیید می‌کند که ما به صفحه جزئیات order صحیح redirect می‌شویم.</p>
<p>هیچ یک از این کدها در واقع یک entity Order ایجاد نمی‌کند، زیرا ما ApplicationInterface را با یک mock جایگزین کرده‌ایم. به همین دلیل، هیچ یک از این کدها نیازی به</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0352_original/original_page.png" alt="Original Page 352">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>به هیچ یک از actors secondary در دسترس باشد. این تست فقط کد را در سمت چپ application، که در آن communication ورودی پردازش می‌شود، فراخوانی می‌کند. شکل 14.3 نشان می‌دهد که چه عناصری در اجرای این OrderControllerTest درگیر هستند.</p>
<p>
<img alt="Figure 14.3. Test coverage of OrderControllerTest." src="https://via.placeholder.com/300"/>
<figcaption>شکل 14.3. Test coverage از OrderControllerTest.</figcaption>
</p>
<p>یک نکته‌ای که باید از آن آگاه باشید: حتی اگر ما یک controller test مانند این بنویسیم، ما نمی‌توانیم کاملاً مطمئن باشیم که application در production کار می‌کند. The WebTestCase client با یک web server ارتباط برقرار نمی‌کند. این یک request HTTP واقعی ایجاد نمی‌کند. این یک object Request را دقیقاً همانطور که قبلاً انجام دادیم، نمونه‌سازی می‌کند. این بدان معناست که هنگامی که application در پشت یک web server اجرا می‌شود، ممکن است هنوز به درستی عمل نکند. ممکن است مشکلاتی در کد بین لحظه‌ای که web server، PHP را فراخوانی می‌کند و لحظه‌ای که framework، controller ما را فراخوانی می‌کند، وجود داشته باشد. بنابراین آیا ما باید application را در یک محیط بیشتر شبیه به production تست کنیم؟ Panther، ابزار testing که قبلاً ذکر کردم، قادر است تست‌ها را بر اساس WebTestCase به تست‌هایی ارتقا دهد که یک web server را راه‌اندازی می‌کنند و تست‌های مشابهی را در حالی اجرا می‌کنند که requests HTTP واقعی را انجام می‌دهند. اما من مطمئن نیستم که آیا باید از این approach در یک adapter test استفاده کنیم.</p>
<p>با هر نوع adapter tests، the trade-off بین تعداد assumptionsی است که test شما تأیید می‌کند و سرعت و پایداری تست‌های شما. اولین</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 353" src="page_0353/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0353_original/original_page.png" alt="Original Page 353">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>test ما نوشتیم، که در آن ما فقط خود OrderController را تست کردیم، می‌تواند یک تست stable در نظر گرفته شود. عناصر زیادی درگیر نیستند، بنابراین مشکلات نامرتبط زیادی وجود ندارند که بتوانند باعث شکست این test شوند. با این حال، ما تصمیم گرفتیم که assumptionsهای زیادی را تأیید نشده باقی می‌گذارد. استفاده از The WebTestCase، اطمینانی را که ما در کد خود داریم، افزایش می‌دهد، اما مراحل بسیار بیشتری درگیر هستند. چنین تستی می‌تواند به دلایل بی‌شماری نامرتبط شکست بخورد، و از آنجایی که شامل فراخوانی کدهای بیشتری می‌شود، بسیار کندتر نیز خواهد بود. راه‌اندازی یک web server و ایجاد requests HTTP واقعی، تست را حتی کندتر می‌کند و احتمال بیشتری دارد که به دلایل سخت برای اشکال‌زدایی شکست بخورد.</p>
<p>در تجربه‌ام، سریع و stable نگه داشتن test suite بسیار مهم است. این کار باعث می‌شود که کار من بسیار سرگرم‌کننده شود و من در مورد کیفیت کارم بسیار مطمئن هستم. بنابراین من فکر می‌کنم که اکثر تست‌ها برای incoming adapters نباید requests HTTP واقعی ایجاد کنند. آن‌ها می‌توانند framework را به صورت programmatically فراخوانی کنند و 80٪ از assumptions را تأیید کنند. با این حال، هوشمندانه است که حداقل چند تست داشته باشیم که شبیه‌ساز یک تنظیم production باشند، فقط به این دلیل که ما می‌دانیم که تمام عناصر infrastructure واقعی با هم خوب کار می‌کنند. برای این کار ما tests های End-to-end را می‌نویسیم (به بخش 14.6 مراجعه کنید).</p>
<p>“چرا mock کردن application در یک adapter test مهم است؟”</p>
<p>دلیل اینکه ما در حال mock کردن ApplicationInterface هستیم این است که ما نباید از integration tests برای تست core code استفاده کنیم. Core code به خود اجازه می‌دهد که با unit tests یا use case tests، که هر دو بسیار سریع اجرا می‌شوند و همچنین بسیار stable هستند، تست شود زیرا آن‌ها کاملاً deterministic هستند و عناصر بیشتری را نسبت به آنچه که دقیقاً مورد نیاز است، درگیر نمی‌کنند. Adapter tests، integration tests هستند و طبق تعریف کندتر و کمتر stable از isolated tests هستند. بنابراین اگرچه ما می‌توانستیم logic core را با استفاده از یک adapter test تست کنیم، اما بهتر است این را به تست‌های ایزوله‌تر بسپاریم و نقطه ورودی به core (the ApplicationInterface در مثال ما) را با یک test double جایگزین کنیم.</p>
<p>createService() یک command method است که یک side-effect ایجاد می‌کند. به همین دلیل است که متد request از نوع POST است. web application ما همچنین دارای controllers است که یک side-effect تولید نمی‌کنند، بلکه فقط مقداری اطلاعات را برمی‌گردانند. به عنوان مثال، صفحه /list-available-ebooks یک لیست از e-books را در HTML render می‌کند. The</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0354_original/original_page.png" alt="Original Page 354">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>controllers ما. The EbookController::listAvailableEbooksAction() متد listAvailable-
        Ebooks() را روی ApplicationInterface فراخوانی می‌کند و مقدار بازگشتی را به template منتقل می‌کند (به Listing 14.8 مراجعه کنید).</p>
<p>Listing 14.8. listAvailableEbooksAction() فراخوانی listAvailableEbooks().</p>
<pre><code class="language-php">
final class EbookController
{
    private ApplicationInterface $application;
    private TemplateRenderer $templateRenderer;
    public function __construct(
        ApplicationInterface $application,
        TemplateRenderer $templateRenderer
    ) {
        $this-&gt;application = $application;
        $this-&gt;templateRenderer = $templateRenderer;
    }
    public function listAvailableEbooksAction(): Response
    {
        $ebooks = $this-&gt;application-&gt;listAvailableEbooks();
        return $this-&gt;templateRenderer-&gt;render(/* ... */);
    }
}
</code></pre>
<p>ما می‌توانیم یک controller test مشابه برای آن مانند آنچه قبلاً انجام داده‌ایم، بنویسیم (به Listing 14.9 مراجعه کنید). اما در اینجا ما نیاز داریم که کمی بیشتر کار کنیم تا مجموعه‌ای از object های Ebook fake را آماده کنیم که توسط test double برگردانده می‌شوند.</p>
<p>Listing 14.9. یک test برای The EbookController.</p>
<pre><code class="language-php">
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
final class EbookControllerTest extends WebTestCase
{
    public function it_renders_a_list_of_ebooks(): void
    {
        $ebooks = [
            EbookBuilder::create()
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0355_original/original_page.png" alt="Original Page 355">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
-&gt;withTitle('Advanced Web Application Architecture')
        -&gt;build()
];
$application = $this-&gt;createMock(ApplicationInterface::class);
$application-&gt;expects($this-&gt;any())
    -&gt;method('listAvailableEbooks')
    -&gt;will($this-&gt;returnValue($ebooks));
$client = self::createClient();
$client-&gt;getContainer()-&gt;set(
    ApplicationInterface::class,
    $application
);
$crawler = $client-&gt;request('GET', '/list-available-ebooks');
self::assertStringContainsString(
    'Advanced Web Application Architecture',
    $crawler-&gt;filter('.ebook-title')-&gt;text()
);
</code></pre>
<p>این test تأیید می‌کند که framework، OrderController را نمونه‌سازی می‌کند و متد createOrderAction() را بر اساس '/create-order' URI فراخوانی می‌کند.
        مقدار بازگشتی متد getById() از Ebook های فیک.
    </p>
<p>
        The return value از request() یک DomCrawler است که شما می‌توانید از آن برای انتخاب عناصر خاصی از HTML response body با استفاده از CSS selectors استفاده کنید.
        سپس شما می‌توانید در مورد attributes یا content آن‌ها assertion انجام دهید.
    </p>
<p>برای ساده‌سازی process از ایجاد read model objects، من معمولاً یک builder معرفی می‌کنم که به من اجازه می‌دهد فقط روی مقادیر مربوطه تمرکز کنم. builder، هر data مورد نیاز دیگری را اضافه می‌کند تا شما مجبور نباشید نگران آن باشید. Listing 14.10 نشان می‌دهد که builder چگونه به نظر می‌رسد.</p>
<p>Listing 14.10. A builder برای object های Ebook read model.</p>
<pre><code class="language-php">
final class EbookBuilder
{
    private string $id = 'ad5075f1-be24-4ae1-8ba8-9efec6f4933b';
    private int $price = 2500;
    private string $title = 'The title';
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0356_original/original_page.png" alt="Original Page 356">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
private function __construct()
{
}
public static function create(): self
{
    return new self();
}
public function withTitle(string $title): self
{
    $this-&gt;title = $title;
    return $this;
}
public function build(): Ebook
{
    return new Ebook(
        EbookId::fromString($this-&gt;id),
        new Money($this-&gt;price, new Currency('EUR')),
        $this-&gt;title
    );
}
</code></pre>
<p>شکل 14.4 عناصری را نشان می‌دهد که در adapter test برای Ebook-Controller دخیل هستند.
        اگر تمام راه‌هایی که application شما با دنیای بیرون ارتباط برقرار می‌کند به ports (interfaces) و adapters (supporting implementations) تقسیم شده‌اند، شما می‌توانید process توصیف شده در اینجا را تکرار کنید و تمام port adapters خود را تست کنید. سپس شما می‌دانید که requests های incoming به درستی پردازش خواهند شد و منجر به calls مناسب به application core می‌شوند. شما همچنین خواهید دانست که values بازگشتی از application core به پاسخ صحیح تبدیل خواهند شد. در سمت دیگر application، جایی که communication outgoing اتفاق می‌افتد، شما می‌دانید که کد به درستی interfaces را از core پیاده‌سازی می‌کند. شکل 14.5 مناطقی از application را که تا کنون با تست پوشش داده‌ایم، نشان می‌دهد.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0357_original/original_page.png" alt="Original Page 357">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
<img alt="Figure 14.4. Test coverage of EbookControllerTest." src="https://via.placeholder.com/300"/>
<figcaption>شکل 14.4. Test coverage از EbookControllerTest.</figcaption>
</p>
<p>ما هنوز کارمان تمام نشده است. اگرچه ما تعدادی unit tests برای domain model objects داریم، اما ما یک تست برای use cases که application ما باید ارائه دهد، نداریم. ما نمی‌دانیم که آیا در داخل core application همه چیز به خوبی با هم کار می‌کند، به عنوان مثال، پس از پرداخت یک order، customer یک ایمیل تأییدیه دریافت خواهد کرد. ما برای این به use case tests نیاز داریم.</p>
<h4><strong>14.5. Use case tests</strong></h4>
<p>Use case tests، use cases را تست می‌کنند، اما مهمتر از همه آن‌ها، primary actions و effects های آن‌ها را مستند می‌کنند، به عنوان مثال:</p>
<ol>
<li>
            هنگامی که customer یک order ایجاد می‌کند، آن‌ها باید یک order confirmation email دریافت کنند.
        </li>
<li>
            هنگامی که مدیر یک e-book جدید به catalog اضافه می‌کند، باید
        </li>
</ol>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 358" src="page_0358/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0358_original/original_page.png" alt="Original Page 358">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        این scenariosها را می‌توان با استفاده از design patterns پوشش داده شده در فصل 11، پیاده‌سازی کرد. با نگاشت scenario اول به patterns، من می‌گویم که ما نیاز داریم:
    </p>
<ol>
<li>یک entity Customer با یک object CustomerId value که ما می‌توانیم از آن برای پیوند order به customer استفاده کنیم.</li>
<li>یک متد createOrder() application service که یک entity Order ایجاد می‌کند، آن را با استفاده از OrderRepository ذخیره می‌کند و domain eventsهای ثبت شده را به EventDispatcher dispatch می‌کند.</li>
<li>یک entity Order که یک رویداد OrderWasCreated تولید می‌کند.</li>
<li>یک interface OrderRepository و یک implementation in-memory که ما می‌توانیم در use case test از آن استفاده کنیم.</li>
<li>یک SendConfirmationMail event subscriber که به رویدادهای OrderWasCreated مشترک می‌شود و ایمیل تأیید order را ارسال می‌کند.</li>
</ol>
<p>چیز دیگری که ما نیاز داریم چیزی است که بتواند sending واقعی را نشان دهد</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 359" src="page_0359/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0359_original/original_page.png" alt="Original Page 359">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>the order confirmation email. باز هم، این نیاز به یک abstraction، به عنوان مثال، interface Mailer خودمان با یک متد sendOrderConfirmationMail() دارد.
        ما همچنین به یک سرویس EventDispatcher نیاز خواهیم داشت. ما نمونه‌ای از آن را در بخش 11.5 دیده‌ایم، از جمله یک implementation. Listing 14.11 همان interface را با یک implementation مشابه نشان می‌دهد.
    </p>
<p>Listing 14.11. The EventDispatcher interface و یک implementation.</p>
<pre><code class="language-php">
interface EventDispatcher
{
    /**
     * @param array&lt;object&gt; $events
     */
    public function dispatchAll(array $events): void;
}
final class ConfigurableEventDispatcher implements EventDispatcher
{
    private array $subscribers = [];
    public function __construct()
    {
    }
    public function addSubscriber(
        string $eventType,
        callable $subscriber
    ): void {
        $this-&gt;subscribers[$eventType][] = $subscriber;
    }
    public function dispatchAll(array $events): void
    {
        foreach ($events as $event) {
            foreach (
                $this-&gt;subscribersForEvent($event) as $subscriber
            ) {
                $subscriber($event);
            }
        }
    }
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0360_original/original_page.png" alt="Original Page 360">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
private function subscribersForEvent(object $event): array
{
    return $this-&gt;subscribers[get_class($event)] ?? [];
}
</code></pre>
<p>ما مجبور نیستیم خودمان را به یک interface خاص متعهد کنیم.
        “Can’t we use the framework’s event dispatcher?”</p>
<p>از نظر فنی شما می‌توانید. با این حال، من متوجه شدم که event dispatchers های third-party اغلب نوع API را که من می‌خواهم استفاده کنم، ارائه نمی‌دهند. به عنوان مثال، آن‌ها متد dispatchAll() را ندارند، آن‌ها به یک class پایه برای هر domain event نیاز دارند، یا object های event آن‌ها mutable هستند. همچنین، event dispatchersها اغلب به listeners اجازه می‌دهند که chain را بشکنند و از انتشار event به سایر subscribersها جلوگیری کنند. همه این موارد ناخواسته هستند و از آنجایی که یک event subscriber یک قطعه کد واقعاً ساده است، شما می‌توانید فقط خودتان آن را بنویسید و این تبدیل به یک maintenance burden نخواهد شد. البته مگر اینکه شما یک library event dispatcher خوب پیدا کنید که این ترفند را برای شما انجام دهد.</p>
<p>از آنجایی که ما به زودی چندین service خواهیم داشت (application service برای ایجاد the order، یک OrderRepository، یک Mailer و غیره)، ما باید یک ترکیب root که به عنوان یک service container نیز شناخته می‌شود، ایجاد کنیم که نمونه‌های service را مدیریت کرده و آن‌ها را در صورت نیاز ایجاد می‌کند. این container با container که framework ارائه می‌دهد، یکسان نیست. در حالی که یک event dispatcher می‌تواند در تئوری third-party code باشد، container ما یک hand-written code<sup>4</sup> خواهد بود. این فقط شامل services مورد نیاز توسط core application ما می‌شود، بنابراین شما یک router یا یک template renderer در آنجا پیدا نخواهید کرد.</p>
<p>Listing 14.12 container را نشان می‌دهد که ما در اولین scenario test از آن استفاده خواهیم کرد.</p>
<p>Listing 14.12. A hand-written service container برای testing</p>
<pre><code class="language-php">
final class TestServiceContainer
{
    private ?EventDispatcher $eventDispatcher = null;
    4See also Matthias Noback (2019),
    “Hand-written service containers“:
    https://
    advwebapparch.com/hand-written-service-containers
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0361_original/original_page.png" alt="Original Page 361">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
private ?ApplicationInterface $application = null;
    private ?OrderRepository $orderRepository = null;
    public function __construct()
    {
    }
    public function eventDispatcher(): EventDispatcher
    {
        if ($this-&gt;eventDispatcher === null) {
            $this-&gt;eventDispatcher = new ConfigurableEventDispatcher();
        }
        return $this-&gt;eventDispatcher();
    }
    public function application(): ApplicationInterface
    {
        if ($this-&gt;application === null) {
            $this-&gt;application = new Application(
                $this-&gt;orderRepository(),
                $this-&gt;eventDispatcher()
            );
        }
        return $this-&gt;application;
    }
    private function orderRepository(): OrderRepository
    {
        if ($this-&gt;orderRepository === null) {
            $this-&gt;orderRepository = new InMemoryOrderRepository();
        }
        return $this-&gt;orderRepository;
    }
    // ...
}
</code></pre>
<p>برخی از guidelinesهای توسعه برای hand-written containers عبارتند از:</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0362_original/original_page.png" alt="Original Page 362">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>1. شما می‌توانید یک hierarchy از containers ایجاد کنید، به عنوان مثال. TestServiceContainer
        از DevelopmentServiceContainer گسترش می‌یابد که از یک ServiceContainer abstract گسترش می‌یابد، که دارای یک زیر class از ProductionServiceContainer است.
    </p>
<p>2. Factory methods باید در صورت امکان private باشند.</p>
<p>3. در داخل hierarchy از containers، شما می‌توانید بخش‌هایی را با تعریف methods محافظت شده (abstract) override کنید. این همچنین به شما اجازه می‌دهد که در صورت نیاز (به عنوان مثال، در production ممکن است the EventDispatcher یک service خصوصی باشد، اما هنگام تست کردن، ممکن است public باشد) دامنه‌ها را برای testing گسترش دهید.
    </p>
<p>4. Services را به عنوان objects stateless تعریف کنید تا بتوانید هر بار که درخواست می‌شود، یک نمونه جدید را از factory method برگردانید. اگر شما باید service را stateful یا mutable کنید، مانند repositories in-memory یا event dispatcher، یا اگر instantiation باید اغلب اتفاق بیفتد، یک نمونه از service را در یک property از container نگه دارید.</p>
<p>5. The constructor از container می‌تواند برای اجبار مقادیر configuration خاصی برای ارائه استفاده شود. توصیه می‌شود یک object configuration value تعریف کنید که پیش‌فرض‌های منطقی را ارائه می‌دهد.
        بازگشت به مثال: ما می‌خواهیم نشان دهیم که، هنگامی که یک order ایجاد شده است، customer یک ایمیل تأیید order دریافت می‌کند. Listing 14.13 نشان می‌دهد که یک test مانند این چگونه است.
    </p>
<p>Listing 14.13. استفاده از the TestServiceContainer در یک test.</p>
<pre><code class="language-php">
public function the_customer_receives_an_order_confirmation_mail(): void
{
    $container = new TestServiceContainer();
    $orderId = $container-&gt;application()-&gt;createOrder(
        new CreateOrder(2, 1, 'matthiasnoback@gmail.com')
    );
    // TODO verify that an email was sent
}
</code></pre>
<p>ما هنوز یک event subscriber را که می‌تواند ایمیل را ارسال کند، تنظیم نکرده‌ایم، بنابراین بیایید این کار را اکنون انجام دهیم (به Listing 14.14 مراجعه کنید).</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0363_original/original_page.png" alt="Original Page 363">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
<pre><code class="language-php">
Listing 14.14. An event subscriber that will send the confirmation email.
final class TestServiceContainer
{
    // ...
    public function eventDispatcher(): EventDispatcher
    {
        if ($this-&gt;eventDispatcher === null) {
            $this-&gt;eventDispatcher = new ConfigurableEventDispatcher();
            // Register the event subscriber here:
            $this-&gt;eventDispatcher-&gt;addSubscriber(
                OrderWasCreated::class,
                [$this-&gt;sendOrderConfirmationEmail(), 'whenOrderWasCreated']
            );
        }
        return $this-&gt;eventDispatcher();
    }
    private function sendOrderConfirmationEmail(): SendOrderConfirmationEmail
    {
        return new SendOrderConfirmationEmail($this-&gt;mailer());
    }
    private function mailer(): Mailer
    {
        // TODO return a Mailer
    }
}
</code></pre>
<p>یک use case test باید فقط core code را پوشش دهد، بنابراین ما هرگز نباید ایمیل‌ها را ارسال کنیم. با این حال، ما می‌خواهیم تأیید کنیم که the SendOrderConfirmationEmail، از Mailer می‌خواهد که آن ایمیل تأییدیه را ارسال کند. دوباره ترفند این است که یک Mailer abstraction تعریف کنیم تا بتوانیم در هنگام testing، mailer واقعی را با یک test double جایگزین کنیم. Listing 14.15 interface Mailer را نشان می‌دهد که من برای این کار در نظر داشتم، و اینکه چگونه the SendOrderConfirmationEmail event subscriber آن را فراخوانی می‌کند.</p>
<p>Listing 14.15.</p>
</p></div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0364_original/original_page.png" alt="Original Page 364">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
interface Mailer
{
    public function sendOrderConfirmationEmail(
        OrderId $orderId
    ): void;
}
final class SendOrderConfirmationEmail
{
    private Mailer $mailer;
    public function __construct(Mailer $mailer)
    {
        $this-&gt;mailer = $mailer;
    }
    public function whenOrderWasCreated(
        OrderWasCreated $event
    ): void {
        $this-&gt;mailer-&gt;sendOrderConfirmationEmail(
            $event-&gt;orderId()
        );
    }
}
</code></pre>
<p>در نهایت آن متد sendOrderConfirmationEmail() ممکن است به ورودی‌های بیشتری نیاز داشته باشد، اما یک OrderId در حال حاضر باید خوب باشد.</p>
<p>در test ما می‌خواهیم نوعی assertion را انجام دهیم تا بررسی کنیم که the Mailer فراخوانی شده است. ما می‌توانیم این کار را با ایجاد یک mock object برای the Mailer service و تزریق آن به service container انجام دهیم (به Listing 14.16 مراجعه کنید).</p>
<p>Listing 14.16. Injecting یک mock Mailer.</p>
<pre><code class="language-php">
final class TestServiceContainer
{
    private ?Mailer $mailer = null;
    public function setMailer(Mailer $mailer): void
    {
        $this-&gt;mailer = $mailer;
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0365_original/original_page.png" alt="Original Page 365">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
}
private function mailer(): Mailer
{
    Assert::that($this-&gt;mailer)-&gt;instanceOf(Mailer::class);
    return $this-&gt;mailer;
}
</code></pre>
<pre><code class="language-php">
// inside the test:
// ...
$mailer = $this-&gt;createMock(Mailer::class);
$mailer-&gt;expects($this-&gt;once())
    -&gt;method('sendOrderConfirmationEmail');
$container-&gt;setMailer($mailer);
// ...
</code></pre>
<p>The downside این است که ما نمی‌توانیم تأیید کنیم که argument صحیح (the OrderId
        از order ایجاد شده) ارائه شده است. یک downside دیگر این است که این approach برای ایجاد mock objects به PHPUnit به عنوان یک test framework متصل است.
        ما بعداً به یک test runner متفاوت برای استفاده از use case tests نگاه خواهیم کرد، بنابراین هوشمندانه است که از PHPUnit دور بمانیم.</p>
<p>راه‌حل این است که یک test double از یک type خاص، یک object که به نام Spy شناخته می‌شود، ایجاد کنیم. این یک record از آنچه برای آن اتفاق افتاده است، نگه می‌دارد، بنابراین شما می‌توانید بعداً در مورد آن assertions انجام دهید. Listing 14.17 نمونه‌ای از یک Mailer spy را نشان می‌دهد.</p>
<p>Listing 14.17. An یک implementation spy برای Mailer.</p>
<pre><code class="language-php">
final class MailerSpy implements Mailer
{
    /**
     * @var array&lt;OrderId&gt;
     */
    private array $emailsSentFor = [];
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0366_original/original_page.png" alt="Original Page 366">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
public function sendOrderConfirmationEmail(OrderId $orderId): void
{
    $this-&gt;emailsSentFor[] = $orderId;
}
/**
 * @return array&lt;OrderId&gt;
 */
public function emailsSentFor(): array
{
    return $this-&gt;emailsSentFor;
}
</code></pre>
<p>ما اکنون می‌توانیم mailer spy را در داخل TestServiceContainer نمونه‌سازی کنیم. این باعث می‌شود که به طور خودکار در تست‌های دیگر نیز در دسترس باشد. ما باید متد factory آن را public کنیم تا ما به emailsSentFor() در داخل test دسترسی داشته باشیم (به Listing 14.18 مراجعه کنید).
    </p>
<p>Listing 14.18. Instantiating the Mailer spy در container.</p>
<pre><code class="language-php">
final class TestServiceContainer
{
    private ?Mailer $mailer = null;
    // ...
    public function mailer(): MailerSpy
    {
        if ($this-&gt;mailer === null) {
            $this-&gt;mailer = new MailerSpy();
        }
        return $this-&gt;mailer;
    }
}
</code></pre>
<p>توجه داشته باشید که من متد setMailer() را حذف کرده‌ام، زیرا دیگر به آن نیازی نداریم. من همچنین return type را از Mailer به MailerSpy محدود کرده‌ام. حتی اگر شما یک class والد داشته باشید که یک Mailer را از factory mailer() برمی‌گرداند، این هنوز هم مجاز است (طبق اصل Liskov Substitution که است).</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0367_original/original_page.png" alt="Original Page 367">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
$container = new TestServiceContainer();
    $orderId = $container-&gt;application()-&gt;createOrder(
        new CreateOrder(2, 1, 'matthiasnoback@gmail.com')
    );
    self::assertContainsEqual(
        $orderId,
        $container-&gt;mailer()-&gt;emailsSentFor()
    );
</code></pre>
<p>
        ممکن است این setup خاص در موقعیت شما مفید نباشد، اما من این مثال را اضافه کردم تا به شما یک impression از نوع setup را که برای ایجاد use case tests برای application خود نیاز دارید، ارائه دهم.
    </p>
<p>"اما ما چگونه می‌دانیم که آیا یک ایمیل واقعی ارسال خواهد شد؟"</p>
<p>نکته خوبیه; the use case test که ما ایجاد کردیم ثابت نمی‌کند که وقتی کد در production اجرا می‌شود یک ایمیل واقعی ارسال خواهد شد. ما می‌توانیم مطمئن باشیم که the Mailer فراخوانی خواهد شد، زیرا تست این را ثابت می‌کند. آنچه ما همچنین باید ثابت کنیم این است که implementation production از the Mailer interface قادر به ارسال ایمیل است. این کار، همانطور که حدس زدید، job یک adapter test است.</p>
<p>نوشتن use case tests برای همان test framework که شما برای unit و adapter tests استفاده می‌کنید، عالی است، به عنوان مثال. PHPUnit. با این حال، من متوجه شده‌ام که نوشتن آن‌ها در Gherkin، یک زبان طراحی شده برای استفاده از use case tests، باعث می‌شود آن‌ها واقعاً از تست‌های code-level متمایز شوند. برای PHP، ابزار go-to Behat<sup>5</sup> است، اگرچه Codeception<sup>6</sup> نیز از scenario-based tests پشتیبانی می‌کند. Listing 14.20 را برای Gherkin-version از test از Listing 14.19 ببینید.</p>
<p>Listing 14.20. A Gherkin scenario</p>
<p><sup>5</sup>https://advwebapparch.com/behat
        <sup>6</sup>https://advwebapparch.com/codeception
    </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0368_original/original_page.png" alt="Original Page 368">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>این scenarios را می‌توان با استفاده از design patterns پوشش داده شده در فصل 11، پیاده‌سازی کرد. با نگاشت scenario اول به patterns، من می‌گویم که ما نیاز داریم:</p>
<p>Feature: Ordering an e-book</p>
<p>Scenario: the customer receives an order confirmation email</p>
<p>When a customer creates an order for an e-book</p>
<p>Then they should receive an order confirmation email</p>
<p>البته، خود scenario چیزی را تست نمی‌کند. این عمدتاً برای ایجاد یک درک مشترک بین متخصصان domain و توسعه‌دهندگان نرم‌افزار مفید است.</p>
<p>“Seems interesting, where can I learn more?”</p>
<p>عمل توصیف features application با استفاده از scenarios های high-level که بر روی technology زوم نمی‌کنند، با نام Specification by Example، Ac-
        ceptance Test-Driven Development یا Behavior-Driven Development شناخته می‌شود. من مطمئنم که دلایل خوبی برای تمایز بین هر یک از این approaches وجود دارد، اما من فقط می‌خواستم چند نام ارائه دهم که ممکن است به شما در یافتن اطلاعات بیشتر در مورد آن کمک کند. من کتاب‌های زیر را در این موضوع توصیه می‌کنم:</p>
<ol>
<li>The BDD Books series by Gáspár Nagy and Seb Rose<sup>a</sup></li>
<li>Gojko Adzic, “Specification by Example”, Manning Publications (2011)</li>
</ol>
<p><sup>a</sup>https://advwebapparch.com/bdd-books
        به منظور استفاده از scenario به عنوان یک automated test، ما باید برای هر مرحله در scenario، مقداری کد بنویسیم. این کد، step definition نامیده می‌شود، و the test runner هر مرحله را با یک step definition در یک class به نام Context مطابقت می‌دهد. Listing 14.21 یک مثال را نشان می‌دهد که از Behat به عنوان test runner استفاده می‌کند.
    </p>
<p>Listing 14.21. Step definitions در class OrderContext.</p>
<pre><code class="language-php">
use Behat\Behat\Context\Context;
use PHPUnit\Framework\Assert;
final class OrderContext implements Context
{
    private TestServiceContainer $container;
</code></pre>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0369_original/original_page.png" alt="Original Page 369">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<pre><code class="language-php">
private ?OrderId $orderId = null;
    public function __construct()
    {
        $this-&gt;container = new TestServiceContainer();
    }
    /**
     * @When a customer creates an order for an e-book
     */
    public function aCustomerCreatesAnOrderForAnEbook(): void
    {
        $this-&gt;orderId = $this-&gt;container-&gt;application()
            -&gt;createOrder(
                new CreateOrder(2, 1, 'matthiasnoback@gmail.com')
            );
    }
    /**
     * @Then they should receive an order confirmation email
     */
    public function theyShouldReceiveAnOrderConfirmationEmail(): void
    {
        Assert::assertInstanceOf(OrderId::class, $this-&gt;orderId);
        Assert::assertContainsEqual(
            $this-&gt;orderId,
            $this-&gt;container-&gt;mailer()-&gt;emailsSentFor()
        );
    }
}
</code></pre>
<p>Behat خط اول scenario را می‌خواند: “When a customer creates an order
        for an e-book” و به دنبال متدی می‌گردد که دارای یک annotation @When به دنبال خود step باشد. در این مورد، متد aCustomerCreatesAnOrderForAn-
        Ebook() را پیدا می‌کند. سپس Behat این متد را فراخوانی می‌کند. اگر این یک exception تولید کند، Behat آن step را "failed" در نظر می‌گیرد. اگر همه چیز خوب پیش برود، Behat، step را موفقیت‌آمیز می‌داند و با step بعدی "Then they should receive an or-
        der confirmation email" ادامه می‌دهد. این step را با the theyShouldReceiveAnOrder-
    </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0370_original/original_page.png" alt="Original Page 370">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        ConfirmationEmail() method. باز هم، این متد اجرا می‌شود. شامل دو assertion است که ممکن است باعث پرتاب exceptions شود. اینکه آیا این اتفاق می‌افتد یا نه، موفقیت scenario را تعیین می‌کند.
    </p>
<p>به نظر من استفاده از Gherkin برای توصیف use cases مزایای زیادی دارد. فقط به چند مورد اشاره می‌کنم:</p>
<ol>
<li>بیان ویژگی‌های application شما با terms های abstract، high-level آسان‌تر است، و جزئیات implementation را حذف می‌کند.</li>
<li>مشخص کردن رفتار application در موقعیت‌های کمی متفاوت آسان‌تر است.</li>
<li>Scenariosها را می‌توان بدون کد اساسی نوشت، بنابراین شما می‌توانید درک خود را از features با سایر سهامداران، که ممکن است چیزی در مورد برنامه‌نویسی ندانند، اعتبار دهید.</li>
<li>
            scenariosها مستندات آنچه که application شما می‌تواند انجام دهد، هستند، آن‌ها مشخص می‌کنند که چه کاری باید انجام دهد، و از آنجایی که اتوماسیون در پشت آن‌ها وجود دارد، آن‌ها می‌توانند تأیید کنند که آنچه مستند و مشخص شده است در واقع در مورد application شما درست است. این باعث می‌شود که این یک فرم از Living documentation<sup>7</sup> باشد.
        </li>
</ol>
<p>شکل 14.6 نشان می‌دهد که چه بخش‌هایی از application تاکنون با تست پوشش داده شده‌اند.</p>
<p>در مورد Behat، نوشتن scenarios و خودکارسازی آن‌ها، چیزهای بیشتری وجود دارد که باید گفت، اما این فراتر از محدوده این کتاب است. اگر علاقه‌مند هستید، شما می‌توانید برخی از مثال‌های بیشتر از use case tests را در demo project<sup>8</sup> که همراه این کتاب است، بیابید.</p>
<h4><strong>14.6. End-to-end tests</strong></h4>
<p>با نگاهی به شکل 14.6 مشخص می‌شود که ما برای تمام بخش‌های مربوطه application، تست‌هایی داریم: خود use cases، برخی unit tests ها که بر روی چند domain object زوم می‌کنند، و integration tests ها برای port adapters. Some-
    </p>
<p><sup>7</sup>کار مورد علاقه من در این زمینه توسط Cyrille Martraire، "Living Documentation"، Addison-Wesley Professional (2019) است.
    </p>
<p><sup>8</sup>https://advwebapparch.com/repository</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0371_original/original_page.png" alt="Original Page 371">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>
        شکل 14.6 پوشش تست پس از اضافه کردن use case tests را نشان می‌دهد.
    </p>
<p>یک چیزی در اینجا از دست رفته است: یک تست که تأیید می‌کند تمام این بخش‌ها پس از اجرای application در یک production environment، به خوبی با هم کار می‌کنند. معلوم می‌شود که همیشه این خطر وجود دارد که چیزی از قلم بیفتد و شما یک application خراب را مستقر کنید. راه‌حل این است که چند end-to-end tests بنویسید که نشان می‌دهد application از یک end از application مستقر شده تا end دیگر، کار می‌کند. یعنی، اگر شما یک diagram پوشش دیگر را ترسیم کنید، یک coverage cloud را دریافت خواهید کرد که کل application، از جمله تمام actorsهای secondary آن را پوشش می‌دهد.
        در حالت ایده‌آل شما end-to-end tests های خود را در برابر چیزی که قرار است مستقر کنید، اجرا می‌کنید. اگر (تقریباً) همه چیز در environment end-to-end test شما همانند environment production شما باشد، در این صورت شما می‌توانید شانس را کاهش دهید که دوباره یک اشتباه از quality assurance خارج شده و به production server مستقر شود.
    </p>
<p>یک end-to-end test باید با application به عنوان یک black box رفتار کند. این نباید ایده‌ای از آنچه در داخل می‌گذرد داشته باشد و فقط از طریق کانال‌های public با آن صحبت کند.
        در مورد یک web application، ممکن است فقط request های HTTP را ارسال کرده و responses را بررسی کند. این نباید نگاهی به داخل database یا هر چیزی داشته باشد.
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 372" src="page_0372/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0372_original/original_page.png" alt="Original Page 372">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>برای web applications منطقی است که از چیزی مانند Panther<sup>9</sup> استفاده کنید. The dif-
        ference بین Panther و standard Symfony WebTestCase که ما در بخش 14.4 دیدیم این است که Panther به جای entry point از framework با خود web server صحبت می‌کند.</p>
<p>از آنجایی که ما در حال حاضر تست‌های زیادی برای بخش‌های مختلف application خود داریم، ما نباید دوباره هر bit از functionality را با استفاده از یک end-to-end test تست کنیم. ما فقط می‌خواهیم اطمینان خود را کمی با نشان دادن اینکه بخش‌ها به خوبی با هم کار می‌کنند، افزایش دهیم. بیشتر مشکلات wiring را می‌توان با اجرای فقط چند scenario مهم به عنوان end-to-end tests کشف کرد. هوشمندانه است که فقط چند end-to-end tests بنویسیم زیرا آن‌ها تمایل دارند کند و ناپایدار باشند. آن‌ها به دلایل بی‌شماری نامرتبط می‌شکنند، و آن دلایل اغلب اشتباهات برنامه‌نویسی یا configuration نیستند.</p>
<h4><strong>14.7. Development workflow</strong></h4>
<p>با تمام این انواع مختلف تست‌ها، سوال این است: از کجا شروع کنیم؟</p>
<p>راه‌های مختلفی برای approach توسعه یک feature وجود دارد. اگر شما application های decoupled ایجاد نمی‌کنید، یک نقطه شروع رایج این است که routing، controller و templates را تنظیم کنید. سپس شاید یک model و یک database migration برای آن. شاید سپس برخی از فرم‌ها و form validation. همه این چیزها framework-specific هستند، بنابراین اگر شما می‌خواهید application های decoupled ایجاد کنید، workflow کاملاً متفاوت خواهد بود.</p>
<p>ما یک کاتالوگ کامل از design patterns داریم که می‌توانیم از آن‌ها برای ساخت application های decoupled خود استفاده کنیم. آن‌ها می‌توانند به عنوان building blocks برای ساختن یک application از ابتدا استفاده شوند. به عنوان مثال، ما می‌توانیم با طراحی entity Order خود، شامل برخی از value objects، شروع کنیم، سپس یک repository برای آن اضافه کنیم، سپس application service را بنویسیم. اما خطر شروع با عناصر کوچکتر و کار کردن به سمت بالا این است که در نهایت ممکن است مشخص شود که شما building blocksهای اشتباه را انتخاب کرده‌اید، یا آن‌ها را به روش اشتباهی طراحی کرده‌اید.
        شما ممکن است این را خودتان کشف کنید، یا ممکن است بازخوردی از یک سهامدار دیگر دریافت کنید که از featureای که شما ساخته‌اید، راضی نیست.
    </p>
<p><sup>9</sup>https://advwebapparch.com/panther</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0373_original/original_page.png" alt="Original Page 373">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>The service container (TestServiceContainer) که در اینجا مورد استفاده قرار می‌گیرد، به این شکل است، و در این case باید یک test double را برای EbookOrderService و InvoicingService تنظیم کنیم.
        به نظر می‌رسد که ما برای پیاده‌سازی این test به تمام این عناصر نیاز داریم.
    </p>
<p>This is a good starting point, but it’s certainly not the only one. A good development workflow for applications در سطح enterprise یک workflow است که در آن شما در درجه اول به use case توجه می‌کنید. اینجوری شروع می‌شود: (1) پیدا کردن و بحث در مورد requirementsها (به صورت high-level)، و (2) توسعه کد مورد نیاز، (3) انجام تست‌های اتوماتیک برای بررسی درست بودن کد. این یک راه ایده‌آل برای شروع به نظر می‌رسد.</p>
<p>A testing strategy for decoupled applications</p>
<p>
        این chapter شامل موارد زیر است:
    </p>
<ul>
<li>چرا برای application های decoupled تست ضروری است</li>
<li>انواع مختلف تست و اینکه چگونه آن‌ها در توسعه نرم‌افزار کمک می‌کنند</li>
<li>چگونه از Hexagonal architecture برای test کردن آسان‌تر application خود استفاده کنیم</li>
<li>یک development workflow برای توسعه application های decoupled</li>
</ul>
<p>
        The core code از یک application از use cases تشکیل شده است. code infrastructure چگونگی برقراری ارتباط با دنیای بیرون و با primary و supporting actors آن را درک می‌کند. برای اینکه application شما قابل تست باشد، باید با core code و infrastructure code شروع کنید، و سپس این موارد را با هم ترکیب کنید.
    </p>
<p>بنابراین اجازه دهید این موارد را به ترتیب دنبال کنیم.</p>
<h4>
        14.1. Test core code using unit tests
    </h4>
<p>
        "چرا جداسازی کد core از infrastructure code بسیار مهم است؟"
    </p>
<p>وقتی شما بر روی یک feature جدید کار می‌کنید، به عنوان مثال: یک customer سفارش یک e-book را می‌دهد. شما به تعدادی از عناصر نرم‌افزاری نیاز دارید تا این feature را implement کنید. برای اینکه شما بتوانید این feature را به سرعت و با اطمینان develop کنید، باید قبل از شروع کار، testها را بنویسید.
    </p>
<p>
        ما یک entity Order را می‌بینیم. ما نشان داده‌ایم که به همین دلیل است که برای ایجاد یک application، یک workflow خوب برای توسعه این است: (1) نوشتن یک description از آنچه application باید انجام دهد، (2) ساختن objects که در core application شما وجود دارند، و (3) ایجاد یک interface برای برقراری ارتباط با infrastructure.
    </p>
<p>در این approach ما شروع به description از feature می‌کنیم. ما این کار را با یک test شروع می‌کنیم. اجازه دهید یک scenario از test را انتخاب کنیم:</p>
<p>Feature: Ordering an e-book</p>
<p>Scenario: the customer receives an order confirmation email</p>
<p>When a customer creates an order for an e-book</p>
<p>Then they should receive an order confirmation email</p>
<p>
        همانطور که می‌بینید، خود scenario چیزی را تست نمی‌کند. این عمدتاً برای ایجاد یک درک مشترک بین متخصصان domain و توسعه‌دهندگان نرم‌افزار مفید است.
    </p>
<p>
        “Seems interesting, where can I learn more?”
    </p>
<p>عمل توصیف features application با استفاده از scenarios های high-level که بر روی technology زوم نمی‌کنند، با نام Specification by Example، Ac-
        ceptance Test-Driven Development یا Behavior-Driven Development شناخته می‌شود. من مطمئنم که دلایل خوبی برای تمایز بین هر یک از این approaches وجود دارد، اما من فقط می‌خواستم چند نام ارائه دهم که ممکن است به شما در یافتن اطلاعات بیشتر در مورد آن کمک کند. من کتاب‌های زیر را در این موضوع توصیه می‌کنم:
    </p>
<ol>
<li>The BDD Books series by Gáspár Nagy and Seb Rose<sup>a</sup></li>
<li>Gojko Adzic, “Specification by Example”, Manning Publications (2011)</li>
</ol>
<p>
        به منظور استفاده از scenario به عنوان یک automated test، ما باید برای هر مرحله در scenario، مقداری کد بنویسیم. این کد، step definition نامیده می‌شود، و the test runner هر مرحله را با یک step definition در یک class به نام Context مطابقت می‌دهد. Listing 14.21 یک مثال را نشان می‌دهد که از Behat به عنوان test runner استفاده می‌کند.
    </p>
<p><sup>a</sup>https://advwebapparch.com/bdd-books
    </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0374_original/original_page.png" alt="Original Page 374">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>به ports adapters برای برقراری ارتباط ورودی نیاز خواهید داشت. این شامل routing، controllers, templates و غیره است. در سمت راست، شما باید adapters port برای communication outgoing را پیاده‌سازی کنید.
        این‌ها شامل repository implementations، some database migrations برای تولید، و شاید برخی از API clients برای توسعه، است. وقتی نوبت به تست کردن این port adapters می‌رسد، شما می‌توانید از پیشنهادات ارائه شده در بخش 14.2 استفاده کنید.
        در نهایت شما می‌توانید مقداری end-to-end tests را تنظیم کنید. یک گزینه جالب این است که از scenarios هایی که برای use case tests نوشته‌اید، استفاده مجدد کنید. Behat به شما اجازه می‌دهد که همان scenario را در برابر یک Context متفاوت اجرا کنید. در طول اجرای اول شما core code را با برقراری تماس با ApplicationInterface مستقیماً تست می‌کنید. در طول اجرای دوم، شما web server و هر service دیگری را که لازم است، راه‌اندازی می‌کنید و کل application را با ایجاد requests HTTP واقعی، تست می‌کنید.
    </p>
<p>برای من این approach top-down به توسعه application عالی است زیرا:</p>
<ul>
<li>با همکاری شروع می‌شود: توسعه‌دهندگان و سایر سهامداران با هم کار می‌کنند تا یک درک مشترک از آنچه باید ایجاد شود، ایجاد کنند.</li>
<li>هنگامی که توسعه‌دهندگان شروع به ساخت یک feature می‌کنند، آن‌ها ابتدا بر روی structural elements تمرکز می‌کنند، بدون اینکه هنوز آن‌ها را بسازند.</li>
<li>scenarios ها که برای ایجاد آن درک مشترک نوشته شده بودند، اکنون می‌توانند برای تأیید گام به گام راه‌حلی که پیاده‌سازی شده است، استفاده شوند؛ شما به ساختن چیز اشتباهی ختم نخواهید شد. شما به طور خودکار می‌دانید چه زمانی کار انجام می‌شود، بنابراین بیش از حد نیاز نخواهید ساخت.</li>
<li>
            با استفاده از انواع مختلف تست‌ها، شما می‌توانید بر روی بخش‌های خاصی، به عنوان مثال، objects کوچکتر مانند entities، یا adapters ports خاص، زوم کنید. شما مجبور نیستید logic domain را از طریق end-to-end tests های کند و ناپایدار تست کنید.
        </li>
<li>
            اعتماد به راه‌حل بسیار بالاست. اجرای تست suite برای یک feature داده شده، ثابت می‌کند که همه چیز کار می‌کند و به کار خود ادامه می‌دهد.
        </li>
</ul>
<h4><strong>14.8. Summary</strong></h4>
<p>تست کردن یک application decoupled نیازمند چندین نوع مختلف تست است. در وهله اول، Use case tests وجود خواهد داشت که رفتار application core را توصیف می‌کند. اجرای این تست‌ها فقط شامل core code می‌شود. شما می‌توانید spec-</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0375_original/original_page.png" alt="Original Page 375">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>در سطح core را توصیف می‌کنند. برای نشان دادن این که، core code را با هم ترکیب کنید، به منظور بررسی رفتار application.
        به نظر می‌رسد که ما می‌توانیم از unit tests برای تأیید رفتار عناصر کوچکتر مانند entities و value objects در داخل core استفاده کنیم. یک application تعدادی ports ورودی را نشان می‌دهد و به تعدادی ports خروجی نیاز دارد. The adapters برای این ports با Adapter tests تست می‌شوند. Adapter tests ها، unit tests نیستند زیرا آن‌ها شامل code infrastructure هستند. non-unit tests اغلب integration tests یا integrated tests نامیده می‌شوند. برای تأیید اینکه تمام بخش‌ها به خوبی با هم کار می‌کنند، شما می‌توانید تعدادی End-to-end tests اضافه کنید، که از application همانطور که یک user واقعی استفاده می‌کند، در یک environment که تا حد امکان environment production را شبیه‌سازی می‌کند، استفاده می‌کند.</p>
<p>Exercises</p>
<p>1. برای هر یک از موارد "things to test" زیر، تصمیم بگیرید که از چه نوع تستی (unit test، adapter test، use case test یا end-to-end test) برای آن استفاده شود.<sup>a</sup></p>
<ol>
<li>هنگامی که customer برای order پرداخت کرد، آن‌ها باید یک invoice دریافت کنند.</li>
<li>
            هنگامی که شما یک order ایجاد می‌کنید، یک رویداد OrderWasCreated ثبت می‌کند.
        </li>
<li>
            هنگامی که شما یک order را با استفاده از متد save() از repository ذخیره می‌کنید، شما می‌توانید یک object معادل را با فراخوانی متد getById() با ارائه همان OrderId دریافت کنید.
        </li>
<li>
            هنگامی که شما یک request POST را به URL /create-order ارسال می‌کنید، این باعث می‌شود که ApplicationInterface::createOrder() فراخوانی شود.
        </li>
<li>
            هنگامی که شما یک request POST را به URL /create-order ارسال می‌کنید، در این صورت صفحه /list-orders order تازه ایجاد شده را نشان می‌دهد.
        </li>
</ol>
<p>2. کدام یک از elements زیر شما برای use case tests نیاز دارید؟<sup>b</sup></p>
<ol>
<li>An interface برای application</li>
<li>یک router</li>
<li>یک service container</li>
<li>یک event dispatcher</li>
<li>یک template renderer</li>
</ol>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0376_original/original_page.png" alt="Original Page 376">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>3. کدام یک از عناصر زیر نباید unit-tested شوند؟<sup>c</sup></p>
<ol>
<li>یک controller</li>
<li>یک application service</li>
<li>یک entity</li>
<li>یک value object</li>
<li>یک repository implementation</li>
</ol>
<p><sup>a</sup> پاسخ صحیح: 1 use case test، 2 unit test، 3 adapter test (به طور خاص: a
        contract test)، 4 adapter test، 5 end-to-end test.
    </p>
<p><sup>b</sup> پاسخ صحیح: 1، 3 و 4.
    </p>
<p><sup>c</sup> پاسخ صحیح: 1. A controller باید با یک adapter test یا یک end-
        to-end test تست شود زیرا آن core code نیست. 2 یک application service، core code است، بنابراین می‌تواند unit-tested شود، اما test کردن آن به عنوان بخشی از یک use case test منطقی‌تر است.
        5 یک repository implementation، infrastructure code است، بنابراین به یک adapter
        test نیاز دارد، که یک unit test نیست، بلکه یک integration test است.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0377_original/original_page.png" alt="Original Page 377">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>15. Conclusion</strong></h3>
<p>این فصل موارد زیر را پوشش می‌دهد:</p>
<ul>
<li>Objections</li>
<li>Trade-offs</li>
</ul>
<p>ما به فصل آخر این کتاب رسیده‌ایم، و قرار نیست مفاهیم بیشتری را معرفی کنیم. من می‌خواستم از این فصل برای تأمل در مورد آنچه تاکنون مورد بحث قرار گرفته است، و برای فهمیدن اینکه آیا و چه زمانی می‌توانید از تکنیک‌های توضیح داده شده در این کتاب در پروژه‌های خود استفاده کنید، استفاده کنم.</p>
<p>هر توصیه‌ای که به شما داده می‌شود، نیاز به تجزیه و تحلیل دقیق در context شما دارد. این توصیه‌ها ممکن است در ابتدا به نظر درست و شهودی برسند، اما هنگام در نظر گرفتن جزئیات خاص پروژه شما، وضعیت کاری خودتان و غیره، ممکن است این توصیه‌ها مشکل‌ساز باشد. شما ممکن است نگران باشید که دنبال کردن توصیه‌ها، تلاش زیادی را می‌طلبد. شاید شما از قبل می‌دانید که برخی از اعضای تیم در پیروی از آن مشکل خواهند داشت. و شاید شما از "انجام اشتباه آن" می‌ترسید و این مانع از اتمام پروژه شما می‌شود.</p>
<p>اگر شما این کتاب را به عنوان توصیه‌های من برای طراحی application خود به یک روش خاص در نظر می‌گیرید، در این صورت شما ممکن است گاهی اوقات آن را زیر سوال برده باشید. البته من مطمئن نیستم که questions یا objections شخصی شما چیست، اما من برخی از questionsها را از خوانندگان و شرکت‌کنندگان کارگاه جمع‌آوری کرده‌ام و در این فصل به آن‌ها پاسخ خواهم داد، به این امید که آن‌ها نیز پاسخ‌هایی را به شما ارائه دهند. اگر این امر باعث می‌شود که برخی از سوالات شما بی‌پاسخ بمانند، دریغ نکنید و مستقیماً با من تماس بگیرید و آن‌ها را بپرسید.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0378_original/original_page.png" alt="Original Page 378">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h4><strong>15. Conclusion</strong></h4>
<h4><strong>15.1. Is a decoupled architecture the right choice for all
            projects?</strong></h4>
<p>آیا چیزی بدون هیچ گونه qualification برای همه موقعیت‌ها صدق می‌کند؟ من فکر می‌کنم که این سوال همیشه باید با "No" پاسخ داده شود. با کلمات معروفی که اغلب توسط توسعه‌دهندگان نرم‌افزار استفاده می‌شود: "There’s no silver bullet". با این حال، برخی از practices وجود دارند که به‌طور قابل‌توجهی بهتر از بقیه هستند. و ما خوش شانس هستیم که تحقیقاتی داریم که این را تأیید می‌کند<sup>1</sup>. وقتی صحبت از معماری decoupled می‌شود، من تحقیقات گسترده‌ای انجام ندادم اما می‌دانم که قطعاً نباید در همه جا اعمال شود. به عنوان مثال، من متوجه شدم که یک application single job، مانند applicationی که URLs را از manuscript این کتاب استخراج می‌کند و یک link registry برای آن راه‌اندازی می‌کند، واقعاً شایسته decoupled شدن نیست. شاید این واقعیت است که کار آن به هر حال صرفاً به infrastructure مربوط می‌شود. شاید به این دلیل است که برای تلاش، بسیار کوچک است.</p>
<p>بیایید به برخی از انواع دیگر applications که ممکن است با یک معماری decoupled بهتر نباشند، نگاهی بیندازیم.</p>
<h4><strong>15.2. My application is not supposed to live longer than
            two years</strong></h4>
<p>یک دلیل برای نادیده گرفتن توصیه من این است که اگر application شما قرار نیست بیشتر از، مثلاً، دو سال دوام داشته باشد. من متوجه هستم که یادگیری یک سبک معماری جدید، آموزش آن به کل تیم، و پیاده‌سازی آن در یک پروژه کوتاه مدت، ممکن است زمان بیشتری نسبت به زمانی که شما فقط همه چیز را به روشی که اکنون انجام می‌دهید، انجام دهید. به عبارت دیگر، هزینه‌ها از مزایای چنین پروژه‌ای بیشتر نیست. اگر شما کاملاً مطمئن هستید که پروژه در عرض چند سال کنار گذاشته می‌شود، من موافقم. اما شما همیشه نمی‌توانید پیش‌بینی کنید که یک application چقدر عمر خواهد کرد. ممکن است به عنوان یک "proof of concept" شروع شود. به بدترین حالت طراحی شده است، به طور ضعیفی برنامه‌ریزی شده است، فقط برای کمک به سهامداران پروژه برای اثبات برخی از نکات. سپس business شروع به کسب درآمد با آن می‌کند و پروژه باید کمی بیشتر زنده بماند. در مقطعی، افزودن functionality جدید واقعاً مشکل‌ساز می‌شود.</p>
<p><sup>1</sup>به عنوان مثال به Nicole Forsgren, Jez Humble, Gene Kim, “Accelerate”, IT Revolution Press (2018) مراجعه کنید.</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0379_original/original_page.png" alt="Original Page 379">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>این مشکل شناخته شده‌ای با نرم‌افزار است و من را بر این باور داشته است که بهتر است از رها کردن practices خاص، زیرا شما فکر می‌کنید که نوع پروژه ممکن است به اندازه کافی طول عمر نداشته باشد تا شایسته آن‌ها باشد، خودداری کنید.
        به عنوان مثال، من فکر می‌کنم testing خودکار هرگز نباید "optional" در نظر گرفته شود.
        آنچه به شما بستگی دارد، نوع تست‌هایی است که شما ایجاد می‌کنید. در فصل 14 ما یک strategy برای testing applications های decoupled را مورد بحث قرار دادیم که ممکن است برای این پروژه‌های POC اعمال نشود. اگر شما (در حال حاضر) به داشتن یک Domain و Application layer decoupled یا ports و adapters های قابل تشخیص توجهی ندارید، در این صورت شما حتی این امکان را ندارید که این عناصر را در isolation تست کنید. در این case شما همچنان باید end-to-end tests ها را بنویسید تا حداقل نوعی confidence در application خود، اکنون و در آینده داشته باشید.</p>
<p>با این حال، فقط از مشکلات کلاسیک با end-to-end tests آگاه باشید: آن‌ها کند و شکننده‌اند، و در عرض چند سال، آن‌ها به یک maintenance burden واقعی تبدیل خواهند شد. بنابراین توصیه من این است که در مقطعی application را decoupled کنید، حتی اگر business به مدت چند سال software را با موفقیت اجرا کرده باشد. شما باید مطمئن شوید که هر سهامدار از نیاز به سخت کار کردن، و ادامه سخت کار کردن، برای حفظ نرم‌افزار در بلندمدت آگاه است (به شکل کاملاً غیرعلمی 15.1 مراجعه کنید).</p>
<p>
<img alt="Figure 15.1. Effort needed from developers vs. the effect they produce." src="https://via.placeholder.com/300"/>
<figcaption>شکل 15.1. Effort مورد نیاز از توسعه‌دهندگان در مقابل effectهایی که تولید می‌کنند.</figcaption>
</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 380" src="page_0380/image_1.png"/></div>
</div>
            </div>
            <div class="page original-page">
                <img src="page_0380_original/original_page.png" alt="Original Page 380">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h4><strong>15. Conclusion</strong></h4>
<h4><strong>15.3. My application offers only CRUD functionality</strong></h4>
<p>یک دلیل دیگر برای نادیده گرفتن این کتاب این است که اگر application شما فقط functionality از نوع CRUD ارائه می‌دهد. یعنی اگر application شما می‌تواند بر اساس یک configuration file که models، fields و types آن‌ها، و form field types و validation rules که برای آن‌ها اعمال می‌شود را توصیف می‌کند، تولید شود. این applications وجود دارند. در واقع، من بسیاری از آن‌ها را ساخته‌ام و کاملاً موافقم: آن‌ها شایسته یک معماری decoupled نیستند.</p>
<p>با این حال، من همچنین چندین application را دیده‌ام که به عنوان pure CRUD applications شروع شدند، اما خیلی زود مشخص شد که CRUD یک راه بسیار محدود برای مدل‌سازی business domain application است. Models های CRUD، به خوبی از domain invariants خود محافظت نمی‌کنند. آن‌ها اغلب هیچ نوع actionای را روی خود تعریف نمی‌کنند. آن‌ها از خود در برابر state transitions نامعتبر محافظت نمی‌کنند، و آن‌ها domain events تولید نمی‌کنند. اما منطق domain و process همچنان باید در جایی پیاده‌سازی شود، بنابراین بخش زیادی از این logic در داخل controllers و framework یا ORM-specific event listeners قرار می‌گیرد. پروژه به هم می‌ریزد، و به زودی شما آرزو می‌کنید که در واقع همه چیز را به روشی decoupled طراحی کرده بودید. تنها چیزی که من می‌گویم این است: قبل از اینکه تصمیم بگیرید که پروژه فقط CRUD است و شایسته یک معماری decoupled نیست، یک نگاه طولانی و سخت داشته باشید.</p>
<h4><strong>15.4. My application is a legacy application</strong></h4>
<p>یک اعتراض رایج دیگر به اعمال سبک معماری توضیح داده شده در این کتاب این است: ما در یک پروژه brownfield زندگی می‌کنیم، ما هرگز نمی‌توانیم به این هدف برسیم.
        من نیز تجربه زیادی با پروژه‌های legacy دارم، و گاهی اوقات مثبت ماندن برایم دشوار است. نیرویی که شما را به پایین می‌کشد، بسیار قوی است. مقاومت در برابر ادعای ورشکستگی سخت است. در عین حال، من می‌دانم که همیشه فضایی برای بهبود وجود دارد. و پیشنهاد مخفی من برای شما این است که برای همه چیز اجازه نخواهید. اگر این به قابل تحمل‌تر کردن کار شما کمک می‌کند، و اگر به شما کمک می‌کند که چیزهای بهتری را سریع‌تر ارائه دهید، مطمئن شوید که کمی زمان را صرف بهبود برخی از جنبه‌های code base که روی آن کار می‌کنید، می‌کنید. تست‌ها را آسان‌تر کنید. کلاس‌ها را آسان‌تر انتقال و تغییر نام دهید، typesهای parameter و return را اضافه کنید تا کد شما قابل کشف‌تر شود. فقط ساعت‌ها یا روزها پشت سر هم صرف نکنید. همچنین، تغییرات زیادی را یکباره ایجاد نکنید، همه چیز را خراب نکنید،</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0381_original/original_page.png" alt="Original Page 381">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<p>و همه را عصبانی می‌کنید. پروژه خود را فقط کمی هر روز بهبود بخشید.
        application legacy شما هرگز به طور کامل decoupled نخواهد بود، اما نیازی هم به این کار نیست. بسیاری از بخش‌های application، در اکثر مواقع دست نخورده باقی می‌مانند، بنابراین بهبود آن بخش‌ها و به خطر انداختن همه چیز، حتی ارزش وقت شما را ندارد.</p>
<h4><strong>15.5. I can never make my entire application decoupled</strong></h4>
<p>ناتوانی در عالی کردن کل application خود، یک objection دیگر به شروع با the decoupled architecture approach در وهله اول است.
        من فکر می‌کنم این احساس را می‌توان در سایر زمینه‌های توسعه نرم‌افزار نیز یافت، نه فقط در معماری. تنظیم یک coding standard، نصب ابزارهای static analysis، این موارد برای همیشه به تعویق می‌افتند زیرا شما می‌ترسید که هرگز نتوانید آن‌ها را در همه جا اعمال کنید. The urge for consistency چیزی است که در تیم‌های توسعه نرم‌افزار زیاد مزاحمت ایجاد می‌کند. چرا امروز شروع نکنیم؟
        هر بهبودی که می‌توانید ایجاد کنید، حتی اگر فقط در یک ماژول باشد، می‌تواند نقطه شروع یک زندگی بهتر برای همه اعضای تیم، و برای خود application نیز باشد. تلاش برای اعمال یک ایده طراحی خوب در همه جا، اتلاف وقت است، اما عدم اعمال آن در هر جایی، یک فرصت تلف شده است.</p>
<h4><strong>15.6. Isn’t this over-engineering?</strong></h4>
<p>وقتی شما تنها فردی در تیم هستید که سعی در اعمال این design ideasها در همه جا دارد، ممکن است با مقاومت روبرو شوید. همه آن classesهای اضافی، و تست‌های اضافی! چرا فقط آن را به روشی که frameworks به ما می‌گوید انجام ندهیم؟ چرا فقط تست‌های functional را ننویسیم و کار را تمام نکنیم؟ من امیدوارم که این کتاب قبلاً بیشتر پاسخ‌ها را ارائه داده باشد. اما برای رسیدگی به "over-engineering objection": من امیدوارم که من همچنین توانسته باشم به شما نشان دهم که آن classes، interfaces و تست‌های اضافی، شایسته حضور هستند. آن‌ها نتیجه ایجاد یک تمایز بین core و infrastructure code هستند. جدا نگه داشتن این موارد نیاز به عناصر اضافی در نرم‌افزار شما دارد. اگر شما احساس می‌کنید که core و infrastructure باید از هم جدا شوند، انجام آن کار اضافی را نمی‌توان over-engineering در نظر گرفت. در عوض، این just-right-engineering است. و از آنجایی که من معتقدم که اکثر web applications، پروژه‌های کوتاه مدت نیستند، و نه فقط CRUD-only، من معتقدم که ما</p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0382_original/original_page.png" alt="Original Page 382">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>15. Conclusion</strong></h3>
<p>ما تا حد زیادی web applications خود را under-engineering کرده‌ایم، و زمان آن فرا رسیده است که کار بهتری انجام دهیم.
        در حالی که سعی می‌کنید این کار را انجام دهید، امیدوارم که شما به cost و benefits از آنچه انجام می‌دهید، توجه کنید. من امیدوارم که شما در کار خود عمل‌گرا باشید و از dogmatism دوری کنید. من امیدوارم که شما به آزمایش ادامه دهید و از اشتباه کردن نترسید. من امیدوارم که شما در تلاش‌های خود موفق شوید.</p>
<p>بهترین موفقیت‌ها،</p>
<p>Matthias</p>
<p>P.S. به من اطلاع دهید که چگونه پیش رفت! </p>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0383_original/original_page.png" alt="Original Page 383">
            </div>
        </div>
        <div class="dual-page-spread">
            <div class="page persian-page">
                <div class="translated-content">
<div>
<h3><strong>15. Conclusion</strong></h3>
</div>
</div>
                <div class="page-images">
</div>
            </div>
            <div class="page original-page">
                <img src="page_0384_original/original_page.png" alt="Original Page 384">
            </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>