<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 371</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        ConfirmationEmail() method. باز هم، این متد اجرا می‌شود. شامل دو assertion است که ممکن است باعث پرتاب exceptions شود. اینکه آیا این اتفاق می‌افتد یا نه، موفقیت scenario را تعیین می‌کند.
    </p>
    <p>به نظر من استفاده از Gherkin برای توصیف use cases مزایای زیادی دارد. فقط به چند مورد اشاره می‌کنم:</p>
    <ol>
        <li>بیان ویژگی‌های application شما با terms های abstract، high-level آسان‌تر است، و جزئیات implementation را حذف می‌کند.</li>
        <li>مشخص کردن رفتار application در موقعیت‌های کمی متفاوت آسان‌تر است.</li>
        <li>Scenariosها را می‌توان بدون کد اساسی نوشت، بنابراین شما می‌توانید درک خود را از features با سایر سهامداران، که ممکن است چیزی در مورد برنامه‌نویسی ندانند، اعتبار دهید.</li>
        <li>
            scenariosها مستندات آنچه که application شما می‌تواند انجام دهد، هستند، آن‌ها مشخص می‌کنند که چه کاری باید انجام دهد، و از آنجایی که اتوماسیون در پشت آن‌ها وجود دارد، آن‌ها می‌توانند تأیید کنند که آنچه مستند و مشخص شده است در واقع در مورد application شما درست است. این باعث می‌شود که این یک فرم از Living documentation<sup>7</sup> باشد.
        </li>
    </ol>
    <p>شکل 14.6 نشان می‌دهد که چه بخش‌هایی از application تاکنون با تست پوشش داده شده‌اند.</p>
    <p>در مورد Behat، نوشتن scenarios و خودکارسازی آن‌ها، چیزهای بیشتری وجود دارد که باید گفت، اما این فراتر از محدوده این کتاب است. اگر علاقه‌مند هستید، شما می‌توانید برخی از مثال‌های بیشتر از use case tests را در demo project<sup>8</sup> که همراه این کتاب است، بیابید.</p>
    <h4><strong>14.6. End-to-end tests</strong></h4>
    <p>با نگاهی به شکل 14.6 مشخص می‌شود که ما برای تمام بخش‌های مربوطه application، تست‌هایی داریم: خود use cases، برخی unit tests ها که بر روی چند domain object زوم می‌کنند، و integration tests ها برای port adapters. Some-
    </p>
    <p><sup>7</sup>کار مورد علاقه من در این زمینه توسط Cyrille Martraire، "Living Documentation"، Addison-Wesley Professional (2019) است.
    </p>
    <p><sup>8</sup>https://advwebapparch.com/repository</p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>