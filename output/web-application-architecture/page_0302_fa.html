<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 302</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        <img src="https://via.placeholder.com/300" alt="Figure 12.1. Controllers contain all business logic and become too big. Mod-els are only simple data holders.">
        <figcaption>شکل 12.1. Controllers شامل تمام business logic می‌شوند و بیش از حد بزرگ می‌شوند. Models فقط data holders ساده هستند.</figcaption>
    </p>
    <p>
        این حرکت چندان موفقیت‌آمیز نبوده است زیرا services استخراج شده، واقعاً از framework جدا نشده‌اند. آن‌ها هنوز به session یا current web request متکی هستند. methods در این services اغلب حول یک مفهوم domain خاص گروه‌بندی می‌شوند و سعی می‌کنند هم business logic و هم persistence logic را برای این مفهوم خاص مدیریت کنند. این services (گاهی اوقات حتی "managers" نامیده می‌شوند) سپس بیش از حد بزرگ می‌شوند و غیرقابل مدیریت می‌شوند. دلیل دیگر برای شکست در این زمینه این است که domain models هنوز هم data holders ساده باقی می‌مانند و نمی‌توانند از هیچ یک از invariants خود محافظت کنند، و نه هیچ قانون business را به تنهایی پیاده‌سازی کنند. این دوباره منجر به services می‌شود که کارهای زیادی برای انجام دادن دارند، و بیش از حد بزرگ می‌شوند که بتوانند با آن‌ها مقابله کنند (به شکل 12.2 مراجعه کنید). بنابراین دلیل شروع استفاده از services خوب است (ما نمی‌خواهیم controllers ما پر از business logic باشد)، اما معمولاً این implementation است که فاقد آن است. بدون decoupling service از framework، بدون جداسازی domain logic از persistence logic، و بدون برداشتن گام اضافی تعریف richer domain objects، نتیجه فاجعه‌بار خواهد بود.
    </p>
    <p>بنابراین حتی پس از اختراع یک "service layer" اضافی، MVC هنوز هم کمبود دارد. به عنوان مثال، به ما کمک نمی‌کند تا یک use case را در یک primary action و effects های secondary آن جدا کنیم. Services معمولاً در نهایت methods بزرگی دارند که شروع به پردازش یک request می‌کنند و تمام tasks های secondary را در همان method انجام می‌دهند (یا اگر شما "خوش شانس" باشید، در methods خصوصی از همان class). این services ممکن است حتی به بخش‌های remote از code base دسترسی پیدا کنند تا کارهای مرتبط از راه دور را انجام دهند.</p>
</div>

        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0302/image_1.png" alt="Image from page 302" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>