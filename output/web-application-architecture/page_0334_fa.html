<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 334</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <pre><code class="language-php">
return new Response(/* ... */);
}
</code></pre>
    <p>ما مجبور نیستیم خودمان را به handling commands محدود کنیم. The “command” bus می‌تواند queriesهایی مانند listAvailableEbooks() را نیز handle کند. شاید در آن صورت باید فقط "bus" یا "message bus" نامیده شود.</p>
    <p>The downside از استفاده از یک interface عمومی مانند CommandBus این است که ما the parameter و return types را که در Application-
        Interface خاص‌تر داریم، از دست می‌دهیم. اما وقتی صحبت از testing می‌شود، CommandBus همان مزیت را دارد که ApplicationInterface. همچنین این یک چیز واحد است که شما می‌توانید هنگام تست کردن incoming port adapters بدون فراخوانی کد در داخل هگزاگون، جایگزین کنید.</p>
    <p>اکنون که ما interfaces را برای هر دو ports های incoming و outgoing داریم، و برخی از نمونه‌های هر دو incoming و outgoing port adapters را دیده‌ایم، روشن است که رابطه بین port و adapter در هر دو مورد متقارن نیست. برای outgoing ports، application (یا هگزاگون) شامل یک interface (OrderRepository, VatRateProvider) است که adapter باید یک implementation را با پیاده‌سازی interface ارائه دهد. برای incoming ports، application همچنین شامل یک interface (به عنوان مثال ApplicationInterface| یا CommandBus) است اما adapters این interface را پیاده‌سازی نمی‌کنند، بلکه از آن استفاده می‌کنند.</p>
    <h4><strong>13.6. Combining ports and adapters with layers</strong></h4>
    <p>در فصل 12 ما یک system layering را برای applications معرفی کردیم، که شامل یک Domain, Application و Infrastructure layer است. Hexagonal architecture با یک معماری لایه‌ای متعامد است. این بدان معناست که شما می‌توانید hexagonal architecture، یک معماری لایه‌ای، یا هر دو را اعمال کنید. هیچ کدام دیگری را القا نمی‌کنند. با این حال، آن‌ها ریشه یکسانی دارند: تمایل به جداسازی pure use cases از infrastructural concerns. به همین دلیل است که من فکر می‌کنم آن‌ها با هم خوب هستند.</p>
    <p>یک application می‌تواند layers داشته باشد و در عین حال ports و adapters را به صراحت تعریف کند. شکل 13.4 نشان می‌دهد که چگونه layers، ports و adapters می‌توانند ترکیب شوند. هگزاگون داخلی شامل use cases application است که تقسیم شده است</p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>