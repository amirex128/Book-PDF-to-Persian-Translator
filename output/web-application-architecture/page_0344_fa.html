<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 344</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>فقط "adapters". به همین دلیل است که برای من منطقی است که این تست‌ها را Adapter tests بنامم. آن‌ها ثابت می‌کنند که یک adapter به درستی کار می‌کند. از آنجایی که دو نوع port وجود دارد، incoming و outgoing، جای تعجب نیست که دو نوع تست adapter نیز وجود دارد.</p>
    <h4><strong>14.3. Contract tests for outgoing port adapters</strong></h4>
    <p>Outgoing ports، ports هایی هستند که در آن application نیاز به ارتباط با برخی از external system ها، مانند یک database یا یک webservice remote دارد. Outgoing ports با interfaces جداگانه، مانند OrderRepository که می‌تواند یک entity را ذخیره کند، و VatRateProvider که ما قبلاً برای تعیین VatRate یک محصول استفاده کردیم، تعریف می‌شوند. این interfaces به عنوان یک abstraction معرفی شدند که به ما اجازه می‌داد تا core code را از infrastructure code جدا کنیم.
        The interface، communication با external system را با یک implementation fake آسان می‌کند که ما می‌توانیم در تست‌های use case خود از آن استفاده کنیم (به بخش 14.5 مراجعه کنید). اما interface همچنین یک contract را تعریف می‌کند که همه چیزهایی را که ما از یک implementation می‌خواهیم، توصیف می‌کند. The contract برای OrderRepository این است که می‌تواند یک entity Order را ذخیره کند و اگر شما متد getById() آن را فراخوانی کنید، شما می‌توانید یک object معادل را از آن دریافت کنید. این مفید است که contract را به وضوح مشخص و مستند کنید، زیرا خود interface نمی‌تواند این موارد را منتقل کند. تنها چیزی که می‌توان در مورد خود آن توصیف کرد، متدهایی است که دارد، return types آن‌ها و parameter types آن‌ها. یک option این است که رفتار را با استفاده از مستندات درون خطی مستند کنید، اما در واقع استفاده از یک contract test برای توصیف contract قدرتمندتر است. Listing 14.3 نشان می‌دهد که این چگونه به نظر می‌رسد.</p>
    <p>Listing 14.3. بخشی از contract test برای OrderRepository.</p>
    <pre><code class="language-php">
use PHPUnit\Framework\TestCase;
final class OrderRepositoryContractTest extends TestCase
{
    /**
     * @test
     * @dataProvider orders
     */
    public function it_can_save_and_load_order_entities(Order $order): void
    {
</code></pre>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>