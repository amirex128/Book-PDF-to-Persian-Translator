<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 261</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        Stopwatch در production، البته currentTimestamp() را روی TimerUsesSystemClock به جای FakeTimer فراخوانی می‌کند. یک dependency injection container معمولاً از setup واقعی object service شما مراقبت می‌کند، از جمله هر یک از dependencies آن. شکل 9.10 تفاوت بین هر دو perspective را نشان می‌دهد.
    </p>
    <p>
        <img src="https://via.placeholder.com/300" alt="Figure 9.10. The code of Stopwatch depends only on the Timer inter-face, but at runtime the Stopwatch will use an object of type TimerUsesSystemClock, without being aware of that.">
        <figcaption>شکل 9.10. کد Stopwatch فقط به interface Timer وابسته است، اما در runtime، Stopwatch از یک object از نوع TimerUsesSystemClock استفاده می‌کند، بدون اینکه از آن آگاه باشد.</figcaption>
    </p>
    <p>
        من متوجه شدم که وقتی از یک سطح پایین، سطح classes و methods شروع می‌کنید و هدف شما این است که تا حد امکان کد object-pure بنویسید، در حالی که تمام موارد مرتبط با infrastructure را به کناره‌ها می‌برید، در نهایت به یک طراحی بسیار بهتر در یک سطح بالاتر نیز خواهید رسید. به همین دلیل است که من این کتاب را فقط با تمرکز بر core در مقابل infrastructure به جای مفاهیم معماری مانند layering و ports و adapters شروع کرده‌ام. البته ما در بخش دوم در مورد این مفاهیم بحث خواهیم کرد، اما برد بزرگ، جداسازی core از infrastructure code است. بقیه موارد خوب هستند و شما بقیه را کم و بیش رایگان دریافت خواهید کرد.
    </p>
    <h4><strong>9.6. Summary</strong></h4>
    <p>در این فصل، ما تعریف core code را به عنوان کدی که use cases یک application را نشان می‌دهد، دوباره بیان کردیم. Infrastructure code کدی است که این use cases را به actors خارجی آن متصل می‌کند. Actors می‌تواند primary actors (users application) یا secondary/supporting actors (سیستم‌های دیگری که application ما از آن‌ها استفاده می‌کند) باشد. برای decoupling از primary actors، ما باید use cases خود را بدون توجه به مکانیزم تحویلی که یک نوع خاص از actor پشتیبانی می‌کند، به طور universal invokable کنیم. برای decoupling از secondary actors، ما</p>
</div>

        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0261/image_1.png" alt="Image from page 261" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>