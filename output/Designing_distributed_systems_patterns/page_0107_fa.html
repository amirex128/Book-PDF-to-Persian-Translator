<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 107</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h3><strong>CHAPTER 9</strong></h3>
  <h4><strong>Ownership Election</strong></h4>
  <p>
   الگوهای قبلی که ما دیده‌ایم، در مورد توزیع requests ها برای scale کردن requests ها در ثانیه، state در حال service داده شدن، یا زمان پردازش یک request بوده‌اند. این فصل پایانی در مورد الگوهای serving چند node، در مورد نحوه scale کردن assignment است. در بسیاری از systems های مختلف، یک مفهوم از ownership وجود دارد که در آن یک process خاص، یک task خاص را بر عهده دارد. ما قبلاً این را در context از systems های sharded و hot-sharded دیده‌ایم که در آن instances های خاص، بخش‌های خاصی از space key sharded را در اختیار داشتند.
  </p>
  <p>
   در context یک server واحد، ownership به طور کلی ساده است زیرا فقط یک application واحد وجود دارد که ownership را ایجاد می‌کند، و می‌تواند از locks های in-process تثبیت شده برای اطمینان از اینکه فقط یک actor واحد، یک shard یا context خاص را در اختیار دارد، استفاده کند. با این حال، محدود کردن ownership به یک application واحد، scalability را محدود می‌کند، زیرا task نمی‌تواند replicated شود، و reliability را نیز محدود می‌کند، زیرا اگر task با شکست مواجه شود، برای مدتی در دسترس نخواهد بود. در نتیجه، هنگامی که ownership در system شما مورد نیاز است، شما نیاز به توسعه یک system توزیع‌شده برای ایجاد ownership دارید.
  </p>
  <p>
   یک نمودار عمومی از distributed ownership در Figure 9-1 نشان داده شده است. در نمودار، سه replica وجود دارد که می‌تواند owner یا master باشد. در ابتدا، اولین replica master است. سپس آن replica با شکست مواجه می‌شود، و replica شماره سه، master می‌شود. در نهایت، replica شماره یک بازیابی می‌شود و به گروه بازمی‌گردد، اما replica سه به عنوان master/owner باقی می‌ماند.
  </p>
  <p>
   93
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>