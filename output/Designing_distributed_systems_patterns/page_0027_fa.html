<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 27</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        زیرا چنین API هم توسط سهولت استفاده و هم توانایی افزودن اتوماسیون مانند rollback، که پیکربندی (و دوباره پیکربندی) را ایمن‌تر و آسان‌تر می‌کند، هدایت می‌شود.
    </p>
    <p>
        مشابه مورد HTTPS، applications جدید را می‌توان با این انتظار نوشت که configuration یک property dynamic است که باید با استفاده از یک cloud API بدست آید، اما تطبیق و به روزرسانی یک application موجود می‌تواند به طور قابل توجهی چالش برانگیزتر باشد. خوشبختانه، sidecar pattern دوباره می‌تواند برای ارائه functionality جدیدی استفاده شود که یک application legacy را بدون تغییر application موجود، افزایش می‌دهد. برای sidecar pattern نشان داده شده در شکل 2-3، دوباره دو container وجود دارد: container که application را سرویس می‌دهد و container که configuration manager است.
    </p>
    <p>
        دو containers با هم در یک pod گروه بندی شده‌اند، جایی که یک directory را بین خود به اشتراک می‌گذارند. این shared directory جایی است که configuration file نگهداری می‌شود.
    </p>
    <p>
        هنگامی که application legacy شروع می‌شود، configuration خود را از filesystem، همانطور که انتظار می‌رود، بارگذاری می‌کند. هنگامی که configuration manager شروع به کار می‌کند، API configuration را بررسی می‌کند و به دنبال تفاوت‌هایی بین filesystem local و configuration ذخیره شده در API می‌گردد. اگر تفاوت‌هایی وجود داشته باشد، configuration manager configuration جدید را در filesystem local دانلود می‌کند و به application legacy signal می‌دهد که باید خود را با این configuration جدید دوباره پیکربندی کند. مکانیزم واقعی برای این notification بسته به application متفاوت است. برخی از applications در واقع configuration file را برای تغییرات نظارت می‌کنند، در حالی که بقیه به یک signal SIGHUP پاسخ می‌دهند. در موارد شدید، configuration manager ممکن است یک سیگنال SIGKILL را برای متوقف کردن application legacy ارسال کند. پس از متوقف شدن، system container orchestration application legacy را مجدداً راه‌اندازی می‌کند، که در این مرحله configuration جدید خود را بارگذاری می‌کند. همانند افزودن HTTPS به یک application موجود، این pattern نشان می‌دهد که چگونه sidecar pattern می‌تواند به تطبیق applications از پیش موجود با سناریوهای cloud-native بیشتر کمک کند.
    </p>
    <p style="text-align: center;">
        <em style="font-style: italic;">Figure 2-3. A sidecar example of managing a dynamic configuration</em>
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0027/image_1.png" alt="Image from page 27" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>