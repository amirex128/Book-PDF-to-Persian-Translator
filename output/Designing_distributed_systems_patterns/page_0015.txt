CHAPTER 1
Introduction
Today’s world of always-on applications and APIs have availability and reliability
requirements that would have been required of only a handful of mission critical
services around the globe only a few decades ago. Likewise, the potential for rapid,
viral growth of a service means that every application has to be built to scale nearly
instantly in response to user demand. These constraints and requirements mean that
almost every application that is built—whether it is a consumer mobile app or a back‐
end payments application—needs to be a distributed system.
But building distributed systems is challenging. Often, they are one-off bespoke solu‐
tions. In this way, distributed system development bears a striking resemblance to the
world of software development prior to the development of modern object-oriented
programming languages. Fortunately, as with the development of object-oriented lan‐
guages, there have been technological advances that have dramatically reduced the
challenges of building distributed systems. In this case, it is the rising popularity of
containers and container orchestrators. As with the concept of objects within object-
oriented programming, these containerized building blocks are the basis for the
development of reusable components and patterns that dramatically simplify and
make accessible the practices of building reliable distributed systems. In the following
introduction, we give a brief history of the developments that have led to where we
are today.
A Brief History of Systems Development
In the beginning, there were machines built for specific purposes, such as calculating
artillery tables or the tides, breaking codes, or other precise, complicated but rote
mathematical applications. Eventually these purpose-built machines evolved into
general-purpose programmable machines. And eventually they evolved from running
1
