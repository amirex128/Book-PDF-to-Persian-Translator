<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 73</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h3><strong>CHAPTER 6</strong></h3>
  <h4><strong>Sharded Services</strong></h4>
  <p>
   در فصل قبل، ما ارزش replicating service stateless را برای reliabil و redundancy و scaling دیدیم. این فصل، service های sharded را در نظر می‌گیرد. با service های replicated که ما در فصل قبل معرفی کردیم، هر replica کاملاً homogeneous بود و قادر به service دادن به هر request ای بود. در مقابل service های replicated، با service های sharded، هر replica یا shard، تنها قادر به service دادن به یک subset از همه requests ها است. یک node load-balancing یا root، مسئول بررسی هر request و توزیع هر request به shard یا shards مناسب برای پردازش است. تفاوت بین service های replicated و sharded در Figure 6-1 نشان داده شده است.
  </p>
  <p>
   <em>Figure 6-1. Replicated service versus sharded service</em>
  </p>
  <p>
   service های Replicated به طور کلی برای ساختن service های stateless استفاده می‌شوند، در حالی که service های sharded به طور کلی برای ساختن service های stateful استفاده می‌شوند. دلیل اصلی برای sharding data این است که اندازه state برای اینکه توسط یک machine واحد service داده شود، بسیار بزرگ است. Sharding به شما این امکان را می‌دهد که یک service را در پاسخ به اندازه state که باید service داده شود، scale کنید.
  </p>
  <h4><strong>Sharded Caching</strong></h4>
  <p>
   برای نشان دادن کامل طراحی یک system sharded، این بخش یک deep dive را به طراحی یک system sharded caching ارائه می‌دهد. یک sharded cache، یک cache است که در
   59
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0073/image_1.png" alt="Image from page 73" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>