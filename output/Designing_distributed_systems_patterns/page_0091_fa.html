<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 91</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   shard، که در shard patent خود به دنبال patent هایی می‌گردد که با کلمه موجود در query مطابقت دارند. هر match ای که پیدا می‌شود، در پاسخ به request shard به root node برگردانده می‌شود. سپس root node، همه این responses ها را با هم جمع می‌کند تا یک response واحد ایجاد کند که شامل تمام patent هایی است که با کلمه خاص مطابقت دارند. عملکرد این search index در Figure 7-3 نشان داده شده است.
  </p>
  <h4><strong>Hands On: Sharded Document Search</strong></h4>
  <p>
   مثال قبلی، requests های term های مختلف را در سراسر cluster پخش کرد، اما این فقط در صورتی کار می‌کند که تمام documents ها در تمام machine های موجود در درخت scatter/gather وجود داشته باشند. اگر فضای کافی برای همه documents ها در تمام leaves های موجود در درخت وجود نداشته باشد، پس sharding باید برای قرار دادن مجموعه‌های مختلفی از documents ها بر روی leaves های مختلف استفاده شود.
  </p>
  <p>
   این بدان معنی است که وقتی یک user درخواستی را برای تمام documents هایی که با کلمات "cat" و "dog" مطابقت دارند، انجام می‌دهد، درخواست در واقع به هر leaf در system scatter/gather ارسال می‌شود. هر leaf node، مجموعه documents هایی را که در مورد آنها می‌داند که با "cat" و "dog" مطابقت دارند، برمی‌گرداند. قبلاً، root node مسئول انجام intersection از دو مجموعه documents بود که برای دو کلمه مختلف برگردانده شد. در مورد sharded، root node مسئول ایجاد union از تمام documents هایی است که توسط تمام shards های مختلف برگردانده می‌شود و این مجموعه کامل از documents را به user برمی‌گرداند.
  </p>
  <p>
   در Figure 7-3، اولین leaf، documents 1 تا 10 را service می‌دهد و {doc1, doc5} را برمی‌گرداند. دومین leaf، documents 11 تا 20 را service می‌دهد و {doc15} را برمی‌گرداند. سومین leaf، documents 21 تا 30 را service می‌دهد و {doc22, doc28} را برمی‌گرداند. root، همه این responses ها را با هم ترکیب می‌کند تا یک response واحد ایجاد کند و {doc1, doc5, doc15, doc22, doc28} را برمی‌گرداند.
  </p>
  <p>
   <em>Figure 7-3. Conjunctive query executing in a scatter/gather search system</em>
  </p>
  <p>
   Scatter/Gather with Leaf Sharding
   | 77
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0091/image_1.png" alt="Image from page 91" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>