<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 47</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        این اطمینان می‌دهد که یک adapter نظارتی بد رفتار نمی‌تواند باعث ایجاد مشکل در یک service با user-facing شود.
    </p>
    <h4 style="font-weight: bold;">Hands On: Using Prometheus for Monitoring</h4>
    <p>
        به عنوان مثال، نظارت بر containers خود را از طریق پروژه open source Prometheus در نظر بگیرید. Prometheus یک monitoring aggregator است که metrics ها را جمع‌آوری کرده و آنها را در یک database time-series واحد جمع‌آوری می‌کند. علاوه بر این database، Prometheus، visualization و query language را برای introspecting the collected metrics فراهم می‌کند. برای جمع‌آوری metrics ها از انواع systems های مختلف، Prometheus انتظار دارد که هر container یک metrics API خاص را در معرض دید قرار دهد. این Prometheus را قادر می‌سازد تا طیف گسترده‌ای از برنامه‌های مختلف را از طریق یک interface واحد، monitor کند.
    </p>
    <p>
        با این حال، بسیاری از برنامه‌های محبوب، مانند key-value store Redis، metrics ها را در یک format که با Prometheus سازگار است، export نمی‌کنند. در نتیجه، adapter pattern برای گرفتن یک service موجود مانند Redis و تطبیق آن با interface جمع‌آوری metrics Prometheus، بسیار مفید است.
    </p>
    <p>
        یک تعریف pod ساده Kubernetes را برای یک server Redis در نظر بگیرید:
    </p>
    <pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: adapter-example
  namespace: default
spec:
  containers:
  - image: redis
    name: redis</code></pre>
    <p>
        در این مرحله، این container قادر به monitor شدن توسط Prometheus نیست زیرا interface مناسب را export نمی‌کند. با این حال، اگر ما به سادگی یک adapter container (در این مورد، یک exporter Prometheus open source) اضافه کنیم، می‌توانیم این pod را تغییر دهیم تا interface صحیح را export کند و بنابراین آن را با انتظارات Prometheus تطبیق دهیم:
    </p>
    <pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: adapter-example
  namespace: default
spec:
  containers:
  - image: redis
    name: redis
 # Provide an adapter that implements the Prometheus interface
  - image: oliver006/redis_exporter
    name: adapter</code></pre>
    <p>
        این مثال، نه‌تنها value adapter pattern را برای اطمینان از یک interface consistent، بلکه value container patterns را به‌طور کلی برای con -
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>