<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 48</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        tainer reuse. در این مورد، example نشان‌داده‌شده، یک container Redis موجود را با یک adapter Prometheus موجود ترکیب می‌کند. تأثیر خالص این یک server Redis قابل مانیتور است، که برای deploy کردن آن، کار کمی از طرف ما لازم است. در صورت عدم وجود adapter pattern، deployment یکسان، به کار سفارشی بسیار بیشتری نیاز داشت و به یک solution کمتر قابل بهره‌برداری منجر می‌شد، زیرا هرگونه به‌روزرسانی برای Redis یا adapter، نیاز به کار برای اعمال به‌روزرسانی داشت.
    </p>
    <h4 style="font-weight: bold;">Logging</h4>
    <p>
        مشابه monitoring، تنوع زیادی در نحوه logging داده‌ها به یک output stream وجود دارد. systemsها ممکن است logsهای خود را به سطوح مختلف (مانند debug، info، warning و error) تقسیم کنند که هر سطح به یک فایل متفاوت می‌رود. برخی ممکن است به سادگی به stdout و stderr log شوند. این امر به‌ویژه در دنیای containerized applications که انتظار کلی وجود دارد که containersهای شما به stdout log می‌شوند، مشکل‌ساز است، زیرا این چیزی است که از طریق دستوراتی مانند docker logs یا kubectl logs در دسترس است.
    </p>
    <p>
        افزودن پیچیدگی بیشتر، اطلاعات logged به‌طور کلی دارای information ساختار یافته است (به عنوان مثال، تاریخ/زمان log)، اما این اطلاعات بین کتابخانه‌های logging مختلف (به عنوان مثال، logging داخلی جاوا در مقابل بسته glog برای Go) بسیار متفاوت است.
    </p>
    <p>
        البته، هنگامی که شما در حال ذخیره و query کردن logs برای system distributed خود هستید، واقعاً به این تفاوت‌ها در format logging اهمیت نمی‌دهید. شما می‌خواهید اطمینان حاصل کنید که با وجود ساختارهای مختلف برای data، هر log در نهایت با timestamp مناسب به پایان می‌رسد.
    </p>
    <p>
        خوشبختانه، همانطور که در مورد monitoring، adapter pattern می‌تواند به ارائه یک design modular و reusable برای هر دو این situation ها کمک کند. در حالی که application container ممکن است به یک فایل log شود، adapter container می‌تواند آن فایل را به stdout هدایت کند. application containers های مختلف می‌توانند اطلاعات را در formats های مختلف log کنند، اما adapter container می‌تواند آن داده‌ها را به یک representation ساختاریافته واحد تبدیل کند که می‌تواند توسط log aggregator شما مصرف شود. باز هم، adapter یک دنیای heterogeneous از applications را می‌گیرد و یک دنیای homogenous از interfaces های common ایجاد می‌کند.
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>