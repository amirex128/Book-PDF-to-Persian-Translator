<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 74</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   بین requests های user و پیاده‌سازی frontend. یک نمودار high-level از system در Figure 6-2 نشان داده شده است.
  </p>
  <p>
   <em>Figure 6-2. A sharded cache</em>
  </p>
  <p>
   در فصل 3، ما در مورد چگونگی استفاده از یک ambassador برای توزیع data به یک service sharded بحث کردیم. این بخش در مورد نحوه ساختن آن service بحث می‌کند. هنگام طراحی یک sharded cache، تعدادی جنبه طراحی وجود دارد که باید در نظر گرفت:
  </p>
  <ul>
   <li>چرا ممکن است به یک sharded cache نیاز داشته باشید</li>
   <li>نقش cache در architecture شما</li>
   <li>cache های Replicated و sharded</li>
   <li>sharding function</li>
  </ul>
  <h4><strong>Why You Might Need a Sharded Cache</strong></h4>
  <p>
   همانطور که در مقدمه ذکر شد، دلیل اصلی برای sharding هر service، افزایش اندازه data ای است که در service ذخیره می‌شود. برای درک اینکه چگونه این به یک system caching کمک می‌کند، system زیر را تصور کنید: هر cache دارای 10 GB از RAM است که برای ذخیره results ها در دسترس است و می‌تواند 100 requests در ثانیه (RPS) را service دهد. سپس فرض کنید که service ما در مجموع 200 GB results احتمالی دارد که می‌توانند برگردانده شوند و 1000 RPS مورد انتظار است. بدیهی است، ما به 10 replica از cache نیاز داریم تا 1000 RPS را برآورده کنیم (10 replicas × 100 requests در ثانیه در هر replica). ساده‌ترین راه برای استقرار این service، به عنوان یک service replicated است، همانطور که در فصل قبل توضیح داده شد. اما با استقرار به این روش، cache توزیع‌شده می‌تواند حداکثر 5٪ (10 GB/200 GB) از کل data set را که ما در حال service دادن آن هستیم، نگه دارد. این به این دلیل است که هر cache replica مستقل است و بنابراین هر cache replica تقریباً دقیقاً data یکسان را در cache ذخیره می‌کند. این برای redundancy عالی است، اما برای به حداکثر رساندن memory utilization بسیار وحشتناک است. اگر در عوض، ما یک cache sharded 10-way را مستقر کنیم، همچنان می‌توانیم مناسب را service دهیم.
  </p>
  <p>
   60
   | Chapter 6: Sharded Services
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0074/image_1.png" alt="Image from page 74" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>