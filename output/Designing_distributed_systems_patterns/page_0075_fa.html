<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 75</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   ate number از نوع RPS (10 × 100 همچنان 1000 است)، اما از آنجایی که هر cache یک مجموعه داده کاملاً منحصربه‌فرد را service می‌دهد، ما می‌توانیم 50٪ (10 × 10 GB/200 GB) از کل data set را ذخیره کنیم. این افزایش ده برابری در cache storage به این معنی است که حافظه cache بسیار بهتر مورد استفاده قرار می‌گیرد، زیرا هر key فقط در یک cache وجود دارد.
  </p>
  <h4><strong>The Role of the Cache in System Performance</strong></h4>
  <p>
   در فصل 5 ما در مورد چگونگی استفاده از cache ها برای بهینه‌سازی end-user performance و latency بحث کردیم، اما یک چیز که پوشش داده نشد، critical بودن cache برای performance، reliability و stability application شما بود.
  </p>
  <p>
   به بیان ساده، سوال مهمی که باید در نظر بگیرید این است: اگر cache از کار بیفتد، تأثیر آن برای users و service شما چه خواهد بود؟
  </p>
  <p>
   وقتی در مورد cache replicated بحث کردیم، این سوال کمتر مرتبط بود زیرا خود cache به صورت افقی قابل scale بود و failures های replica های خاص فقط منجر به transient failures می‌شد. به همین ترتیب، cache می‌تواند در پاسخ به افزایش load بدون تأثیر بر end user، به صورت افقی scale شود.
  </p>
  <p>
   این موضوع زمانی تغییر می‌کند که شما cache های sharded را در نظر می‌گیرید. از آنجایی که یک user یا request خاص همیشه به همان shard map می‌شود، اگر آن shard از کار بیفتد، آن user یا request همیشه cache را از دست می‌دهد تا زمانی که shard بازیابی شود. با توجه به ماهیت cache به عنوان data transient، این miss ذاتاً یک مشکل نیست و system شما باید بداند چگونه data را دوباره محاسبه کند. با این حال، این recalculation ذاتا کندتر از استفاده مستقیم از cache است و بنابراین، implications performance را برای end users شما دارد.
  </p>
  <p>
   performance cache شما بر حسب hit rate آن تعریف می‌شود. hit rate درصد زمانی است که cache شما شامل data برای یک user request است. در نهایت، hit rate، ظرفیت کلی system توزیع‌شده شما را تعیین می‌کند و بر ظرفیت و performance کلی system شما تأثیر می‌گذارد.
  </p>
  <p>
   تصور کنید، اگر بخواهید، یک لایه request-serving دارید که می‌تواند 1000 RPS را مدیریت کند. پس از 1000 RPS، system شروع به برگرداندن خطاهای HTTP 500 به users می‌کند. اگر شما یک cache با hit rate 50٪ را در جلوی این لایه request-serving قرار دهید، اضافه کردن این cache، حداکثر RPS شما را از 1000 RPS به 2000 RPS افزایش می‌دهد. برای درک اینکه چرا این درست است، می‌توانید ببینید که از 2000 requests ورودی، 1000 (50٪) را می‌توان توسط cache service داد و 1000 requests باقی می‌ماند تا توسط serving layer شما service داده شود. در این مورد، cache کاملاً برای service شما critical است، زیرا اگر cache از کار بیفتد، serving layer overload می‌شود و نیمی از تمام user requests های شما با شکست مواجه می‌شوند. با توجه به این موضوع، احتمالاً منطقی است که service خود را در حداکثر 1500 RPS rate کنید تا کل 2000 RPS. اگر این کار را انجام دهید، می‌توانید یک failure از نیمی از cache replicas های خود را حفظ کنید و همچنان service خود را پایدار نگه دارید.
  </p>
  <p>
   اما performance system شما فقط بر حسب تعداد requests هایی که می‌تواند پردازش کند، تعریف نمی‌شود. performance end-user system شما بر حسب latency requests نیز تعریف می‌شود. یک result از یک cache به طور کلی بسیار سریعتر است
  </p>
  <p>
   Sharded Caching
   | 61
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>