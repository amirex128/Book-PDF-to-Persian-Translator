<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 16</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
  one program at a time to running multiple programs روی یک machine واحد از طریق operating systems زمان-اشتراکی، اما این ماشین‌ها هنوز از یکدیگر جدا بودند.
  </p>
  <p>
  به تدریج، ماشین‌ها به هم متصل شدند و معماری‌های client-server متولد شدند، به‌طوری‌که یک ماشین با قدرت نسبتاً کم روی میز کار کسی می‌توانست برای مهار قدرت بیشتر یک mainframe در اتاق یا ساختمان دیگری استفاده شود. در حالی که این نوع programming client-server تا حدودی پیچیده‌تر از نوشتن یک program برای یک ماشین واحد بود، درک آن هنوز نسبتاً ساده بود. client(ها) درخواست‌ها را ثبت می‌کردند؛ server(ها) به این درخواست‌ها رسیدگی می‌کردند.
  </p>
  <p>
  در اوایل دهه 2000، ظهور اینترنت و datacenters در مقیاس بزرگ که شامل هزاران کامپیوتر نسبتاً کم‌هزینه و کالایی بود که به هم متصل شده بودند، باعث توسعه گسترده distributed systems شد. برخلاف معماری‌های client-server، applications از نوع distributed system از چندین application مختلف تشکیل شده‌اند که روی ماشین‌های مختلف یا بسیاری از replicas که در سراسر ماشین‌های مختلف اجرا می‌شوند، اجرا می‌شوند، همه با هم ارتباط برقرار می‌کنند تا یک system مانند web-search یا یک platform فروش خرده‌فروشی را پیاده‌سازی کنند.
  </p>
  <p>
  به دلیل ماهیت distributed آن‌ها، وقتی به درستی ساختاردهی شوند، distributed systems ذاتاً قابل اعتمادتر هستند. و وقتی به درستی معماری شوند، می‌توانند به مدل‌های سازمانی بسیار مقیاس‌پذیرتری برای تیم‌های مهندسان نرم‌افزاری که این systems را ساخته‌اند، منجر شوند. متأسفانه، این مزایا هزینه‌ای دارند. این distributed systems می‌توانند به طور قابل توجهی پیچیده‌تر از طراحی، ساخت و اشکال‌زدایی صحیح باشند. مهارت‌های مهندسی مورد نیاز برای ساخت یک distributed system قابل اعتماد به طور قابل توجهی بالاتر از مهارت‌های مورد نیاز برای ساخت applications single-machine مانند frontends موبایل یا وب است.
  </p>
  <p>
  صرف نظر از این، نیاز به reliable distributed systems همچنان در حال افزایش است. بنابراین نیاز متناظری به ابزارها، patterns و practices برای ساختن آن‌ها وجود دارد. خوشبختانه، technology نیز سهولت ساختن distributed systems را افزایش داده است. Containers، container images و container orchestrators در سال‌های اخیر محبوب شده‌اند زیرا آن‌ها foundation و building blocks برای distributed systems قابل اعتماد هستند. با استفاده از containers و container orchestration به عنوان یک foundation، می‌توانیم مجموعه‌ای از patterns و components قابل استفاده مجدد را ایجاد کنیم. این patterns و components یک toolkit هستند که می‌توانیم از آن‌ها برای ساختن systems خود به طور قابل اعتمادتر و کارآمدتر استفاده کنیم.
  </p>
  <h3>A Brief History of Patterns in Software Development</h3>
  <p>
  این اولین باری نیست که چنین تحولی در صنعت نرم‌افزار رخ داده است. برای یک context بهتر در مورد چگونگی shape گرفتن patterns, practices و components قابل استفاده مجدد توسعه systems، مفید است که به لحظاتی از گذشته نگاهی بیندازیم که در آن‌ها تحولات مشابهی رخ داده است.
  </p>
  <p>2 | Chapter 1: Introduction</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>