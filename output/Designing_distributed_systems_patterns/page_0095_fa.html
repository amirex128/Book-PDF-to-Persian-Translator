<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 95</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h3><strong>CHAPTER 8</strong></h3>
  <h4><strong>Functions and Event-Driven Processing</strong></h4>
  <p>
   تا کنون، ما طراحی system هایی با محاسبات طولانی مدت را بررسی کرده‌ایم. servers هایی که requests های user را مدیریت می‌کنند، همیشه در حال اجرا هستند. این pattern برای بسیاری از applications که تحت بار سنگین قرار دارند، مقدار زیادی data را در حافظه نگه می‌دارند یا به نوعی background processing نیاز دارند، مناسب است. با این حال، یک کلاس از applications وجود دارد که ممکن است فقط به طور موقت برای رسیدگی به یک request واحد یا به سادگی نیاز به پاسخگویی به یک event خاص داشته باشد. این سبک از طراحی application مبتنی بر request یا event، اخیراً با توسعه محصولات function-as-a-service (FaaS) توسط ارائه دهندگان بزرگ cloud public، رونق یافته است. اخیراً، پیاده‌سازی‌های FaaS نیز بر روی cluster orchestrators در cloud private یا محیط‌های فیزیکی ظاهر شده‌اند. این فصل architecture های در حال ظهور را برای این سبک جدید از computing توصیف می‌کند. در بسیاری از موارد، FaaS یک component در یک architecture گسترده‌تر است تا یک راه‌حل کامل.
  </p>
  <p>
   اغلب، FaaS به عنوان serverless computing نامیده می‌شود. و در حالی که این درست است (شما servers را در FaaS نمی‌بینید)، ارزش دارد که بین FaaS مبتنی بر event و مفهوم گسترده‌تر serverless computing تمایز قائل شوید. در واقع، serverless computing می‌تواند برای طیف گسترده‌ای از service های computing اعمال شود. به عنوان مثال، یک container orchestrator چند مستأجری (container-as-a-service) serverless است اما event-driven نیست. برعکس، یک FaaS متن‌باز (open source) که بر روی یک cluster از machine های فیزیکی که شما مالک و اداره‌کننده آن هستید، اجرا می‌شود، event-driven است اما serverless نیست. درک این تمایز به شما این امکان را می‌دهد که تعیین کنید چه زمانی event-driven، serverless یا هر دو، انتخاب مناسبی برای application شما است.
  </p>
  <p>
   81
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0095/image_1.png" alt="Image from page 95" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>