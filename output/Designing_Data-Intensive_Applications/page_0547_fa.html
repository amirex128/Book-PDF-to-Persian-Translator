<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 547</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        اگر <strong>integrity</strong> نقض شود، ناسازگاری دائمی است: انتظار
        کشیدن و دوباره تلاش کردن در اکثر موارد، فساد پایگاه داده را برطرف
        نمی‌کند. در عوض، بررسی و تعمیر صریح مورد نیاز است. در
        <strong>context</strong> از تراکنش‌های <strong>ACID</strong> (نگاه کنید به "معنی
        <strong>ACID</strong>" در صفحه 223)، <strong>consistency</strong> معمولاً به عنوان
        نوعی مفهوم <em>application-specific</em> از <strong>integrity</strong> درک
        می‌شود. <em>Atomicity</em> و <em>durability</em> ابزارهای مهمی برای
        حفظ <strong>integrity</strong> هستند.
    </p>
    <p>
        به‌صورت شعار: نقض <strong>timeliness</strong> "<strong>eventual
        consistency</strong>" است، در حالی که نقض <strong>integrity</strong>،
        "<strong>perpetual inconsistency</strong>" است.
    </p>
    <p>
        من قصد دارم این ادعا را مطرح کنم که در اکثر برنامه‌ها، <strong>integrity</strong>
        بسیار مهم‌تر از <strong>timeliness</strong> است. نقض <strong>timeliness</strong>
        می‌تواند آزاردهنده و گیج‌کننده باشد، اما نقض
        <strong>integrity</strong> می‌تواند فاجعه‌آمیز باشد.
    </p>
    <p>
        به عنوان مثال، در بیانیه‌ی کارت اعتباری شما، این‌که یک تراکنش که
        شما در 24 ساعت گذشته انجام داده‌اید، هنوز ظاهر نشده است،
        تعجب‌آور نیست—این طبیعی است که این سیستم‌ها دارای یک
        <em>lag</em> خاصی باشند. ما می‌دانیم که بانک‌ها تراکنش‌ها را به‌صورت
        <em>asynchronously</em> <em>reconcile</em> و <em>settle</em> می‌کنند، و
        <strong>timeliness</strong> در اینجا چندان مهم نیست [3]. با این حال، اگر
        موجودی بیانیه برابر با مجموع تراکنش‌ها به‌علاوه موجودی
        بیانیه‌ی قبلی نباشد (یک خطا در مجموع)، یا اگر یک تراکنش به
        شما شارژ شده باشد اما به تاجر پرداخت نشده باشد (ناپدید شدن
        پول)، بسیار بد خواهد بود. چنین مشکلاتی نقض <strong>integrity</strong>
        سیستم خواهد بود.
    </p>

    <h4>درستی سیستم‌های <strong>Dataflow</strong></h4>
    <p>
        تراکنش‌های <strong>ACID</strong> معمولاً هر دو <strong>timeliness</strong> (به
        عنوان مثال، <em>linearizability</em>) و <strong>integrity</strong> (به
        عنوان مثال، <strong>atomic commit</strong>) را تضمین می‌کنند.
        بنابراین، اگر شما به درستی برنامه از دیدگاه تراکنش‌های <strong>ACID</strong>
        نزدیک شوید، تمایز بین <strong>timeliness</strong> و <strong>integrity</strong>
        تقریباً بی‌اهمیت است.
    </p>
    <p>
        از سوی دیگر، یک ویژگی جالب از سیستم‌های <strong>dataflow</strong> مبتنی بر
        رویداد که ما در این فصل مورد بحث قرار دادیم این است که آن‌ها
        <strong>timeliness</strong> و <strong>integrity</strong> را از هم جدا می‌کنند.
        هنگام پردازش جریان‌های رویداد به‌صورت <em>asynchronously</em>،
        هیچ تضمینی برای <strong>timeliness</strong> وجود ندارد، مگر این‌که
        شما صریحاً <strong>consumers</strong> بسازید که منتظر رسیدن یک پیام
        باشند قبل از بازگشت. اما <strong>integrity</strong> در واقع برای
        سیستم‌های <strong>streaming</strong> اساسی است.
    </p>
    <p>
        <strong>Exactly-once</strong> یا <em>effectively-once semantics</em> (نگاه کنید
        به "تحمل خطا" در صفحه 476) یک مکانیسم برای حفظ
        <strong>integrity</strong> است. اگر یک رویداد از دست برود، یا اگر یک رویداد
        دو بار تأثیر بگذارد، <strong>integrity</strong> از یک سیستم داده ممکن
        است نقض شود. بنابراین، تحویل پیام تحمل‌کننده‌ی خطا و سرکوب
        تکراری (به عنوان مثال، عملیات <em>idempotent</em>) برای حفظ
        <strong>integrity</strong> از یک سیستم داده در مواجهه با <strong>faults</strong>
        مهم هستند.
    </p>
    <p>
        همان‌طور که در بخش آخر دیدیم، سیستم‌های پردازش <strong>stream</strong>
        قابل اعتماد می‌توانند <strong>integrity</strong> را بدون نیاز به تراکنش‌های
        توزیع شده و یک پروتکل <strong>atomic commit</strong> حفظ کنند، که
        به این معنی است که آن‌ها به‌طور بالقوه می‌توانند درستی قابل
        مقایسه‌ای را با عملکرد بسیار بهتری به‌دست آورند
        هدف قرار دادن درستی
        |
        525
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>