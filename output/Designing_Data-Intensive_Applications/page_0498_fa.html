<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 498</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        ویرایش پروفایل)؟ به عبارت دیگر: اگر <strong>state</strong> در طول زمان
        تغییر می‌کند، و شما با برخی از <strong>state</strong> <strong>join</strong>
        می‌کنید، شما از کدام نقطه زمانی برای <strong>join</strong> استفاده
        می‌کنید [45]؟
    </p>
    <p>
        چنین وابستگی به زمانی می‌تواند در بسیاری از مکان‌ها رخ دهد. به عنوان
        مثال، اگر شما چیزی می‌فروشید، شما نیاز دارید که نرخ مالیات مناسب را
        برای فاکتورها اعمال کنید، که به کشور یا ایالت، نوع محصول، و تاریخ
        فروش بستگی دارد (از آن‌جایی که نرخ‌های مالیات در طول زمان تغییر
        می‌کنند). هنگام <strong>joining</strong> فروش‌ها به یک جدول از نرخ‌های
        مالیات، شما احتمالاً می‌خواهید با نرخ مالیات در زمان فروش <strong>join</strong>
        کنید، که اگر شما در حال <em>reprocessing</em> داده‌های تاریخی هستید،
        ممکن است با نرخ مالیات فعلی متفاوت باشد.
    </p>
    <p>
        اگر ترتیب رویدادها در سراسر <strong>streams</strong> نامشخص باشد،
        <strong>join</strong> <em>nondeterministic</em> می‌شود [87]، که به این معنی
        است که شما نمی‌توانید همان job را دوباره در همان ورودی اجرا کنید و
        لزوماً همان نتیجه را به‌دست آورید: رویدادها در <strong>streams</strong>
        ورودی ممکن است به روشی متفاوت با هم تداخل داشته باشند، زمانی که
        شما دوباره job را اجرا می‌کنید.
    </p>
    <p>
        در انبارهای داده، این مسئله به‌عنوان یک <strong>slowly changing
        dimension (SCD)</strong> شناخته می‌شود، و اغلب با استفاده از یک
        شناسه منحصر به فرد برای یک نسخه خاص از رکورد <strong>joined</strong>
        برطرف می‌شود: به عنوان مثال، هر بار که نرخ مالیات تغییر می‌کند، یک
        شناسه جدید به آن داده می‌شود، و فاکتور شامل شناسه برای نرخ
        مالیات در زمان فروش است [88, 89]. این تغییر <strong>join</strong> را
        <em>deterministic</em> می‌کند، اما این نتیجه را دارد که <strong>log compaction</strong>
        امکان‌پذیر نیست، زیرا تمام نسخه‌های رکوردها در جدول باید حفظ
        شوند.
    </p>

    <h4>تحمل خطا</h4>
    <p>
        در بخش پایانی این فصل، بیایید بررسی کنیم که چگونه پردازنده‌های
        <strong>stream</strong> می‌توانند <strong>faults</strong> را تحمل کنند. ما در فصل 10
        دیدیم که فریم‌ورک‌های پردازش <strong>batch</strong> می‌توانند <strong>faults</strong>
        را نسبتاً آسان تحمل کنند: اگر یک <strong>task</strong> در یک job <strong>MapReduce</strong>
        شکست بخورد، به‌سادگی می‌توان دوباره آن را در یک ماشین دیگر
        شروع کرد، و خروجی <strong>task</strong> شکست‌خورده دور ریخته می‌شود. این
        <strong>retry</strong> شفاف امکان‌پذیر است زیرا فایل‌های ورودی <em>immutable</em>
        هستند، هر <strong>task</strong> خروجی خود را در یک فایل جداگانه روی
        <strong>HDFS</strong> می‌نویسد، و خروجی تنها زمانی قابل مشاهده می‌شود که
        یک <strong>task</strong> با موفقیت تکمیل شود.
    </p>
    <p>
        به‌طور خاص، رویکرد <strong>batch</strong> برای تحمل خطا تضمین می‌کند که
        خروجی job <strong>batch</strong> یکسان است گویی هیچ اتفاقی رخ نداده
        است، حتی اگر در واقع برخی از <strong>tasks</strong> از کار افتاده باشند. این‌طور
        به نظر می‌رسد که هر رکورد ورودی دقیقاً یک بار پردازش شده
        است—هیچ رکوردی رد نمی‌شود، و هیچ‌کدام دو بار پردازش نمی‌شوند.
        اگرچه راه‌اندازی مجدد <strong>tasks</strong> به این معنی است که رکوردها در
        واقع ممکن است چندین بار پردازش شوند، اثر قابل مشاهده در خروجی
        این است که گویی آن‌ها فقط یک بار پردازش شده‌اند. این اصل به‌عنوان
        <strong>exactly-once semantics</strong> شناخته می‌شود، اگرچه
        <em>effectively-once</em> یک اصطلاح توصیفی‌تر خواهد بود [90].
    </p>
    <p>
        همان مسئله‌ی تحمل خطا در پردازش <strong>stream</strong> ایجاد می‌شود، اما
        رسیدگی به آن آسان‌تر نیست: انتظار تا زمانی که یک <strong>task</strong>
        تکمیل شود قبل از این‌که خروجی آن را قابل مشاهده کنید، یک گزینه
        نیست، زیرا یک <strong>stream</strong> نامحدود است و بنابراین شما هرگز
        نمی‌توانید پردازش آن را تمام کنید.
        پایگاه‌های داده و جریان‌ها
        |
        469
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>