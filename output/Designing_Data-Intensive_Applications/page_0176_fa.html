<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 176</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        شکل 5-2. Leader-based replication با یک synchronous و یک asynchronous fol‐lower.
    </p>
    <p>
        در مثال شکل 5-2، replication به follower 1 synchronous است: leader منتظر می‌ماند تا follower 1 تأیید کند که write را دریافت کرده است، قبل از گزارش موفقیت به user و قبل از قابل مشاهده کردن write برای other clients. The replication to follower 2 asynchronous است: leader message را ارسال می‌کند، اما منتظر یک response از follower نمی‌ماند.
    </p>
    <p>
        این نمودار نشان می‌دهد که یک delay قابل توجه قبل از اینکه follower 2 message را پردازش کند، وجود دارد. به طور معمول، replication بسیار سریع است: اکثر systems database تغییرات را در followers در کمتر از یک ثانیه اعمال می‌کنند. با این حال، هیچ تضمینی وجود ندارد که چقدر طول بکشد. شرایطی وجود دارد که followers ممکن است از leader به میزان چند دقیقه یا بیشتر عقب بمانند. به عنوان مثال، اگر یک follower از یک failure در حال بازیابی است، اگر سیستم در حال کار نزدیک به حداکثر ظرفیت است، یا اگر مشکلات network بین nodes وجود داشته باشد.
    </p>
    <p>
        مزیت synchronous replication این است که follower تضمین شده است که یک کپی up-to-date از داده‌ها دارد که با leader سازگار است. اگر leader ناگهان fail شود، ما می‌توانیم مطمئن باشیم که داده‌ها هنوز در follower در دسترس هستند. The disadvantage این است که اگر synchronous follower پاسخ ندهد (زیرا crash کرده است، یا یک network fault وجود دارد، یا به هر دلیل دیگر)، write نمی‌تواند پردازش شود.
        leader باید همه writes را block کند و تا زمانی که synchronous replica دوباره در دسترس قرار گیرد، منتظر بماند.
    </p>
    <p>
        به همین دلیل، غیر عملی است که همه followers synchronous باشند: هر یک node outage باعث می‌شود که کل سیستم به حالت توقف درآید. در عمل، اگر شما synchronous replication را در یک database فعال کنید، معمولاً به این معنی است که یکی از followers synchronous است و بقیه asynchronous هستند. اگر synchronous follower در دسترس نباشد یا کند شود، یکی از followers asynchronous synchronous می‌شود. این تضمین می‌کند که شما یک کپی up-to-date از داده‌ها را حداقل در دو nodes دارید: the
    </p>
    <p>
        154 | Chapter 5: Replication
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0176/image_1.png" alt="Image from page 176" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>