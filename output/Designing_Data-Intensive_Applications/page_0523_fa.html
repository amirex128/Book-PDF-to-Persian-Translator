<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 523</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        به این ترتیب، پردازنده‌های <strong>batch</strong> و <strong>stream</strong>
        مانند پیاده‌سازی‌های پیچیده‌ی <strong>triggers</strong>، <strong>stored
        procedures</strong>، و روال‌های نگهداری <strong>materialized view</strong>
        هستند. سیستم‌های داده‌ی مشتق شده که آن‌ها نگه‌داری می‌کنند، مانند
        انواع مختلف <strong>index</strong> هستند. به عنوان مثال، یک پایگاه داده‌ی
        رابطه‌ای ممکن است از <strong>indexes</strong> <strong>B-tree</strong>، <strong>hash
        indexes</strong>، <strong>spatial indexes</strong> (نگاه کنید به "<strong>Multi-column
        indexes</strong>" در صفحه 87)، و سایر انواع <strong>indexes</strong> پشتیبانی
        کند. در معماری در حال ظهور سیستم‌های داده‌ی مشتق شده، به‌جای
        پیاده‌سازی این <strong>facilities</strong> به عنوان <strong>features</strong> از یک
        محصول پایگاه داده‌ی یکپارچه، آن‌ها توسط قطعات نرم‌افزاری مختلف
        ارائه می‌شوند که بر روی ماشین‌های مختلف اجرا می‌شوند، و توسط تیم‌های
        مختلف مدیریت می‌شوند.
    </p>
    <p>
        این پیشرفت‌ها در آینده ما را به کجا می‌برند؟ اگر ما از این فرض شروع
        کنیم که هیچ مدل داده یا فرمت ذخیره‌سازی واحدی وجود ندارد که برای
        همه‌ی الگوهای دسترسی مناسب باشد، من حدس می‌زنم که دو مسیر وجود
        دارد که از طریق آن‌ها ابزارهای ذخیره‌سازی و پردازش مختلف با این
        وجود می‌توانند به یک سیستم منسجم ترکیب شوند:
    </p>
    <ul>
        <li>
            پایگاه‌های داده‌ی فدرال: متحد کردن <strong>reads</strong>
        </li>
        <p>
            امکان ارائه‌ی یک رابط <strong>query</strong> یکپارچه به طیف گسترده‌ای
            از <strong>storage engines</strong> و روش‌های پردازش اساسی وجود
            دارد—رویکردی که به‌عنوان پایگاه داده‌ی فدرال یا <strong>polystore</strong>
            شناخته می‌شود [18، 19]. به عنوان مثال، <strong>feature</strong>
            <strong>foreign data wrapper</strong> از <strong>PostgreSQL</strong> با این الگو
            مطابقت دارد [20]. برنامه‌هایی که به یک مدل داده‌ی تخصصی یا
            رابط <strong>query</strong> نیاز دارند، همچنان می‌توانند به‌طور مستقیم به
            <strong>storage engines</strong> اساسی دسترسی پیدا کنند، در حالی‌که
            کاربرانی که می‌خواهند داده‌ها را از مکان‌های مختلف ترکیب
            کنند، می‌توانند این کار را به راحتی از طریق رابط فدرال انجام
            دهند.
        </p>
        <p>
            یک رابط <strong>query</strong> فدرال از سنت رابطه‌ای یک سیستم
            یکپارچه‌ی واحد با یک زبان <strong>query</strong> سطح بالا و
            <strong>semantics</strong> های ظریف پیروی می‌کند، اما یک پیاده‌سازی
            پیچیده دارد.
        </p>
        <li>
            پایگاه‌های داده‌ی <strong>Unbundled</strong>: متحد کردن <strong>writes</strong>
        </li>
        <p>
            در حالی که <strong>federation</strong>، <strong>querying</strong> <em>read-only</em>
            را در سراسر چندین سیستم مختلف انجام می‌دهد، یک پاسخ خوب
            برای همگام‌سازی <strong>writes</strong> در سراسر آن سیستم‌ها ندارد. ما
            گفتیم که در داخل یک پایگاه داده واحد، ایجاد یک index
            <em>consistent</em> یک <strong>feature</strong> داخلی است.
            هنگامی‌که ما چندین سیستم ذخیره‌سازی را ترکیب می‌کنیم، به‌طور
            مشابه نیاز داریم که اطمینان حاصل کنیم که تمام تغییرات داده‌ها در
            تمام مکان‌های مناسب قرار می‌گیرند، حتی در مواجهه با
            <strong>faults</strong>. آسان‌تر کردن اتصال قابل اعتماد سیستم‌های
            ذخیره‌سازی با هم (به عنوان مثال، از طریق <strong>change data
            capture</strong> و <strong>event logs</strong>) مانند <strong>unbundling</strong>
            <strong>features</strong> از یک پایگاه داده است که می‌تواند <strong>writes</strong>
            را در فناوری‌های مختلف همگام‌سازی کند [7، 21].
        </p>
        <p>
            رویکرد <strong>unbundled</strong> از سنت <strong>Unix</strong> از ابزارهای کوچک
            که یک کار را خوب انجام می‌دهند [22] پیروی می‌کند، که از طریق
            یک <strong>API</strong> سطح پایین یکنواخت (<strong>pipes</strong>) ارتباط
            برقرار می‌کنند، و می‌تواند با استفاده از یک زبان سطح بالاتر (<strong>shell</strong>)
            ترکیب شود [16].
        </p>
    </ul>
    <p>
        به‌کار انداختن <strong>unbundling</strong>
    </p>
    <p>
        <strong>Federation</strong> و <strong>unbundling</strong> دو روی یک سکه هستند: ترکیب
        یک سیستم قابل اعتماد، مقیاس‌پذیر و قابل نگهداری از اجزای
        مختلف. <em>Federated read-only</em>
        <strong>Unbundling Databases</strong>
        |
        499
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>