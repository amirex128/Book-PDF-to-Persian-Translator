<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 50</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        groups of people—به عنوان مثال، مهندسان vendor database و developers application که از database آن‌ها استفاده می‌کنند—برای کار موثر با هم.
    </p>
    <p>
        انواع مختلفی از data models وجود دارد و هر data model فرضیاتی را در مورد نحوه استفاده از آن در بر می‌گیرد. برخی از انواع usage آسان هستند و برخی پشتیبانی نمی‌شوند. برخی از operations سریع هستند و برخی عملکرد بدی دارند. برخی از data transformations طبیعی هستند و برخی دیگر ناخوشایند.
    </p>
    <p>
        به‌دست آوردن تسلط بر یک data model (فکر کنید چند کتاب در مورد relational data modeling وجود دارد) می‌تواند تلاش زیادی بطلبد. ساختن software به اندازه کافی سخت است، حتی زمانی که با یک data model کار می‌کنید و نگران عملکردهای داخلی آن نیستید. اما از آنجایی که data model چنین تأثیر عمیقی بر آنچه software بالای آن می‌تواند انجام دهد و نمی‌تواند انجام دهد، دارد، انتخاب موردی که برای application مناسب باشد، مهم است.
    </p>
    <p>
        در این فصل ما به طیف وسیعی از data models general-purpose برای data storage و querying (نقطه 2 در لیست قبلی) نگاه خواهیم کرد. به طور خاص، ما relational model، document model و چند data models مبتنی بر graph را مقایسه خواهیم کرد. ما همچنین به زبان‌های query مختلف نگاهی خواهیم داشت و use cases آن‌ها را مقایسه خواهیم کرد. در فصل 3 ما در مورد نحوه عملکرد storage engines بحث خواهیم کرد. یعنی نحوه پیاده‌سازی واقعی این data models (نقطه 3 در لیست).
    </p>
    <h4>Relational Model Versus Document Model</h4>
    <p>
        شناخته‌شده‌ترین data model امروزی احتمالاً مربوط به SQL است که بر اساس relational model است که توسط Edgar Codd در سال 1970 [1] پیشنهاد شده است: داده‌ها به relations (که در SQL tables نامیده می‌شوند) سازمان‌دهی می‌شوند، جایی که هر relation یک collection نامرتب از tuples (rows در SQL) است.
    </p>
    <p>
        Relational model یک proposal تئوری بود و بسیاری از مردم در آن زمان شک داشتند که آیا می‌توان آن را به طور موثر پیاده‌سازی کرد یا خیر. با این حال، تا اواسط دهه 1980، relational database management systems (RDBMSes) و SQL به ابزارهای انتخابی برای اکثر افرادی تبدیل شده بودند که نیاز به ذخیره و query داده‌ها با نوعی ساختار منظم داشتند. تسلط relational databases حدود 25 تا 30 سال به طول انجامیده است - یک ابدیت در تاریخ computing.
    </p>
    <p>
        ریشه‌های relational databases در پردازش داده‌های کسب‌وکار نهفته است که در دهه‌های 1960 و 70 بر روی mainframe computers انجام می‌شد. از دیدگاه امروزی، use cases پیش پا افتاده به نظر می‌رسند: معمولاً transaction processing (وارد کردن فروش یا تراکنش‌های بانکی، رزرو بلیط هواپیما، نگهداری سهام در انبارها) و batch processing (صدور فاکتور مشتری، حقوق و دستمزد، گزارش‌دهی).
    </p>
    <p>
        سایر databases در آن زمان، developers application را مجبور می‌کردند که در مورد internal representation داده‌ها در database بسیار فکر کنند. هدف relational model پنهان کردن آن implementation detail در پشت یک interface تمیزتر بود.
    </p>
    <p>
        در طول سال‌ها، رویکردهای رقیب زیادی برای data storage و querying وجود داشته است. در دهه‌های 1970 و اوایل دهه 1980، network model و hierarchical model
    </p>
    <p>
        28 | Chapter 2: Data Models and Query Languages
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>