<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 539</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        (<em>overstating</em> یک معیار). در این <strong>context</strong>،
        <strong>exactly-once</strong> به‌معنای تنظیم محاسبه به‌گونه‌ای است
        که اثر نهایی یکسان است گویی هیچ <strong>faults</strong> رخ نداده است،
        حتی اگر عملیات واقعاً به‌دلیل برخی از <strong>faults</strong> دوباره
        تلاش شده باشد. ما قبلاً در مورد چند رویکرد برای دستیابی به این
        هدف بحث کردیم.
    </p>
    <p>
        یکی از مؤثرترین رویکردها این است که عملیات را <em>idempotent</em>
        (نگاه کنید به "<strong>Idempotence</strong>" در صفحه 478) کنید؛ یعنی،
        اطمینان حاصل کنید که بدون در نظر گرفتن این‌که یک یا چند بار اجرا
        شود، همان اثر را دارد. با این حال، انجام یک عملیات که ذاتاً
        <em>idempotent</em> نیست و <em>idempotent</em> کردن آن، مستلزم مقداری
        تلاش و مراقبت است: شما ممکن است نیاز داشته باشید که برخی
        <strong>metadata</strong>های اضافی را حفظ کنید (مانند مجموعه‌ی
        <strong>operation IDs</strong> که یک مقدار را به‌روزرسانی کرده‌اند)، و
        در صورت <em>failing over</em> از یک <strong>node</strong> به دیگری،
        <strong>fencing</strong> را تضمین کنید (نگاه کنید به "رهبر و قفل" در
        صفحه 301).
    </p>

    <h4>سرکوب تکراری</h4>
    <p>
        همان الگوی نیاز به سرکوب تکراری در بسیاری از مکان‌های دیگر
        علاوه بر پردازش <strong>stream</strong> رخ می‌دهد. به عنوان مثال،
        <strong>TCP</strong> از شماره‌های توالی روی بسته‌ها برای قرار دادن
        آن‌ها در ترتیب صحیح در <strong>recipient</strong> استفاده می‌کند، و
        برای تعیین این‌که آیا هر بسته‌ای در شبکه از بین رفته یا تکراری
        شده است. هر بسته‌ای که از دست رفته باشد دوباره ارسال می‌شود
        و هر تکراری توسط <strong>TCP stack</strong> حذف می‌شود قبل از این‌که
        داده‌ها را به یک برنامه تحویل دهد.
    </p>
    <p>
        با این حال، این سرکوب تکراری فقط در <strong>context</strong> یک اتصال
        <strong>TCP</strong> واحد کار می‌کند. تصور کنید اتصال <strong>TCP</strong> یک
        <strong>client</strong> به یک پایگاه داده است، و در حال حاضر تراکنش را
        در مثال 12-1 اجرا می‌کند. در بسیاری از پایگاه‌های داده، یک
        تراکنش به یک اتصال <strong>client</strong> گره خورده است (اگر <strong>client</strong>
        چندین <strong>query</strong> را ارسال کند، پایگاه داده می‌داند که آن‌ها به
        یک تراکنش یکسان تعلق دارند زیرا آن‌ها از طریق همان اتصال
        <strong>TCP</strong> ارسال می‌شوند). اگر <strong>client</strong> دچار یک
        <em>network interruption</em> و <strong>connection timeout</strong> پس از
        ارسال <strong>COMMIT</strong> شود، اما قبل از دریافت پاسخ از سرور
        پایگاه داده، نمی‌داند که آیا تراکنش <strong>committed</strong> شده
        است یا خیر (شکل 8-1).
    </p>
    <p>
        مثال 12-1. انتقال غیر <em>idempotent</em> پول از یک حساب به حساب
        دیگر
    </p>
    <pre><code class="language-sql">BEGIN TRANSACTION;
UPDATE accounts SET balance = balance + 11.00 WHERE account_id = 1234;
UPDATE accounts SET balance = balance - 11.00 WHERE account_id = 4321;
COMMIT;
</code></pre>
    <p>
        <strong>Client</strong> می‌تواند دوباره به پایگاه داده متصل شود و تراکنش را
        دوباره امتحان کند، اما اکنون خارج از محدوده‌ی سرکوب تکراری
        <strong>TCP</strong> است. از آن‌جایی‌که تراکنش در مثال 12-1 <em>idempotent</em>
        نیست، ممکن است 22 دلار به‌جای 11 دلار مورد نظر، منتقل
        شود.
    </p>
    <p>
        بنابراین، حتی اگر مثال 12-1 یک مثال استاندارد برای <em>atomicity</em>
        تراکنش باشد، در واقع درست نیست، و بانک‌های واقعی این‌طور
        عمل نمی‌کنند [3].
    </p>
    <p>
        پروتکل‌های <strong>Two-phase commit (2PC)</strong> (نگاه کنید به
        "<strong>Atomic Commit</strong> و <strong>Two-Phase Commit (2PC)</strong>" در
        صفحه 354)، نگاشت 1:1 بین یک اتصال <strong>TCP</strong> و یک
        تراکنش را می‌شکنند، زیرا آن‌ها باید به یک هماهنگ‌کننده‌ی
        تراکنش اجازه دهند تا پس از یک <em>network failure</em> دوباره به
        یک پایگاه داده متصل شود—
        هدف قرار دادن درستی
        |
        517
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>