<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 149</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        tags.) این نوع schema dynamically generated به سادگی یک هدف طراحی از Thrift یا Protocol Buffers نبود، در حالی که برای Avro بود.
    </p>
    <h4>Code generation و dynamically typed languages</h4>
    <p>
        Thrift و Protocol Buffers به code generation تکیه می‌کنند: پس از تعریف یک schema، شما می‌توانید کدی را تولید کنید که این schema را در یک زبان برنامه‌نویسی از انتخاب شما پیاده‌سازی می‌کند. این در زبان‌های statically typed مانند Java, C++ یا C# مفید است، زیرا به structures in-memory کارآمد اجازه می‌دهد تا برای data decoded استفاده شوند و به نوع checking و autocompletion در IDEs هنگام نوشتن برنامه‌هایی که به data structures دسترسی دارند، اجازه می‌دهد.
    </p>
    <p>
        در زبان‌های برنامه‌نویسی dynamically typed مانند JavaScript, Ruby یا Python، تولید کد چندان منطقی ندارد، زیرا هیچ type checker در زمان کامپایل وجود ندارد که باید برآورده شود. Code generation اغلب در این زبان‌ها ناخوشایند است، زیرا آن‌ها در غیر این صورت از یک گام compilation صریح اجتناب می‌کنند. علاوه بر این، در مورد یک schema dynamically generated (مانند یک schema Avro که از یک database table تولید شده است)، code generation یک مانع غیرضروری برای رسیدن به داده‌ها است.
    </p>
    <p>
        Avro code generation اختیاری را برای زبان‌های برنامه‌نویسی statically typed ارائه می‌دهد، اما می‌توان از آن نیز بدون هیچ code generation استفاده کرد. اگر شما یک object con‐tainer file (که schema writer’s را تعبیه می‌کند) دارید، شما می‌توانید به سادگی آن را با استفاده از کتابخانه Avro باز کنید و به data به همان روشی که می‌توانید به یک فایل JSON نگاه کنید، نگاه کنید. فایل self-describing است زیرا شامل تمام metadata ضروری است.
    </p>
    <p>
        این property به ویژه در conjunction با زبان‌های data pro‐cessing dynamically typed مانند Apache Pig [26] مفید است. در Pig، شما می‌توانید فقط برخی از فایل‌های Avro را باز کنید، شروع به تجزیه و تحلیل آن‌ها کنید و datasets مشتق شده را به فایل‌های خروجی در format Avro بنویسید، بدون اینکه حتی به schemas فکر کنید.
    </p>
    <h4>The Merits of Schemas</h4>
    <p>
        همانطور که دیدیم، Protocol Buffers, Thrift و Avro همگی از یک schema برای توصیف یک binary encoding format استفاده می‌کنند. زبان‌های schema آن‌ها بسیار ساده‌تر از XML Schema یا JSON Schema هستند، که از قوانین اعتبارسنجی بسیار دقیق‌تری پشتیبانی می‌کنند (به عنوان مثال، "string value از این فیلد باید با این regular expression مطابقت داشته باشد" یا "the integer value از این فیلد باید بین 0 و 100 باشد"). از آنجایی که Protocol Buffers, Thrift و Avro ساده‌تر برای پیاده‌سازی و ساده‌تر برای استفاده هستند، آن‌ها برای پشتیبانی از طیف نسبتاً گسترده‌ای از زبان‌های برنامه‌نویسی رشد کرده‌اند.
    </p>
    <p>
        ایده‌هایی که این encodings بر اساس آن‌ها هستند، به هیچ وجه جدید نیستند. به عنوان مثال، آن‌ها اشتراکات زیادی با ASN.1 دارند، یک زبان تعریف schema که اولین بار در سال 1984 [27] استاندارد شد. این برای تعریف پروتکل‌های شبکه مختلف استفاده می‌شد و encoding binary آن (DER) هنوز برای encoding SSL certificates (X.509)، به عنوان مثال، استفاده می‌شود [28]. ASN.1 از schema evolution با استفاده از tag numbers پشتیبانی می‌کند، مشابه Protocol Buf‐
    </p>
    <p>
        Formats for Encoding Data | 127
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>