<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 387</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <h4>xiii. This particular variant of consensus</h4>
    <p>
        This particular variant of consensus is called uniform consensus، که معادل regular consensus در asynchronous systems با unreliable failure detectors است [71]. The academic literature معمولاً به جای nodes، به processes اشاره دارد، اما ما در اینجا برای consistency با بقیه این کتاب از nodes استفاده می‌کنیم.
    </p>

    <p>
        در این formalism، یک consensus algorithm باید properties زیر را برآورده کند [25]:xiii
    </p>
    <ul>
        <li>Uniform agreement
            <p>
                هیچ دو node متفاوت تصمیم نمی‌گیرند.
            </p>
        </li>
        <li>Integrity
            <p>
                هیچ node دو بار تصمیم نمی‌گیرد.
            </p>
        </li>
        <li>Validity
            <p>
                اگر یک node، مقدار v را تصمیم بگیرد، سپس v توسط یک node پیشنهاد شده است.
            </p>
        </li>
        <li>Termination
            <p>
                هر node که crash نکند، در نهایت مقداری را تصمیم می‌گیرد.
            </p>
        </li>
    </ul>

    <p>
        The uniform agreement و integrity properties، ایده اصلی از consensus را تعریف می‌کنند: همه در مورد یک outcome یکسان تصمیم می‌گیرند، و هنگامی که شما تصمیم گرفتید، شما نمی‌توانید نظر خود را تغییر دهید. The validity property، بیشتر برای رد کردن trivial solutions وجود دارد: به عنوان مثال، شما می‌توانید یک algorithm داشته باشید که همیشه null را تصمیم می‌گیرد، مهم نیست چه چیزی پیشنهاد شده است؛ این algorithm، agreement و integrity properties را برآورده می‌کند، اما validity property را نه.
    </p>

    <p>
        اگر شما در مورد fault tolerance اهمیت نمی‌دهید، سپس برآورده کردن سه property اول آسان است: شما می‌توانید فقط یک node را به عنوان "dictator" hardcode کنید، و اجازه دهید آن node تمام decisions را انجام دهد. با این حال، اگر آن یک node شکست بخورد، سپس سیستم دیگر نمی‌تواند هیچ تصمیمی بگیرد. در واقع، این همان چیزی است که ما در مورد two-phase commit دیدیم: اگر the coordinator شکست بخورد، in-doubt participants نمی‌توانند تصمیم بگیرند که آیا commit کنند یا abort.
    </p>

    <p>
        The termination property، ایده fault tolerance را فرموله می‌کند. این اساساً می‌گوید که یک consensus algorithm نمی‌تواند به سادگی در اطراف بنشیند و برای همیشه هیچ کاری انجام ندهد - به عبارت دیگر، باید progress کند. حتی اگر برخی از nodes شکست بخورند، other nodes هنوز هم باید به یک decision برسند. (Termination یک liveness property است، در حالی که سه property دیگر safety properties هستند - به "Safety and liveness" در صفحه 308 مراجعه کنید.)
    </p>

    <p>
        The system model of consensus فرض می‌کند که هنگامی که یک node "crashes"، ناگهان ناپدید می‌شود و هرگز برنمی‌گردد. (به جای یک software crash، تصور کنید که یک زلزله وجود دارد، و datacenter شامل node شما توسط یک landslide نابود می‌شود. شما باید فرض کنید که node شما زیر 30 فوت گل مدفون شده است و هرگز قرار نیست دوباره online شود.) در این system model، هر algorithm که باید منتظر بازیابی یک node باشد، قرار نیست بتواند termination property را برآورده کند. به طور خاص، 2PC الزامات termination را برآورده نمی‌کند.
    </p>
    <p>
        Distributed Transactions and Consensus | 365
    </p>
 </div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>