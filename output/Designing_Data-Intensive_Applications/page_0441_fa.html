<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 441</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <h4>فراتر از <strong>MapReduce</strong></h4>
    <p>
        اگرچه <strong>MapReduce</strong> بسیار محبوب شد و در اواخر دهه 2000 مورد توجه زیادی
        قرار گرفت، اما تنها یکی از بسیاری از مدل‌های برنامه‌نویسی ممکن برای
        سیستم‌های توزیع شده است. بسته به حجم داده‌ها، ساختار داده‌ها، و نوع
        پردازشی که با آن‌ها انجام می‌شود، ابزارهای دیگر ممکن است برای بیان یک
        محاسبه مناسب‌تر باشند.
    </p>
    <p>
        با این وجود، ما زمان زیادی را در این فصل صرف بحث در مورد <strong>MapReduce</strong>
        کردیم زیرا این یک ابزار یادگیری مفید است، زیرا یک انتزاع نسبتاً واضح و ساده
        بر روی یک سیستم فایل توزیع شده است. یعنی ساده به این معنا که بتوانیم
        درک کنیم چه کار می‌کند، نه به این معنا که استفاده از آن آسان است. کاملاً
        برعکس: پیاده‌سازی یک job پردازش پیچیده با استفاده از <strong>APIs</strong> های خام
        <strong>MapReduce</strong> در واقع بسیار دشوار و طاقت‌فرسا است—به عنوان مثال، شما
        باید هر الگوریتم <strong>join</strong> را از ابتدا پیاده‌سازی کنید [37].
    </p>
    <p>
        در پاسخ به دشواری استفاده مستقیم از <strong>MapReduce</strong>، مدل‌های برنامه‌نویسی
        سطح بالاتر مختلف (<strong>Pig</strong>، <strong>Hive</strong>، <strong>Cascading</strong>، <strong>Crunch</strong>) به عنوان
        انتزاع‌هایی بر روی <strong>MapReduce</strong> ایجاد شدند. اگر شما درک کنید که
        <strong>MapReduce</strong> چگونه کار می‌کند، یادگیری آن‌ها نسبتاً آسان است، و
        ساختارهای سطح بالاتر آن‌ها، بسیاری از وظایف پردازش <strong>batch</strong> رایج را به
        طور قابل توجهی آسان‌تر می‌کند.
    </p>
    <p>
        با این حال، مشکلاتی نیز در خود مدل اجرای <strong>MapReduce</strong> وجود دارد، که با
        افزودن یک سطح دیگر از انتزاع برطرف نمی‌شوند و خود را به صورت عملکرد
        ضعیف برای برخی از انواع پردازش نشان می‌دهند. از یک طرف، <strong>MapReduce</strong>
        بسیار <strong>robust</strong> است: شما می‌توانید از آن برای پردازش تقریباً مقادیر
        دلخواه بزرگی از داده‌ها در یک سیستم <strong>multi-tenant</strong> غیرقابل اعتماد با
        خاتمه‌های مکرر <strong>task</strong> استفاده کنید، و همچنان job را انجام می‌دهد (اگرچه
        آهسته). از سوی دیگر، ابزارهای دیگر گاهی اوقات چندین مرتبه سریع‌تر برای
        برخی از انواع پردازش هستند.
    </p>
    <p>
        در بقیه این فصل، ما به برخی از این جایگزین‌ها برای پردازش <strong>batch</strong>
        نگاه خواهیم کرد. در فصل 11 ما به پردازش جریان می‌رویم، که می‌تواند به
        عنوان راه دیگری برای سرعت بخشیدن به پردازش <strong>batch</strong> در نظر گرفته شود.
    </p>

    <h4><strong>Materialization</strong> از حالت <strong>Intermediate</strong></h4>
    <p>
        همان‌طور که قبلاً بحث شد، هر job <strong>MapReduce</strong> از هر job دیگری مستقل
        است. نقاط تماس اصلی یک job با بقیه جهان، دایرکتوری‌های ورودی و خروجی
        آن در سیستم فایل توزیع شده است. اگر شما می‌خواهید خروجی یک job به
        ورودی یک job دوم تبدیل شود، شما نیاز دارید دایرکتوری ورودی job دوم را
        به عنوان دایرکتوری خروجی job اول پیکربندی کنید، و یک زمان‌بند
        <strong>workflow</strong> خارجی باید job دوم را تنها پس از تکمیل job اول، شروع کند.
    </p>
    <p>
        این تنظیم مناسب است اگر خروجی از job اول، یک مجموعه داده باشد که شما
        می‌خواهید در سازمان خود به طور گسترده منتشر کنید. در این صورت، شما باید
        بتوانید به آن ارجاع دهید
        <strong>Beyond MapReduce</strong>
        |
        419
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>