<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 442</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        با <strong>name</strong> و استفاده مجدد از آن به عنوان ورودی برای چندین job مختلف
        (از جمله jobs های توسعه یافته توسط تیم‌های دیگر). انتشار داده‌ها به یک
        مکان شناخته شده در سیستم فایل توزیع شده، <strong>coupling</strong> آزاد را ممکن می‌سازد
        تا jobs نیازی نداشته باشند که بدانند چه کسی ورودی آن‌ها را تولید یا
        خروجی آن‌ها را مصرف می‌کند (نگاه کنید به "جدا کردن منطق و سیم‌کشی" در
        صفحه 396).
    </p>
    <p>
        با این حال، در بسیاری از موارد، شما می‌دانید که خروجی یک job فقط برای
        ورودی یک job دیگر استفاده می‌شود، که توسط همان تیم نگهداری می‌شود. در
        این مورد، فایل‌ها در سیستم فایل توزیع شده به سادگی حالت <strong>intermediate</strong>
        هستند: وسیله‌ای برای انتقال داده‌ها از یک job به job بعدی. در جریان‌های
        کاری پیچیده‌ای که برای ساخت سیستم‌های توصیه شامل 50 یا 100 jobs
        <strong>MapReduce</strong> استفاده می‌شود [29]، حالت <strong>intermediate</strong> زیادی از این
        دست وجود دارد.
    </p>
    <p>
        فرآیند نوشتن این حالت <strong>intermediate</strong> به فایل‌ها <strong>materialization</strong> نامیده
        می‌شود. (ما قبلاً در زمینه <strong>materialized views</strong>، در "تجمیع: <strong>Data Cubes</strong>
        و <strong>Materialized Views</strong>" در صفحه 101 با این اصطلاح مواجه شدیم. این به
        معنای مشتاقانه محاسبه کردن نتیجه‌ی یک عملیات و نوشتن آن است، به جای
        محاسبه‌ی آن بر اساس تقاضا در هنگام درخواست.)
    </p>
    <p>
        در مقابل، مثال تجزیه و تحلیل <strong>log</strong> در ابتدای فصل از <strong>Unix pipes</strong> برای
        اتصال خروجی یک دستور با ورودی دستور دیگر استفاده کرد. <strong>Pipes</strong> حالت
        <strong>intermediate</strong> را به‌طور کامل <strong>materialize</strong> نمی‌کنند، بلکه به‌طور
        افزایشی خروجی را به ورودی <strong>stream</strong> می‌کنند، با استفاده از تنها یک
        بافر <em>in-memory</em> کوچک.
    </p>
    <p>
        رویکرد <strong>MapReduce</strong> برای <strong>materializing</strong> کامل حالت <strong>intermediate</strong>، در
        مقایسه با <strong>Unix pipes</strong>، دارای معایبی است:
    </p>
    <ul>
        <li>
            یک job <strong>MapReduce</strong> تنها زمانی می‌تواند شروع شود که تمام <strong>tasks</strong>
            در jobs های قبلی (که ورودی‌های آن را تولید می‌کنند) تکمیل شده باشند،
            در حالی که فرآیندهای متصل توسط یک <strong>Unix pipe</strong> همزمان شروع
            می‌شوند، با خروجی که به محض تولید شدن مصرف می‌شود.
            <strong>Skew</strong> یا بار متفاوت بر روی ماشین‌های مختلف به این معنی است که یک job
            اغلب دارای چند <strong>straggler tasks</strong> است که زمان بیشتری نسبت به سایر
            <strong>tasks</strong> طول می‌کشد تا تکمیل شوند. مجبور بودن به انتظار تا تکمیل شدن
            تمام <strong>tasks</strong> از job قبلی، اجرای <strong>workflow</strong> را به عنوان یک کل کند
            می‌کند.
        </li>
        <li>
            <strong>Mappers</strong> اغلب <em>redundant</em> هستند: آن‌ها فقط همان فایلی را می‌خوانند که
            به تازگی توسط یک <strong>reducer</strong> نوشته شده است، و آن را برای مرحله‌ی
            بعدی تقسیم‌بندی و مرتب‌سازی آماده می‌کنند. در بسیاری از موارد، کد
            <strong>mapper</strong> می‌تواند بخشی از <strong>reducer</strong> قبلی باشد: اگر خروجی <strong>reducer</strong>
            به همان روشی که خروجی <strong>mapper</strong> تقسیم‌بندی و مرتب‌سازی شده بود،
            تقسیم‌بندی و مرتب‌سازی می‌شد، آن‌گاه <strong>reducers</strong> می‌توانستند مستقیماً
            به هم متصل شوند، بدون این‌که با مراحل <strong>mapper</strong> تداخل داشته باشند.
        </li>
        <li>
            ذخیره‌سازی حالت <strong>intermediate</strong> در یک سیستم فایل توزیع شده به این معنی
            است که آن فایل‌ها در چندین <strong>node</strong> تکرار می‌شوند، که اغلب برای چنین
            داده‌های موقتی <em>overkill</em> است.
        </li>
    </ul>
    <p>
        420
        |
        فصل 10: پردازش <strong>Batch</strong>
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>