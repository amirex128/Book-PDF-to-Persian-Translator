<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 397</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <ol>
        <li>Use an algorithm to automatically choose a new leader.
            <p>
                این رویکرد به یک consensus algorithm نیاز دارد، و توصیه می‌شود از یک algorithm اثبات شده استفاده کنید که شرایط نامطلوب شبکه را به درستی handle کند [107].
            </p>
        </li>
    </ol>

    <p>
        اگرچه یک single-leader database می‌تواند linearizability را بدون اجرای یک consensus algorithm در هر write ارائه دهد، اما همچنان برای حفظ leadership و برای تغییرات leadership به consensus نیاز دارد. بنابراین، به نوعی، داشتن یک leader فقط "kicks the can down the road" است: consensus هنوز هم مورد نیاز است، فقط در یک مکان متفاوت، و کمتر مکرر. خبر خوب این است که algorithms و systems fault-tolerant برای consensus وجود دارد، و ما به طور خلاصه در این فصل در مورد آن‌ها بحث کردیم.
    </p>

    <p>
        ابزارهایی مانند ZooKeeper نقش مهمی در ارائه یک consensus "outsourced"، failure detection، و membership service ایفا می‌کنند که applications می‌توانند از آن استفاده کنند. استفاده از آن آسان نیست، اما بسیار بهتر از تلاش برای توسعه algorithms خودتان است که بتوانند در برابر تمام مشکلات مورد بحث در فصل 8 مقاومت کنند. اگر شما متوجه شدید که می‌خواهید یکی از آن چیزهایی را انجام دهید که به consensus قابل تقلیل است، و شما می‌خواهید fault-tolerant باشد، سپس توصیه می‌شود از چیزی مانند ZooKeeper استفاده کنید.
    </p>

    <p>
        با این وجود، همه سیستم‌ها لزوماً به consensus نیاز ندارند: به عنوان مثال، سیستم‌های leaderless و multi-leader replication معمولاً از global consensus استفاده نمی‌کنند. The conflicts که در این systems رخ می‌دهد ("Handling Write Conflicts" در صفحه 171 را ببینید) نتیجه نداشتن consensus در سراسر leadersهای مختلف است، اما شاید این اشکالی نداشته باشد: شاید ما به سادگی نیاز داریم که بدون linearizability مقابله کنیم و یاد بگیریم که بهتر با داده‌هایی که دارای branching و merging version histories هستند، کار کنیم.
    </p>

    <p>
        این فصل به تحقیقات زیادی در مورد تئوری distributed systems اشاره کرد. اگرچه مقالات و اثبات‌های تئوری همیشه آسان نیستند، و گاهی اوقات فرضیات غیرواقعی را مطرح می‌کنند، اما برای اطلاع‌رسانی از کار عملی در این زمینه بسیار ارزشمند هستند: آن‌ها به ما کمک می‌کنند در مورد آنچه که می‌توان و نمی‌توان انجام داد استدلال کنیم، و به ما کمک می‌کنند راه‌های counterintuitive را که در آن distributed systems اغلب flawed هستند، پیدا کنیم. اگر وقت دارید، بررسی منابع ارزش دارد.
    </p>

    <p>
        این ما را به پایان Part II از این کتاب می‌رساند، که در آن ما replication (فصل 5)، partitioning (فصل 6)، transactions (فصل 7)، distributed system failure models (فصل 8)، و در نهایت consistency و consensus (فصل 9) را پوشش دادیم. اکنون که ما یک foundation محکم از تئوری ایجاد کرده‌ایم، در Part III، ما یک بار دیگر به سیستم‌های عملی‌تر خواهیم پرداخت، و در مورد نحوه ساختن applications قدرتمند از heterogeneous building blocks بحث خواهیم کرد.
    </p>

    <h4>References</h4>
    <p>[1] Peter Bailis and Ali Ghodsi: “Eventual Consistency Today: Limitations, Extensions, and Beyond,” ACM Queue, volume 11, number 3, pages 55-63, March 2013.
        doi:10.1145/2460276.2462076
    </p>
    <p>
        Summary | 375
    </p>
 </div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>