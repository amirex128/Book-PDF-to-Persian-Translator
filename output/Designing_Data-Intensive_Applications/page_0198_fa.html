<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 198</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        with its own identifier، that data change is ignored، زیرا node می‌داند که قبلاً آن را پردازش کرده است.
    </p>
    <p>
        A problem با topologies circular و star این است که اگر فقط یک node fail شود، می‌تواند flow از replication messages بین other nodes را قطع کند و باعث می‌شود که آن‌ها نتوانند ارتباط برقرار کنند تا زمانی که node تعمیر شود. The topology می‌تواند برای کار در اطراف node fail شده دوباره پیکربندی شود، اما در اکثر deployments، چنین reconfiguration باید به صورت دستی انجام شود. The fault tolerance از یک topology متصل‌تر (مانند all-to-all) بهتر است زیرا به messages اجازه می‌دهد تا در امتداد paths مختلف حرکت کنند و از یک point of failure واحد اجتناب کنند.
    </p>
    <p>
        از سوی دیگر، all-to-all topologies نیز می‌توانند مشکلاتی داشته باشند. به طور خاص، برخی از network links ممکن است سریعتر از دیگران باشند (به عنوان مثال، به دلیل network congestion)، با نتیجه این که برخی از replication messages ممکن است other را "overtake" کنند، همانطور که در شکل 5-9 نشان داده شده است.
    </p>
    <p>
        شکل 5-9. With multi-leader replication، writes ممکن است به ترتیب اشتباه در برخی از replicas برسند.
    </p>
    <p>
        در شکل 5-9، client A یک ردیف را در leader 1 درج می‌کند و client B آن ردیف را در leader 3 به‌روزرسانی می‌کند. با این حال، leader 2 ممکن است writes را به ترتیب متفاوتی دریافت کند: ممکن است ابتدا update را دریافت کند (که، از دیدگاه آن، یک update به یک ردیف است که در database وجود ندارد) و فقط بعداً insert مربوطه را دریافت کند (که
        باید قبل از update آمده باشد).
    </p>
    <p>
        This is a problem of causality، similar to the one we saw in “Consistent Prefix Reads” on page 165: the update depends on the prior insert, so we need to make sure that all nodes process the insert first, and then the update. Simply attaching a timestamp to
    </p>
    <p>
        176 | Chapter 5: Replication
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0198/image_1.png" alt="Image from page 198" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>