<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 43</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <h3>علائم پیچیدگی</h3>
    <p>
        متغیرهای مختلفی از علائم پیچیدگی وجود دارد: انفجار فضای حالت، coupling تنگاتنگ ماژول‌ها، وابستگی‌های درهم‌تنیده، نام‌گذاری و اصطلاحات ناسازگار، hacks با هدف حل مشکلات performance، special-casing برای دور زدن issues در جای دیگر، و موارد بسیار دیگر. در این مورد مطالب زیادی گفته شده است [31, 32, 33].
    </p>
    <p>
        هنگامی که پیچیدگی، maintenance را دشوار می‌کند، بودجه‌ها و برنامه‌ها اغلب over‐run می‌شوند. در نرم‌افزار پیچیده، خطر بیشتری برای معرفی bugs هنگام ایجاد تغییر وجود دارد: هنگامی که درک و استدلال سیستم برای developers سخت‌تر می‌شود، فرض‌های پنهان، عواقب ناخواسته، و تعاملات غیرمنتظره، راحت‌تر نادیده گرفته می‌شوند. برعکس، کاهش پیچیدگی به شدت قابلیت maintenance نرم‌افزار را بهبود می‌بخشد و بنابراین سادگی باید یک هدف کلیدی برای سیستم‌هایی باشد که ما می‌سازیم.
    </p>
    <p>
        ساده‌تر کردن یک سیستم لزوماً به معنای کاهش عملکرد آن نیست؛ همچنین می‌تواند به معنای حذف پیچیدگی تصادفی باشد. Moseley و Marks [32] پیچیدگی را accidental تعریف می‌کنند اگر ذاتی در مشکلی که نرم‌افزار حل می‌کند (همانطور که توسط کاربران دیده می‌شود) نباشد، اما فقط از پیاده‌سازی ناشی شود.
    </p>
    <p>
        یکی از بهترین ابزارهایی که برای حذف پیچیدگی accidental در اختیار داریم، abstraction است. یک abstraction خوب می‌تواند مقدار زیادی از جزئیات پیاده‌سازی را پشت یک façade تمیز و ساده برای درک پنهان کند. یک abstraction خوب همچنین می‌تواند برای طیف گسترده‌ای از applications مختلف استفاده شود. نه تنها این reuse از reimplementing یک چیز مشابه چندین بار کارآمدتر است، بلکه منجر به نرم‌افزار با کیفیت بالاتری نیز می‌شود، زیرا پیشرفت‌های کیفیت در جزء abstraction شده، به همه applications که از آن استفاده می‌کنند، سود می‌رساند.
    </p>
    <p>
        به عنوان مثال، زبان‌های برنامه‌نویسی high-level، abstractions هستند که machine code، CPU registers و syscalls را پنهان می‌کنند. SQL یک abstraction است که ساختارهای داده on-disk و in-memory پیچیده، درخواست‌های concurrent از سایر clients و inconsistencies پس از crashes را پنهان می‌کند. البته، هنگام برنامه‌نویسی در یک زبان high-level، ما همچنان از machine code استفاده می‌کنیم. ما فقط مستقیماً از آن استفاده نمی‌کنیم، زیرا abstraction زبان برنامه‌نویسی ما را از فکر کردن در مورد آن نجات می‌دهد.
    </p>
    <p>
        با این حال، یافتن abstractions خوب بسیار دشوار است. در زمینه distributed systems، اگرچه الگوریتم‌های خوب زیادی وجود دارد، اما اینکه چگونه باید آن‌ها را در abstractions بسته‌بندی کنیم تا به ما کمک کند پیچیدگی سیستم را در یک سطح قابل مدیریت نگه داریم، بسیار کمتر مشخص است.
    </p>
    <p>
        در سراسر این کتاب، ما چشمان خود را برای abstractions خوب باز نگه می‌داریم که به ما امکان می‌دهد بخش‌هایی از یک سیستم بزرگ را به components تعریف شده و قابل استفاده مجدد استخراج کنیم.
    </p>

    <h4>Evolvability: آسان کردن تغییر</h4>
    <p>
        بسیار بعید است که requirements سیستم شما برای همیشه بدون تغییر باقی بمانند. احتمال بیشتری وجود دارد که آن‌ها در نوسان مداوم باشند: شما حقایق جدیدی یاد می‌گیرید، use cases قبلاً پیش‌بینی نشده ظهور می‌کنند، اولویت‌های تجاری تغییر می‌کنند، users، new ها را درخواست می‌کنند.
    </p>
    <p>
        Maintainability | 21
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>