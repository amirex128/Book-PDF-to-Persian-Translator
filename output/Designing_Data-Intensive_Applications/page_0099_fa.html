<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 99</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        i. If all keys and values had a fixed size, you could use binary search on a segment file and avoid the in-memory index entirely. However, they are usually variable-length in practice, which makes it difficult to tell where one record ends and the next one starts if you don’t have an index.
    </p>
    <p>
        What if the same key appears in several input segments? Remember that each segment contains all the values written to the database during some period of time. This means that all the values in one input segment must be more recent than all the values in the other segment (assuming that we always merge adjacent segments). When multiple segments contain the same key, we can keep the value from the most recent segment and discard the values in older segments.
    </p>
    <ol>
        <li>به منظور یافتن یک key خاص در فایل، شما دیگر نیازی به نگه‌داشتن یک index از همه keys در memory ندارید. به شکل 3-5 برای یک مثال مراجعه کنید: فرض کنید شما به دنبال key handiwork هستید، اما شما offset دقیق آن key را در فایل segment نمی‌دانید. با این حال، شما offsets را برای keys handbag و handsome می‌دانید و به دلیل sorting شما می‌دانید که handiwork باید بین آن دو ظاهر شود. این بدان معنی است که شما می‌توانید به offset برای handbag بروید و از آنجا تا زمانی که handiwork را پیدا می‌کنید، scan کنید (یا نه، اگر key در فایل وجود نداشته باشد).</li>
    </ol>
    <p>
        شکل 3-5. An SSTable با یک index in-memory.
    </p>
    <p>
        شما هنوز به یک index in-memory نیاز دارید تا offsets را برای برخی از keys به شما بگوید، اما می‌تواند sparse باشد: یک key برای هر چند کیلوبایت از فایل segment کافی است، زیرا چند کیلوبایت را می‌توان بسیار سریع scan کرد.i
    </p>
    <ol start="3">
        <li>از آنجایی که درخواست‌های read در هر صورت نیاز به scan بر روی چندین key-value pairs در range درخواستی دارند، امکان گروه‌بندی آن records در یک block و compress کردن آن قبل از نوشتن آن روی دیسک وجود دارد (که توسط ناحیه سایه‌دار در شکل 3-5 نشان داده شده است). سپس هر ورودی از index in-memory sparse به ابتدای یک block compressed اشاره می‌کند.</li>
    </ol>
    <p>
        علاوه بر صرفه‌جویی در فضای دیسک، compression همچنین استفاده از پهنای باند I/O را کاهش می‌دهد.
    </p>
    <p>
        Data Structures That Power Your Database | 77
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0099/image_1.png" alt="Image from page 99" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>