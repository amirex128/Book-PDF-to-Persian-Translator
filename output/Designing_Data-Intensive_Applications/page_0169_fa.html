<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 169</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        machines، شما نیازی به operating در مقیاس Google ندارید: حتی برای شرکت‌های کوچک، یک architecture distributed multi-region اکنون امکان‌پذیر است.
    </p>
    <p>
        در این بخش از کتاب، ما بر shared-nothing architectures متمرکز می‌شویم—نه به این دلیل که آن‌ها لزوماً بهترین انتخاب برای هر use case هستند، بلکه به این دلیل که آن‌ها بیشترین احتیاط را از شما، developer application، می‌طلبند. اگر data شما در سراسر multiple nodes توزیع شده است، شما باید از constraints و trade-offs که در چنین سیستم distributed رخ می‌دهد، آگاه باشید—database نمی‌تواند جادویی آن‌ها را از شما پنهان کند.
    </p>
    <p>
        در حالی که یک shared-nothing architecture distributed مزایای زیادی دارد، اما معمولاً پیچیدگی‌های اضافی را برای applications به همراه دارد و گاهی اوقات expressiveness از data models که شما می‌توانید استفاده کنید را محدود می‌کند. در برخی موارد، یک برنامه تک رشته‌ای ساده می‌تواند به طور قابل توجهی بهتر از یک cluster با بیش از 100 هسته CPU عمل کند [4]. از سوی دیگر، سیستم‌های shared-nothing می‌توانند بسیار قدرتمند باشند. چند فصل آینده به جزئیات در مورد issues که هنگام توزیع داده‌ها به وجود می‌آیند، می‌پردازد.
    </p>
    <h4>Replication Versus Partitioning</h4>
    <p>
        دو روش رایج برای توزیع داده‌ها در سراسر multiple nodes وجود دارد:
    </p>
    <ul>
        <li>Replication</li>
        <li>نگه‌داشتن یک کپی از همان داده‌ها در چندین node مختلف، که به طور بالقوه در locations متفاوت هستند. Replication redundancy را فراهم می‌کند: اگر برخی از nodes در دسترس نباشند، data هنوز هم می‌تواند از nodes باقی‌مانده ارائه شود. Replication همچنین می‌تواند به بهبود performance کمک کند. ما در مورد replication در فصل 5 بحث می‌کنیم.</li>
        <li>Partitioning</li>
        <li>تقسیم یک database بزرگ به زیرمجموعه‌های کوچکتر که partitions نامیده می‌شوند، به طوری که partitions مختلف می‌توانند به nodes مختلف (که همچنین به عنوان sharding شناخته می‌شوند) اختصاص داده شوند. ما در مورد partitioning در فصل 6 بحث می‌کنیم.</li>
    </ul>
    <p>
        این‌ها مکانیزم‌های جداگانه‌ای هستند، اما آن‌ها اغلب با هم همراه می‌شوند، همانطور که در شکل II-1 نشان داده شده است.
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>