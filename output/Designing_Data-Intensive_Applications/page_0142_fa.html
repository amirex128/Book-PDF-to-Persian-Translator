<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 142</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        otherwise بسیار شبیه به CompactProtocol از Thrift است. Protocol Buffers همان record را در 33 بایت جا می‌دهد.
    </p>
    <p>
        شکل 4-4. Example record encoded با استفاده از Protocol Buffers.
    </p>
    <p>
        یک نکته قابل توجه: در schemas که قبلاً نشان داده شد، هر فیلد یا required یا optional علامت‌گذاری شده بود، اما این هیچ تفاوتی در نحوه encoding فیلد ایجاد نمی‌کند (هیچ چیز در داده‌های binary نشان نمی‌دهد که آیا یک فیلد required بوده است یا خیر). تفاوت به سادگی این است که required یک بررسی runtime را فعال می‌کند که در صورت تنظیم نشدن فیلد، fail می‌شود، که می‌تواند برای گرفتن bugs مفید باشد.
    </p>
    <h4>Field tags و schema evolution</h4>
    <p>
        ما قبلاً گفتیم که schemas ناگزیر نیاز به تغییر در طول زمان دارند. ما به این schema evolution می‌گوییم. چگونه Thrift و Protocol Buffers تغییرات schema را در حین حفظ backward و forward compatibility مدیریت می‌کنند؟
    </p>
    <p>
        همانطور که از مثال‌ها مشاهده می‌کنید، یک record encoded، فقط concatenation از fields encoded آن است. هر فیلد توسط tag number خود (اعداد 1، 2، 3 در نمونه schemas) شناسایی می‌شود و با یک datatype (به عنوان مثال، string یا integer) حاشیه‌نویسی می‌شود. اگر یک فیلد value تنظیم نشده باشد، به سادگی از record encoded حذف می‌شود. از این می‌توانید ببینید که field tags برای معنای داده‌های encoded بسیار مهم هستند. شما می‌توانید name از یک فیلد را در schema تغییر دهید، زیرا data encoded هرگز به field names اشاره نمی‌کند، اما شما نمی‌توانید tag یک فیلد را تغییر دهید، زیرا این کار تمام داده‌های موجود را invalid می‌کند.
    </p>
    <p>
        120 | Chapter 4: Encoding and Evolution
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0142/image_1.png" alt="Image from page 142" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>