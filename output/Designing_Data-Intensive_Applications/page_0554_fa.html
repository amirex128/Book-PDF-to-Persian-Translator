<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 554</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>هرچه سیستم‌های بیشتری را بتوانیم در بررسی یکپارچگی لحاظ کنیم، فرصت‌های کمتری برای نادیده گرفتن فساد در مرحله‌ای از فرآیند وجود دارد. اگر بتوانیم بررسی کنیم که کل 
   <strong>data pipeline</strong>
   مشتق‌شده از ابتدا تا انتها درست است، در این صورت هر دیسک، شبکه، 
   <strong>service</strong>
   و الگوریتم در طول مسیر، به‌طور ضمنی در بررسی لحاظ می‌شوند.</p>
  <p>داشتن بررسی‌های یکپارچگی 
   <strong>end-to-end</strong>
   مداوم، اعتماد شما را نسبت به درستی سیستم‌هایتان افزایش می‌دهد، که به نوبه خود به شما امکان می‌دهد سریع‌تر حرکت کنید [70]. مانند تست خودکار، 
   <strong>auditing</strong>
   شانس یافتن سریع 
   <strong>bug</strong>
   ها را افزایش می‌دهد و در نتیجه خطر آسیب دیدن به دلیل تغییر در سیستم یا فناوری ذخیره‌سازی جدید را کاهش می‌دهد. اگر از ایجاد تغییرات نمی‌ترسید، می‌توانید یک 
   <strong>application</strong>
   را بسیار بهتر برای پاسخگویی به نیازهای در حال تغییر، تکامل دهید.</p>
  <h4>ابزارهایی برای سیستم‌های <strong>data</strong> قابل <strong>audit</strong></h4>
  <p>در حال حاضر، سیستم‌های 
   <strong>data</strong>
   زیادی، 
   <strong>auditability</strong>
   را به عنوان یک نگرانی در سطح بالا در نظر نمی‌گیرند. برخی از برنامه‌ها، مکانیزم‌های 
   <strong>audit</strong>
   خود را پیاده‌سازی می‌کنند، به عنوان مثال با ثبت تمام تغییرات در یک جدول 
   <strong>audit</strong>
   جداگانه، اما تضمین یکپارچگی لاگ 
   <strong>audit</strong>
   و وضعیت 
   <strong>database</strong>
   هنوز دشوار است. یک لاگ 
   <strong>transaction</strong>
   را می‌توان با امضای دوره‌ای آن با یک 
   <strong>hardware security module</strong>
   ، غیرقابل دستکاری کرد، اما این تضمین نمی‌کند که 
   <strong>transaction</strong>
   های صحیح در وهله اول وارد لاگ شده باشند.</p>
  <p>استفاده از ابزارهای رمزنگاری برای اثبات یکپارچگی یک سیستم به گونه‌ای که در برابر طیف وسیعی از مسائل 
   <strong>hardware</strong>
   و 
   <strong>software</strong>
   مقاوم باشد و حتی اقدامات بالقوه مخرب جالب خواهد بود. ارزهای رمزنگاری شده، 
   <strong>blockchains</strong>
   و فناوری‌های دفتر کل توزیع‌شده مانند 
   <strong>Bitcoin, Ethereum, Ripple, Stellar</strong>
   و موارد دیگر [71, 72, 73] برای بررسی این حوزه ظهور کرده‌اند.</p>
  <p>من صلاحیت اظهار نظر در مورد مزایای این فناوری‌ها به عنوان ارز یا مکانیزم‌هایی برای توافق‌نامه‌ها را ندارم. با این حال، از دیدگاه سیستم‌های 
   <strong>data</strong>
   ، آنها حاوی ایده‌های جالبی هستند. اساساً، آنها 
   <strong>databases</strong>
   توزیع‌شده‌ای هستند، با یک مدل 
   <strong>data</strong>
   و مکانیزم 
   <strong>transaction</strong>
   ، که در آن 
   <strong>replica</strong>
   های مختلف می‌توانند توسط سازمان‌های غیرقابل اعتماد متقابل میزبانی شوند. 
   <strong>replica</strong>
   ها به‌طور مداوم یکپارچگی یکدیگر را بررسی می‌کنند و از یک پروتکل 
   <strong>consensus</strong>
   برای توافق بر روی 
   <strong>transaction</strong>
   هایی که باید اجرا شوند، استفاده می‌کنند.</p>
  <p>من تا حدودی نسبت به جنبه‌های تحمل خطای 
   <strong>Byzantine</strong>
   این فناوری‌ها شک دارم (به "خطاهای 
   <strong>Byzantine</strong>
   " در صفحه 304 مراجعه کنید)، و تکنیک اثبات کار (به عنوان مثال، 
   <strong>Bitcoin mining</strong>
   ) را فوق‌العاده اتلاف‌آمیز می‌دانم. توان عملیاتی 
   <strong>transaction</strong>
   بیت کوین نسبتاً کم است، اگرچه به دلایل سیاسی و اقتصادی بیشتر از دلایل فنی. با این حال، جنبه‌های بررسی یکپارچگی جالب هستند.</p>
  <p>
   <strong>Auditing</strong>
   رمزنگاری و بررسی یکپارچگی اغلب به 
   <strong>Merkle trees</strong>
   [74] متکی است، که درختانی از 
   <strong>hash</strong>
   ها هستند که می‌توان از آنها برای اثبات کارآمد این که یک رکورد در برخی از مجموعه داده‌ها ظاهر می‌شود (و چند چیز دیگر) استفاده کرد. در خارج از هیاهوی ارزهای رمزنگاری شده، شفافیت گواهی یک فناوری امنیتی است که برای بررسی اعتبار گواهی‌های 
   <strong>TLS/SSL</strong>
   به 
   <strong>Merkle trees</strong>
   متکی است [75, 76].</p>
  <p>532 | فصل 12: آینده سیستم‌های 
   <strong>Data</strong>
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>