<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 550</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        در کنار هم، این مشاهدات به این معنی است که سیستم‌های <strong>dataflow</strong>
        می‌توانند خدمات مدیریت داده را برای بسیاری از برنامه‌ها بدون نیاز
        به هماهنگی، ارائه دهند، در حالی‌که همچنان تضمین‌های <strong>integrity</strong>
        قوی را ارائه می‌دهند. چنین سیستم‌های داده‌ای که از هماهنگی اجتناب
        می‌کنند، جذابیت زیادی دارند: آن‌ها می‌توانند عملکرد و تحمل خطای
        بهتری نسبت به سیستم‌هایی که نیاز به انجام هماهنگی <em>synchronous</em>
        دارند، به‌دست آورند [56].
    </p>
    <p>
        به عنوان مثال، چنین سیستمی می‌تواند به‌صورت توزیع شده در
        چندین <strong>datacenter</strong> در یک پیکربندی چند <strong>leader</strong>
        عمل کند، که به‌صورت <em>asynchronously</em> بین مناطق <strong>replicating</strong>
        می‌کند. هر <strong>datacenter</strong> می‌تواند به‌طور مستقل از سایرین
        به‌عملکرد خود ادامه دهد، زیرا هیچ هماهنگی <em>cross-region
        synchronous</em> مورد نیاز نیست. چنین سیستمی تضمین‌های
        <strong>timeliness</strong> ضعیفی خواهد داشت—نمی‌توانست بدون
        معرفی هماهنگی <em>linearizable</em> باشد—اما همچنان می‌تواند
        تضمین‌های <strong>integrity</strong> قوی داشته باشد.
    </p>
    <p>
        در این <strong>context</strong>، تراکنش‌های <em>serializable</em> همچنان به‌عنوان
        بخشی از حفظ <strong>state</strong> مشتق شده، مفید هستند، اما آن‌ها
        می‌توانند در یک محدوده‌ی کوچک اجرا شوند که در آن خوب عمل
        می‌کنند [8]. تراکنش‌های توزیع شده ناهمگن مانند تراکنش‌های <strong>XA</strong>
        (نگاه کنید به "تراکنش‌های توزیع شده در عمل" در صفحه 360) مورد
        نیاز نیستند. هماهنگی <em>synchronous</em> همچنان می‌تواند در مکان‌هایی
        که مورد نیاز است معرفی شود (به عنوان مثال، برای اعمال
        محدودیت‌های سخت قبل از یک عملیات که بازیابی از آن امکان‌پذیر
        نیست)، اما نیازی نیست که همه‌چیز هزینه‌ی هماهنگی را پرداخت
        کند اگر تنها بخش کوچکی از یک برنامه به آن نیاز داشته باشد [43].
    </p>
    <p>
        یک راه دیگر برای نگاه کردن به هماهنگی و محدودیت‌ها: آن‌ها تعداد
        عذرخواهی‌هایی را که شما باید به‌دلیل ناسازگاری‌ها انجام دهید را
        کاهش می‌دهند، اما به‌طور بالقوه عملکرد و در دسترس بودن سیستم
        شما را نیز کاهش می‌دهند، و بنابراین به‌طور بالقوه تعداد
        عذرخواهی‌هایی که شما باید به‌دلیل قطعی‌ها انجام دهید را
        افزایش می‌دهند. شما نمی‌توانید تعداد عذرخواهی‌ها را به صفر
        برسانید، اما شما می‌توانید هدف خود را پیدا کردن بهترین
        <strong>trade-off</strong> برای نیازهای خود قرار دهید—نقطه‌ی مطلوب
        که در آن نه ناسازگاری‌های زیادی وجود دارد و نه مشکلات در
        دسترسی.
    </p>

    <h4>اعتماد کنید، اما تأیید کنید</h4>
    <p>
        تمام بحث‌های ما در مورد درستی، <strong>integrity</strong>، و تحمل خطا
        تحت این فرض بوده است که چیزهای خاصی ممکن است اشتباه
        پیش بروند، اما چیزهای دیگر این‌طور نخواهند بود. ما این
        فرضیات را مدل سیستم خود می‌نامیم (نگاه کنید به "<strong>Mapping</strong>
        مدل‌های سیستم به دنیای واقعی" در صفحه 309): به عنوان مثال،
        ما باید فرض کنیم که فرآیندها می‌توانند <strong>crash</strong> کنند،
        ماشین‌ها می‌توانند ناگهان برق خود را از دست بدهند، و شبکه
        می‌تواند پیام‌ها را به‌طور دلخواه به تأخیر بیندازد یا <em>drop</em>
        کند. اما ما همچنین ممکن است فرض کنیم که داده‌هایی که روی
        دیسک نوشته می‌شوند، پس از <strong>fsync</strong> از دست نمی‌روند، که
        داده‌ها در حافظه خراب نمی‌شوند، و دستورالعمل ضرب <strong>CPU</strong>
        ما همیشه نتیجه‌ی درستی را برمی‌گرداند.
    </p>
    <p>
        این فرضیات کاملاً منطقی هستند، زیرا آن‌ها بیشتر مواقع درست
        هستند، و اگر ما مجبور بودیم که دائماً نگران اشتباهات کامپیوترهای
        خود باشیم، انجام هر کاری دشوار می‌شد. به‌طور سنتی، مدل‌های
        سیستم یک رویکرد باینری به سمت <strong>faults</strong> در پیش
        می‌گیرند: ما فرض می‌کنیم که برخی از چیزها می‌توانند اتفاق
        بیفتند، و چیزهای دیگر هرگز نمی‌توانند اتفاق بیفتند.
    </p>
    <p>
        در واقعیت، این بیشتر یک مسئله‌ی احتمالات است: برخی از
        چیزها محتمل‌تر هستند، دیگر
        528
        |
        فصل 12: آینده‌ی سیستم‌های داده
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>