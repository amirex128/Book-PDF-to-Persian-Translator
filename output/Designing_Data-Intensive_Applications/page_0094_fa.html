<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 94</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <h4>Hash Indexes</h4>
    <p>
        بیایید با indexes برای key-value data شروع کنیم. این تنها نوع data نیست که می‌توانید index کنید، اما بسیار رایج است و یک building block مفید برای indexes پیچیده‌تر است.
    </p>
    <p>
        Key-value stores کاملاً شبیه به type dictionary هستند که می‌توانید در اکثر زبان‌های برنامه‌نویسی پیدا کنید و معمولاً به عنوان یک hash map (hash table) پیاده‌سازی می‌شوند. Hash maps در بسیاری از کتاب‌های درسی الگوریتم‌ها توضیح داده شده‌اند [1, 2]، بنابراین ما در اینجا به جزئیات نحوه عملکرد آن‌ها نمی‌پردازیم. از آنجایی که ما قبلاً hash maps را برای in-memory data structures خود داریم، چرا از آن‌ها برای index کردن data خود روی دیسک استفاده نکنیم؟
    </p>
    <p>
        بگذارید بگوییم data storage ما فقط شامل اضافه کردن به یک فایل است، همانطور که در مثال قبلی بود. سپس ساده‌ترین strategy indexing ممکن این است: یک in-memory hash map را نگه دارید که در آن هر key به یک byte offset در فایل داده‌ها نگاشت می‌شود—مکانی که در آن value را می‌توان یافت، همانطور که در شکل 3-1 نشان داده شده است. هر زمان که شما یک key-value pair جدید را به فایل اضافه می‌کنید، شما همچنین hash map را به‌روزرسانی می‌کنید تا offset از data که تازه نوشته‌اید را منعکس کند (این هم برای درج keys جدید و هم برای به‌روزرسانی keys موجود کار می‌کند). وقتی می‌خواهید یک value را جستجو کنید، از hash map برای یافتن offset در فایل داده‌ها استفاده کنید، به آن location بروید و value را بخوانید.
    </p>
    <p>
        شکل 3-1. ذخیره یک log از key-value pairs در یک format CSV-like، که با یک in-memory hash map index شده است.
    </p>
    <p>
        این ممکن است ساده‌لوحانه به نظر برسد، اما یک رویکرد مناسب است. در واقع، این اساساً همان کاری است که Bitcask (storage engine پیش‌فرض در Riak) انجام می‌دهد [3]. Bitcask خواندن و نوشتن با performance بالا را ارائه می‌دهد، مشروط بر اینکه همه keys در RAM موجود قرار بگیرند، زیرا hash map کاملاً در memory نگهداری می‌شود. The values می‌توانند از فضای بیشتری نسبت به حافظه موجود استفاده کنند، زیرا می‌توانند از دیسک با فقط یک disk
    </p>
    <p>
        72 | Chapter 3: Storage and Retrieval
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0094/image_1.png" alt="Image from page 94" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>