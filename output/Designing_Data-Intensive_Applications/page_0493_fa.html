<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 493</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        در برخی موارد، استفاده از یک پیام ویژه برای نشان دادن این‌که، "از این
        به بعد دیگر هیچ پیامی با <strong>timestamp</strong> زودتر از t وجود
        نخواهد داشت" امکان‌پذیر است، که می‌تواند توسط <strong>consumers</strong>
        برای راه‌اندازی <strong>windows</strong> استفاده شود [81]. با این حال، اگر
        چندین <strong>producer</strong> روی ماشین‌های مختلف در حال تولید رویدادها
        هستند، که هر کدام دارای آستانه‌های <strong>timestamp</strong> حداقل خود
        هستند، <strong>consumers</strong> نیاز دارند که هر <strong>producer</strong> را به‌صورت
        جداگانه پیگیری کنند. اضافه کردن و حذف <strong>producers</strong> در این
        مورد دشوارتر است.
    </p>

    <h4>به هر حال از ساعت چه کسی استفاده می‌کنید؟</h4>
    <p>
        اختصاص دادن <strong>timestamps</strong> به رویدادها، حتی زمانی که رویدادها
        می‌توانند در چندین نقطه از سیستم <strong>buffered</strong> شوند، دشوارتر
        است. به عنوان مثال، یک برنامه تلفن همراه را در نظر بگیرید که
        رویدادهایی را برای معیارهای استفاده به یک سرور گزارش می‌دهد. این
        برنامه ممکن است در حالی‌که دستگاه <em>offline</em> است، استفاده شود، که
        در این صورت رویدادها را به‌طور محلی روی دستگاه <strong>buffer</strong> می‌کند
        و آن‌ها را زمانی که اتصال به اینترنت دوباره در دسترس قرار گرفت
        (که ممکن است ساعت‌ها یا حتی روزها بعد باشد) به یک سرور ارسال
        می‌کند. برای هر <strong>consumers</strong> از این <strong>stream</strong>، رویدادها
        به‌عنوان <em>stragglers</em> بسیار تأخیردار ظاهر می‌شوند.
    </p>
    <p>
        در این <strong>context</strong>، <strong>timestamp</strong> روی رویدادها واقعاً باید
        زمانی باشد که تعامل کاربر رخ داده است، طبق ساعت محلی دستگاه
        تلفن همراه. با این حال، ساعت روی یک دستگاه کنترل‌شده توسط
        کاربر اغلب قابل اعتماد نیست، زیرا ممکن است به‌طور تصادفی یا
        عمدی روی زمان اشتباه تنظیم شده باشد (نگاه کنید به "همگام‌سازی
        ساعت و دقت" در صفحه 289). زمانی که رویداد توسط سرور دریافت
        شد (طبق ساعت سرور) احتمالاً دقیق‌تر است، زیرا سرور تحت کنترل
        شما است، اما از نظر توصیف تعامل کاربر، کم‌اهمیت‌تر است.
    </p>
    <p>
        برای تنظیم ساعت‌های نادرست دستگاه، یک رویکرد این است که سه
        <strong>timestamps</strong> را ثبت کنید [82]:
    </p>
    <ul>
        <li>
            زمانی که رویداد رخ داد، طبق ساعت دستگاه
        </li>
        <li>
            زمانی که رویداد به سرور ارسال شد، طبق ساعت دستگاه
        </li>
        <li>
            زمانی که رویداد توسط سرور دریافت شد، طبق ساعت سرور
        </li>
    </ul>
    <p>
        با تفریق <strong>timestamp</strong> دوم از سوم، شما می‌توانید <strong>offset</strong> را
        بین ساعت دستگاه و ساعت سرور تخمین بزنید (با فرض این‌که تأخیر
        شبکه در مقایسه با دقت <strong>timestamp</strong> مورد نیاز، ناچیز
        باشد). سپس شما می‌توانید آن <strong>offset</strong> را به <strong>timestamp</strong>
        رویداد اعمال کنید، و در نتیجه زمان واقعی را که در آن رویداد
        واقعاً رخ داده است، تخمین بزنید (با فرض این‌که <strong>device clock
        offset</strong> بین زمانی که رویداد رخ داده است و زمانی که به سرور
        ارسال شده است، تغییر نکرده باشد).
    </p>
    <p>
        این مشکل مختص پردازش <strong>stream</strong> نیست—پردازش <strong>batch</strong>
        از همان مسائل استدلال در مورد زمان رنج می‌برد. این فقط در یک
        <strong>context</strong> <strong>streaming</strong> بیشتر قابل توجه است، که ما
        بیشتر از گذر زمان آگاه هستیم.
        پردازش جریان‌ها
        |
        471
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>