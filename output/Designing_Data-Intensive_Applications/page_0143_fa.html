<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 143</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        You can add new fields to the schema، به شرطی که شما به هر فیلد یک tag number جدید بدهید. اگر کد قدیمی (که در مورد tag numbers جدیدی که شما اضافه کرده‌اید، اطلاعی ندارد) تلاش می‌کند data نوشته شده توسط کد جدید را بخواند، از جمله یک فیلد جدید با یک tag number که آن را تشخیص نمی‌دهد، به سادگی می‌تواند آن فیلد را نادیده بگیرد. the datatype annotation به parser اجازه می‌دهد تا تعیین کند که چند بایت نیاز به skip دارد. این backward com‐patibility را حفظ می‌کند: کد قدیمی می‌تواند records را که توسط کد جدید نوشته شده‌اند، بخواند.
    </p>
    <p>
        در مورد backward compatibility چطور؟ تا زمانی که هر فیلد دارای یک tag number یکتا باشد، کد جدید همیشه می‌تواند data قدیمی را بخواند، زیرا tag numbers هنوز همان معنا را دارند. تنها جزئیات این است که اگر شما یک فیلد جدید اضافه می‌کنید، شما نمی‌توانید آن را required کنید. اگر شما بخواهید یک فیلد را اضافه کنید و آن را required کنید، آن check در صورت خواندن data توسط کد قدیمی، fail می‌شود، زیرا کد قدیمی فیلد جدیدی را که شما اضافه کرده‌اید، نخواهد نوشت. بنابراین، برای حفظ backward compatibility، هر فیلدی که شما پس از deployment اولیه از schema اضافه می‌کنید، باید optional یا دارای یک default value باشد.
    </p>
    <p>
        حذف یک فیلد درست مانند اضافه کردن یک فیلد است، با نگرانی‌های backward و forward compatibility معکوس شده است. این بدان معناست که شما فقط می‌توانید یک فیلد را که optional است، حذف کنید (یک فیلد required هرگز نمی‌تواند حذف شود) و شما هرگز نمی‌توانید دوباره از همان tag number استفاده کنید (زیرا شما هنوز هم ممکن است data را در جایی داشته باشید که شامل tag number قدیمی است، و آن فیلد باید توسط کد جدید نادیده گرفته شود).
    </p>
    <h4>Datatypes and schema evolution</h4>
    <p>
        تغییر datatype یک فیلد چطور؟ این ممکن است امکان‌پذیر باشد—جزئیات را در documentation بررسی کنید—اما خطر این وجود دارد که values دقت خود را از دست بدهند یا truncated شوند. به عنوان مثال، فرض کنید شما یک integer 32 بیتی را به یک integer 64 بیتی تغییر می‌دهید. کد جدید می‌تواند به راحتی data نوشته شده توسط کد قدیمی را بخواند، زیرا parser می‌تواند هر bit گمشده را با zeros پر کند. با این حال، اگر کد قدیمی data نوشته شده توسط کد جدید را می‌خواند، کد قدیمی همچنان از یک متغیر 32 بیتی برای نگه داشتن value استفاده می‌کند. اگر value 64 بیتی decoded در 32 bits جا نشود، truncated خواهد شد.
    </p>
    <p>
        A curious detail از Protocol Buffers این است که آن یک list یا array datatype ندارد، اما در عوض یک repeated marker برای fields دارد (که یک گزینه سوم در کنار required و optional است). همانطور که در شکل 4-4 مشاهده می‌کنید، encoding از یک repeated field دقیقاً همان چیزی است که در مورد آن گفته می‌شود: همان field tag به سادگی چندین بار در record ظاهر می‌شود. این effect خوبی دارد که تغییر یک فیلد optional (single-valued) به یک فیلد repeated (multi-valued) خوب است. کد جدید که data قدیمی را می‌خواند، یک list با صفر یا یک element را می‌بیند (بسته به اینکه آیا فیلد وجود داشته است یا خیر). کد قدیمی که data جدید را می‌خواند، فقط آخرین عنصر از list را می‌بیند.
    </p>
    <p>
        Thrift دارای یک list datatype اختصاصی است که با datatype از list elements پارامتر شده است. این به همان evolution از single-valued به multi-valued که Protocol Buffers انجام می‌دهد، اجازه نمی‌دهد، اما مزیت پشتیبانی از lists nested را دارد.
    </p>
    <p>
        Formats for Encoding Data | 121
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>