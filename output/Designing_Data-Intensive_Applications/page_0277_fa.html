<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 277</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <h4>Pros and cons of stored procedures</h4>
    <p>
        <em>Stored procedures</em> از مدتی پیش در relational databases وجود داشته‌اند، و از سال 1999 بخشی از <em>SQL standard</em> (SQL/PSM) بوده‌اند. آنها به دلایل مختلفی به یک <em>bad reputation</em> رسیده‌اند:
    </p>
    <ul>
        <li>
            هر vendor database زبان خود را برای <em>stored procedures</em> دارد (Oracle دارای PL/SQL است، SQL Server دارای T-SQL است، PostgreSQL دارای PL/pgSQL است، و غیره). این زبان‌ها با پیشرفت‌های زبان‌های برنامه‌نویسی عمومی همگام نبوده‌اند، بنابراین از دیدگاه امروزی بسیار زشت و کهنه به نظر می‌رسند، و فاقد اکوسیستم کتابخانه‌هایی هستند که در اکثر زبان‌های برنامه‌نویسی یافت می‌شود.
        </li>
        <li>
            کد در حال اجرا در یک database مدیریت آن دشوار است: در مقایسه با یک application server، <em>debug</em> کردن آن سخت‌تر است، نگهداری آن در کنترل version و <em>deploy</em> کردن آن مشکل‌تر است، تست کردن آن سخت‌تر است، و ادغام آن با یک system جمع‌آوری <em>metrics</em> برای <em>monitoring</em> دشوار است.
        </li>
        <li>
            یک database اغلب بسیار نسبت به performance حساس‌تر از یک application server است، زیرا یک نمونه database واحد اغلب توسط بسیاری از application servers به اشتراک گذاشته می‌شود. یک <em>stored procedure</em> که به درستی نوشته نشده است (به عنوان مثال، استفاده از مقدار زیادی حافظه یا زمان CPU) در یک database می‌تواند مشکلات بیشتری نسبت به کد که به درستی در یک application server نوشته نشده است، ایجاد کند.
        </li>
    </ul>
    <p>
        با این حال، می‌توان بر این مسائل غلبه کرد. پیاده‌سازی‌های مدرن <em>stored procedures</em>، PL/SQL را کنار گذاشته‌اند و به جای آن از زبان‌های برنامه‌نویسی عمومی موجود استفاده می‌کنند: VoltDB از Java یا Groovy استفاده می‌کند، Datomic از Java یا Clojure استفاده می‌کند، و Redis از Lua استفاده می‌کند.
    </p>
    <p>
        با <em>stored procedures</em> و داده‌های <em>in-memory</em>، اجرای تمام <strong>Transactions</strong> در یک <em>single thread</em> امکان‌پذیر می‌شود. از آنجایی که آنها نیازی به انتظار برای I/O ندارند و از سربار سایر مکانیسم‌های <em>concurrency control</em> اجتناب می‌کنند، می‌توانند <em>throughput</em> بسیار خوبی را در یک <em>single thread</em> به دست آورند.
    </p>
    <p>
        VoltDB همچنین از <em>stored procedures</em> برای <em>replication</em> استفاده می‌کند: به جای کپی کردن <em>writes</em> یک <em>transaction</em> از یک node به دیگری، همان <em>stored procedure</em> را در هر <em>replica</em> اجرا می‌کند. بنابراین VoltDB مستلزم است که <em>stored procedures</em> <em>deterministic</em> باشند (هنگامی که در nodes مختلف اجرا می‌شوند، باید نتیجه یکسانی تولید کنند). به عنوان مثال، اگر یک <strong>Transaction</strong> نیاز به استفاده از تاریخ و زمان فعلی دارد، باید این کار را از طریق <em>APIs deterministic</em> خاص انجام دهد.
    </p>
    <h4>Partitioning</h4>
    <p>
        اجرای تمام <strong>Transactions</strong> به صورت سریال، <em>concurrency control</em> را بسیار ساده‌تر می‌کند، اما <em>transaction throughput</em> database را به سرعت یک <em>CPU core</em> واحد در یک machine واحد محدود می‌کند. <em>Read-only transactions</em> ممکن است در جای دیگری، با استفاده از <em>snapshot isolation</em>، اجرا شوند، اما برای applications با <em>high write throughput</em>، <em>transaction processor</em> تک رشته‌ای می‌تواند به یک bottleneck جدی تبدیل شود.
    </p>
    <p>
        Serializability
        <br>
        |
        <br>
        255
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>