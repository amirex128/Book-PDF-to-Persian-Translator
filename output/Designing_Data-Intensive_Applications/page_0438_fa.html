<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 438</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        [56]؛ نگاه کنید به "انعطاف‌پذیری <strong>Schema</strong> در مدل سند" در صفحه 39). این می‌تواند
        یک مزیت باشد اگر تولیدکننده و مصرف‌کنندگان تیم‌های متفاوتی با
        اولویت‌های مختلف باشند. ممکن است حتی یک مدل داده‌ی ایده‌آل وجود نداشته
        باشد، بلکه دیدگاه‌های متفاوتی از داده‌ها وجود داشته باشد که برای اهداف
        مختلف مناسب هستند. به سادگی تخلیه داده‌ها به شکل خام، امکان چندین
        تبدیل از این دست را فراهم می‌کند. این رویکرد، اصل سوشی نامیده شده است:
        "داده‌های خام بهتر هستند" [57].
    </p>
    <p>
        بنابراین، <strong>Hadoop</strong> اغلب برای پیاده‌سازی فرآیندهای <strong>ETL</strong> استفاده شده است (نگاه کنید به
        "<strong>Data Warehousing</strong>" در صفحه 91): داده‌ها از سیستم‌های پردازش تراکنش به شکل
        خام در سیستم فایل توزیع شده ریخته می‌شوند، و سپس jobs های <strong>MapReduce</strong>
        نوشته می‌شوند تا آن داده‌ها را پاکسازی کنند، آن‌ها را به یک فرم رابطه‌ای
        تبدیل کنند، و آن‌ها را برای اهداف تحلیلی به یک انبار داده <strong>MPP</strong> وارد کنند.
        مدل‌سازی داده‌ها همچنان اتفاق می‌افتد، اما در یک مرحله جداگانه است،
        جدا از جمع‌آوری داده‌ها. این تفکیک امکان‌پذیر است زیرا یک سیستم فایل
        توزیع شده از داده‌های رمزگذاری شده در هر فرمتی پشتیبانی می‌کند.
    </p>

    <h4>تنوع مدل‌های پردازش</h4>
    <p>
        پایگاه‌های داده <strong>MPP</strong>، قطعات نرم‌افزاری یکپارچه و متمرکز هستند که از چیدمان
        ذخیره‌سازی روی دیسک، برنامه‌ریزی query، زمان‌بندی و اجرا مراقبت می‌کنند.
        از آن‌جایی که این مؤلفه‌ها می‌توانند برای نیازهای خاص پایگاه داده تنظیم و
        بهینه شوند، کل سیستم می‌تواند عملکرد بسیار خوبی را در مورد انواع
        queries هایی که برای آن‌ها طراحی شده است، به دست آورد. علاوه بر این،
        زبان query <strong>SQL</strong>، queries های رسا و <strong>semantics</strong> های ظریف را بدون نیاز به
        نوشتن کد امکان‌پذیر می‌کند و آن را برای ابزارهای گرافیکی که توسط
        تحلیلگران کسب‌وکار (مانند <strong>Tableau</strong>) استفاده می‌شوند، در دسترس قرار می‌دهد.
    </p>
    <p>
        از سوی دیگر، همه انواع پردازش را نمی‌توان به طور منطقی به عنوان queries
        <strong>SQL</strong> بیان کرد. به عنوان مثال، اگر در حال ساخت سیستم‌های یادگیری ماشین و
        توصیه، یا <strong>indexes</strong> جستجوی متن کامل با مدل‌های رتبه‌بندی مرتبط، یا انجام
        تجزیه و تحلیل تصویر هستید، به احتمال زیاد به یک مدل کلی‌تر از پردازش داده
        نیاز دارید. این نوع پردازش‌ها اغلب بسیار خاص یک برنامه کاربردی خاص هستند
        (به عنوان مثال، <strong>feature engineering</strong> برای یادگیری ماشین، مدل‌های زبان
        طبیعی برای ترجمه ماشینی، توابع تخمین ریسک برای پیش‌بینی کلاهبرداری)،
        بنابراین آن‌ها ناگزیر نیاز به نوشتن کد دارند، نه فقط queries.
    </p>
    <p>
        <strong>MapReduce</strong> به مهندسان این امکان را داد که به راحتی کد خود را بر روی
        مجموعه‌داده‌های بزرگ اجرا کنند. اگر شما <strong>HDFS</strong> و <strong>MapReduce</strong> دارید، می‌توانید
        یک موتور اجرای query <strong>SQL</strong> را بر روی آن بسازید، و در واقع این کاری است که
        پروژه <strong>Hive</strong> انجام داد [31]. با این حال، شما همچنین می‌توانید بسیاری از اشکال
        دیگر فرآیندهای <strong>batch</strong> را بنویسید که خودشان را به بیان شدن به عنوان یک query
        <strong>SQL</strong>، قرض نمی‌دهند.
    </p>
    <p>
        متعاقباً، مردم دریافتند که <strong>MapReduce</strong> برای برخی از انواع پردازش‌ها بیش از حد
        محدودکننده است و عملکرد ضعیفی دارد، بنابراین مدل‌های پردازش مختلف
        دیگری بر روی <strong>Hadoop</strong> توسعه یافتند (ما برخی از آن‌ها را در "فراتر از
        <strong>MapReduce</strong>" در صفحه 419 خواهیم دید). داشتن دو مدل پردازش، <strong>SQL</strong> و
        <strong>MapReduce</strong>، کافی نبود: حتی مدل‌های مختلف بیشتری مورد نیاز بود! و به دلیل
        باز بودن پلتفرم <strong>Hadoop</strong>
        416
        |
        فصل 10: پردازش <strong>Batch</strong>
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>