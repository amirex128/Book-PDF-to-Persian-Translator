<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 412</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        Batch processing systems (offline systems)
        یک batch processing system مقدار زیادی از input data را می‌گیرد، یک job را برای پردازش آن اجرا می‌کند، و مقداری output data تولید می‌کند. Jobs اغلب مدتی طول می‌کشد (از چند دقیقه تا چندین روز)، بنابراین به طور معمول یک user منتظر نیست که job تمام شود. در عوض، batch jobs اغلب برنامه‌ریزی می‌شوند تا به طور دوره‌ای اجرا شوند (به عنوان مثال، یک بار در روز). The primary performance measure از یک batch job معمولاً throughput است (زمانی که برای خرد کردن از طریق یک input dataset با اندازه مشخص طول می‌کشد). ما در این فصل در مورد batch processing بحث می‌کنیم.
    </p>

    <p>
        Stream processing systems (near-real-time systems)
        Stream processing جایی بین online و offline/batch processing است (بنابراین گاهی اوقات near-real-time یا nearline processing نامیده می‌شود). مانند یک batch processing system، یک stream processor، inputs را مصرف می‌کند و outputs تولید می‌کند (به جای پاسخ دادن به requests). با این حال، یک stream job بر روی events مدتی پس از وقوع آن‌ها، عمل می‌کند، در حالی که یک batch job بر روی یک set از input data ثابت عمل می‌کند. این تفاوت به stream processing systems اجازه می‌دهد که latency کمتری نسبت به systemsهای batch معادل داشته باشند. از آنجایی که stream processing بر روی batch processing ساخته شده است، ما در فصل 11 در مورد آن بحث می‌کنیم.
    </p>

    <p>
        همانطور که در این فصل خواهیم دید، batch processing یک building block مهم در تلاش ما برای ساختن applications قابل اعتماد، scalable و maintainable است. به عنوان مثال، MapReduce، یک batch processing algorithm که در سال 2004 منتشر شد [1]، (شاید بیش از حد با شور و شوق) "the algorithm که Google را آنقدر massively scalable می‌کند" [2] نامیده شد. متعاقباً در سیستم‌های داده‌ای open source مختلف، از جمله Hadoop, CouchDB, و MongoDB پیاده‌سازی شد.
    </p>

    <p>
        MapReduce یک programming model نسبتاً low-level در مقایسه با the parallel processing systems است که سال‌ها قبل برای data warehouses توسعه داده شد [3, 4]، اما از نظر مقیاس پردازشی که می‌توانست بر روی commodity hardware به دست آید، یک گام بزرگ به جلو بود. اگرچه اهمیت MapReduce اکنون در حال کاهش است [5]، اما همچنان ارزش درک را دارد، زیرا یک تصویر واضح از اینکه چرا و چگونه batch processing مفید است، ارائه می‌دهد.
    </p>

    <p>
        در واقع، batch processing یک form بسیار قدیمی از computing است. مدت‌ها قبل از اینکه کامپیوترهای دیجیتال programmable اختراع شوند، punch card tabulating machines - مانند machines Hollerith که در سرشماری ایالات متحده در سال 1890 [6] استفاده می‌شد - یک form semi-mechanized از batch processing را برای محاسبه aggregate statistics از inputs بزرگ پیاده‌سازی کردند. و MapReduce شباهت عجیبی به machines electromechanical IBM card-sorting دارد که به طور گسترده برای business data processing در دهه‌های 1940 و 1950 استفاده می‌شد [7]. طبق معمول، history تمایل به تکرار خود دارد.
    </p>

    <p>
        در این فصل، ما به MapReduce و چندین batch processing algorithms و frameworks دیگر نگاه خواهیم کرد، و بررسی می‌کنیم که چگونه در modern data systems استفاده می‌شوند. اما ابتدا، برای شروع، ما به data processing با استفاده از ابزارهای standard Unix نگاه خواهیم کرد. حتی اگر شما از قبل با آن‌ها آشنا هستید، یک یادآوری در مورد the Unix philosophy ارزش
    </p>
    <p>
        390 | Chapter 10: Batch Processing
    </p>
 </div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>