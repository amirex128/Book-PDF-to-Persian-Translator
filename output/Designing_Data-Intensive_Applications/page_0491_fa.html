<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 491</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        ii. تشکر از <strong>Kostas Kloudas</strong> از جامعه <strong>Flink</strong> برای
        ارائه این قیاس.
    </p>
    <p>
        <em>deterministic</em>: اجرای دوباره‌ی همان فرآیند بر روی ورودی یکسان،
        نتیجه‌ی یکسانی را به دست می‌دهد (نگاه کنید به "تحمل خطا" در صفحه
        422).
    </p>
    <p>
        از سوی دیگر، بسیاری از فریم‌ورک‌های پردازش <strong>stream</strong> از ساعت
        سیستم محلی روی ماشین پردازش (زمان پردازش) برای تعیین
        <strong>windowing</strong> استفاده می‌کنند [79]. این رویکرد این مزیت را دارد که
        ساده است، و اگر تأخیر بین ایجاد رویداد و پردازش رویداد به‌طور
        ناچیز کوتاه باشد، منطقی است. با این حال، اگر هر گونه تأخیر
        پردازشی قابل توجهی وجود داشته باشد—یعنی، اگر پردازش ممکن است
        به‌طور محسوسی دیرتر از زمانی که رویداد واقعاً رخ داده است،
        اتفاق بیفتد، این رویکرد از کار می‌افتد.
    </p>

    <h4>زمان رویداد در مقابل زمان پردازش</h4>
    <p>
        دلایل زیادی وجود دارد که چرا ممکن است پردازش به تأخیر بیفتد:
        صف‌بندی، خطاهای شبکه (نگاه کنید به "شبکه‌های غیرقابل اعتماد" در
        صفحه 277)، یک مشکل عملکردی که منجر به <em>contention</em> در
        <strong>message broker</strong> یا پردازنده می‌شود، راه‌اندازی مجدد
        <strong>stream consumer</strong>، یا <em>reprocessing</em> رویدادهای گذشته (نگاه
        کنید به "پخش مجدد پیام‌های قدیمی" در صفحه 451) در حین بازیابی از
        یک خطا یا پس از رفع یک <strong>bug</strong> در کد.
    </p>
    <p>
        علاوه بر این، تأخیر پیام‌ها همچنین می‌تواند منجر به <strong>ordering</strong>
        غیرقابل پیش‌بینی پیام‌ها شود. به عنوان مثال، فرض کنید یک کاربر
        ابتدا یک درخواست وب را انجام می‌دهد (که توسط سرور وب A رسیدگی
        می‌شود)، و سپس یک درخواست دوم (که توسط سرور B رسیدگی
        می‌شود). A و B رویدادهایی را منتشر می‌کنند که درخواست‌هایی را که
        مدیریت کرده‌اند، شرح می‌دهد، اما رویداد B قبل از رویداد A به
        <strong>message broker</strong> می‌رسد. اکنون پردازنده‌های <strong>stream</strong>
        ابتدا رویداد B و سپس رویداد A را خواهند دید، حتی اگر در واقع
        به ترتیب معکوس رخ داده باشند.
    </p>
    <p>
        اگر این کمک می‌کند که یک قیاس داشته باشید، فیلم‌های <strong>Star Wars</strong> را
        در نظر بگیرید: قسمت IV در سال 1977، قسمت V در سال 1980، و
        قسمت VI در سال 1983 منتشر شد، که پس از آن قسمت‌های I، II و III
        در سال‌های 1999، 2002 و 2005 به ترتیب منتشر شدند، و قسمت VII
        در سال 2015 [80].ii اگر شما فیلم‌ها را به ترتیبی که منتشر شدند
        تماشا کردید، ترتیبی که در آن شما فیلم‌ها را پردازش کردید، با
        ترتیب روایت آن‌ها ناسازگار است. (شماره قسمت مانند <strong>timestamp</strong>
        رویداد است، و تاریخی که شما فیلم را تماشا کردید، زمان پردازش
        است.) به عنوان انسان، ما می‌توانیم با چنین ناپیوستگی‌هایی مقابله
        کنیم، اما الگوریتم‌های پردازش <strong>stream</strong> باید به‌طور خاص برای
        انطباق با این مسائل زمانی و <strong>ordering</strong> نوشته شوند.
    </p>
    <p>
        گیج کردن زمان رویداد و زمان پردازش منجر به داده‌های بد می‌شود. به
        عنوان مثال، فرض کنید شما یک پردازنده <strong>stream</strong> دارید که نرخ
        درخواست‌ها را اندازه‌گیری می‌کند (شمارش تعداد درخواست‌ها در ثانیه).
        اگر شما پردازنده <strong>stream</strong> را دوباره مستقر کنید، ممکن است به
        مدت یک دقیقه خاموش شود و <strong>backlog</strong> رویدادها را هنگام
        بازگشت به کار، پردازش کند. اگر شما نرخ را بر اساس زمان پردازش
        اندازه‌گیری کنید، این‌طور به نظر می‌رسد که یک افزایش ناگهانی
        <em>anomalous</em> از درخواست‌ها در حین پردازش <strong>backlog</strong> وجود
        داشت، در حالی‌که در واقع نرخ واقعی درخواست‌ها ثابت بود (شکل 11-7).
        پردازش جریان‌ها
        |
        469
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>