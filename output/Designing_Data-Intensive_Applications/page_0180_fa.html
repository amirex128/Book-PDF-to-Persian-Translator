<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 180</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        ii. This approach is known as fencing or, more emphatically, Shoot The Other Node In The Head (STONITH).
        We will discuss fencing in more detail in “The leader and the lock” on page 301.
    </p>
    <p>
        ردیف‌ها، اما از آنجایی که counter leader جدید از leader قدیمی‌تر عقب بود، از برخی از primary keys که قبلاً توسط leader قدیمی‌تر اختصاص داده شده بودند، دوباره استفاده کرد. این primary keys همچنین در یک فروشگاه Redis استفاده می‌شدند، بنابراین استفاده مجدد از primary keys منجر به inconsistency بین MySQL و Redis شد که باعث شد برخی از data private برای کاربران اشتباه فاش شود.
    </p>
    <ul>
        <li>In certain fault scenarios (see Chapter 8)، ممکن است اتفاق بیفتد که دو node هر دو بر این باور باشند که آن‌ها leader هستند. این وضعیت split brain نامیده می‌شود و خطرناک است: اگر هر دو leader writes را بپذیرند و هیچ فرآیندی برای حل conflicts وجود نداشته باشد ("Multi-Leader Replication" در صفحه 168 را ببینید)، داده‌ها احتمالاً از بین می‌روند یا corrupted می‌شوند. به عنوان یک safety catch، برخی از systems یک مکانیزم برای خاموش کردن یک node دارند، اگر دو leader شناسایی شوند.ii با این حال، اگر این مکانیزم با دقت طراحی نشده باشد، شما می‌توانید با خاموش شدن هر دو node به پایان برسید [14].</li>
        <li>What is the right timeout before the leader is declared dead? A longer timeout به معنای زمان طولانی‌تری برای recovery در موردی است که leader fail می‌شود. با این حال، اگر timeout خیلی کوتاه باشد، ممکن است failovers غیرضروری وجود داشته باشد. به عنوان مثال، یک tempo‐rary load spike می‌تواند باعث شود که زمان پاسخ یک node، بالاتر از timeout افزایش یابد، یا یک network glitch می‌تواند باعث تاخیر در بسته‌ها شود. اگر سیستم در حال حاضر با high load یا network problems در حال مبارزه است، یک failover غیرضروری احتمالاً وضعیت را بدتر می‌کند، نه بهتر.</li>
    </ul>
    <p>
        هیچ راه‌حل آسانی برای این مشکلات وجود ندارد. به همین دلیل، برخی از teams operations ترجیح می‌دهند failovers را به صورت دستی انجام دهند، حتی اگر software از automatic failover پشتیبانی کند.
    </p>
    <p>
        These issues—node failures; unreliable networks; and trade-offs around replica con‐sistency, durability, availability, and latency—are in fact fundamental problems in distributed systems. In Chapter 8 and Chapter 9 we will discuss them in greater depth.
    </p>
    <h4>Implementation of Replication Logs</h4>
    <p>
        How does leader-based replication work under the hood? Several different replication methods are used in practice, so let’s look at each one briefly.
    </p>
    <h4>Statement-based replication</h4>
    <p>
        در ساده‌ترین حالت، leader هر write request (statement) را که اجرا می‌کند، log می‌کند و آن statement log را به followers خود ارسال می‌کند. برای یک relational database، این بدان معناست که هر statement INSERT, UPDATE, یا DELETE به followers ارسال می‌شود و هر
    </p>
    <p>
        158 | Chapter 5: Replication
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>