<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 528</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        i. توضیح دادن یک <strong>joke</strong> به‌ندرت آن را بهبود می‌بخشد، اما من
        نمی‌خواهم هیچ‌کس احساس بی‌اطلاعی کند. در اینجا، <strong>Church</strong>
        اشاره‌ای است به ریاضیدان <strong>Alonzo Church</strong>، که
        <strong>lambda calculus</strong> را ایجاد کرد، یک شکل اولیه از محاسبه که
        اساس اکثر زبان‌های برنامه‌نویسی <em>functional</em> است. <strong>Lambda
        calculus</strong> هیچ <strong>state</strong> <em>mutable</em> ندارد (یعنی، هیچ
        متغیری که بتواند بازنویسی شود)، بنابراین می‌توان گفت که
        <strong>mutable state</strong> از کار <strong>Church</strong> جدا است.
    </p>
    <p>
        برای این منظور مناسب نیستند. آن‌ها با الزامات توسعه‌ی برنامه
        امروزی، مانند مدیریت وابستگی و بسته، کنترل نسخه،
        <strong>rolling upgrades</strong>، تکامل‌پذیری، <strong>monitoring</strong>،
        معیارها، فراخوانی <strong>network services</strong>، و ادغام با سیستم‌های
        خارجی، سازگار نیستند.
    </p>
    <p>
        از سوی دیگر، ابزارهای استقرار و مدیریت <strong>cluster</strong> مانند
        <strong>Mesos</strong>، <strong>YARN</strong>، <strong>Docker</strong>، <strong>Kubernetes</strong>
        و سایرین به‌طور خاص برای هدف اجرای کد برنامه طراحی شده‌اند.
        با تمرکز بر انجام یک کار به‌خوبی، آن‌ها می‌توانند این کار را
        بسیار بهتر از یک پایگاه داده انجام دهند که اجرای توابع تعریف
        شده توسط کاربر را به‌عنوان یکی از <strong>features</strong> متعدد خود
        فراهم می‌کند.
    </p>
    <p>
        من فکر می‌کنم که این منطقی است که برخی از بخش‌های یک سیستم
        در ذخیره‌سازی داده‌های <em>durable</em> تخصص داشته باشند، و بخش‌های
        دیگر در اجرای کد برنامه تخصص داشته باشند. این دو می‌توانند
        تعامل داشته باشند در حالی‌که هنوز هم مستقل هستند.
    </p>
    <p>
        امروزه اکثر برنامه‌های وب به‌عنوان <strong>services</strong> <em>stateless</em>
        مستقر می‌شوند، که در آن هر درخواست کاربر می‌تواند به هر
        <strong>application server</strong> هدایت شود، و سرور پس از ارسال
        پاسخ، همه‌چیز را در مورد درخواست فراموش می‌کند. این سبک
        از استقرار راحت است، زیرا سرورها را می‌توان به‌دلخواه اضافه
        یا حذف کرد، اما <strong>state</strong> باید به جایی برود: معمولاً، یک
        پایگاه داده. روند این بوده است که منطق برنامه <em>stateless</em> را از
        مدیریت <strong>state</strong> (پایگاه‌های داده) جدا نگه داریم: قرار ندادن
        منطق برنامه در پایگاه داده و قرار ندادن <strong>state</strong> <em>persistent</em>
        در برنامه [36]. همان‌طور که مردم در جامعه‌ی برنامه‌نویسی
        <em>functional</em> دوست دارند <strong>joke</strong> کنند، "ما به جدایی
        <strong>Church</strong> و <strong>state</strong> اعتقاد داریم" [37].i
    </p>
    <p>
        در این مدل برنامه وب معمول، پایگاه داده به‌عنوان نوعی متغیر
        مشترک <em>mutable</em> عمل می‌کند که می‌توان به‌طور <em>synchronously</em>
        از طریق شبکه به آن دسترسی داشت. برنامه می‌تواند متغیر را
        بخواند و به‌روزرسانی کند، و پایگاه داده مراقب است تا آن را
        <em>durable</em> کند، مقداری کنترل <strong>concurrency</strong> و تحمل
        خطا را فراهم می‌کند.
    </p>
    <p>
        با این حال، در اکثر زبان‌های برنامه‌نویسی شما نمی‌توانید به
        تغییرات در یک متغیر <em>mutable</em> <strong>subscribe</strong> کنید—شما
        فقط می‌توانید آن را به‌طور دوره‌ای بخوانید. برخلاف یک
        <strong>spreadsheet</strong>، خوانندگان متغیر مطلع نمی‌شوند اگر مقدار
        متغیر تغییر کند. (شما می‌توانید چنین اعلان‌هایی را در کد
        خودتان پیاده‌سازی کنید—این به‌عنوان الگوی <strong>observer</strong>
        شناخته می‌شود—اما اکثر زبان‌ها این الگو را به‌عنوان یک
        <strong>feature</strong> داخلی ندارند.)
    </p>
    <p>
        پایگاه‌های داده این رویکرد <strong>passive</strong> به داده‌های <em>mutable</em>
        را به ارث برده‌اند: اگر شما می‌خواهید بدانید آیا محتویات پایگاه
        داده تغییر کرده است، اغلب تنها گزینه‌ی شما <strong>poll</strong>
        کردن است (یعنی، تکرار <strong>query</strong> خود به‌طور دوره‌ای).
        <strong>Subscribing</strong> به تغییرات، تنها در حال شروع به‌عنوان یک
        <strong>feature</strong> است (نگاه کنید به "پشتیبانی <strong>API</strong> برای
        جریان‌های تغییر" در صفحه 456).
        506
        |
        فصل 12: آینده‌ی سیستم‌های داده
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>