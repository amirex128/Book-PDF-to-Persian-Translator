<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 229</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        شکل 6-4. Partitioning secondary indexes توسط document.
    </p>
    <p>
        In this indexing approach، هر partition کاملاً جداگانه است: هر partition، indexes secondary خود را حفظ می‌کند و فقط documents را در آن partition پوشش می‌دهد. به اینکه چه data در other partitions ذخیره شده است، اهمیت نمی‌دهد. هر زمان که شما نیاز به write به database دارید—برای اضافه کردن، حذف یا update یک document—شما فقط نیاز دارید که با partition که حاوی document ID است که شما در حال نوشتن آن هستید، سروکار داشته باشید. به همین دلیل، یک index document-partitioned، also known as a local index (برخلاف یک global index که در بخش بعدی توضیح داده شده است) نامیده می‌شود.
    </p>
    <p>
        با این حال، خواندن از یک index document-partitioned نیاز به مراقبت دارد: مگر اینکه شما با document IDs کار خاصی انجام داده باشید، هیچ دلیلی وجود ندارد که چرا همه ماشین‌ها با یک رنگ خاص یا یک make خاص در یک partition یکسان باشند. در شکل 6-4، ماشین‌های قرمز در هر دو partition 0 و partition 1 ظاهر می‌شوند. بنابراین، اگر شما می‌خواهید به دنبال ماشین‌های قرمز باشید، شما نیاز دارید که query را به همه partitions ارسال کنید و تمام نتایجی را که دریافت می‌کنید، ترکیب کنید.
    </p>
    <p>
        This approach to querying a partitioned database گاهی اوقات scatter/gather نامیده می‌شود و می‌تواند queries read را روی secondary indexes بسیار گران کند. حتی اگر شما partitions را به طور موازی query کنید، scatter/gather مستعد tail latency amplifica‐tion است (به "Percentiles in Practice" در صفحه 16 مراجعه کنید). با این حال، به طور گسترده‌ای استفاده می‌شود: MongoDB، Riak [15]، Cassandra [16]، Elasticsearch [17]، SolrCloud [18] و VoltDB [19] همگی از indexes secondary document-partitioned استفاده می‌کنند.
        اکثر vendors database توصیه می‌کنند که شما scheme partitioning خود را طوری ساختاربندی کنید که queries secondary index بتواند از یک partition واحد ارائه شود، اما این همیشه امکان‌پذیر نیست، به خصوص زمانی که شما در حال استفاده از multiple secondary indexes در یک query واحد هستید (مانند filtering cars by color و by make در همان زمان).
    </p>
    <p>
        Partitioning and Secondary Indexes | 207
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0229/image_1.png" alt="Image from page 229" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>