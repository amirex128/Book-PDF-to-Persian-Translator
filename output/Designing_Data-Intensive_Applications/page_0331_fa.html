<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 331</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <ul>
        <li>
            اگر a <em>safety property</em> نقض شود، ما می‌توانیم به یک نقطه زمانی خاص که در آن شکسته شد، اشاره کنیم (به عنوان مثال، اگر <em>the uniqueness property</em> نقض شد، ما می‌توانیم operation خاصی را که در آن یک <em>duplicate fencing token</em> بازگردانده شد، شناسایی کنیم).
            <br>
            پس از اینکه یک <em>safety property</em> نقض شد، این تخلف را نمی‌توان لغو کرد—آسیب قبلاً وارد شده است.
        </li>
        <li>
            A <em>liveness property</em> به روش دیگری عمل می‌کند: ممکن است در برخی از نقاط زمانی حفظ نشود (به عنوان مثال، یک node ممکن است یک درخواست ارسال کرده باشد اما هنوز پاسخی دریافت نکرده باشد)، اما همیشه این امید وجود دارد که ممکن است در آینده برآورده شود (یعنی با دریافت یک پاسخ).
        </li>
    </ul>
    <p>
        یک مزیت از تمایز بین <em>safety</em> و <em>liveness properties</em> این است که به ما در برخورد با <em>system models</em> های دشوار کمک می‌کند. برای الگوریتم‌های <em>distributed</em>، معمول است که <em>safety properties</em> همیشه برقرار باشند، در تمام موقعیت‌های ممکن از یک <em>system model</em> [88]. یعنی، حتی اگر همه nodes <em>crash</em> کنند، یا کل شبکه شکست بخورد، الگوریتم باید اطمینان حاصل کند که یک نتیجه نادرست را برنمی‌گرداند (یعنی، <em>safety properties</em> همچنان برآورده می‌شوند).
    </p>
    <p>
        با این حال، با <em>liveness properties</em>، ما مجاز به ایجاد caveats هستیم: به عنوان مثال، ما می‌توانیم بگوییم که یک درخواست فقط در صورتی نیاز به دریافت پاسخ دارد که اکثریت nodes ها <em>crashed</em> نشده باشند، و فقط در صورتی که شبکه در نهایت از یک <em>outage</em> بازیابی شود. تعریف <em>the partially synchronous model</em> نیازمند است که در نهایت system به یک حالت <em>synchronous</em> بازگردد—یعنی، هر دوره از <em>network interruption</em> فقط برای یک مدت زمان محدود دوام دارد و سپس تعمیر می‌شود.
    </p>
    <h4>Mapping system models to the real world</h4>
    <p>
        <em>Safety</em> و <em>liveness properties</em> و <em>system models</em> برای استدلال در مورد correctness یک الگوریتم <em>distributed</em> بسیار مفید هستند. با این حال، هنگام پیاده‌سازی یک الگوریتم در عمل، واقعیت‌های درهم و برهم دوباره شما را گاز می‌گیرند، و مشخص می‌شود که <em>system model</em> یک <em>simplified abstraction of reality</em> است.
    </p>
    <p>
        به عنوان مثال، الگوریتم‌ها در <em>the crash-recovery model</em> عموماً فرض می‌کنند که داده‌ها در ذخیره‌سازی stable، از <em>crashes</em> ها جان سالم به در می‌برند. با این حال، اگر داده‌ها روی دیسک خراب شوند، یا داده‌ها به دلیل <em>hardware error</em> یا <em>misconfiguration</em> پاک شوند، چه اتفاقی می‌افتد [91]؟ اگر یک server دارای باگ <em>firmware</em> است و در زمان <em>reboot</em>، هارد درایوهای خود را شناسایی نمی‌کند، حتی اگر درایوها به درستی به server متصل شده باشند، چه اتفاقی می‌افتد [92]؟
    </p>
    <p>
        <em>Quorum algorithms</em> (به "Quorums for reading and writing" در صفحه 179 مراجعه کنید) متکی به یک node هستند که داده‌هایی را که ادعا می‌کند ذخیره کرده است، به خاطر می‌آورد. اگر یک node ممکن است از <em>amnesia</em> رنج ببرد و داده‌های ذخیره شده قبلی را فراموش کند، این شرط <em>quorum</em> را می‌شکند، و بنابراین correctness الگوریتم را می‌شکند. شاید یک <em>system model</em> جدید مورد نیاز است، که در آن ما فرض می‌کنیم که ذخیره‌سازی <em>stable</em> عمدتاً از <em>crashes</em> ها جان سالم به در می‌برد، اما ممکن است گاهی اوقات از دست برود. اما استدلال در مورد آن مدل، سخت‌تر می‌شود.
        <br>
        Knowledge, Truth, and Lies
        <br>
        |
        <br>
        309
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>