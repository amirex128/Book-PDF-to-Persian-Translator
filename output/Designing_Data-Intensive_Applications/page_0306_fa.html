<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 306</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        system با ظرفیت اضافی می‌تواند به راحتی صفوف را تخلیه کند، در حالی که در یک system با <em>highly utilized</em>، صفوف طولانی می‌توانند خیلی سریع ایجاد شوند.
    </p>
    <p>
        در <em>public clouds</em> و <em>multi-tenant datacenters</em>، منابع بین بسیاری از مشتریان به اشتراک گذاشته می‌شوند: <em>network links</em> و <em>switches</em>، و حتی <em>network interface</em> و <em>CPUs</em> هر machine (هنگام اجرا روی <em>virtual machines</em>)، به اشتراک گذاشته می‌شوند. <em>Batch workloads</em> مانند MapReduce (به فصل 10 مراجعه کنید) می‌تواند به راحتی <em>network links</em> را اشباع کند. از آنجایی که شما هیچ کنترلی بر استفاده دیگر مشتریان از منابع مشترک ندارید، تأخیرهای شبکه می‌توانند بسیار متغیر باشند اگر کسی در نزدیکی شما (یک همسایه پر سر و صدا) از منابع زیادی استفاده می‌کند [28, 29].
    </p>
    <p>
        در چنین محیط‌هایی، شما فقط می‌توانید <em>timeouts</em> را به صورت تجربی انتخاب کنید: توزیع زمان‌های <em>network round-trip</em> را در یک دوره طولانی و در چندین machine اندازه‌گیری کنید، تا تغییرپذیری مورد انتظار تأخیرها را تعیین کنید. سپس، با در نظر گرفتن ویژگی‌های application خود، شما می‌توانید یک <em>trade-off</em> مناسب بین تأخیر تشخیص <em>failure</em> و خطر <em>premature timeouts</em> را تعیین کنید.
    </p>
    <p>
        حتی بهتر است، به جای استفاده از <em>configured constant timeouts</em>، systems می‌توانند به طور مداوم زمان‌های پاسخگویی و تغییرپذیری آنها (<em>jitter</em>) را اندازه‌گیری کنند، و <em>timeouts</em> را به طور خودکار با توجه به توزیع زمان پاسخگویی مشاهده شده تنظیم کنند. این کار را می‌توان با یک <em>Phi Accrual failure detector</em> [30] انجام داد، که به عنوان مثال در Akka و Cassandra استفاده می‌شود [31]. <em>TCP retransmission timeouts</em> نیز به طور مشابه عمل می‌کنند [27].
    </p>
    <h4>Synchronous Versus Asynchronous Networks</h4>
    <p>
        اگر ما می‌توانستیم به شبکه اعتماد کنیم تا <em>packets</em> را با مقداری تأخیر ثابت حداکثر تحویل دهد، و <em>packets</em> را <em>drop</em> نکند، <em>distributed systems</em> بسیار ساده‌تر می‌شدند. چرا نمی‌توانیم این را در سطح سخت‌افزار حل کنیم و شبکه را قابل اعتماد کنیم تا نرم‌افزار نیازی به نگرانی در مورد آن نداشته باشد؟
    </p>
    <p>
        برای پاسخ به این سوال، مقایسه شبکه‌های <em>datacenter</em> با شبکه تلفن ثابت سنتی (غیر سلولی، غیر VoIP) جالب است، که بسیار قابل اعتماد است: <em>delayed audio frames</em> و <em>dropped calls</em> بسیار نادر هستند. یک تماس تلفنی به طور مداوم نیاز به <em>low end-to-end latency</em> و پهنای باند کافی برای انتقال نمونه‌های صوتی صدای شما دارد. آیا داشتن قابلیت اطمینان و قابلیت پیش‌بینی مشابه در شبکه‌های کامپیوتری خوب نخواهد بود؟
    </p>
    <p>
        وقتی شما از طریق شبکه تلفن تماس می‌گیرید، یک <em>circuit</em> ایجاد می‌کند: یک مقدار ثابت، تضمین شده از پهنای باند برای تماس، در کل مسیر بین دو تماس‌گیرنده اختصاص داده شده است. این <em>circuit</em> تا زمانی که تماس پایان یابد، در جای خود باقی می‌ماند [32]. به عنوان مثال، یک شبکه ISDN با نرخ ثابتی از 4000 فریم در ثانیه اجرا می‌شود. هنگامی که یک تماس برقرار می‌شود، 16 بیت فضا در هر فریم (در هر جهت) به آن اختصاص داده می‌شود. بنابراین، برای مدت زمان تماس، به هر طرف تضمین می‌شود که بتواند دقیقاً 16 بیت داده صوتی را هر 250 میکروثانیه ارسال کند [33, 34].
        <br>
        284
        <br>
        |
        <br>
        Chapter 8: The Trouble with Distributed Systems
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>