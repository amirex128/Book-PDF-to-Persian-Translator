<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 525</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        لازم است برای حفظ <strong>state</strong> در پردازنده‌های <strong>stream</strong>، و
        به‌منظور <strong>queries</strong> برای خروجی پردازنده‌های <strong>batch</strong> و
        <strong>stream</strong> (نگاه کنید به "خروجی جریان‌های کاری <strong>Batch</strong>" در
        صفحه 411 و "پردازش <strong>Streams</strong>" در صفحه 464). موتورهای
        <strong>query</strong> تخصصی همچنان برای <strong>workloads</strong> خاص مهم
        خواهند بود: به عنوان مثال، موتورهای <strong>query</strong> در انبارهای داده‌ی
        <strong>MPP</strong> برای <strong>queries</strong> تحلیلی اکتشافی بهینه شده‌اند و این
        نوع <strong>workload</strong> را بسیار خوب مدیریت می‌کنند (نگاه کنید به
        "مقایسه‌ی <strong>Hadoop</strong> با پایگاه‌های داده‌ی توزیع شده" در صفحه
        414).
    </p>
    <p>
        پیچیدگی اجرای چندین بخش مختلف از زیرساخت‌ها می‌تواند یک
        مشکل باشد: هر قطعه نرم‌افزار یک منحنی یادگیری، مسائل
        پیکربندی، و <em>quirks</em> عملیاتی دارد، و بنابراین ارزش دارد که تا
        حد امکان قطعات متحرک کمی را مستقر کنید. یک محصول نرم‌افزاری
        یکپارچه واحد نیز ممکن است قادر به دستیابی به عملکرد بهتر و قابل
        پیش‌بینی‌تری در مورد انواع <strong>workloads</strong> که برای آن‌ها طراحی شده
        است، در مقایسه با سیستمی که از چندین ابزار تشکیل شده است که
        شما با کد برنامه آن‌ها را ترکیب کرده‌اید [23]. همان‌طور که در
        پیشگفتار گفتم، ساختن برای مقیاسی که به آن نیاز ندارید، یک تلاش
        هدر رفته است و ممکن است شما را در یک طراحی غیرقابل انعطاف
        حبس کند. در واقع، این نوعی بهینه‌سازی زودرس است.
    </p>
    <p>
        هدف از <strong>unbundling</strong> این نیست که با پایگاه‌های داده‌ی جداگانه در
        مورد عملکرد برای <strong>workloads</strong> خاص رقابت کنید؛ هدف این است
        که به شما اجازه دهد چندین پایگاه داده‌ی مختلف را با هم ترکیب
        کنید تا عملکرد خوبی را برای طیف وسیع‌تری از <strong>workloads</strong>
        نسبت به آن‌چه که با یک قطعه نرم‌افزار واحد امکان‌پذیر است، به
        دست آورید. این در مورد وسعت است، نه عمق—در همان راستای
        تنوع مدل‌های ذخیره‌سازی و پردازشی است که ما در "مقایسه‌ی
        <strong>Hadoop</strong> با پایگاه‌های داده‌ی توزیع شده" در صفحه 414 مورد
        بحث قرار دادیم.
    </p>
    <p>
        بنابراین، اگر یک فناوری واحد وجود دارد که هرآن‌چه را که نیاز دارید
        انجام می‌دهد، احتمالاً بهترین کار این است که به‌سادگی از آن
        محصول استفاده کنید تا این‌که سعی کنید خودتان آن را از اجزای
        سطح پایین‌تر دوباره پیاده‌سازی کنید. مزایای <strong>unbundling</strong>
        و ترکیب، تنها زمانی وارد تصویر می‌شوند که هیچ قطعه نرم‌افزار
        واحدی وجود نداشته باشد که تمام نیازهای شما را برآورده
        کند.
    </p>

    <h4>چه چیزی کم است؟</h4>
    <p>
        ابزارهایی برای ترکیب سیستم‌های داده در حال بهتر شدن هستند، اما
        من فکر می‌کنم که یک بخش اصلی کم است: ما هنوز معادل <strong>Unix
        shell</strong> (یعنی یک زبان سطح بالا برای ترکیب سیستم‌های
        ذخیره‌سازی و پردازش به روشی ساده و اعلانی) از پایگاه داده‌ی
        <strong>unbundled</strong> را نداریم.
    </p>
    <p>
        به عنوان مثال، من دوست دارم اگر ما می‌توانستیم به‌سادگی اعلام
        کنیم <strong>mysql | elasticsearch</strong>، که با قیاس با <strong>Unix
        pipes</strong> [22]، معادل <strong>unbundled</strong> از <strong>CREATE
        INDEX</strong> خواهد بود: تمام اسناد را در یک پایگاه داده‌ی <strong>MySQL</strong>
        می‌گرفت و آن‌ها را در یک <strong>cluster Elasticsearch</strong>
        <strong>index</strong> می‌کرد. سپس به‌طور مداوم تمام تغییرات ایجاد شده در
        پایگاه داده را ثبت می‌کرد و به‌طور خودکار آن‌ها را در index جستجو
        اعمال می‌کرد، بدون این‌که ما مجبور باشیم کد برنامه سفارشی
        بنویسیم. این نوع ادغام باید با تقریباً هر نوع سیستم ذخیره‌سازی
        یا <strong>indexing</strong> امکان‌پذیر باشد.
        <strong>Unbundling Databases</strong>
        |
        503
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>