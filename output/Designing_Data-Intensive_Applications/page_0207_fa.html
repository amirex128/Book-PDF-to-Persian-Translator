<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 207</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        The problem is that events may arrive in a different order at different nodes, due to variable network delays and partial failures. For example, Figure 5-12 shows two cli‐ents, A and B, simultaneously writing to a key X in a three-node datastore:
    </p>
    <ul>
        <li>Node 1 receives the write from A, but never receives the write from B due to a transient outage.</li>
        <li>Node 2 first receives the write from A, then the write from B.</li>
        <li>Node 3 first receives the write from B, then the write from A.</li>
    </ul>
    <p>
        شکل 5-12. Concurrent writes در یک Dynamo-style datastore: هیچ ordering well-defined وجود ندارد.
    </p>
    <p>
        اگر هر node به سادگی value را برای یک key overwrote می‌کرد، هر زمان که یک write request از یک client دریافت می‌کرد، nodes به طور دائمی inconsistent می‌شدند، همانطور که توسط the final get request در شکل 5-12 نشان داده شده است: node 2 فکر می‌کند که the final value از X، B است، در حالی که other nodes فکر می‌کنند که value، A است.
    </p>
    <p>
        به منظور تبدیل شدن به eventual consistent، replicas باید به سمت same value همگرا شوند. چگونه این کار را انجام می‌دهند؟ ممکن است فرد امیدوار باشد که databases replicated این کار را به طور خودکار انجام دهند، اما متاسفانه اکثر پیاده‌سازی‌ها بسیار ضعیف هستند: اگر شما می‌خواهید از دست دادن data اجتناب کنید، شما—developer application—نیاز دارید که اطلاعات زیادی در مورد internals از conflict handling database خود بدانید.
    </p>
    <p>
        ما به طور خلاصه در مورد برخی از تکنیک‌ها برای conflict resolution در "Handling Write Conflicts" در صفحه 171 اشاره کردیم. قبل از اینکه این فصل را جمع‌بندی کنیم، بیایید این issue را با جزئیات بیشتری بررسی کنیم.
    </p>
    <p>
        Leaderless Replication | 185
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0207/image_1.png" alt="Image from page 207" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>