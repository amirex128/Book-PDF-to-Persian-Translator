<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 96</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        شکل 3-3. انجام compaction و segment merging به طور همزمان.
    </p>
    <p>
        هر segment اکنون hash table in-memory خود را دارد که keys را به file offsets نگاشت می‌کند. به منظور یافتن value برای یک key، ما ابتدا hash map جدیدترین segment را بررسی می‌کنیم. اگر key وجود نداشته باشد، ما دومین segment جدیدتر را بررسی می‌کنیم و به همین ترتیب. The merging process تعداد segments را کم نگه می‌دارد، بنابراین lookups نیازی به بررسی hash maps زیادی ندارند.
    </p>
    <p>
        جزئیات زیادی برای عملی کردن این ایده ساده در عمل وجود دارد. به طور خلاصه، برخی از issues که در یک پیاده‌سازی واقعی مهم هستند، عبارتند از:
    </p>
    <ul>
        <li>File format</li>
        <li>CSV بهترین format برای یک log نیست. استفاده از یک format باینری که ابتدا طول یک string را بر حسب بایت رمزگذاری می‌کند، و پس از آن string خام (بدون نیاز به escaping) سریع‌تر و ساده‌تر است.</li>
        <li>Deleting records</li>
        <li>اگر شما می‌خواهید یک key و value مرتبط با آن را حذف کنید، باید یک record deletion ویژه (که گاهی اوقات tombstone نامیده می‌شود) را به فایل data اضافه کنید. هنگامی که log seg‐ments ادغام می‌شوند، tombstone به process merging می‌گوید که هرگونه value قبلی را برای key حذف شده دور بریزد.</li>
        <li>Crash recovery</li>
        <li>اگر database دوباره راه‌اندازی شود، hash maps in-memory از دست می‌روند. در اصل، شما می‌توانید hash map هر segment را با خواندن کل فایل segment از ابتدا تا انتها و یادداشت offset از most recent value برای هر key در حین انجام این کار، بازیابی کنید. با این حال، اگر فایل‌های segment بزرگ باشند، این کار ممکن است زمان زیادی ببرد، که باعث می‌شود server restarts دردناک باشد. Bitcask recovery را با ذخیره کردن</li>
    </ul>
    <p>
        74 | Chapter 3: Storage and Retrieval
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0096/image_1.png" alt="Image from page 96" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>