<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 436</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <ul>
        <li>
            اگر شما یک <strong>bug</strong> را به کد معرفی کنید و خروجی اشتباه یا خراب شود،
            شما به سادگی می‌توانید به نسخه قبلی کد بازگردید و job را دوباره اجرا
            کنید، و خروجی دوباره صحیح خواهد بود. یا، حتی ساده‌تر، می‌توانید خروجی
            قدیمی را در یک دایرکتوری متفاوت نگه دارید و به سادگی به آن بازگردید.
            پایگاه‌های داده با تراکنش‌های <strong>read-write</strong> این ویژگی را ندارند: اگر شما کد
            اشکال‌دار را مستقر کنید که داده‌های بد را به پایگاه داده می‌نویسد، سپس
            بازگرداندن کد هیچ کاری برای رفع داده‌ها در پایگاه داده انجام نخواهد داد.
            (ایده‌ی توانایی بازیابی از کد اشکال‌دار <strong>human fault tolerance</strong> نامیده
            می‌شود [50].)
        </li>
        <li>
            در نتیجه این سهولت در بازگشت، توسعه‌ی <strong>feature</strong> می‌تواند سریع‌تر از
            محیطی که اشتباهات می‌تواند به معنای آسیب برگشت‌ناپذیر باشد، پیش برود. این
            اصل به حداقل رساندن برگشت‌ناپذیری برای توسعه نرم‌افزار <strong>Agile</strong> مفید است
            [51].
        </li>
        <li>
            اگر یک <strong>map</strong> یا <strong>reduce task</strong> شکست بخورد، فریم‌ورک <strong>MapReduce</strong>
            به‌طور خودکار آن را دوباره زمان‌بندی می‌کند و دوباره روی همان ورودی اجرا
            می‌کند. اگر شکست به دلیل یک <strong>bug</strong> در کد باشد، همچنان خراب می‌شود و در
            نهایت باعث می‌شود job پس از چند تلاش با شکست مواجه شود؛ اما اگر شکست
            به دلیل یک مشکل گذرا باشد، خطا تحمل می‌شود. این <strong>retry</strong> خودکار تنها به
            این دلیل ایمن است که ورودی‌ها <em>immutable</em> هستند و خروجی‌ها از <strong>tasks</strong>
            شکست‌خورده توسط فریم‌ورک <strong>MapReduce</strong> دور ریخته می‌شوند.
        </li>
        <li>
            همان مجموعه فایل‌ها را می‌توان به عنوان ورودی برای jobs های مختلف استفاده
            کرد، از جمله jobs های <strong>monitoring</strong> که معیارها را محاسبه می‌کنند و ارزیابی
            می‌کنند که آیا خروجی یک job ویژگی‌های مورد انتظار را دارد (به عنوان مثال، با
            مقایسه آن با خروجی از اجرای قبلی و اندازه‌گیری تفاوت‌ها).
        </li>
        <li>
            مانند ابزارهای <strong>Unix</strong>، jobs های <strong>MapReduce</strong> منطق را از سیم‌کشی جدا
            می‌کنند (پیکربندی دایرکتوری‌های ورودی و خروجی)، که جداسازی
            <strong>concerns</strong> را فراهم می‌کند و امکان استفاده مجدد از کد را فراهم می‌کند: یک
            تیم می‌تواند روی پیاده‌سازی یک job تمرکز کند که یک کار را خوب انجام
            می‌دهد، در حالی که تیم‌های دیگر می‌توانند تصمیم بگیرند که کجا و چه زمانی
            آن job را اجرا کنند.
        </li>
    </ul>
    <p>
        در این زمینه‌ها، اصول طراحی که برای <strong>Unix</strong> خوب عمل کردند، به نظر می‌رسد
        برای <strong>Hadoop</strong> نیز خوب عمل می‌کنند—اما <strong>Unix</strong> و <strong>Hadoop</strong> نیز از جهاتی متفاوت هستند.
        به عنوان مثال، از آن‌جایی که اکثر ابزارهای <strong>Unix</strong> فایل‌های متنی <em>untyped</em> را
        فرض می‌کنند، باید مقدار زیادی <strong>parsing</strong> ورودی انجام دهند (مثال تحلیل
        log ما در ابتدای فصل از {print $7} برای استخراج <strong>URL</strong> استفاده کرد). در
        <strong>Hadoop</strong>، برخی از آن تبدیل‌های <strong>syntactic</strong> کم‌ارزش با استفاده از فرمت‌های فایل
        ساختاریافته‌تر حذف می‌شوند: <strong>Avro</strong> (نگاه کنید به "<strong>Avro</strong>" در صفحه 122) و <strong>Parquet</strong>
        (نگاه کنید به "<strong>Column-Oriented Storage</strong>" در صفحه 95) اغلب استفاده می‌شوند،
        زیرا آن‌ها <strong>encoding</strong> مبتنی بر <strong>schema</strong> کارآمد را ارائه می‌دهند و امکان تکامل
        schemas آن‌ها را در طول زمان فراهم می‌کنند (نگاه کنید به فصل 4).
    </p>

    <h4>مقایسه <strong>Hadoop</strong> با پایگاه‌های داده توزیع شده</h4>
    <p>
        همان‌طور که دیدیم، <strong>Hadoop</strong> تا حدودی شبیه یک نسخه توزیع شده از <strong>Unix</strong> است، جایی
        که <strong>HDFS</strong> فایل‌سیستم است و <strong>MapReduce</strong> یک پیاده‌سازی عجیب از یک فرآیند
        <strong>Unix</strong> است.
    </p>
    <p>
        414
        |
        فصل 10: پردازش <strong>Batch</strong>
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>