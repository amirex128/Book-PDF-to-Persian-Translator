<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 543</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        اعمال محدودیت‌ها
    </p>
    <p>
        بیایید در مورد درستی در <strong>context</strong> از ایده‌های اطراف
        <strong>unbundling databases</strong> فکر کنیم ("<strong>Unbundling Databases</strong>"
        در صفحه 499). ما دیدیم که سرکوب تکراری <em>end-to-end</em> را می‌توان
        با یک <strong>request ID</strong> که از <strong>client</strong> تا پایگاه داده که
        <strong>write</strong> را ثبت می‌کند، منتقل می‌شود، به‌دست
        آورد. در مورد انواع دیگر محدودیت‌ها چطور؟
    </p>
    <p>
        به‌طور خاص، بیایید روی <strong>uniqueness constraints</strong> تمرکز
        کنیم—مانند موردی که ما در مثال 12-2 به آن متکی بودیم. در
        "محدودیت‌ها و تضمین‌های منحصربه‌فرد بودن" در صفحه 330 ما
        چندین مثال دیگر از <strong>features</strong> برنامه را دیدیم که نیاز به
        اعمال <strong>uniqueness</strong> دارند: یک نام کاربری یا آدرس <strong>email</strong>
        باید به‌طور منحصربه‌فرد یک کاربر را شناسایی کند، یک
        <strong>service</strong> ذخیره‌سازی فایل نمی‌تواند بیش از یک فایل با
        نام یکسان داشته باشد، و دو نفر نمی‌توانند یک صندلی را در یک
        پرواز یا در یک تئاتر رزرو کنند.
    </p>
    <p>
        سایر انواع محدودیت‌ها بسیار شبیه هستند: به عنوان مثال، اطمینان از
        این‌که موجودی حساب هرگز منفی نمی‌شود، این‌که شما بیش از آن
        مقدار آیتم موجود در انبار را نمی‌فروشید، یا این‌که یک سالن
        اجتماعات، رزروهای همپوشانی ندارد. تکنیک‌هایی که <strong>uniqueness</strong>
        را اعمال می‌کنند، اغلب برای این نوع محدودیت‌ها نیز استفاده
        می‌شوند.
    </p>

    <h4><strong>Uniqueness constraints</strong> نیاز به اجماع دارند</h4>
    <p>
        در فصل 9 ما دیدیم که در یک محیط توزیع شده، اعمال یک
        <strong>uniqueness constraint</strong> به <strong>consensus</strong> نیاز
        دارد: اگر چندین درخواست همزمان با مقدار یکسان وجود داشته
        باشد، سیستم به‌نوعی نیاز دارد که تصمیم بگیرد کدام‌یک از
        عملیات متناقض پذیرفته می‌شود، و موارد دیگر را به‌عنوان
        نقض محدودیت رد کند.
    </p>
    <p>
        رایج‌ترین راه برای دستیابی به این <strong>consensus</strong> این است که یک
        <strong>node</strong> واحد را <strong>leader</strong> قرار دهیم، و آن را مسئول
        تصمیم‌گیری‌ها کنیم. این کار تا زمانی خوب است که شما
        مخالف هدایت تمام درخواست‌ها از طریق یک <strong>node</strong> واحد
        نباشید (حتی اگر <strong>client</strong> در طرف دیگر دنیا باشد)، و تا زمانی
        که آن <strong>node</strong> شکست نخورد. اگر شما نیاز دارید که شکست
        <strong>leader</strong> را تحمل کنید، شما دوباره به مشکل <strong>consensus</strong>
        برمی‌گردید (نگاه کنید به "<strong>Single-leader replication</strong> و
        <strong>consensus</strong>" در صفحه 367).
    </p>
    <p>
        بررسی <strong>uniqueness</strong> را می‌توان با <strong>partitioning</strong> بر
        اساس مقداری که نیاز به <strong>unique</strong> بودن دارد، <em>scaled out</em>
        کرد. به عنوان مثال، اگر شما نیاز دارید که <strong>uniqueness</strong>
        را بر اساس <strong>request ID</strong> تضمین کنید، همان‌طور که در مثال
        12-2 نشان داده شده است، شما می‌توانید اطمینان حاصل کنید که
        تمام درخواست‌ها با <strong>request ID</strong> یکسان به یک
        <strong>partition</strong> یکسان هدایت می‌شوند (نگاه کنید به فصل 6). اگر شما
        نیاز دارید که نام‌های کاربری <strong>unique</strong> باشند، شما
        می‌توانید بر اساس <strong>hash</strong> از نام کاربری، <strong>partition</strong>
        کنید.
    </p>
    <p>
        با این حال، <strong>replication</strong> <em>asynchronous multi-master</em>
        منتفی است، زیرا ممکن است رخ دهد که <strong>masters</strong>
        مختلف، به‌طور هم‌زمان <strong>writes</strong> متناقضی را بپذیرند، و
        بنابراین مقادیر دیگر <strong>unique</strong> نیستند (نگاه کنید به
        "پیاده‌سازی سیستم‌های <strong>Linearizable</strong>" در صفحه 332). اگر
        شما می‌خواهید بلافاصله هر <strong>writes</strong> را که محدودیت را نقض
        می‌کند، رد کنید، هماهنگی <em>synchronous</em> اجتناب‌ناپذیر است
        [56].
        هدف قرار دادن درستی
        |
        521
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>