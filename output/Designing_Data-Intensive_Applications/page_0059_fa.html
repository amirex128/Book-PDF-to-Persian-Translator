<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 59</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        iv. Foreign key constraints به شما اجازه می‌دهند تا modifications را محدود کنید، اما چنین constraints توسط relational model مورد نیاز نیستند. حتی با constraints، joins روی foreign keys در زمان query انجام می‌شوند، در حالی که در CODASYL، join عملاً در زمان insert انجام می‌شد.
    </p>
    <p>
        links بین records در network model، foreign keys نبودند، بلکه بیشتر شبیه pointers در یک زبان برنامه‌نویسی (در حالی که هنوز روی دیسک ذخیره می‌شدند) بودند. تنها راه دسترسی به یک record، دنبال کردن یک مسیر از یک root record در امتداد این chains of links بود. این کار access path نامیده می‌شد.
    </p>
    <p>
        در ساده‌ترین حالت، یک access path می‌تواند مانند traversal از یک linked list باشد: در head از list شروع کنید و یک record را در یک زمان بررسی کنید تا زمانی که مورد نظر خود را پیدا کنید. اما در دنیای relationships many-to-many، چندین مسیر مختلف می‌تواند به همان record منتهی شود و یک programmer که با network model کار می‌کند، باید این access paths مختلف را در ذهن خود دنبال کند.
    </p>
    <p>
        یک query در CODASYL با جابجایی یک cursor از طریق database با تکرار lists of records و دنبال کردن access paths انجام می‌شد. اگر یک record چندین parent داشت (به عنوان مثال، چندین pointer ورودی از records دیگر)، application code باید تمام relationships مختلف را دنبال می‌کرد. حتی اعضای کمیته CODASYL اذعان داشتند که این کار مانند پیمایش در یک فضای داده n-dimensional است [17].
    </p>
    <p>
        اگرچه انتخاب دستی access path قادر بود از قابلیت‌های سخت‌افزاری بسیار محدود در دهه 1970 (مانند tape drives که seeks آن‌ها بسیار کند است) استفاده بهینه را ببرد، اما مشکل این بود که آن‌ها کد را برای querying و updating database پیچیده و غیرقابل انعطاف می‌کردند. هم با hierarchical و هم با network model، اگر شما یک path به داده‌هایی که می‌خواستید نداشتید، در یک موقعیت دشوار قرار داشتید. شما می‌توانستید access paths را تغییر دهید، اما سپس مجبور بودید مقدار زیادی کد query database دست‌نویس را طی کنید و آن را دوباره بنویسید تا access paths جدید را مدیریت کند. ایجاد تغییرات در application’s data model دشوار بود.
    </p>
    <h4>The relational model</h4>
    <p>
        کاری که relational model در مقابل انجام داد این بود که همه data را در فضای باز قرار داد: یک relation (table) به سادگی یک collection از tuples (rows) است و همین. هیچ ساختارهای تو در توی پرپیچ و خم، هیچ access paths پیچیده‌ای برای دنبال کردن وجود ندارد، اگر می‌خواهید به data نگاه کنید. شما می‌توانید هر یا همه rows در یک table را بخوانید، آن‌هایی را که با یک condition دلخواه مطابقت دارند، انتخاب کنید. شما می‌توانید یک ردیف خاص را با تعیین برخی از columns به عنوان key و مطابقت با آن‌ها بخوانید. شما می‌توانید یک ردیف جدید را بدون نگرانی در مورد foreign key relationships به و از tables دیگر، وارد هر table کنید.iv
    </p>
    <p>
        در یک relational database، query optimizer به طور خودکار تصمیم می‌گیرد که کدام بخش از query را به چه ترتیبی اجرا کند و از کدام indexes استفاده کند. این انتخاب‌ها در واقع همان "access path" هستند، اما تفاوت بزرگ این است که آن‌ها به طور خودکار توسط
    </p>
    <p>
        Relational Model Versus Document Model | 37
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>