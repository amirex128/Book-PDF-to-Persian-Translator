<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 38</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>به‌عنوان‌مثال، با تعداد هسته‌های <strong>CPU</strong> آن)، تنها تعداد کمی از درخواست‌های کند طول می‌کشد تا پردازش درخواست‌های بعدی را متوقف کنند—اثری که گاهی اوقات به‌عنوان مسدود کردن <strong>head-of-line</strong> شناخته می‌شود. حتی اگر پردازش آن درخواست‌های بعدی روی سرور سریع باشد، <strong>client</strong> زمان پاسخ کلی کندی را به دلیل زمان انتظار برای تکمیل درخواست قبلی مشاهده خواهد کرد. به دلیل این اثر، اندازه‌گیری زمان پاسخ در سمت <strong>client</strong> مهم است.</p>
  <p>هنگام تولید مصنوعی <strong>load</strong> به‌منظور آزمایش مقیاس‌پذیری یک سیستم، <strong>client</strong> تولیدکننده <strong>load</strong> باید به‌طور مستقل از زمان پاسخ، درخواست‌ها را ارسال کند. اگر <strong>client</strong> قبل از ارسال درخواست بعدی، منتظر تکمیل درخواست قبلی بماند، این رفتار اثر دارد که صف‌ها را در آزمایش به‌طور مصنوعی کوتاه‌تر از واقعیت نگه می‌دارد، که اندازه‌گیری‌ها را منحرف می‌کند [23].</p>
  <h4>Percentiles in Practice</h4>
  <p><strong>Percentiles</strong> بالا به‌ویژه در سرویس‌های <strong>backend</strong> که چندین بار به‌عنوان بخشی از ارائه یک درخواست <strong>end-user</strong> واحد فراخوانی می‌شوند، اهمیت پیدا می‌کنند. حتی اگر تماس‌ها را به‌صورت موازی انجام دهید، درخواست <strong>end-user</strong> هنوز باید منتظر بماند تا کندترین تماس‌های موازی تکمیل شود. فقط یک تماس کند طول می‌کشد تا کل درخواست <strong>end-user</strong> کند شود، همان‌طور که در شکل 1-5 نشان داده شده است. حتی اگر تنها درصد کمی از تماس‌های <strong>backend</strong> کند باشند، اگر یک درخواست <strong>end-user</strong> به چندین تماس <strong>backend</strong> نیاز داشته باشد، احتمال دریافت یک تماس کند افزایش می‌یابد، و بنابراین نسبت بیشتری از درخواست‌های <strong>end-user</strong> در نهایت کند می‌شوند (اثری که به‌عنوان <strong>tail latency amplification</strong> شناخته می‌شود [24]).</p>
  <p>اگر می‌خواهید <strong>percentiles</strong> زمان پاسخ را به داشبوردهای نظارت <strong>services</strong> خود اضافه کنید، باید آن‌ها را به‌طور مداوم به‌طور مؤثر محاسبه کنید. به‌عنوان‌مثال، ممکن است بخواهید یک پنجره چرخشی از زمان‌های پاسخ درخواست‌ها را در 10 دقیقه گذشته نگه دارید. هر دقیقه، میانه و <strong>percentiles</strong> مختلف را در مقادیر موجود در آن پنجره محاسبه می‌کنید و آن متریک‌ها را روی یک نمودار ترسیم می‌کنید.</p>
  <p>پیاده‌سازی ساده این است که لیستی از زمان‌های پاسخ را برای همه درخواست‌ها در پنجره زمانی نگه دارید و آن لیست را هر دقیقه مرتب کنید. اگر این برای شما خیلی ناکارآمد است، الگوریتم‌هایی وجود دارند که می‌توانند یک تقریب خوب از <strong>percentiles</strong> را با حداقل هزینه <strong>CPU</strong> و حافظه محاسبه کنند، مانند <strong>forward decay</strong> [25]، <strong>t-digest</strong> [26] یا <strong>HdrHistogram</strong> [27]. مراقب باشید که میانگین‌گیری <strong>percentiles</strong>، به‌عنوان‌مثال، برای کاهش وضوح زمان یا ترکیب <strong>data</strong> از چندین دستگاه، از نظر ریاضی بی‌معنی است—روش درست برای جمع‌آوری <strong>data</strong> زمان پاسخ، افزودن هیستوگرام‌ها است [28].</p>
  <p>16 | Chapter 1: Reliable, Scalable, and Maintainable Applications</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>