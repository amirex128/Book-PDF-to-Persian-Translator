<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 542</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        در برابر حمله‌کنندگان شبکه محافظت می‌کند، اما در برابر <strong>compromises</strong>
        سرور محافظت نمی‌کند. فقط رمزگذاری و <strong>authentication</strong> <em>end-to-
        end</em> می‌تواند در برابر همه‌ی این موارد محافظت کند.
    </p>
    <p>
        اگرچه <strong>features</strong> سطح پایین (سرکوب تکراری <strong>TCP</strong>،
        <strong>checksums Ethernet</strong>، رمزگذاری <strong>WiFi</strong>) نمی‌توانند
        به‌تنهایی <strong>features end-to-end</strong> مورد نظر را ارائه
        دهند، آن‌ها هنوز هم مفید هستند، زیرا احتمال بروز مشکلات را در
        سطوح بالاتر کاهش می‌دهند. به عنوان مثال، درخواست‌های <strong>HTTP</strong>
        اغلب اگر <strong>TCP</strong> بسته‌ها را به ترتیب صحیح قرار ندهد،
        <em>mangled</em> خواهند شد. ما فقط نیاز داریم که به یاد داشته
        باشیم که <strong>features</strong> قابلیت اطمینان سطح پایین، به‌خودی خود
        برای اطمینان از درستی <em>end-to-end</em> کافی نیستند.
    </p>

    <h4>اعمال استدلال <strong>end-to-end</strong> در سیستم‌های داده</h4>
    <p>
        این موضوع من را به پایان‌نامه‌ی اصلی‌ام برمی‌گرداند: فقط به این
        دلیل که یک برنامه از یک سیستم داده استفاده می‌کند که
        ویژگی‌های ایمنی نسبتاً قوی را ارائه می‌دهد، مانند تراکنش‌های
        <em>serializable</em>، به این معنی نیست که تضمین می‌شود که برنامه
        از از دست رفتن یا خراب شدن داده‌ها عاری است. خود برنامه
        نیاز دارد که اقدامات <em>end-to-end</em> را انجام دهد، مانند
        سرکوب تکراری، نیز.
    </p>
    <p>
        این یک <em>shame</em> است، زیرا مکانیسم‌های تحمل خطا به‌درستی
        عمل کردن، سخت هستند. مکانیسم‌های قابلیت اطمینان سطح پایین،
        مانند آن‌هایی که در <strong>TCP</strong> وجود دارند، کاملاً خوب عمل
        می‌کنند، و بنابراین <strong>faults</strong> سطح بالاتر با نسبتاً به‌ندرت
        رخ می‌دهند. واقعاً خوب خواهد بود که ماشین‌آلات تحمل خطای
        باقی‌مانده سطح بالا را در یک <strong>abstraction</strong> جمع کنیم تا
        کد برنامه نیازی به نگرانی در مورد آن نداشته باشد—اما من
        می‌ترسم که هنوز <strong>abstraction</strong> مناسب را پیدا نکرده
        باشیم.
    </p>
    <p>
        تراکنش‌ها مدت‌هاست که به‌عنوان یک <strong>abstraction</strong> خوب دیده
        می‌شوند، و من معتقدم که آن‌ها مفید هستند. همان‌طور که در
        مقدمه فصل 7 بحث شد، آن‌ها طیف گسترده‌ای از مسائل
        احتمالی (<strong>writes</strong> همزمان، نقض محدودیت‌ها، <strong>crashes</strong>،
        <em>network interruptions</em>، <strong>disk failures</strong>) را می‌گیرند
        و آن‌ها را به دو نتیجه‌ی ممکن تبدیل می‌کنند: <strong>commit</strong> یا
        <strong>abort</strong>.
    </p>
    <p>
        این یک ساده‌سازی بزرگ از مدل برنامه‌نویسی است، اما من می‌ترسم
        که کافی نباشد.
    </p>
    <p>
        تراکنش‌ها پرهزینه هستند، به‌ویژه زمانی که شامل فناوری‌های
        ذخیره‌سازی ناهمگن می‌شوند (نگاه کنید به "تراکنش‌های توزیع شده
        در عمل" در صفحه 360). وقتی ما از استفاده از تراکنش‌های
        توزیع شده به این دلیل که خیلی گران هستند خودداری
        می‌کنیم، در نهایت باید مکانیسم‌های تحمل خطا را در کد
        برنامه دوباره پیاده‌سازی کنیم. همان‌طور که نمونه‌های متعددی
        در سراسر این کتاب نشان داده شده است، استدلال در مورد
        <strong>concurrency</strong> و <strong>partial failure</strong> دشوار و
        <em>counterintuitive</em> است، و بنابراین من مشکوک هستم که اکثر
        مکانیسم‌های سطح برنامه به‌درستی کار نمی‌کنند. نتیجه، از
        دست رفتن یا خراب شدن داده‌ها است.
    </p>
    <p>
        به همین دلایل، من فکر می‌کنم ارزش دارد که <strong>abstractions</strong>
        های تحمل خطا را بررسی کنیم که درک درستی از
        ویژگی‌های <em>application-specific end-to-end</em> را آسان می‌کنند،
        اما همچنین عملکرد خوب و ویژگی‌های عملیاتی خوب را در یک
        محیط توزیع شده در مقیاس بزرگ حفظ می‌کنند.
        520
        |
        فصل 12: آینده‌ی سیستم‌های داده
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>