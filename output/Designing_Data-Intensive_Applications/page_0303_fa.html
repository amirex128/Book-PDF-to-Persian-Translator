<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 303</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <ul>
        <li>
            اگر شما به رابط مدیریت <em>network switches</em> در <em>datacenter</em> خود دسترسی دارید، می‌توانید از آنها query بگیرید تا <em>link failures</em> را در سطح سخت‌افزار تشخیص دهید (به عنوان مثال، اگر <em>remote machine</em> خاموش شده باشد). این گزینه رد می‌شود اگر شما از طریق اینترنت متصل می‌شوید، یا اگر در یک <em>datacenter shared</em> هستید که به خود <em>switches</em> دسترسی ندارید، یا اگر به دلیل یک مشکل شبکه نمی‌توانید به رابط مدیریت برسید.
        </li>
        <li>
            اگر یک <em>router</em> مطمئن است که آدرس IP که شما در حال تلاش برای اتصال به آن هستید، غیرقابل دسترس است، ممکن است به شما با یک بسته ICMP Destination Unreachable پاسخ دهد. با این حال، <em>router</em> نیز دارای یک قابلیت تشخیص <em>failure</em> جادویی نیست—آن تحت همان محدودیت‌ها به عنوان سایر شرکت‌کنندگان در شبکه است.
        </li>
    </ul>
    <p>
        بازخورد سریع در مورد اینکه یک node از راه دور down است، مفید است، اما شما نمی‌توانید روی آن حساب کنید. حتی اگر TCP تأیید کند که یک <em>packet</em> تحویل داده شده است، application ممکن است قبل از handling آن، <em>crashed</em> شده باشد. اگر شما می‌خواهید مطمئن شوید که یک درخواست موفقیت‌آمیز بوده است، شما نیاز به یک پاسخ مثبت از خود application دارید [24].
    </p>
    <p>
        برعکس، اگر چیزی اشتباه پیش رفته است، ممکن است یک پاسخ <em>error</em> در سطحی از <em>stack</em> دریافت کنید، اما به طور کلی شما باید فرض کنید که اصلاً پاسخی دریافت نخواهید کرد. شما می‌توانید چند بار دوباره امتحان کنید (TCP به طور شفاف دوباره امتحان می‌کند، اما شما همچنین ممکن است در سطح application دوباره امتحان کنید)، منتظر بمانید تا یک <em>timeout</em> سپری شود، و در نهایت اگر در مدت <em>timeout</em> پاسخی دریافت نکردید، node را <em>dead</em> اعلام کنید.
    </p>
    <h4>Timeouts and Unbounded Delays</h4>
    <p>
        اگر یک <em>timeout</em> تنها راه مطمئن برای تشخیص <em>fault</em> است، پس <em>timeout</em> باید چقدر طول بکشد؟ متاسفانه هیچ پاسخ ساده‌ای وجود ندارد.
    </p>
    <p>
        یک <em>long timeout</em> به معنای انتظار طولانی تا زمانی است که یک node <em>dead</em> اعلام شود (و در این مدت، کاربران ممکن است مجبور به انتظار یا دیدن پیام‌های <em>error</em> باشند). یک <em>short timeout</em> <em>faults</em> را سریع‌تر تشخیص می‌دهد، اما خطر بالاتری از اعلام نادرست یک node <em>dead</em> را به همراه دارد در حالی که در واقع فقط دچار یک <em>slowdown</em> موقتی شده است (به عنوان مثال، به دلیل <em>load spike</em> روی node یا شبکه).
    </p>
    <p>
        <em>Prematurely declaring</em> یک node <em>dead</em> مشکل‌ساز است: اگر node واقعاً زنده باشد و در حال انجام کاری باشد (به عنوان مثال، ارسال یک ایمیل)، و یک node دیگر کنترل را به دست گیرد، action ممکن است دو بار انجام شود. ما این مسئله را با جزئیات بیشتر در "Knowledge, Truth, and Lies" در صفحه 300، و در فصل‌های 9 و 11 مورد بحث قرار خواهیم داد.
    </p>
    <p>
        وقتی یک node <em>dead</em> اعلام می‌شود، مسئولیت‌های آن باید به nodes های دیگر منتقل شود، که بار اضافی را روی nodes های دیگر و شبکه قرار می‌دهد. اگر system در حال حاضر با <em>high load</em> دست و پنجه نرم می‌کند، اعلام nodes ها <em>dead</em> قبل از موعد می‌تواند مشکل را بدتر کند. به طور خاص، ممکن است اتفاق بیفتد که node واقعاً <em>dead</em> نبوده است، بلکه فقط به دلیل <em>overload</em> در پاسخگویی کند بوده است. انتقال بار آن به nodes های دیگر می‌تواند باعث یک <em>cascading failure</em> شود (در موارد شدید، همه nodes یکدیگر را <em>dead</em> اعلام می‌کنند، و همه چیز متوقف می‌شود).
        <br>
        Unreliable Networks
        <br>
        |
        <br>
        281
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>