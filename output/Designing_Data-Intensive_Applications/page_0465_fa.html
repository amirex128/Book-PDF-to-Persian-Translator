<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 465</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <ul>
        <li>
            اگر <strong>consumer</strong> یک <strong>service</strong> را در شبکه در معرض نمایش قرار
            دهد، <strong>producers</strong> می‌توانند یک درخواست مستقیم <strong>HTTP</strong> یا
            <strong>RPC</strong> (نگاه کنید به "<strong>Dataflow</strong> از طریق <strong>Services</strong>: <strong>REST</strong> و
            <strong>RPC</strong>" در صفحه 131) برای <em>push</em> کردن پیام‌ها به
            <strong>consumer</strong> ارسال کنند. این ایده پشت <strong>webhooks</strong> [12] است،
            الگویی که در آن یک <strong>URL</strong> <strong>callback</strong> از یک <strong>service</strong> در یک
            <strong>service</strong> دیگر ثبت می‌شود، و هر زمان که یک رویداد رخ دهد،
            درخواستی را به آن <strong>URL</strong> ارسال می‌کند.
        </li>
    </ul>
    <p>
        اگرچه این سیستم‌های پیام‌رسانی مستقیم در موقعیت‌هایی که برای آن‌ها طراحی
        شده‌اند خوب عمل می‌کنند، اما به‌طور کلی به کد برنامه نیاز دارند تا از
        احتمال از دست رفتن پیام‌ها آگاه باشند. خطاهایی که آن‌ها می‌توانند تحمل
        کنند بسیار محدود است: حتی اگر پروتکل‌ها بسته‌هایی را که در شبکه از
        دست رفته‌اند، شناسایی و دوباره ارسال کنند، به‌طور کلی فرض می‌کنند که
        <strong>producers</strong> و <strong>consumers</strong> به‌طور مداوم <em>online</em> هستند.
    </p>
    <p>
        اگر یک <strong>consumer</strong> <em>offline</em> باشد، ممکن است پیام‌هایی را که در
        حالی‌که غیرقابل دسترس است، از دست بدهد. برخی از پروتکل‌ها به
        <strong>producer</strong> اجازه می‌دهند تحویل پیام‌های ناموفق را دوباره امتحان
        کند، اما این رویکرد ممکن است در صورت از کار افتادن <strong>producer</strong>،
        شکست بخورد، و <strong>buffer</strong> پیام‌هایی را که قرار بود دوباره امتحان کند،
        از دست بدهد.
    </p>

    <h4><strong>Message brokers</strong></h4>
    <p>
        یک جایگزین رایج، ارسال پیام‌ها از طریق یک <strong>message broker</strong> (که
        به آن <strong>message queue</strong> نیز گفته می‌شود) است، که اساساً نوعی
        پایگاه داده است که برای مدیریت جریان‌های پیام بهینه شده است [13]. این
        به‌عنوان یک سرور اجرا می‌شود، با <strong>producers</strong> و <strong>consumers</strong> که
        به آن به‌عنوان <strong>clients</strong> متصل می‌شوند. <strong>Producers</strong> پیام‌ها را
        به <strong>broker</strong> می‌نویسند، و <strong>consumers</strong> آن‌ها را با خواندن از
        <strong>broker</strong> دریافت می‌کنند.
    </p>
    <p>
        با متمرکز کردن داده‌ها در <strong>broker</strong>، این سیستم‌ها می‌توانند
        <strong>clients</strong> را که می‌آیند و می‌روند (اتصال، قطع اتصال و خرابی) را
        راحت‌تر تحمل کنند، و مسئله‌ی <em>durability</em> به‌جای آن به <strong>broker</strong>
        منتقل می‌شود. برخی از <strong>message brokers</strong>، پیام‌ها را فقط در حافظه
        نگهداری می‌کنند، در حالی که برخی دیگر (بسته به پیکربندی) آن‌ها را روی
        دیسک می‌نویسند تا در صورت خرابی <strong>broker</strong> از بین نروند. در مواجهه با
        <strong>consumers</strong> کند، آن‌ها به‌طور کلی صف‌بندی <em>unbounded</em> را
        مجاز می‌کنند (بر خلاف <em>dropping</em> پیام‌ها یا <strong>backpressure</strong>)،
        اگرچه این انتخاب ممکن است به پیکربندی نیز بستگی داشته باشد.
    </p>
    <p>
        پیامد صف‌بندی نیز این است که <strong>consumers</strong> به‌طور کلی
        <em>asynchronous</em> هستند: هنگامی که یک <strong>producer</strong> یک پیام را ارسال
        می‌کند، معمولاً فقط منتظر می‌ماند تا <strong>broker</strong> تأیید کند که پیام را
        <strong>buffered</strong> کرده است و منتظر پردازش پیام توسط
        <strong>consumers</strong> نمی‌ماند. تحویل به <strong>consumers</strong> در یک نقطه زمانی
        نامشخص در آینده اتفاق می‌افتد—اغلب در عرض کسری از ثانیه، اما گاهی
        اوقات اگر یک <strong>queue backlog</strong> وجود داشته باشد، به‌طور قابل توجهی
        دیرتر.
    </p>

    <h4><strong>Message brokers</strong> در مقایسه با پایگاه‌های داده</h4>
    <p>
        برخی از <strong>message brokers</strong> حتی می‌توانند در پروتکل‌های <strong>two-phase
        commit</strong> با استفاده از <strong>XA</strong> یا <strong>JTA</strong> شرکت کنند (نگاه کنید به
        "تراکنش‌های توزیع شده در عمل" در صفحه 360). این <strong>feature</strong> باعث می‌شود
        انتقال جریان‌های رویداد
        |
        443
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>