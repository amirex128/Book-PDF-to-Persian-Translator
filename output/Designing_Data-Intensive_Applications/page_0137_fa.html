<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 137</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <ul>
        <li>There is optional schema support for both XML [11] and JSON [12]. These schema languages are quite powerful, and thus quite complicated to learn and implement. Use of XML schemas is fairly widespread, but many JSON-based tools don’t bother using schemas. Since the correct interpretation of data (such as numbers and binary strings) depends on information in the schema, applications that don’t use XML/JSON schemas need to potentially hardcode the appro‐priate encoding/decoding logic instead.</li>
        <li>CSV does not have any schema, so it is up to the application to define the meaning of each row and column. If an application change adds a new row or column, you have to handle that change manually. CSV is also a quite vague format (what happens if a value contains a comma or a newline character?). Although its escaping rules have been formally specified [13], not all parsers implement them correctly.</li>
    </ul>
    <p>
        با وجود این flaws، JSON, XML و CSV برای بسیاری از اهداف به اندازه کافی خوب هستند. احتمال دارد که آن‌ها محبوب باقی بمانند، به خصوص به عنوان data interchange formats (یعنی، برای ارسال داده‌ها از یک سازمان به سازمان دیگر). در این شرایط، تا زمانی که افراد در مورد format توافق داشته باشند، اغلب مهم نیست که format چقدر زیبا یا کارآمد است. دشواری در متقاعد کردن سازمان‌های مختلف به توافق بر سر هر چیزی، بر بیشتر نگرانی‌های دیگر غلبه می‌کند.
    </p>
    <h4>Binary encoding</h4>
    <p>
        برای داده‌هایی که فقط به صورت داخلی در سازمان شما استفاده می‌شوند، فشار کمتری برای استفاده از یک format encoding lowest-common-denominator وجود دارد. به عنوان مثال، شما می‌توانید یک format را انتخاب کنید که compact‌تر یا سریع‌تر برای parsing است. برای یک dataset کوچک، gains ناچیز هستند، اما هنگامی که شما وارد terabytes می‌شوید، انتخاب data format می‌تواند تأثیر زیادی داشته باشد.
    </p>
    <p>
        JSON کمتر از XML verbose است، اما هر دو همچنان فضای زیادی را نسبت به binary formats استفاده می‌کنند. این observation منجر به توسعه a profusion of binary encodings برای JSON (MessagePack, BSON, BJSON, UBJSON, BISON و Smile، برای نام بردن از چند مورد) و برای XML (WBXML و Fast Infoset، به عنوان مثال) شد. این formats در niches مختلف پذیرفته شده‌اند، اما هیچ یک از آن‌ها به اندازه نسخه‌های textual از JSON و XML به طور گسترده پذیرفته نشده‌اند.
    </p>
    <p>
        برخی از این formats مجموعه datatypes را گسترش می‌دهند (به عنوان مثال، تمایز integers و floating-point numbers، یا اضافه کردن پشتیبانی برای binary strings)، اما در غیر این صورت آن‌ها data model JSON/XML را بدون تغییر حفظ می‌کنند. به طور خاص، از آنجایی که آن‌ها یک schema را تجویز نمی‌کنند، آن‌ها نیاز به شامل شدن همه object field names در data encoded دارند.
        یعنی، در یک binary encoding از document JSON در Example 4-1، آن‌ها نیاز به شامل کردن رشته‌های userName, favoriteNumber و interests در جایی دارند.
    </p>
    <p>
        Formats for Encoding Data | 115
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>