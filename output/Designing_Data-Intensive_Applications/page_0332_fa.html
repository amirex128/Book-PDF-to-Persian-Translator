<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 332</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        <em>A theoretical description of an algorithm</em> می‌تواند اعلام کند که موارد خاصی به سادگی فرض می‌شود که اتفاق نمی‌افتند—و در <em>non-Byzantine systems</em>، ما باید برخی از فرضیات را در مورد <em>faults</em> هایی که می‌توانند و نمی‌توانند رخ دهند، ایجاد کنیم. با این حال، یک پیاده‌سازی واقعی ممکن است همچنان نیاز داشته باشد که کدی را برای رسیدگی به موردی که در آن چیزی که فرض می‌شد غیرممکن است، رخ می‌دهد، شامل شود، حتی اگر آن مدیریت به <em>printf("Sucks to be you")</em> و <em>exit(666)</em> منتهی شود—یعنی، اجازه دادن به یک <em>human operator</em> برای پاک کردن مشکل [93].
    </p>
    <p>
        (این احتمالاً تفاوت بین علوم کامپیوتر و <em>software engineering</em> است.)
    </p>
    <p>
        این بدان معنا نیست که <em>theoretical, abstract system models</em> بی‌ارزش هستند—برعکس این است. آنها برای تقطیر پیچیدگی سیستم‌های واقعی به مجموعه‌ای از <em>faults</em> ها، که ما می‌توانیم در مورد آنها استدلال کنیم، بسیار مفید هستند، به‌طوری‌که می‌توانیم مشکل را درک کنیم و سعی کنیم آن را به‌طور سیستماتیک حل کنیم. ما می‌توانیم <em>algorithms</em> را با نشان دادن اینکه ویژگی‌های آنها همیشه در برخی از <em>system model</em> ها حفظ می‌شوند، correct کنیم.
    </p>
    <p>
        اثبات <em>correct</em> بودن یک الگوریتم به این معنی نیست که پیاده‌سازی آن در یک system واقعی لزوماً همیشه به درستی رفتار می‌کند. اما این یک گام اول بسیار خوب است، زیرا تحلیل نظری می‌تواند مشکلاتی را در یک الگوریتم کشف کند که ممکن است برای مدت طولانی در یک system واقعی پنهان بماند، و فقط زمانی شما را <em>bite</em> کند که فرضیات شما (به عنوان مثال، در مورد زمان‌بندی) به دلیل شرایط غیرعادی شکست خورده باشد. <em>Theoretical analysis</em> و آزمایش تجربی به یک اندازه مهم هستند.
    </p>
    <h4>Summary</h4>
    <p>
        در این فصل ما در مورد طیف گسترده‌ای از مشکلاتی که می‌تواند در <em>distributed systems</em> رخ دهد، بحث کردیم، از جمله:
    </p>
    <ul>
        <li>
            هر زمان که شما سعی می‌کنید یک <em>packet</em> را از طریق شبکه ارسال کنید، ممکن است از دست برود یا به طور دلخواه به تأخیر بیفتد. به همین ترتیب، پاسخ ممکن است از دست برود یا به تأخیر بیفتد، بنابراین اگر شما پاسخی دریافت نمی‌کنید، هیچ ایده‌ای ندارید که آیا پیام ارسال شده است یا خیر.
        </li>
        <li>
            ساعت یک node ممکن است به طور قابل توجهی با سایر nodes همگام‌سازی شده باشد (علیرغم تلاش‌های شما برای تنظیم NTP)، ممکن است ناگهان به جلو یا عقب در زمان بپرد، و تکیه بر آن خطرناک است زیرا شما به احتمال زیاد اندازه‌گیری خوبی از <em>error interval</em> ساعت خود ندارید.
        </li>
        <li>
            یک process ممکن است برای یک مدت زمان قابل توجهی در هر نقطه‌ای در اجرای خود متوقف شود (شاید به دلیل یک <em>stop-the-world garbage collector</em>)، توسط سایر nodes ها <em>dead</em> اعلام شود، و سپس دوباره بدون اینکه متوجه شود متوقف شده است، به زندگی بازگردد.
        </li>
    </ul>
    <p>
        این واقعیت که چنین <em>partial failures</em> می‌تواند رخ دهد، ویژگی تعیین‌کننده <em>distributed systems</em> است. هر زمان که نرم‌افزار سعی می‌کند کاری را که شامل nodes های دیگر است انجام دهد، این احتمال وجود دارد که گاهی اوقات شکست بخورد، یا به طور تصادفی کند شود، یا اصلاً پاسخ ندهد (و در نهایت <em>timeout</em>). در <em>distributed systems</em>، ما سعی می‌کنیم system های <em>tolerant</em> بسازیم
        <br>
        310
        <br>
        |
        <br>
        Chapter 8: The Trouble with Distributed Systems
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>