<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 425</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <h4>v. The joins we talk about in this book</h4>
    <p>
        joins که ما در این کتاب در مورد آن‌ها صحبت می‌کنیم، به طور کلی equi-joins هستند، که رایج‌ترین نوع join هستند، که در آن یک record با other records که یک مقدار یکسان در یک field خاص (مانند یک ID) دارند، مرتبط می‌شود. برخی از databases، از انواع عمومی‌تر joins پشتیبانی می‌کنند، به عنوان مثال با استفاده از یک less-than operator به جای یک equality operator، اما ما فضایی برای پوشش آن‌ها در اینجا نداریم.
    </p>

    <p>
        executions، various workflow schedulers برای Hadoop توسعه داده شده‌اند، شامل Oozie, Azkaban, Luigi, Airflow، و Pinball [28].
    </p>

    <p>
        These schedulers همچنین دارای features management هستند که هنگام حفظ یک collection بزرگ از batch jobs مفید هستند. Workflows که شامل 50 تا 100 MapReduce jobs هستند، هنگام ساختن recommendation systems [29] رایج هستند، و در یک سازمان بزرگ، بسیاری از تیم‌های مختلف ممکن است jobsهای مختلفی را اجرا کنند که output یکدیگر را می‌خوانند.
        Tool support برای مدیریت چنین dataflows پیچیده مهم است.
    </p>

    <p>
        Various higher-level tools برای Hadoop، مانند Pig [30]، Hive [31]، Cascading [32]، Crunch [33]، و FlumeJava [34]، همچنین workflows از multiple MapReduce stages را راه‌اندازی می‌کنند که به طور خودکار به درستی به هم متصل می‌شوند.
    </p>

    <h4>Reduce-Side Joins and Grouping</h4>
    <p>
        ما در مورد joins در فصل 2 در context از data models و query languages بحث کردیم، اما ما در مورد اینکه چگونه joins در واقع پیاده‌سازی می‌شوند، بحث نکردیم. زمان آن فرا رسیده است که ما دوباره آن thread را برداریم.
    </p>

    <p>
        در بسیاری از datasets، این رایج است که یک record، یک association با یک record دیگر داشته باشد: یک foreign key در یک relational model، یک document reference در یک document model، یا یک edge در یک graph model. A join، هر زمان که شما کدی دارید که نیاز دارد به records در هر دو طرف آن association (هم record که reference را نگه می‌دارد و هم record که به آن reference می‌شود) دسترسی داشته باشد، ضروری است. همانطور که در فصل 2 بحث شد، denormalization می‌تواند نیاز به joins را کاهش دهد اما عموماً آن را به طور کامل حذف نمی‌کند.v
    </p>

    <p>
        در یک database، اگر شما یک query را اجرا کنید که فقط شامل تعداد کمی از records است، database معمولاً از یک index برای یافتن سریع records مورد علاقه استفاده می‌کند (فصل 3 را ببینید). اگر query شامل joins باشد، ممکن است به multiple index lookups نیاز داشته باشد. با این حال، MapReduce هیچ مفهومی از indexes ندارد - حداقل نه به معنای معمول.
    </p>

    <p>
        هنگامی که یک MapReduce job، یک set از فایل‌ها را به عنوان input دریافت می‌کند، کل محتوای تمام آن فایل‌ها را می‌خواند؛ یک database، این operation را یک full table scan می‌نامد. اگر شما فقط می‌خواهید تعداد کمی از records را بخوانید، a full table scan در مقایسه با یک index lookup، به طرز وحشتناکی گران است. با این حال، در analytic queries (به "Transaction Processing or Analytics?" در صفحه 90 مراجعه کنید) این رایج است که بخواهید aggregates را بر روی تعداد زیادی از records محاسبه کنید. در این مورد، scanning کل input ممکن است یک چیز کاملاً معقول باشد، به خصوص اگر شما بتوانید processing را در سراسر multiple machines parallelize کنید.
    </p>
    <p>
        MapReduce and Distributed Filesystems | 403
    </p>
 </div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>