<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 484</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        سیستم‌ها بدون نیاز به تغییر آن‌ها. اجرای سیستم‌های قدیمی و جدید در کنار هم
        اغلب آسان‌تر از انجام یک <strong>schema migration</strong> پیچیده در یک
        سیستم موجود است.
    </p>
    <p>
        هنگامی که دیگر به سیستم قدیمی نیازی نبود، شما به‌سادگی می‌توانید آن
        را خاموش کنید و منابع آن را بازگردانید [47، 57].
    </p>
    <p>
        ذخیره‌سازی داده‌ها معمولاً بسیار ساده است اگر شما مجبور نباشید نگران
        چگونگی <strong>queried</strong> و دسترسی به آن باشید؛ بسیاری از پیچیدگی‌های
        طراحی <strong>schema</strong>، index کردن، و <strong>storage engines</strong>
        نتیجه‌ی تمایل به پشتیبانی از الگوهای <strong>query</strong> و دسترسی خاص
        (نگاه کنید به فصل 3) است. به همین دلیل، شما انعطاف‌پذیری زیادی را با
        جدا کردن فرمی که داده‌ها در آن نوشته می‌شوند از فرمی که در آن
        خوانده می‌شوند، و با اجازه دادن به چندین <strong>views</strong> <em>read</em>
        مختلف، به‌دست می‌آورید. این ایده گاهی اوقات به‌عنوان <strong>command query
        responsibility segregation (CQRS)</strong> شناخته می‌شود [42، 58، 59].
    </p>
    <p>
        رویکرد سنتی برای طراحی پایگاه داده و <strong>schema</strong> بر اساس مغالطه‌ی
        این است که داده‌ها باید به همان فرمی نوشته شوند که <strong>queried</strong>
        خواهند شد. بحث‌ها در مورد <strong>normalization</strong> و <strong>denormalization</strong>
        (نگاه کنید به "روابط <strong>Many-to-One</strong> و <strong>Many-to-Many</strong>" در
        صفحه 33) تا حد زیادی نامربوط می‌شوند اگر شما می‌توانید داده‌ها را از
        یک <strong>log</strong> رویداد که برای نوشتن بهینه شده است، به وضعیت
        برنامه که برای خواندن بهینه شده است ترجمه کنید: کاملاً منطقی است که
        داده‌ها را در <strong>views</strong> که برای خواندن بهینه شده‌اند،
        <strong>denormalize</strong> کنید، زیرا فرآیند ترجمه یک مکانیسم برای
        همگام نگه داشتن آن با <strong>event log</strong> به شما می‌دهد.
    </p>
    <p>
        در "شرح <strong>Load</strong>" در صفحه 11، ما در مورد <strong>home timelines</strong> از
        <strong>Twitter</strong> بحث کردیم، یک <strong>cache</strong> از توییت‌های اخیر
        نوشته شده توسط افرادی که یک کاربر خاص دنبال می‌کند (مانند یک
        صندوق پستی). این یک مثال دیگر از <strong>state</strong> برای خواندن بهینه شده
        است: <strong>home timelines</strong> بسیار <strong>denormalized</strong> هستند،
        زیرا توییت‌های شما در تمام <strong>timelines</strong> افرادی که شما را دنبال
        می‌کنند، تکرار می‌شوند. با این حال، سرویس <strong>fan-out</strong>، این
        <strong>state</strong> تکراری را با توییت‌های جدید و روابط جدید دنبال
        کردن، همگام نگه می‌دارد، که این امر تکرار را مدیریت‌پذیر نگه
        می‌دارد.
    </p>

    <h4>کنترل <strong>Concurrency</strong></h4>
    <p>
        بزرگترین نقطه ضعف <strong>event sourcing</strong> و <strong>change data capture</strong>
        این است که <strong>consumers</strong> از <strong>event log</strong> معمولاً <em>asynchronous</em>
        هستند، بنابراین این احتمال وجود دارد که یک کاربر ممکن است یک
        نوشته در <strong>log</strong> ایجاد کند، سپس از یک <strong>log-derived view</strong>
        بخواند و متوجه شود که نوشته آن‌ها هنوز در <strong>read view</strong> منعکس
        نشده است. ما قبلاً در "خواندن نوشتن‌های خودتان" در صفحه 162 این
        مشکل و راه‌حل‌های احتمالی را مورد بحث قرار دادیم.
    </p>
    <p>
        یک راه‌حل این است که به‌روزرسانی‌های <strong>read view</strong> را
        <em>synchronously</em> با اضافه کردن رویداد به <strong>log</strong> انجام دهیم. این
        امر به یک تراکنش نیاز دارد تا نوشتن‌ها را در یک واحد <em>atomic</em>
        ترکیب کند، بنابراین شما یا باید <strong>event log</strong> و <strong>read view</strong>
        را در همان سیستم ذخیره‌سازی نگه دارید، یا به یک تراکنش توزیع شده
        در سراسر سیستم‌های مختلف نیاز دارید.
    </p>
    <p>
        به‌طور جایگزین، شما می‌توانید از رویکردی که در "پیاده‌سازی
        ذخیره‌سازی <em>linearizable</em> با استفاده از <strong>total order broadcast</strong>"
        در صفحه 350 بحث شد، استفاده کنید.
    </p>
    <p>
        از سوی دیگر، استخراج وضعیت فعلی از یک <strong>event log</strong> همچنین
        برخی از جنبه‌های کنترل <strong>concurrency</strong> را ساده می‌کند. بخش زیادی
        از نیاز به تراکنش‌های چند شیئی (نگاه کنید به "عملیات
        <strong>Single-Object</strong> و <strong>Multi-Object</strong>" در صفحه 228) از یک
        کاربر واحد ناشی می‌شود
        پایگاه‌های داده و جریان‌ها
        |
        462
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>