<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 329</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        باید در system به نوعی <em>formalize</em> کنیم، در این صورت انواع <em>faults</em> را که انتظار داریم در یک system رخ دهند، پیش‌بینی می‌کنیم. ما این کار را با تعریف a <em>system model</em> انجام می‌دهیم، که یک <em>abstraction</em> است که توضیح می‌دهد که یک الگوریتم چه چیزهایی را می‌تواند فرض کند.
    </p>
    <p>
        با توجه به فرضیات زمان‌بندی، سه <em>system models</em> به‌طور معمول مورد استفاده قرار می‌گیرند:
    </p>
    <ul>
        <li>
            Synchronous model
            <br>
            <em>The synchronous model</em>، تأخیر شبکه <em>bounded</em>، توقف <em>process pauses</em> <em>bounded</em>، و <em>bounded clock error</em> را فرض می‌کند. این به معنای ساعت‌های دقیقاً همگام‌سازی شده یا تأخیر شبکه صفر نیست. فقط به این معنی است که شما می‌دانید که تأخیر شبکه، توقف‌ها، و <em>clock drift</em> هرگز از یک <em>upper bound</em> ثابت تجاوز نخواهد کرد [88]. <em>The synchronous model</em>، یک مدل واقع‌بینانه از اکثر systems های کاربردی نیست، زیرا (همانطور که در این فصل مورد بحث قرار گرفت) تأخیرها و توقف‌های نامحدود رخ می‌دهند.
        </li>
        <li>
            Partially synchronous model
            <br>
            Partial synchrony به این معنی است که یک system، در بیشتر مواقع، مانند یک <em>synchronous system</em> رفتار می‌کند، اما گاهی اوقات از حدود تأخیر شبکه، توقف <em>process pauses</em>، و <em>clock drift</em> فراتر می‌رود [88]. این یک مدل واقع‌بینانه از بسیاری از systems ها است: در بیشتر مواقع، شبکه‌ها و <em>processes</em> ها به خوبی رفتار می‌کنند—در غیر این صورت ما هرگز نمی‌توانستیم هیچ کاری انجام دهیم—اما ما باید با این واقعیت حساب کنیم که هر فرضیات زمان‌بندی ممکن است گه‌گاه شکسته شود. هنگامی که این اتفاق می‌افتد، تأخیر شبکه، توقف‌ها، و خطای ساعت ممکن است به طور دلخواه زیاد شوند.
        </li>
        <li>
            Asynchronous model
            <br>
            در این مدل، یک الگوریتم مجاز به انجام هیچ فرضیات زمان‌بندی نیست—در واقع، حتی یک ساعت ندارد (بنابراین نمی‌تواند از <em>timeouts</em> استفاده کند). برخی از الگوریتم‌ها را می‌توان برای مدل <em>asynchronous</em> طراحی کرد، اما بسیار محدودکننده است.
        </li>
    </ul>
    <p>
        علاوه بر این، در کنار مسائل زمان‌بندی، ما باید <em>node failures</em> را در نظر بگیریم. سه <em>system models</em> رایج برای nodes عبارتند از:
    </p>
    <ul>
        <li>
            Crash-stop faults
            <br>
            در <em>the crash-stop model</em>، یک الگوریتم ممکن است فرض کند که یک node فقط می‌تواند به یک روش <em>fail</em> شود، یعنی با <em>crashing</em>. این بدان معناست که node ممکن است ناگهان در هر لحظه پاسخ دادن را متوقف کند، و پس از آن، آن node برای همیشه از بین می‌رود—هرگز برنمی‌گردد.
        </li>
        <li>
            Crash-recovery faults
            <br>
            ما فرض می‌کنیم که nodes ممکن است در هر لحظه <em>crash</em> کنند، و شاید پس از مدتی نامعلوم دوباره پاسخ دهند. در <em>the crash-recovery model</em>، فرض می‌شود که nodes، <em>stable storage</em> (یعنی، ذخیره‌سازی دیسک غیرفرار) دارند که در سراسر <em>crashes</em> حفظ می‌شود، در حالی که فرض می‌شود که <em>in-memory state</em> از بین رفته است.
        </li>
        <li>
            Byzantine (arbitrary) faults
            <br>
            Nodes ها ممکن است مطلقاً هر کاری انجام دهند، از جمله تلاش برای فریب و گمراه کردن سایر nodes ها، همانطور که در بخش آخر توضیح داده شد.
            <br>
            Knowledge, Truth, and Lies
            <br>
            |
            <br>
            307
        </li>
    </ul>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>