<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 328</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>
        به طور مشابه، اگر یک پروتکل بتواند ما را از آسیب‌پذیری‌ها، <em>security compromises</em>، و حملات مخرب محافظت کند، جذاب خواهد بود. متاسفانه، این نیز واقع‌بینانه نیست: در اکثر systems ها، اگر یک <em>attacker</em> بتواند یک node را به خطر بیندازد، احتمالاً می‌تواند همه آنها را به خطر بیندازد، زیرا احتمالاً آنها در حال اجرای نرم‌افزار یکسان هستند. بنابراین، مکانیسم‌های سنتی (<em>authentication, access control, encryption, firewalls</em>، و غیره) همچنان محافظت اصلی در برابر <em>attackers</em> هستند.
    </p>
    <h4>Weak forms of lying</h4>
    <p>
        اگرچه ما فرض می‌کنیم که nodes ها به طور کلی صادق هستند، اما ممکن است اضافه کردن مکانیسم‌هایی به نرم‌افزار که در برابر <em>weak forms</em> از "دروغ گفتن" محافظت می‌کنند—به عنوان مثال، پیام‌های نامعتبر به دلیل مشکلات سخت‌افزاری، باگ‌های نرم‌افزاری، و <em>misconfiguration</em>—ارزش داشته باشد. این مکانیسم‌های محافظت، <em>full-blown Byzantine fault tolerance</em> نیستند، زیرا در برابر یک <em>determined adversary</em> مقاومت نمی‌کنند، اما با این وجود، گام‌های ساده و عمل‌گرایانه به سمت قابلیت اطمینان بهتر هستند. به عنوان مثال:
    </p>
    <ul>
        <li>
            <em>Network packets</em> گاهی اوقات به دلیل مشکلات سخت‌افزاری یا باگ‌ها در <em>operating systems, drivers, routers</em> و غیره خراب می‌شوند. معمولاً، <em>corrupted packets</em> توسط <em>checksums</em> های ساخته شده در TCP و UDP گرفته می‌شوند، اما گاهی اوقات از تشخیص اجتناب می‌کنند [85, 86, 87]. اقدامات ساده معمولاً محافظت کافی در برابر چنین <em>corruption</em> ای هستند، مانند <em>checksums</em> در <em>application-level protocol</em>.
        </li>
        <li>
            یک application که به صورت عمومی قابل دسترسی است، باید هر ورودی از users را با دقت <em>sanitize</em> کند، به عنوان مثال بررسی اینکه آیا یک value در یک محدوده معقول قرار دارد و محدود کردن اندازه <em>strings</em> برای جلوگیری از <em>denial of service</em> از طریق تخصیص حافظه بزرگ. یک service داخلی در پشت یک <em>firewall</em> ممکن است بتواند با بررسی‌های کمتری در مورد ورودی‌ها (به عنوان مثال، در <em>protocol parsing</em> [85]) کنار بیاید، اما برخی از <em>sanity-checking</em> های اساسی از <em>values</em> (به عنوان مثال، در <em>protocol parsing</em> [85]) یک ایده خوب است.
        </li>
        <li>
            <em>NTP clients</em> را می‌توان با چندین آدرس سرور پیکربندی کرد. هنگام همگام‌سازی، client با همه آنها تماس می‌گیرد، خطاهای آنها را تخمین می‌زند، و بررسی می‌کند که آیا اکثریت سرورها روی یک <em>time range</em> توافق دارند. تا زمانی که بیشتر سرورها خوب هستند، یک سرور NTP <em>misconfigured</em> که زمان نادرستی را گزارش می‌کند، به عنوان یک <em>outlier</em> تشخیص داده می‌شود و از همگام‌سازی مستثنی می‌شود [37]. استفاده از چندین سرور، NTP را بیشتر <em>robust</em> می‌کند نسبت به زمانی که فقط از یک سرور واحد استفاده می‌کند.
        </li>
    </ul>
    <p>
        Many algorithms have been designed to solve distributed systems problems—for
        example, we will examine solutions for the consensus problem in Chapter 9. In order
        to be useful, these algorithms need to tolerate the various faults of distributed systems
        that we discussed in this chapter.
        <br>
        Clock readings have a confidence interval
        <br>
        You may be able to read a machine’s time-of-day clock with microsecond or even
        nanosecond resolution. But even if you can get such a fine-grained measurement,
        that doesn’t mean the value is actually accurate to such precision. In fact, it most
        likely is not—as mentioned previously, the drift in an imprecise quartz clock can
        easily be several milliseconds, even if you synchronize with an NTP server on the
        local network every minute. With an NTP server on the public internet, the best pos‐
        sible accuracy is probably to the tens of milliseconds, and the error may easily spike
        to over 100 ms when there is network congestion [57].
        Thus, it doesn’t make sense to think of a clock reading as a point in time—it is more
        like a range of times, within a confidence interval: for example, a system may be 95%
        confident that the time now is between 10.3 and 10.5 seconds past the minute, but it
        Unreliable Clocks
        |
        293
    </p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>