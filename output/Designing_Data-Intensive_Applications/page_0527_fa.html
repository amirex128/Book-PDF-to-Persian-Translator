<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 527</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        کد برنامه به عنوان یک تابع مشتق شده
    </p>
    <p>
        وقتی یک مجموعه‌داده از دیگری مشتق می‌شود، از طریق نوعی تابع
        تبدیل کننده می‌گذرد. به عنوان مثال:
    </p>
    <ul>
        <li>
            یک <strong>secondary index</strong>، نوعی مجموعه‌داده‌ی مشتق شده
            با یک تابع تبدیل مستقیم است: برای هر سطر یا سند در جدول
            پایه، مقادیر را در ستون‌ها یا <strong>fields</strong> که <strong>indexed</strong>
            می‌شوند، انتخاب می‌کند، و بر اساس آن مقادیر مرتب
            می‌کند (با فرض یک <strong>index B-tree</strong> یا <strong>SSTable</strong>،
            که بر اساس <strong>key</strong> مرتب شده‌اند، همان‌طور که در فصل 3 بحث
            شد).
        </li>
        <li>
            یک index جستجوی متن کامل با اعمال توابع مختلف پردازش زبان
            طبیعی مانند تشخیص زبان، <strong>word segmentation</strong>،
            <strong>stemming</strong> یا <strong>lemmatization</strong>، تصحیح
            املایی، و شناسایی مترادف‌ها، ایجاد می‌شود، و پس از آن یک
            ساختار داده برای <strong>lookups</strong> کارآمد ساخته می‌شود (مانند یک
            index معکوس).
        </li>
        <li>
            در یک سیستم <strong>machine learning</strong>، ما می‌توانیم مدل را در نظر
            بگیریم که با اعمال توابع مختلف <strong>feature extraction</strong> و
            تجزیه و تحلیل آماری از داده‌های آموزشی مشتق شده است.
            هنگامی‌که مدل برای داده‌های ورودی جدید اعمال می‌شود، خروجی
            مدل از ورودی و مدل (و از این رو، به‌طور غیرمستقیم، از داده‌های
            آموزشی) مشتق می‌شود.
        </li>
        <li>
            یک <strong>cache</strong> اغلب حاوی یک تجمیع از داده‌ها به شکلی است
            که در یک <strong>user interface (UI)</strong> نمایش داده می‌شود. بنابراین
            <em>Populating</em> <strong>cache</strong> نیاز به دانش این دارد که چه
            <strong>fields</strong> در <strong>UI</strong> ارجاع داده می‌شوند؛ تغییرات در
            <strong>UI</strong> ممکن است نیاز به به‌روزرسانی تعریف این‌که چگونه
            <strong>cache</strong> <em>populated</em> شده است و بازسازی
            <strong>cache</strong> داشته باشد.
        </li>
    </ul>
    <p>
        تابع مشتق شده برای یک <strong>secondary index</strong> آن‌قدر معمولاً مورد
        نیاز است که در بسیاری از پایگاه‌های داده به‌عنوان یک
        <strong>feature</strong> اصلی ساخته شده است، و شما می‌توانید آن را با
        گفتن <strong>CREATE INDEX</strong> فراخوانی کنید. برای <strong>full-text
        indexing</strong>، ویژگی‌های زبانی پایه برای زبان‌های رایج ممکن است
        در یک پایگاه داده ساخته شوند، اما <strong>features</strong> پیچیده‌تر
        اغلب نیاز به تنظیم خاص <strong>domain</strong> دارند. در <strong>machine
        learning</strong>، <strong>feature engineering</strong> به‌طور مشهور
        مختص برنامه است، و اغلب باید دانش دقیقی در مورد تعامل
        کاربر و استقرار یک برنامه را در بر گیرد [35].
    </p>
    <p>
        وقتی تابعی که یک مجموعه‌داده مشتق شده را ایجاد می‌کند، یک تابع
        استاندارد مانند ایجاد یک <strong>secondary index</strong> نیست، کد سفارشی
        برای رسیدگی به جنبه‌های خاص برنامه مورد نیاز است. و این کد
        سفارشی جایی است که بسیاری از پایگاه‌های داده با مشکل مواجه
        هستند. اگرچه پایگاه‌های داده‌ی رابطه‌ای معمولاً از <strong>triggers</strong>،
        <strong>stored procedures</strong> و توابع تعریف شده توسط کاربر
        پشتیبانی می‌کنند، که می‌توان از آن‌ها برای اجرای کد برنامه در
        پایگاه داده استفاده کرد، اما آن‌ها تا حدودی یک تفکر ثانویه در طراحی
        پایگاه داده بوده‌اند (نگاه کنید به "انتقال جریان‌های رویداد" در صفحه
        440).
    </p>

    <h4>جداسازی کد برنامه و <strong>state</strong></h4>
    <p>
        از نظر تئوری، پایگاه‌های داده می‌توانند محیط‌های استقراری برای کد
        برنامه دلخواه باشند، مانند یک سیستم عامل. با این حال، در عمل آن‌ها
        تبدیل به
        <strong>Unbundling Databases</strong>
        |
        505
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>