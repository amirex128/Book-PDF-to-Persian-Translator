<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 464</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        آن را پر می‌کند، فرستنده مسدود می‌شود تا زمانی که گیرنده داده‌ها را از
        <strong>buffer</strong> خارج کند (نگاه کنید به "تراکم شبکه و صف‌بندی" در صفحه
        282).
    </p>
    <p>
        اگر پیام‌ها در یک صف <strong>buffered</strong> شوند، درک این‌که چه اتفاقی می‌افتد
        با بزرگ شدن آن صف، مهم است. آیا اگر صف دیگر در حافظه جا نشد، سیستم
        از کار می‌افتد، یا پیام‌ها را روی دیسک می‌نویسد؟ اگر چنین است، دسترسی
        به دیسک چگونه بر عملکرد سیستم پیام‌رسانی تأثیر می‌گذارد [6]؟
    </p>
    <ol>
        <li>
            چه اتفاقی می‌افتد اگر <strong>nodes</strong> از کار بیفتند یا موقتاً <em>offline</em>
            شوند—آیا هیچ پیامی از دست می‌رود؟ همانند پایگاه‌های داده، <em>durability</em>
            ممکن است به ترکیبی از نوشتن روی دیسک و/یا <strong>replication</strong> نیاز
            داشته باشد (به نوار کناری "<strong>Replication</strong> و <strong>Durability</strong>" در
            صفحه 227)، که هزینه‌ای دارد. اگر می‌توانید گاهی اوقات پیام‌ها را از
            دست بدهید، احتمالاً می‌توانید توان عملیاتی بالاتر و تأخیر کمتری را
            در همان سخت‌افزار دریافت کنید.
        </li>
    </ol>
    <p>
        پذیرفتن یا عدم پذیرفتن از دست رفتن پیام‌ها، بستگی زیادی به برنامه
        دارد. به عنوان مثال، با خوانش‌های حسگر و معیارها که به‌طور دوره‌ای
        منتقل می‌شوند، شاید یک نقطه داده‌ی از دست رفته گاه به گاه مهم
        نباشد، زیرا به هر حال یک مقدار به‌روز شده در مدت زمان کوتاهی بعد ارسال
        خواهد شد. با این حال، مراقب باشید که اگر تعداد زیادی پیام <em>dropped</em>
        شوند، ممکن است فوراً مشخص نشود که معیارها نادرست هستند [7]. اگر
        در حال شمارش رویدادها هستید، این مهم‌تر است که آن‌ها به‌طور قابل
        اطمینانی تحویل داده شوند، زیرا هر پیام از دست رفته به معنای
        شمارنده‌های نادرست است.
    </p>
    <p>
        یک ویژگی خوب سیستم‌های پردازش <strong>batch</strong> که ما در فصل 10 بررسی
        کردیم این است که آن‌ها یک تضمین قابلیت اطمینان قوی ارائه می‌دهند:
        <strong>tasks</strong> شکست‌خورده به‌طور خودکار دوباره امتحان می‌شوند، و خروجی
        جزئی از <strong>tasks</strong> شکست‌خورده به‌طور خودکار دور ریخته می‌شود. این بدان
        معنی است که خروجی یکسان است گویی هیچ شکستی رخ نداده است، که به
        ساده‌سازی مدل برنامه‌نویسی کمک می‌کند. در اواخر این فصل ما بررسی
        خواهیم کرد که چگونه می‌توانیم تضمین‌های مشابهی را در یک <strong>context</strong>
        <strong>streaming</strong> ارائه دهیم.
    </p>

    <h4>پیام‌رسانی مستقیم از <strong>producers</strong> به <strong>consumers</strong></h4>
    <p>
        تعدادی از سیستم‌های پیام‌رسانی از ارتباط شبکه مستقیم بین
        <strong>producers</strong> و <strong>consumers</strong> بدون عبور از طریق <strong>nodes</strong>
        واسطه استفاده می‌کنند:
    </p>
    <ul>
        <li>
            <strong>UDP multicast</strong> به‌طور گسترده در صنعت مالی برای جریان‌هایی مانند
            فیدهای بازار سهام استفاده می‌شود، که در آن تأخیر کم مهم است [8]. اگرچه
            خود <strong>UDP</strong> غیرقابل اعتماد است، پروتکل‌های سطح برنامه می‌توانند
            بسته‌های از دست رفته را بازیابی کنند (<strong>producer</strong> باید بسته‌هایی را
            که ارسال کرده است را به خاطر بسپارد تا بتواند آن‌ها را در صورت
            درخواست دوباره ارسال کند).
        </li>
        <li>
            کتابخانه‌های پیام‌رسانی بدون <strong>broker</strong> مانند <strong>ZeroMQ</strong> [9] و
            <strong>nanomsg</strong>، رویکردی مشابه اتخاذ می‌کنند و پیام‌رسانی
            انتشار/اشتراک را از طریق <strong>TCP</strong> یا <strong>IP multicast</strong> پیاده‌سازی
            می‌کنند.
        </li>
        <li>
            <strong>StatsD</strong> [10] و <strong>Brubeck</strong> [7] از پیام‌رسانی <strong>UDP</strong>
            غیرقابل اعتماد برای جمع‌آوری معیارها از تمام ماشین‌های موجود در
            شبکه و نظارت بر آن‌ها استفاده می‌کنند. (در پروتکل <strong>StatsD</strong>،
            معیارهای <strong>counter</strong> تنها در صورتی صحیح هستند که تمام پیام‌ها
            دریافت شوند؛ استفاده از <strong>UDP</strong>، معیارها را در بهترین حالت تقریبی
            می‌کند [11]. همچنین نگاه کنید به "<strong>TCP</strong> در مقابل <strong>UDP</strong>" در صفحه
            283.)
            442
            |
            فصل 11: پردازش <strong>Stream</strong>
        </li>
    </ul>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>