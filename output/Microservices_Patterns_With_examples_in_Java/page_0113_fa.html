<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 113</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h3>Communicating using the synchronous Remote procedure invocation pattern</h3>
  <p>
   سپس از یک الگوریتم <strong>load-balancing</strong>، مانند <strong>round-robin</strong> یا تصادفی، برای انتخاب یک
   نمونه سرویس استفاده می‌کند. سپس یک <strong>request</strong> را به یک نمونه سرویس منتخب ارسال می‌کند.
  </p>
  <p>
   <strong>service discovery</strong> در سطح اپلیکیشن توسط <strong>Netflix</strong> و <strong>Pivotal</strong> محبوب شده است. <strong>Netflix</strong>
   چندین مؤلفه را توسعه داده و <strong>open source</strong> کرده است: <strong>Eureka</strong>، یک <strong>service</strong> با <strong>high available</strong>
   <strong>registry</strong>، کلاینت <strong>Eureka Java</strong>، و <strong>Ribbon</strong>، یک کلاینت <strong>HTTP</strong> پیچیده که پشتیبانی می‌کند
   کلاینت <strong>Eureka</strong>. <strong>Pivotal</strong>، <strong>Spring Cloud</strong> را توسعه داد، یک فریم‌ورک مبتنی بر <strong>Spring</strong> که
   استفاده از اجزای <strong>Netflix</strong> را بسیار آسان می‌کند. سرویس‌های مبتنی بر <strong>Spring Cloud</strong>
   به طور خودکار با <strong>Eureka</strong> ثبت می‌شوند، و کلاینت‌های مبتنی بر <strong>Spring Cloud</strong> به طور خودکار
   از <strong>Eureka</strong> برای <strong>service discovery</strong> استفاده می‌کنند.
  </p>
  <p>
   یکی از مزایای <strong>service discovery</strong> در سطح اپلیکیشن این است که سناریو را مدیریت می‌کند
   هنگامی که سرویس‌ها بر روی چندین پلتفرم استقرار مستقر می‌شوند. به عنوان مثال، تصور کنید
   شما فقط برخی از سرویس‌ها را بر روی <strong>Kubernetes</strong> مستقر کرده‌اید، که در فصل 12 مورد بحث قرار گرفت، و
   بقیه در یک محیط قدیمی اجرا می‌شوند. <strong>service discovery</strong> در سطح اپلیکیشن با استفاده از
   به عنوان مثال، <strong>Eureka</strong>، در هر دو محیط کار می‌کند، در حالی که <strong>Kubernetes-based ser-</strong>
   <strong>vice discovery</strong> فقط در <strong>Kubernetes</strong> کار می‌کند.
  </p>
  <p>
   یک نقطه ضعف <strong>service discovery</strong> در سطح اپلیکیشن این است که شما به یک سرویس نیاز دارید
   کتابخانه <strong>discovery</strong> برای هر زبان - و احتمالاً فریم‌ورک - که استفاده می‌کنید. <strong>Spring</strong>
   <strong>Cloud</strong> فقط به توسعه‌دهندگان <strong>Spring</strong> کمک می‌کند. اگر شما از فریم‌ورک <strong>Java</strong> دیگری یا یک
   زبان غیر <strong>JVM</strong> مانند <strong>NodeJS</strong> یا <strong>GoLang</strong> استفاده می‌کنید، باید یک سرویس دیگر را پیدا کنید
   فریم‌ورک <strong>discovery</strong>. یکی دیگر از معایب <strong>service discovery</strong> در سطح اپلیکیشن این است که
   شما مسئول راه‌اندازی و مدیریت <strong>service registry</strong> هستید، که یک حواس‌پرتی است. به عنوان یک
   نتیجه، معمولاً بهتر است از یک مکانیسم <strong>service discovery</strong> استفاده کنید
   ارائه شده توسط زیرساخت استقرار.
  </p>
  <h4>APPLYING THE PLATFORM-PROVIDED SERVICE DISCOVERY PATTERNS</h4>
  <p>
   در ادامه در فصل 12 خواهید آموخت که بسیاری از پلتفرم‌های استقرار مدرن مانند
   <strong>Docker</strong> و <strong>Kubernetes</strong> دارای یک <strong>service registry</strong> داخلی و یک مکانیسم <strong>service discovery</strong> هستند.
   پلتفرم استقرار به هر سرویس یک نام <strong>DNS</strong>، یک آدرس <strong>IP</strong> مجازی (<strong>VIP</strong>) می‌دهد، و یک
   نام <strong>DNS</strong> که به آدرس <strong>VIP</strong> <strong>resolve</strong> می‌شود. یک کلاینت سرویس، یک
   <strong>request</strong> را به نام <strong>DNS/VIP</strong>، انجام می‌دهد و پلتفرم استقرار به‌طور خودکار <strong>request</strong> را مسیریابی می‌کند
   به یکی از نمونه‌های سرویس موجود. در نتیجه، ثبت سرویس،
   <strong>service discovery</strong> و مسیریابی <strong>request</strong>، کاملاً توسط پلتفرم استقرار مدیریت می‌شود.
   شکل 3.6 نحوه عملکرد این را نشان می‌دهد.
  </p>
  <p>
   پلتفرم استقرار شامل یک <strong>service registry</strong> است که آدرس‌های <strong>IP</strong> را ردیابی می‌کند
   سرویس‌های مستقر شده. در این مثال، یک کلاینت با استفاده از
   الگو: <strong>Client-side discovery</strong>
  </p>
  <p>
   یک کلاینت سرویس، فهرست نمونه‌های سرویس موجود را از <strong>service reg-</strong>
   <strong>istry</strong> بازیابی می‌کند و آنها را <strong>load balance</strong> می‌کند. به <strong>http://microservices.io/patterns/client-</strong>
   <strong>side-discovery.html</strong> مراجعه کنید.
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>