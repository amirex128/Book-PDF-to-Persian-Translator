<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 47</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>17</p>
  <p><strong>Benefits and drawbacks of the microservice architecture</strong></p>
  <p>در بسیاری از سازمان‌ها، محدود کردن انتخاب‌ها منطقی است، اما نکته کلیدی این است که شما توسط تصمیمات گذشته محدود نشده‌اید.
  </p>
  <p>
   علاوه بر این، از آنجایی که <strong>services</strong> کوچک هستند، بازنویسی آن‌ها با استفاده از زبان‌ها و فناوری‌های بهتر عملی می‌شود. اگر آزمایش یک فناوری جدید شکست بخورد، می‌توانید آن کار را بدون به خطر انداختن کل پروژه دور بریزید. این کاملاً متفاوت از زمانی است که از معماری <strong>monolithic</strong> استفاده می‌کنید، که در آن انتخاب‌های فناوری اولیه شما، توانایی شما را برای استفاده از زبان‌ها و فریم‌ورک‌های مختلف در آینده به شدت محدود می‌کند.
  </p>
  <p>1.5.2</p>
  <p><strong>Drawbacks of the microservice architecture</strong></p>
  <p>مطمئناً، هیچ فناوری گلوله نقره‌ای نیست و معماری <strong>microservice</strong> دارای تعدادی معایب و مشکلات مهم است. در واقع بیشتر این کتاب در مورد چگونگی پرداختن به این معایب و مسائل است. همانطور که در مورد چالش‌ها می‌خوانید، نگران نباشید. در ادامه این کتاب راه‌هایی برای رسیدگی به آن‌ها شرح می‌دهم.</p>
  <p>در اینجا معایب و مشکلات اصلی معماری <strong>microservice</strong> آمده است:</p>
  <ul>
   <li>
    یافتن مجموعه مناسبی از <strong>services</strong> یک چالش است.
   </li>
   <li>
    سیستم‌های توزیع شده پیچیده هستند، که توسعه، تست و استقرار را دشوار می‌کند.
   </li>
   <li>
    استقرار ویژگی‌هایی که چندین <strong>service</strong> را در بر می‌گیرند، به هماهنگی دقیق نیاز دارد.
   </li>
   <li>
    تصمیم‌گیری در مورد زمان اتخاذ معماری <strong>microservice</strong> دشوار است.
   </li>
  </ul>
  <p>بیایید به نوبه خود به هر یک نگاهی بیندازیم.</p>
  <p><strong>FINDING THE RIGHT SERVICES IS CHALLENGING</strong></p>
  <p>یک چالش در استفاده از معماری <strong>microservice</strong> این است که هیچ الگوریتم مشخص و خوش‌تعریفی برای تجزیه یک سیستم به <strong>services</strong> وجود ندارد. مانند بسیاری از توسعه <strong>software</strong>، این تا حدودی یک هنر است. برای بدتر کردن اوضاع، اگر یک سیستم را به اشتباه تجزیه کنید، یک <strong>monolith</strong> توزیع شده می‌سازید، سیستمی متشکل از <strong>services</strong> <strong>coupled</strong> که باید با هم مستقر شوند. یک <strong>monolith</strong> توزیع شده دارای معایب معماری <strong>monolithic</strong> و معماری <strong>microservice</strong> است.</p>
  <p><strong>DISTRIBUTED SYSTEMS ARE COMPLEX</strong></p>
  <p>یکی دیگر از مسائل مربوط به استفاده از معماری <strong>microservice</strong> این است که
   <strong>developers</strong> باید با پیچیدگی‌های اضافی ایجاد یک سیستم توزیع شده مقابله کنند. <strong>Services</strong> باید از یک مکانیزم ارتباط بین فرآیندی استفاده کنند. این پیچیده‌تر از یک فراخوانی متد ساده است. علاوه بر این، یک <strong>service</strong> باید طوری طراحی شود که از خرابی جزئی استفاده کند و با <strong>service</strong> از راه دور که یا در دسترس نیست یا تاخیر بالایی دارد، مقابله کند.</p>
  <p>
   پیاده‌سازی موارد استفاده که <strong>services</strong> متعددی را در بر می‌گیرند، نیازمند استفاده از تکنیک‌های ناآشنا است. هر <strong>service</strong> پایگاه داده خود را دارد، که پیاده‌سازی <strong>transactions</strong> و <strong>queries</strong> را که <strong>services</strong> را پوشش می‌دهند، به یک چالش تبدیل می‌کند. همانطور که در فصل 4 توضیح داده شد، یک <strong>application</strong> مبتنی بر
   <strong>microservices</strong> باید از آنچه به عنوان <strong>sagas</strong> شناخته می‌شود برای حفظ سازگاری داده‌ها در <strong>services</strong> استفاده کند. فصل 7 توضیح می‌دهد که یک <strong>application</strong> مبتنی بر <strong>microservices</strong> نمی‌تواند داده‌ها را از چندین <strong>service</strong> با استفاده از <strong>queries</strong> ساده بازیابی کند. در عوض، باید <strong>queries</strong> را با استفاده از ترکیب <strong>API</strong> یا
   <strong>CQRS views</strong> پیاده‌سازی کند.
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>