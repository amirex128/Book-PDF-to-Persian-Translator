86
CHAPTER 3
Interprocess communication in a microservice architecture
brokerless and broker-based architectures and describe the criteria for selecting a
message broker. I then discuss several important topics, including scaling consum-
ers while preserving message ordering, detecting and discarding duplicate messages,
and sending and receiving messages as part of a database transaction. Let’s begin by
looking at how messaging works.
3.3.1
Overview of messaging
A useful model of messaging is defined in the book Enterprise Integration Patterns
(Addison-Wesley Professional, 2003) by Gregor Hohpe and Bobby Woolf. In this
model, messages are exchanged over message channels. A sender (an application or
service) writes a message to a channel, and a receiver (an application or service) reads
messages from a channel. Let’s look at messages and then look at channels.
ABOUT MESSAGES
A message consists of a header and a message body (www.enterpriseintegrationpatterns
.com/Message.html). The header is a collection of name-value pairs, metadata that
describes the data being sent. In addition to name-value pairs provided by the mes-
sage’s sender, the message header contains name-value pairs, such as a unique message
id generated by either the sender or the messaging infrastructure, and an optional
return address, which specifies the message channel that a reply should be written to.
The message body is the data being sent, in either text or binary format.
 There are several different kinds of messages:
Document—A generic message that contains only data. The receiver decides how
to interpret it. The reply to a command is an example of a document message.
Command—A message that’s the equivalent of an RPC request. It specifies the
operation to invoke and its parameters.
Event—A message indicating that something notable has occurred in the sender.
An event is often a domain event, which represents a state change of a domain
object such as an Order, or a Customer.
The approach to the microservice architecture described in this book uses commands
and events extensively.
 Let’s now look at channels, the mechanism by which services communicate. 
ABOUT MESSAGE CHANNELS
As figure 3.7 shows, messages are exchanged over channels (www.enterpriseintegra-
tionpatterns.com/MessageChannel.html). The business logic in the sender invokes a
sending port interface, which encapsulates the underlying communication mechanism.
The sending port is implemented by a message sender adapter class, which sends a mes-
sage to a receiver via a message channel. A message channel is an abstraction of the
messaging infrastructure. A message handler adapter class in the receiver is invoked to
handle the message. It invokes a receiving port interface implemented by the consumer’s
 
