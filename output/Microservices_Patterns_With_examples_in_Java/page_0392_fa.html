<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 392</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h3><span style="font-weight: bold;">فصل 11</span></h3>
  <h3><span style="font-weight: bold;">Developing production-ready services</span></h3>
  <h4><span style="font-weight: bold;">11.2.1 Using push-based externalized configuration</span></h4>
  <p>
   The push model به collaboration از deployment environment و the
   service متکی است. The deployment environment configuration properties را فراهم می‌کند
   زمانی که یک service instance را ایجاد می‌کند. It might, as figure 11.7 shows، configuration prop-
   erties را به عنوان environment variables منتقل کند. Alternatively, the deployment environment ممکن است sup-
   ply the configuration properties با استفاده از یک configuration file. The service instance سپس
   configuration properties را زمانی که راه‌اندازی می‌شود، می‌خواند.
  </p>
  <p>
   The deployment environment و the service باید در مورد نحوه configuration
   properties توافق داشته باشند. The precise mechanism به specific deployment
   environment بستگی دارد. For example, فصل 12 نحوه مشخص کردن environment را توضیح می‌دهد
   variables از یک Docker container.
  </p>
  <p>
   Let’s imagine که شما تصمیم گرفته‌اید تا externalized configuration property
   values با استفاده از environment variables ارائه دهید. Your application می‌تواند System.getenv() را فراخوانی کند
   to obtain their values. But if you’re a Java developer، احتمالاً شما از یک frame-
   work استفاده می‌کنید که یک mechanism راحت‌تر ارائه می‌دهد. The FTGO services با استفاده از
   Spring Boot ساخته شده‌اند، که یک extremely flexible externalized configuration mechanism دارد
   که configuration properties را از منابع مختلف با pre-defined well-
   cedence rules بازیابی می‌کند (https://docs.spring.io/spring-boot/docs/current/reference/html/boot-
   features-external-config.html). Let’s look at how it works.
  </p>
  <p>
   Spring Boot properties را از منابع مختلف می‌خواند. I find the following sources
   useful در یک microservice architecture:
  </p>
  <p>
   Order
   History Service
   instance
   Process
   Environment variables
   Deployment
   infrastructure
   Conﬁgures
   Creates
   Reads
   BOOTSTRAP_SERVERS=kafka1:9092
   AWS_ACCESS_KEY_ID=
   AWS_SECRET_ACCESS_KEY=...
   AWS_REGION=...
   ....
  </p>
  <p>
   Figure 11.7
   When the deployment infrastructure یک instance از Order History ایجاد می‌کند
   Service, it sets the environment variables حاوی externalized configuration. Order
   History Service این environment variables را می‌خواند.
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>