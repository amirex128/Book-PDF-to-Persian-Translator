<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 75</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>45</p>
  <p>فصل 2</p>
  <p><strong>Decomposition strategies</strong></p>
  <p>تا حد انتزاعی‌تر عملیات سیستم. یک عملیات سیستم، انتزاعی از یک درخواست است که <strong>application</strong> باید آن را مدیریت کند. این یا یک دستور است که داده‌ها را به‌روزرسانی می‌کند، یا یک <strong>query</strong> که داده‌ها را بازیابی می‌کند. رفتار هر دستور بر اساس یک مدل <strong>domain</strong> انتزاعی تعریف می‌شود، که از الزامات نیز مشتق شده است. عملیات سیستم به سناریوهای معماری تبدیل می‌شوند که نحوه همکاری <strong>services</strong> را نشان می‌دهند.</p>
  <p>قدم دوم در این فرآیند، تعیین تجزیه به <strong>services</strong> است. استراتژی‌های متعددی برای انتخاب وجود دارد. یک استراتژی، که منشأ آن در رشته معماری کسب‌وکار است، تعریف <strong>services</strong> متناظر با قابلیت‌های کسب‌وکار است. استراتژی دیگر این است که <strong>services</strong> را حول زیر دامنه‌های طراحی مبتنی بر <strong>domain</strong> (<strong>DDD</strong>) سازماندهی کنید. نتیجه نهایی <strong>services</strong> است که حول مفاهیم کسب‌وکار سازماندهی شده‌اند نه مفاهیم فنی.</p>
  <p>قدم سوم در تعریف معماری <strong>application</strong>، تعیین <strong>API</strong> هر <strong>service</strong> است. برای انجام این کار، شما هر عملیات سیستمی را که در مرحله اول شناسایی شده است، به یک <strong>service</strong> اختصاص می‌دهید. یک <strong>service</strong> ممکن است یک عملیات را به طور کامل خود پیاده‌سازی کند. از طرف دیگر، ممکن است نیاز به همکاری با <strong>services</strong> دیگر داشته باشد. در این صورت، شما تعیین می‌کنید که چگونه <strong>services</strong> با هم همکاری می‌کنند، که معمولاً نیاز به پشتیبانی <strong>services</strong> از عملیات اضافی دارد.
   همچنین باید تصمیم بگیرید که از کدام یک از مکانیسم‌های <strong>IPC</strong> که در فصل 3 توضیح می‌دهم، برای پیاده‌سازی <strong>API</strong> هر <strong>service</strong> استفاده کنید.
  </p>
  <p>چندین مانع برای تجزیه وجود دارد. اولین مورد، تأخیر شبکه است. ممکن است متوجه شوید که یک تجزیه خاص به دلیل رفت و برگشت‌های زیاد بین <strong>services</strong>، غیرعملی است. مانع دیگر برای تجزیه این است که ارتباط همزمان بین <strong>services</strong>، در دسترس بودن را کاهش می‌دهد. ممکن است لازم باشد از مفهوم <strong>services</strong> خود-محصور، که در فصل 3 توضیح داده شده است، استفاده کنید. مانع سوم، نیاز به حفظ سازگاری داده‌ها در <strong>services</strong> است. شما معمولاً باید از <strong>sagas</strong>، که در فصل 4 مورد بحث قرار می‌گیرند، استفاده کنید. مانع چهارم و نهایی برای تجزیه، کلاس‌های به اصطلاح <strong>god</strong> هستند، که در سراسر یک <strong>application</strong> استفاده می‌شوند. خوشبختانه، شما می‌توانید از مفاهیم طراحی مبتنی بر دامنه برای حذف کلاس‌های
   <strong>god</strong> استفاده کنید.
  </p>
  <p>این بخش ابتدا نحوه شناسایی عملیات یک <strong>application</strong> را توضیح می‌دهد. پس از آن، ما به استراتژی‌ها و دستورالعمل‌هایی برای تجزیه یک <strong>application</strong> به <strong>services</strong> و موانع تجزیه و نحوه رسیدگی به آن‌ها نگاهی خواهیم انداخت. در نهایت، نحوه تعریف <strong>API</strong> هر <strong>service</strong> را توضیح خواهم داد.</p>
  <p>2.2.1</p>
  <p><strong>Identifying the system operations</strong></p>
  <p>اولین قدم در تعریف معماری یک <strong>application</strong>، تعریف عملیات سیستم است. نقطه شروع، الزامات <strong>application</strong>، از جمله داستان‌های کاربر و سناریوهای کاربری مرتبط با آن‌ها (توجه داشته باشید که این‌ها با سناریوهای معماری متفاوت هستند) است. عملیات سیستم با استفاده از فرآیند دو مرحله‌ای نشان داده شده در شکل 2.6 شناسایی و تعریف می‌شوند. این فرآیند از فرآیند طراحی شی گرا در کتاب
   <strong>Applying UML and Patterns (Prentice Hall, 2004)</strong> اثر <strong>Craig Larman</strong> الهام گرفته شده است (به www.craiglarman.com/wiki/index.php?title=Book_Applying_UML_and_Patterns برای جزئیات مراجعه کنید). اولین گام، مدل <strong>domain</strong> سطح بالا را ایجاد می‌کند که شامل کلاس‌های کلیدی است
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>