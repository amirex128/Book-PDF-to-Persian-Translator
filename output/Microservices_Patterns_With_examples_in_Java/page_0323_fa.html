<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 323</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h3>Testing microservices:</h3>
  <p>
   write automated tests به عنوان بخشی از توسعه. این امر، بهره‌وری آنها را بهبود می‌بخشد، زیرا، به عنوان مثال، آنها تست هایی خواهند داشت که بازخورد فوری را در هنگام ویرایش کد ارائه می‌دهند.
  </p>
  <p>
   از این نظر، FTGO یک سازمان کاملاً معمولی است. گزارش Sauce Labs Testing Trends در سال 2018 یک تصویر کاملاً تیره از وضعیت test automation را ترسیم می‌کند (https://saucelabs.com/resources/white-papers/testing-trends-for-2018). این گزارش نحوه خودکار بودن تنها 26٪ از سازمان‌ها را عمدتاً توضیح می‌دهد و 3٪ ناچیز کاملاً خودکار هستند!
  </p>
  <p>
   اتکا به manual testing به دلیل کمبود tooling و frameworks نیست.
   به عنوان مثال، JUnit، یک فریم‌ورک testing محبوب جاوا، اولین بار در سال 1998 منتشر شد.
   دلیل عدم وجود automated tests، عمدتاً فرهنگی است: "Testing، کار QA است"، "این بهترین استفاده از زمان یک developers نیست" و غیره. همچنین کمک نمی‌کند که توسعه یک مجموعه تست سریع، اما مؤثر و قابل نگهداری چالش برانگیز باشد. و، یک application monolithic بزرگ و معمولی، آزمایش آن بسیار دشوار است.
  </p>
  <p>
   یکی از انگیزه های کلیدی برای استفاده از معماری microservice، همانطور که در فصل 2 توضیح داده شد، بهبود testability است. با این حال، در عین حال، پیچیدگی معماری microservice، ایجاب می‌کند که شما automated tests بنویسید. علاوه بر این، برخی از جنبه‌های testing microservices چالش‌برانگیز هستند. این به این دلیل است که ما باید تأیید کنیم که service ها می‌توانند به درستی تعامل داشته باشند و در عین حال تعداد end-to-end-tests های slow، complex و unreliable را که service های زیادی را راه‌اندازی می‌کنند، به حداقل برسانیم.
  </p>
  <p>
   این فصل اولین فصل از دو فصل در مورد testing است. این یک مقدمه برای testing است. فصل 10 مفاهیم testing پیشرفته‌تر را پوشش می‌دهد. این دو فصل طولانی هستند، اما با هم، ایده‌ها و تکنیک‌های testing را پوشش می‌دهند که به طور کلی برای توسعه نرم‌افزار مدرن و به ویژه برای معماری microservice ضروری هستند.
  </p>
  <p>
   من این فصل را با توصیف استراتژی‌های testing مؤثر برای یک application مبتنی بر microservices شروع می‌کنم. این استراتژی‌ها شما را قادر می‌سازند تا مطمئن شوید که نرم‌افزار شما کار می‌کند، در حالی که complexity و زمان اجرا تست را به حداقل می‌رساند. پس از آن، من نحوه نوشتن یک نوع خاص از تست را برای service های شما شرح می‌دهم: unit tests. فصل 10 انواع دیگر تست ها را پوشش می‌دهد: integration، component و end-to-end.
  </p>
  <p>
   بیایید با نگاهی به استراتژی‌های testing برای microservices شروع کنیم.
  </p>
  <p>
   Why an introduction to testing?
  </p>
  <p>
   ممکن است تعجب کنید که چرا این فصل شامل مقدمه‌ای بر مفاهیم testing اساسی است. اگر قبلاً با مفاهیمی مانند test pyramid و انواع مختلف تست ها آشنا هستید، در این فصل سرعت خواندن خود را افزایش دهید و به فصل بعدی بروید، که بر موضوعات testing مخصوص microservices تمرکز دارد. اما بر اساس تجربیات من در مشاوره و آموزش client ها در سراسر جهان، یک ضعف اساسی بسیاری از سازمان‌های توسعه نرم‌افزار، عدم وجود automated testing است. این به این دلیل است که اگر می‌خواهید نرم‌افزار را سریع و مطمئن ارائه دهید، انجام automated testing کاملاً ضروری است. این تنها راه برای داشتن یک lead time کوتاه است که مدت زمانی است که طول می‌کشد تا کد committed شده را وارد production کنید. شاید مهم‌تر از آن، automated testing ضروری است زیرا شما را مجبور می‌کند یک application testable را توسعه دهید. معرفی automating testing در یک application از قبل بزرگ و complex، معمولاً بسیار دشوار است. به عبارت دیگر، مسیر سریع به monolithic hell، ننوشتن automated tests است.
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>