<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 76</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>46</p>
  <p>فصل 2</p>
  <p><strong>Decomposition strategies</strong></p>
  <p>عملیات سیستم را مشخص می‌کند. <strong>API</strong>، این عملیات را فراهم می‌کند. و یا مثال هایی را در خصوص ایجاد <strong>API</strong> می زند</p>
  <p>به منظور نشان دادن آنچه این بخش در بر دارد، ابتدا نشان می‌دهد که چگونه یک <strong>application</strong> <strong>operations</strong> را شناسایی کنید. پس از آن، ما به استراتژی‌ها و دستورالعمل‌هایی برای تجزیه یک <strong>application</strong> به <strong>services</strong> و موانع تجزیه و چگونگی رسیدگی به آن‌ها نگاهی خواهیم انداخت. در نهایت، نحوه تعریف <strong>API</strong> هر <strong>service</strong> را توضیح خواهم داد.</p>
  <p>2.2.1</p>
  <p><strong>Identifying the system operations</strong></p>
  <p>اولین قدم در تعریف معماری یک <strong>application</strong>، تعریف عملیات سیستم است. نقطه شروع، الزامات <strong>application</strong>، از جمله داستان‌های کاربر و سناریوهای کاربری مرتبط با آن‌ها است (توجه داشته باشید که این‌ها با سناریوهای معماری متفاوت هستند). عملیات سیستم با استفاده از فرآیند دو مرحله‌ای نشان داده شده در شکل 2.6 شناسایی و تعریف می‌شوند. این فرآیند از فرآیند طراحی شی گرا در کتاب
   <strong>Applying UML and Patterns (Prentice Hall, 2004)</strong> اثر
   <strong>Craig Larman</strong> الهام گرفته شده است (برای جزئیات به
   <a href="www.craiglarman.com/wiki/index.php?title=Book_Applying_UML_and_Patterns">www.craiglarman.com/wiki/index.php?title=Book_Applying_UML_and_Patterns</a> مراجعه کنید). اولین گام، مدل <strong>domain</strong> سطح بالا را ایجاد می‌کند.
  </p>
  <p>این مدل <strong>domain</strong>، عمدتاً از اسم‌های داستان‌های کاربر مشتق می‌شود، و عملیات سیستم عمدتاً از فعل‌ها مشتق می‌شود. شما همچنین می‌توانید مدل <strong>domain</strong> را با استفاده از تکنیکی به نام <strong>Event Storming</strong> تعریف کنید، که در فصل 5 در مورد آن صحبت خواهم کرد.</p>
  <p>رفتار هر عملیات سیستم بر اساس تأثیر آن بر یک یا چند <strong>domain objects</strong> و روابط بین آن‌ها توصیف می‌شود. یک عملیات سیستم می‌تواند
   <strong>domain objects</strong> را ایجاد، به‌روزرسانی یا حذف کند، و همچنین روابط بین آن‌ها را ایجاد یا از بین ببرد.
  </p>
  <p>بیایید نگاهی بیندازیم که چگونه یک مدل <strong>domain</strong> سطح بالا را تعریف کنیم. پس از آن، عملیات سیستم را بر اساس مدل <strong>domain</strong> تعریف خواهم کرد.</p>
  <p><strong>CREATING A HIGH-LEVEL DOMAIN MODEL</strong></p>
  <p>اولین قدم در فرآیند تعریف عملیات سیستم، ترسیم یک مدل <strong>domain</strong> سطح بالا برای <strong>application</strong> است. توجه داشته باشید که این مدل <strong>domain</strong> بسیار ساده‌تر از چیزی است که در نهایت پیاده‌سازی خواهد شد. <strong>application</strong> حتی یک مدل <strong>domain</strong> واحد نخواهد داشت زیرا، همانطور که به زودی خواهید آموخت، هر <strong>service</strong> مدل <strong>domain</strong> خود را دارد. علیرغم اینکه یک ساده‌سازی شدید است، یک مدل <strong>domain</strong> سطح بالا در این مرحله مفید است زیرا واژگان را برای توصیف رفتار عملیات سیستم تعریف می‌کند.
  </p>
  <p>یک مدل <strong>domain</strong> با استفاده از تکنیک‌های استاندارد مانند تجزیه و تحلیل اسم‌ها در داستان‌ها و سناریوها و صحبت با متخصصان <strong>domain</strong> ایجاد می‌شود. به عنوان مثال،</p>
  <p>الزامات عملکردی</p>
  <p><strong>FTGO</strong></p>
  <p>به عنوان یک مصرف‌کننده</p>
  <p>من می‌خواهم یک سفارش ثبت کنم</p>
  <p>بنابراین من می‌توانم ...</p>
  <p><strong>createOrder()</strong></p>
  <p><strong>acceptOrder()</strong></p>
  <p>به عنوان یک رستوران</p>
  <p>من می‌خواهم یک سفارش را بپذیرم</p>
  <p>بنابراین من می‌توانم ...</p>
  <p>مرحله 2</p>
  <p>مدل <strong>domain</strong> سطح بالا</p>
  <p>مرحله 1</p>
  <p>سفارش</p>
  <p>نقشه به</p>
  <p>عملیات سیستم بر اساس مدل <strong>domain</strong> تعریف می‌شوند.</p>
  <p>مدل <strong>domain</strong> مشتق شده از</p>
  <p>الزامات</p>
  <p>رستوران</p>
  <p>تحویل</p>
  <p>شکل 2.6</p>
  <p>عملیات سیستم از الزامات <strong>application</strong> با استفاده از یک فرآیند دو مرحله‌ای مشتق شده‌اند. اولین قدم ایجاد یک مدل <strong>domain</strong> سطح بالا است. قدم دوم تعریف عملیات سیستم است که بر اساس مدل <strong>domain</strong> تعریف شده‌اند.</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>