INDEX
483
messaging. See Asynchronous messaging pattern
Messaging style patterns. See Asynchronous messag-
ing pattern
metrics collection 262
Micro framework 380
micrometer-registry-prometheus library 375
microservice architecture 8–14, 34, 43
as form of modularity 11–12
benefits of 14–17
continuous delivery and deployment of large, 
complex applications 15
fault isolation improvement 16
independently scalable services 16
new technology experimentation and 
adoption 16–17
small, easily maintained services 15
defining 44–64
decomposition guidelines 56–57
defining service APIs 61–64
identifying system operations 45–50
obstacles to decomposing an application into 
services 57–61
service definition with Decompose by business 
capability pattern 51–54
service definition with Decompose by sub-
domain pattern 54–55
drawbacks of 17–19
adoption timing 18–19
challenge of finding right services 17
complex distributed systems 17–18
deployment coordination 18
each service has own database 12
FTGO application 12–13
loose coupling, defined 42–43
not silver bullet 19–20
relationships between process, organization, 
and 29–32
human side of adopting microservices
31–32
software development and delivery 
organization 29–30
software development and delivery 
process 30–31
relative unimportance of size of service 43
role of shared libraries 43
scale cube 8–11
X-axis scaling 9
Y-axis scaling 10–11
Z-axis scaling 9–10
service-oriented architecture versus 13–14
services, defined 41–42
software architecture 34–37
4+1 view model of 35–37
definition of 35
relevance of 37
transaction management 111–117
maintaining data consistency 114–117
need for distributed transactions 112
trouble with distributed transactions 112–114
Microservice chassis pattern 28, 378–382
service meshes 380–382
using 379–380
MINOR part, Semvers 70
Mixer 409
Mobile API module 264
Mockito 305
mocks 296
modularity, microservice architecture as form 
of 11–12
Mono abstraction 277
monolithic architecture 1–32, 40
benefits of 4
causes of monolithic hell 4–7
intimidation due to complexity 4–5
long and arduous path from commit to 
deployment 5–6
reliability challenges 6
scaling challenges 6
slow development 5
technology stack obsolescence 6–7
FTGO monolithic architecture 3–4
multiply() method 310
MyBATIS 185
N
Netflix Falcor 281
Netflix Hystrix 79
Netflix Zuul 273
Netflix, as API gateway 267–268
network latency 57
network timeouts 79
NodePort service 406
nodes 280, 400
nonblocking I/O 268
nonfunctional requirements 8
non-key attributes 246
NoSQL-based event store
creating saga orchestrator when using 211–212
idempotent message processing when using 197
SQL versus 237–238
notePickedUp() method 250
O
O/R (Object-Relational) impedance 
mismatch 185–186, 200
OAuth 2.0 protocol 357–360
object-oriented design pattern 20
object-oriented programming (OOP) 149
 
