<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 20</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h3><mark>PREFACE</mark></h3>
  <p>
   به وضوح، این application به سرعت از معماری monolith خود فراتر رفته بود، اما چه
   جایگزینی وجود داشت؟ پاسخ مدتی در جامعه software در شرکت‌هایی مانند eBay و Amazon
   وجود داشت. به عنوان مثال، Amazon
   مهاجرت از monolith را در حدود سال 2002 آغاز کرد
   (
   <a
    href="https://plus.google.com/110981030061712822816/posts/AaygmbzVeRq"
    target="_blank"
   >
    https://plus.google.com/110981030061712822816/
    posts/AaygmbzVeRq
   </a>
   ). معماری جدید، monolith را با مجموعه‌ای از
   loosely coupled services جایگزین کرد. Services توسط چیزی که Amazon آن را two-pizza
   teams می‌نامد، متعلق به آن هستند—تیم‌هایی به اندازه کافی کوچک که با دو پیتزا تغذیه
   شوند.
  </p>
  <p>
   Amazon این معماری را برای تسریع سرعت توسعه software اتخاذ کرده بود تا شرکت
   بتواند سریع‌تر نوآوری کند و به طور موثرتری رقابت کند. نتایج چشمگیر است: طبق گزارش‌ها،
   Amazon هر 11.6 ثانیه تغییراتی را در production پیاده‌سازی می‌کند!
  </p>
  <p>
   در اوایل سال 2010، پس از اینکه به پروژه‌های دیگری منتقل شدم، آینده معماری
   software سرانجام با من همگام شد. در آن زمان بود که کتاب The Art of Scalability:
   Scalable Web Architecture, Processes, and Organizations for the Modern Enterprise
   (Addison-Wesley Professional, 2009) نوشته Michael T. Fisher و Martin L. Abbott
   را خواندم. یک ایده کلیدی در آن کتاب، scale cube است که، همانطور که در فصل 2
   توضیح داده شده است، یک مدل سه بعدی برای مقیاس‌بندی یک application است. مقیاس‌بندی
   محور Y که توسط scale cube تعریف شده است، یک application را به صورت functional به
   services تجزیه می‌کند. در گذشته، این کاملاً واضح بود، اما برای من در آن زمان، یک لحظه
   a-ha بود! من می‌توانستم چالش‌هایی را که دو سال قبل با آن مواجه بودم با
   architecting Cloud Foundry به عنوان مجموعه‌ای از services حل کنم!
  </p>
  <p>
   در آوریل 2012، اولین سخنرانی خود را در مورد این رویکرد معماری ارائه دادم، با عنوان
   “Decomposing Applications of Deployability and Scalability”
   (
   <a href="www.slideshare.net/chris.e.richardson/decomposing-applications-for-scalability-and-deployability-april-2012" target="_blank">www.slideshare.net/chris.e.richardson/decomposing-applications-for-scalability-and-deployability-april-2012</a>
   ). در آن زمان، اصطلاحاً
   accepted برای این نوع معماری وجود نداشت. من گاهی اوقات آن را modular، polyglot
   architecture می‌نامیدم، زیرا services می‌توانستند به زبان‌های مختلف نوشته شوند.
  </p>
  <p>
   اما در مثالی دیگر از اینکه چگونه آینده به طور نامساوی توزیع شده است، اصطلاح
   microservice در یک کارگاه معماری software در سال 2011 برای توصیف این نوع
   architecture استفاده شد
   (
   <a href="https://en.wikipedia.org/wiki/Microservices" target="_blank">https://en.wikipedia.org/wiki/Microservices</a>
   ).
   من اولین بار این اصطلاح را زمانی شنیدم که Fred George در Oredev 2013 سخنرانی
   کرد و آن را دوست داشتم!
  </p>
  <p>
   در ژانویه 2014، وب‌سایت
   <a href="https://microservices.io" target="_blank">https://microservices.io</a>
   را برای مستندسازی الگوهای architecture و design که با آن مواجه شده بودم، ایجاد
   کردم. سپس در مارس 2014، James Lewis و Martin Fowler یک پست وبلاگ در مورد
   microservices منتشر کردند (
   <a href="https://martinfowler.com/articles/microservices.html" target="_blank">https://martinfowler.com/articles/microservices.html</a>
   ). با popularizing اصطلاح microservices، پست وبلاگ باعث شد تا جامعه software حول
   این مفهوم متمرکز شود.
  </p>
  <p>
   ایده teams کوچک و loosely coupled که به سرعت و به طور قابل اعتماد
   microservices را توسعه و ارائه می‌دهند، به آرامی در حال انتشار در جامعه software
   است. اما احتمالاً این vision از آینده با واقعیت روزانه شما بسیار متفاوت است. امروزه،
   business-critical enterprise applications معمولاً monoliths بزرگی هستند که توسط
   تیم‌های بزرگ توسعه یافته‌اند. releases از software به ندرت اتفاق می‌افتد و اغلب برای
   همه افراد درگیر دردناک است. IT اغلب برای همگام شدن با نیازهای business تلاش
   می‌کند. شما می‌پرسید چگونه می‌توانید معماری microservice را اتخاذ کنید.
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>