<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 465</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h2><strong>Strategies for refactoring a monolith to microservices</strong></h2>
  <p>
   چند فیلد و متد به یک کلاس موجود. یا ممکن است feature جدید خیلی تنگ
   به کد در monolith متصل شود. اگر شما سعی کردید این نوع fea-
   ture را به عنوان یک service پیاده‌سازی کنید، معمولاً متوجه می‌شوید که performance به دلیل
   interprocess communication بیش از حد، آسیب می‌بیند. همچنین ممکن است در حفظ مشکل داشته باشید
   data consistency. اگر یک feature جدید نمی‌تواند به عنوان یک service پیاده‌سازی شود، راه‌حل این است
   اغلب برای پیاده‌سازی اولیه feature جدید در monolith. بعداً، شما می‌توانید آن feature را به همراه سایر featuresهای مرتبط به service خودشان استخراج کنید.
  </p>
  <p>
   پیاده‌سازی features جدید به عنوان servicesها، توسعه آن fea-
   turesها را سرعت می‌بخشد. این یک راه خوب برای نشان دادن سریع ارزش microservice architec-
   ture است. همچنین نرخ رشد monolith را کاهش می‌دهد. اما در نهایت، شما نیاز دارید که
   monolith را با استفاده از دو استراتژی دیگر جدا کنید. شما نیاز دارید که functionality را به
   strangler application با استخراج functionality از monolith به servicesها مهاجرت دهید.
   شما همچنین ممکن است بتوانید velocity توسعه را با تقسیم monolith hor-
   izontally بهبود بخشید. بیایید نگاهی به نحوه انجام این کار بیندازیم.
  </p>
  <p>
   Monolith
   <br/>
   Outbound
   <br/>
   adapter
   <br/>
   API gateway
   <br/>
   Old features
   <br/>
   New features
   <br/>
   Integration
   <br/>
   glue
   <br/>
   Inbound
   <br/>
   adapter
   <br/>
   Inbound
   <br/>
   adapter
   <br/>
   Database
   <br/>
   adapter
   <br/>
   Database
   <br/>
   adapter
   <br/>
   Inbound
   <br/>
   adapter
   <br/>
   Event
   <br/>
   subscriber
   <br/>
   adapter
   <br/>
   Event
   <br/>
   publisher
   <br/>
   adapter
   <br/>
   Service
   <br/>
   database
   <br/>
   Monolith
   <br/>
   database
   <br/>
   «aggregate»
   <br/>
   DelayedDelivery
   <br/>
   Service
   <br/>
   «aggregate»
   <br/>
   Order
   <br/>
   «aggregate»
   <br/>
   Notification
   <br/>
   Service
   <br/>
   implementing
   <br/>
   new feature
  </p>
  <p>
   <strong>Figure 13.2</strong>
   <br/>
   A new feature is implemented as a service that’s part of the strangler application. The
   integration glue integrates the service with the monolith and consists of adapters that implement
   synchronous and asynchronous APIs. An API gateway routes requests that invoke new functionality
   to the service.
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>