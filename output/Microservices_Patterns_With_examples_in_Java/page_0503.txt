473
index
Numerics
2PC (two-phase commit) 112
3rd party registration pattern 84–85, 108
4+1 view model of software architecture 35–37
500 status code, HTTP 367
A
AbstractAutowiringHttpRequestHandler class 423
AbstractHttpHandler class 423
accept() method 165, 172
acceptance tests 335–338
defining 336
executing specifications using Cucumber 338
writing using Gherkin 337–338
acceptOrder() method 460
Access Token 28, 354, 357
ACD (Atomicity, Consistency, Durability) 111
ACID (Atomicity, Consistency, Isolation, Dur-
ability) transactions 98, 110
ACLs (access control lists) 350
ActiveMQ message broker 92
add() method 310
addOrder() method 249–250
AggregateRepository class 206–208
aggregates 147, 374, 439
consistency boundaries 155
creating, finding, and updating 207–208
defining aggregate commands 207
defining with ReflectiveMutableCommand-
ProcessingAggregate class 206–207
designing business logic with 159–160
event sourcing
aggregate history 186, 199–200
aggregate methods and events 189–191
event sourcing-based Order aggregate
191–193
persisting aggregates using events 186–188
event sourcing and aggregate history 199–200
explicit boundaries 154–155
granularity 158
identifying 155
Order aggregate 175–180
methods 177–180
state machine 176–177
structure of 175–176
rules for 155–157
Ticket aggregate 169–173
behavior of 170–171
KitchenService domain service 171–172
KitchenServiceCommandHandler class
172–173
structure of Ticket class 170
traditional persistence and aggregate 
history 186
aliases 285
Alternative pattern 22
AMI (Amazon Machine Image) 390
anomalies 126
Anti-corruption layer pattern 447
AOP (aspect-oriented programming) 373, 378
Apache Flume 370
Apache Kafka 92
Apache Openwhisk 416
Apache Shiro 351
API composition pattern 221–228
benefits and drawbacks of 227–228
increased overhead 227
lack of transactional data consistency
228
risk of reduced availability 227–228
 
