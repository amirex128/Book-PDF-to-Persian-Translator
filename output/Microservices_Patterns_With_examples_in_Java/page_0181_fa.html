<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 181</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h3><strong>Business logic organization patterns (الگوهای سازماندهی منطق تجاری)</strong></h3>
  <p>همانند الگوی Transaction script (اسکریپت تراکنش)، یک کلاس OrderService (سرویس سفارش) دارای یک متد برای هر request (درخواست) / system operation (عملیات سیستم) است. اما هنگام استفاده از الگوی Domain model (مدل دامنه)، متدهای service (سرویس) معمولاً ساده هستند. به این دلیل که یک متد service (سرویس) تقریباً همیشه به persistent domain objects (اشیاء دامنه پایدار) واگذار می‌شود، که بخش عمده business logic (منطق تجاری) را در خود دارند. یک متد service (سرویس) ممکن است، به عنوان مثال، یک object (شی) domain (دامنه) را از database (پایگاه داده) بارگیری کند و یکی از متدهای آن را فراخوانی کند. در این مثال، کلاس Order (سفارش) هم state (حالت) و هم رفتار را دارد. علاوه بر این، state (حالت) آن خصوصی است و فقط می‌تواند به طور غیرمستقیم از طریق متدهای آن دسترسی داشته باشد.</p>
  <p>استفاده از یک design (طراحی) object-oriented (شی‌گرا) دارای تعدادی مزیت است. اول، design (طراحی) آسان است برای درک و نگهداری. به جای تشکیل یک کلاس بزرگ که همه کارها را انجام می‌دهد، از تعدادی کلاس کوچک تشکیل شده است که هر کدام تعداد کمی مسئولیت دارند. علاوه بر این، کلاس‌هایی مانند Account (حساب)، BankingTransaction (تراکنش بانکی)، و OverdraftPolicy (سیاست اضافه‌برداشت) از دنیای واقعی تقلید می‌کنند، که نقش آنها را در design (طراحی) آسان‌تر می‌کند. دوم، design (طراحی) object-oriented (شی‌گرا) ما آسان‌تر است برای تست (آزمایش): هر کلاس می‌تواند و باید به طور مستقل آزمایش شود. در نهایت، یک design (طراحی) object-oriented (شی‌گرا) آسان‌تر است برای گسترش زیرا می‌تواند از الگوهای طراحی شناخته شده، مانند الگوی Strategy (استراتژی) و الگوی Template method (متد الگو) استفاده کند، که راه‌هایی را برای گسترش یک component (کامپوننت) بدون تغییر کد، تعریف می‌کنند.</p>
  <p>الگوی Domain model (مدل دامنه) به خوبی کار می‌کند، اما مشکلاتی با این رویکرد وجود دارد، به ویژه در یک microservice (ریز سرویس) architecture (معماری ریز سرویس). برای رسیدگی به این مشکلات، شما باید از یک refinement (اصلاحیه) از OOD (طراحی شی‌گرا) که به عنوان DDD (طراحی مبتنی بر دامنه) شناخته می‌شود، استفاده کنید.</p>
  <h4><strong>5.1.3 About Domain-driven design (درباره طراحی مبتنی بر دامنه)</strong></h4>
  <p>DDD، که در کتاب Domain-Driven Design (طراحی مبتنی بر دامنه) توسط Eric Evans (اریک ایوانز) (Addison-Wesley Professional, 2003) شرح داده شده است، یک refinement (اصلاحیه) از OOD (طراحی شی‌گرا) است و یک رویکرد برای توسعه business logic (منطق تجاری) پیچیده است. من DDD را در فصل 2 هنگام بحث در مورد مفید بودن subdomains (زیر دامنه‌ها) DDD هنگام تجزیه یک application (برنامه) به services (سرویس‌ها) معرفی کردم. هنگام استفاده از DDD، هر service (سرویس) model (مدل) domain (دامنه) خود را دارد، که از مشکلات یک model (مدل) domain (دامنه) واحد در سطح application (برنامه) جلوگیری می‌کند. Subdomains (زیر دامنه‌ها) و مفهوم مرتبط Bounded Context (متن محدود) دو مورد از الگوهای استراتژیک DDD (طراحی مبتنی بر دامنه) هستند.</p>
  <p>DDD همچنین دارای برخی الگوهای تاکتیکی است که building blocks (بلوک‌های سازنده) برای domain models (مدل‌های دامنه) هستند. هر الگو یک role (نقش) است که یک کلاس در یک model (مدل) domain (دامنه) ایفا می‌کند و ویژگی‌های کلاس را تعریف می‌کند. building blocks (بلوک‌های سازنده) که به طور گسترده توسط توسعه‌دهندگان اتخاذ شده‌اند عبارتند از:</p>
  <ul>
   <li>Entity (موجودیت) - یک object (شی) که دارای یک persistent identity (هویت پایدار) است. دو entity (موجودیت) که ویژگی‌های آنها مقادیر یکسانی دارند، همچنان objects (اشیاء) متفاوتی هستند. در یک application (برنامه) Java EE، کلاس‌هایی که با استفاده از JPA @Entity (JPA موجودیت) ذخیره می‌شوند، معمولاً entities (موجودیت‌های) DDD هستند.</li>
   <li>Value object (شیء ارزشی) - یک object (شی) که مجموعه‌ای از مقادیر است. دو value objects (شیءهای ارزشی) که ویژگی‌های آنها مقادیر یکسانی دارند، می‌توانند به جای یکدیگر استفاده شوند. یک example (نمونه) از یک value object (شیء ارزشی) یک کلاس Money (پول) است، که شامل یک currency (ارز) و یک amount (مقدار) است.</li>
   <li>Factory (کارخانه) - یک object (شی) یا متدی که منطق ایجاد object (شی) را پیاده‌سازی می‌کند که برای انجام مستقیم توسط یک constructor (سازنده) بسیار پیچیده است. همچنین می‌تواند concrete (محسوس) را پنهان کند</li>
  </ul>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>