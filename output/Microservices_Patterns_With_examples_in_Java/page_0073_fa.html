<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 73</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>43</p>
  <p><strong>What is the microservice architecture exactly?</strong></p>
  <p>به دلیل این <strong>decoupling</strong>، تست <strong>business logic</strong> به صورت ایزوله بسیار آسان‌تر است. مزیت دیگر این است که معماری یک <strong>application</strong> مدرن را دقیق‌تر منعکس می‌کند.
   <strong>business logic</strong> را می‌توان از طریق آداپتورهای متعدد فراخوانی کرد، که هر کدام یک <strong>API</strong> یا <strong>UI</strong> خاص را پیاده‌سازی می‌کنند.</p>
  <p><strong>WHAT IS LOOSE COUPLING?</strong></p>
  <p>به اشتراک نگذاشتن جداول پایگاه داده نیز باعث بهبود جداسازی در زمان اجرا می‌شود. به عنوان مثال، این امر تضمین می‌کند که یک <strong>service</strong> نمی‌تواند قفل‌های پایگاه داده را نگه دارد که <strong>service</strong> دیگری را مسدود می‌کند. اما در ادامه، خواهید آموخت که یکی از معایب عدم اشتراک پایگاه‌های داده این است که حفظ سازگاری داده‌ها و <strong>querying</strong> در <strong>services</strong> پیچیده‌تر است.</p>
  <p><strong>THE ROLE OF SHARED LIBRARIES</strong></p>
  <p><strong>developers</strong> اغلب عملکرد را در یک کتابخانه (ماژول) بسته‌بندی می‌کنند تا بتواند توسط <strong>applications</strong> متعدد بدون تکرار کد استفاده شود. به هر حال، امروزه بدون مخازن <strong>Maven</strong> یا
   <strong>npm</strong> کجا خواهیم بود؟ ممکن است وسوسه شوید که از کتابخانه‌های مشترک در معماری <strong>microservice</strong> نیز استفاده کنید. در ظاهر، به نظر می‌رسد که یک راه خوب برای کاهش تکرار کد در <strong>services</strong> شما است. اما شما باید اطمینان حاصل کنید که به‌طور تصادفی وابستگی‌هایی بین <strong>services</strong> خود ایجاد نکنید.</p>
  <p>به عنوان مثال، تصور کنید که <strong>services</strong> متعدد نیاز به به‌روزرسانی <strong>Order business object</strong> دارند. یک رویکرد این است که آن عملکرد را به عنوان یک کتابخانه بسته‌بندی کنید که توسط <strong>services</strong> متعدد استفاده می‌شود. از یک طرف، استفاده از یک کتابخانه، تکرار کد را حذف می‌کند. از سوی دیگر، در نظر بگیرید که چه اتفاقی می‌افتد وقتی الزامات به گونه‌ای تغییر می‌کنند که بر <strong>Order business object</strong> تأثیر می‌گذارد. شما باید همزمان آن
   <strong>services</strong> را دوباره بسازید و مستقر کنید. یک رویکرد بسیار بهتر این است که عملکردی را که احتمالاً تغییر می‌کند، مانند مدیریت سفارش، به عنوان یک <strong>service</strong> پیاده‌سازی کنید.
  </p>
  <p>شما باید تلاش کنید تا از کتابخانه‌ها برای عملکردی استفاده کنید که بعید است تغییر کند. به عنوان مثال، در یک <strong>application</strong> معمولی، این منطقی نیست که هر <strong>service</strong> یک کلاس <strong>Money</strong> عمومی را پیاده‌سازی کند. در عوض، شما باید یک کتابخانه ایجاد کنید که توسط <strong>services</strong> استفاده می‌شود.</p>
  <p><strong>THE SIZE OF A SERVICE IS MOSTLY UNIMPORTANT</strong></p>
  <p>یک مشکل با اصطلاح <strong>microservice</strong> این است که اولین چیزی که می‌شنوید <strong>micro</strong> است. این نشان می‌دهد که یک <strong>service</strong> باید بسیار کوچک باشد. این در مورد سایر اصطلاحات مبتنی بر اندازه مانند <strong>miniservice</strong> یا
   <strong>nanoservice</strong> نیز صدق می‌کند. در واقعیت، اندازه یک متریک مفید نیست.</p>
  <p>یک هدف بسیار بهتر این است که یک <strong>service</strong> خوش‌ساخت را به عنوان یک <strong>service</strong> تعریف کنید که توسط یک تیم کوچک با حداقل زمان <strong>lead</strong> و با حداقل همکاری با سایر تیم‌ها قابل توسعه باشد. از نظر تئوری، یک تیم ممکن است فقط مسئول یک <strong>service</strong> واحد باشد، بنابراین آن <strong>service</strong> به هیچ وجه <strong>micro</strong> نیست. برعکس، اگر یک <strong>service</strong> به یک تیم بزرگ نیاز دارد یا زمان زیادی برای تست می‌برد، احتمالاً منطقی است که تیم و <strong>service</strong> را تقسیم کنید. یا اگر به طور مداوم نیاز به تغییر یک <strong>service</strong> دارید، به دلیل تغییرات در سایر <strong>services</strong> یا اگر تغییراتی را در <strong>services</strong> دیگر ایجاد می‌کنید، این نشانه‌ای است که <strong>loosely coupled</strong> نیست. شما حتی ممکن است یک <strong>monolith</strong> توزیع شده بسازید.
  </p>
  <p>معماری <strong>microservice</strong> یک <strong>application</strong> را به صورت مجموعه‌ای از <strong>services loosely coupled</strong> ساختار می‌دهد. در نتیجه، ویژگی‌های زمان توسعه را بهبود می‌بخشد - قابلیت نگهداری، قابلیت تست، قابلیت استقرار و غیره - و سازمان را قادر می‌سازد تا <strong>software</strong> بهتری را سریع‌تر توسعه دهد. همچنین مقیاس‌پذیری یک <strong>application</strong> را بهبود می‌بخشد، اگرچه این هدف اصلی نیست. برای توسعه یک معماری <strong>microservice</strong> برای <strong>application</strong> خود، باید <strong>services</strong> را شناسایی کرده و تعیین کنید که چگونه با هم همکاری می‌کنند. بیایید نگاهی بیندازیم که چگونه این کار را انجام دهیم.</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>