<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 212</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h3><strong style="color:darkblue">فصل 5: طراحی منطق کسب‌وکار در معماری microservice</strong></h3>
  <p>
   ایجاد و update کردن orders است. این به این دلیل است که Orders باید به صورت transactional با data متعلق به services دیگر سازگار باشند. در نتیجه، اکثر methods از OrderService یک saga ایجاد می‌کنند، نه اینکه یک Order را مستقیماً update کنند.
  </p>
  <p>
   این فصل نحوه پیاده‌سازی business logic با استفاده از یک رویکرد سنتی برای persistence را پوشش داده است. این امر شامل ادغام messaging و event publishing با مدیریت transaction از database می‌شود. کد event publishing با business logic در هم آمیخته است. فصل بعد به event sourcing نگاهی می‌اندازد، یک رویکرد event-centric برای نوشتن business logic که در آن event generation جدایی‌ناپذیر از business logic است، نه اینکه اضافه شود.
  </p>
  <p>
   Summary
  </p>
  <ul>
   <li>الگوی procedural Transaction script اغلب یک راه خوب برای پیاده‌سازی business logic ساده است. اما هنگام پیاده‌سازی business logic پیچیده، باید استفاده از الگوی object-oriented Domain model را در نظر بگیرید.</li>
   <li>یک راه خوب برای سازماندهی business logic از یک service به عنوان مجموعه‌ای از DDD aggregates است. DDD aggregates مفید هستند زیرا domain model را ماژولار می‌کنند، امکان object reference بین services را از بین می‌برند و اطمینان می‌دهند که هر ACID transaction در داخل یک service است.</li>
   <li>یک aggregate باید domain events را هنگامی که ایجاد یا update می‌شود، منتشر کند. domain events کاربردهای گسترده‌ای دارند. فصل 4 در مورد چگونگی پیاده‌سازی choreography-based sagas بحث می‌کند. و، در فصل 7، من در مورد نحوه استفاده از domain events برای update کردن replicated data صحبت می‌کنم. مشترکین domain event همچنین می‌توانند users و applicationsهای دیگر را مطلع کنند و WebSocket messages را به مرورگر user منتشر کنند.</li>
  </ul>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>