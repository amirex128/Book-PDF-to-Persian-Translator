CONTENTS
xiv
11 
Developing production-ready services
348
11.1
Developing secure services
349
Overview of security in a traditional monolithic application
350
Implementing security in a microservice architecture
353
11.2
Designing configurable services
360
Using push-based externalized configuration
362
■Using pull-
based externalized configuration
363
11.3
Designing observable services
364
Using the Health check API pattern
366
■Applying the Log 
aggregation pattern
368
■Using the Distributed tracing 
pattern
370
■Applying the Application metrics pattern
373
Using the Exception tracking pattern
376
■Applying the Audit 
logging pattern
377
11.4
Developing services using the Microservice chassis 
pattern
378
Using a microservice chassis
379
■From microservice chassis to 
service mesh
380
12 
Deploying microservices
383
12.1
Deploying services using the Language-specific packaging 
format pattern
386
Benefits of the Service as a language-specific package pattern
388
Drawbacks of the Service as a language-specific package 
pattern
389
12.2
Deploying services using the Service as a virtual machine 
pattern
390
The benefits of deploying services as VMs
392
■The drawbacks of 
deploying services as VMs
392
12.3
Deploying services using the Service as a container 
pattern
393
Deploying services using Docker
395
■Benefits of deploying 
services as containers
398
■Drawbacks of deploying services 
as containers
399
12.4
Deploying the FTGO application with Kubernetes
399
Overview of Kubernetes
399
■Deploying the Restaurant service 
on Kubernetes
402
■Deploying the API gateway
405
Zero-downtime deployments
406
■Using a service mesh 
to separate deployment from release
407
 
