<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 327</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h3>Testing microservices:</h3>
  <p>
   <strong>Part 1</strong>
  </p>
  <p>
   <strong>TESTING STRATEGIES FOR MICROSERVICE ARCHITECTURES</strong>
  </p>
  <p>
   <strong>THE DIFFERENT TYPES OF TESTS</strong>
  </p>
  <p>
   انواع مختلفی از تست ها وجود دارد. برخی از تست ها، مانند performance tests و usability tests، تأیید می‌کنند که application نیازهای quality of service خود را برآورده می‌کند. در این فصل، من بر روی automated tests تمرکز می‌کنم که جنبه‌های functional application یا service را تأیید می‌کنند. من نحوه نوشتن چهار نوع مختلف از تست ها را توضیح می‌دهم:
  </p>
  <ul>
   <li>
    Unit tests—یک بخش کوچک از یک service، مانند یک کلاس را تست می‌کند.
   </li>
   <li>
    Integration tests—تأیید می‌کند که یک service می‌تواند با service های infrastructure مانند databases و سایر application services ها تعامل داشته باشد.
   </li>
   <li>
    Component tests—Acceptance tests ها برای یک service فردی.
   </li>
   <li>
    End-to-end tests—Acceptance tests ها برای کل application.
   </li>
  </ul>
  <p>
   آنها، در درجه اول از نظر scope با هم تفاوت دارند. در یک انتهای طیف، unit tests ها قرار دارند که رفتار کوچکترین عنصر برنامه معنی‌دار را تأیید می‌کنند. برای یک زبان object-oriented مانند جاوا، این یک کلاس است. در انتهای دیگر طیف، end-to-end tests ها قرار دارند که رفتار کل application را تأیید می‌کنند. در میانه، component tests ها قرار دارند که service های فردی را تست می‌کنند. Integration tests، همانطور که در فصل بعد خواهید دید، scope نسبتاً کوچکی دارند، اما از unit tests خالص پیچیده‌تر هستند. Scope تنها یک راه برای شناسایی تست ها است. راه دیگر، استفاده از test quadrant است.
  </p>
  <p>
   <strong>USING THE TEST QUADRANT TO CATEGORIZE TESTS</strong>
  </p>
  <p>
   یک راه خوب برای طبقه‌بندی تست ها، test quadrant Brian Marick است (www.exampler.com/old-blog/2003/08/21/#agile-testing-project-1). test quadrant، که در شکل 9.4 نشان داده شده است، تست ها را در امتداد دو بعد طبقه‌بندی می‌کند:
  </p>
  <ul>
   <li>
    اینکه آیا تست، business facing یا technology facing است—یک تست business-facing با استفاده از اصطلاحات یک domain expert توصیف می‌شود، در حالی که یک تست technology-facing با استفاده از اصطلاحات developers و implementation توصیف می‌شود.
   </li>
   <li>
    اینکه آیا هدف از تست، پشتیبانی از programming است یا critique application—developers ها از تست هایی استفاده می‌کنند که از programming به عنوان بخشی از کار روزانه خود پشتیبانی می‌کنند. تست هایی که critique application را دارند، با هدف شناسایی مناطقی که نیاز به بهبود دارند.
   </li>
  </ul>
  <p>
   Compile-time unit tests
  </p>
  <p>
   Testing یک بخش جدایی‌ناپذیر از توسعه است. workflow توسعه مدرن، ویرایش کد، و سپس اجرای تست ها است. علاوه بر این، اگر شما یک Test-Driven Development (TDD) practitioner هستید، یک ویژگی جدید را توسعه می‌دهید یا یک باگ را با نوشتن ابتدا یک تست ناموفق و سپس نوشتن کد برای گذراندن آن، برطرف می‌کنید. حتی اگر شما یک TDD adherent نیستید، یک راه عالی برای رفع یک باگ، نوشتن یک تست است که باگ را بازتولید می‌کند و سپس کد را می‌نویسید که آن را برطرف می‌کند.
  </p>
  <p>
   تست هایی که شما به عنوان بخشی از این workflow اجرا می‌کنید، به عنوان compile-time tests شناخته می‌شوند. در یک IDE مدرن، مانند IntelliJ IDEA یا Eclipse، شما معمولاً کد خود را به عنوان یک گام جداگانه compile نمی‌کنید. در عوض، شما از یک keystroke واحد برای compile کردن کد و اجرای تست ها استفاده می‌کنید. برای اینکه در جریان کار باقی بمانید، این تست ها باید سریع اجرا شوند - در حالت ایده‌آل، بیش از چند ثانیه نباشد.
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>