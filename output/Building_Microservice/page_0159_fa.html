<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 159</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>بنابراین برای استفاده در <em>perimeter</em>، به طرز خارق‌العاده‌ای خوب عمل می‌کند، و برای ارتباط مبتنی بر <em>synchronous request-response</em> بین <em>microservices</em>، عالی است.</p>
  <h4>GraphQL</h4>
  <p>در سال‌های اخیر، <em>GraphQL</em> محبوبیت بیشتری پیدا کرده است، که عمدتاً به این دلیل است که در یک زمینه خاص برتری دارد. یعنی، این امر امکان را برای یک دستگاه سمت <em>client-side</em> فراهم می‌کند تا <em>queries</em> را تعریف کند که می‌تواند از نیاز به برقراری چندین <em>request</em> برای بازیابی همان اطلاعات جلوگیری کند. این می‌تواند بهبودهای قابل توجهی از نظر عملکرد دستگاه‌های محدود سمت <em>client-side</em> ارائه دهد و همچنین می‌تواند از نیاز به پیاده‌سازی <em>bespoke server-side aggregation</em> جلوگیری کند.</p>
  <p>برای مثال ساده، دستگاهی را تصور کنید که می‌خواهد صفحه‌ای را نمایش دهد که مروری بر آخرین سفارشات مشتری را نشان می‌دهد. این صفحه باید حاوی اطلاعاتی در مورد مشتری، همراه با اطلاعاتی در مورد پنج سفارش اخیر مشتری باشد. صفحه فقط به چند <em>field</em> از <em>customer record</em> نیاز دارد، و فقط تاریخ، ارزش، و <em>shipped status</em> هر سفارش. دستگاه تلفن همراه می‌تواند <em>calls</em> را به دو <em>downstream microservices</em> صادر کند تا اطلاعات مورد نیاز را بازیابی کند، اما این شامل برقراری چندین <em>calls</em>، از جمله بازگرداندن اطلاعاتی است که در واقع مورد نیاز نیست. به خصوص با دستگاه‌های تلفن همراه، این می‌تواند اسراف‌آمیز باشد—از <em>data plan</em> یک دستگاه تلفن همراه بیشتر از حد نیاز استفاده می‌کند، و می‌تواند بیشتر طول بکشد.</p>
  <p><em>GraphQL</em> به دستگاه تلفن همراه اجازه می‌دهد تا یک <em>query</em> واحد را صادر کند که می‌تواند تمام اطلاعات مورد نیاز را بازیابی کند. برای اینکه این کار انجام شود، شما به یک <em>microservice</em> نیاز دارید که یک <em>GraphQL endpoint</em> را در معرض دستگاه <em>client</em> قرار دهد. این <em>GraphQL endpoint</em> ورودی برای همه <em>client queries</em> است و یک <em>schema</em> را برای استفاده دستگاه‌های <em>client</em> در معرض نمایش قرار می‌دهد. این <em>schema</em> انواع موجود را برای <em>client</em> در معرض نمایش قرار می‌دهد، و یک <em>graphical query builder</em> خوب نیز در دسترس است تا ایجاد این <em>queries</em> را آسان‌تر کند. با کاهش تعداد <em>calls</em> و مقدار داده بازیابی شده توسط دستگاه <em>client</em>، می‌توانید به خوبی با برخی از چالش‌هایی که هنگام ساخت <em>user interfaces</em> با معماری‌های <em>microservice</em> رخ می‌دهد، مقابله کنید.</p>
  <h4>چالش‌ها</h4>
  <p>در ابتدا، یک چالش کمبود پشتیبانی زبان برای <em>GraphQL specification</em> بود، که در ابتدا <em>JavaScript</em> تنها انتخاب شما بود. این بسیار بهبود یافته است، به طوری که همه فناوری‌های اصلی اکنون از این <em>specification</em> پشتیبانی می‌کنند. در واقع، پیشرفت‌های قابل توجهی در <em>GraphQL</em> و پیاده‌سازی‌های مختلف در سراسر جهان وجود داشته است، که <em>GraphQL</em> را به یک چشم‌انداز بسیار کم خطرتر از چند سال پیش تبدیل کرده است. با این حال، ممکن است بخواهید از چند چالش باقیمانده با این فناوری آگاه باشید.</p>
  <p>برای یک مورد، دستگاه <em>client</em> می‌تواند <em>queries</em> را به صورت پویا تغییر دهد، و من از تیم‌هایی شنیده‌ام که در نتیجه این قابلیت با <em>GraphQL queries</em> مشکلاتی داشته‌اند که باعث ایجاد بار قابل توجهی بر روی <em>server side</em> شده است. وقتی <em>GraphQL</em> را با چیزی مانند <em>SQL</em> مقایسه می‌کنیم، با یک مسئله مشابه روبرو می‌شویم. یک عبارت <em>SQL</em> گران قیمت می‌تواند باعث</p>
 </div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>