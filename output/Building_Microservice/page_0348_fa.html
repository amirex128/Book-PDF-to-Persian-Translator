<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 348</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        7 Charity Majors, “Metrics: Not the Observability Droids You’re Looking For,” Honeycomb (blog), October 24, 2017, https://oreil.ly/TEETp.
    </p>
    <p>
        با توجه به ماهیت این نوع داده‌ها، ما ممکن است بخواهیم این <strong>metrics</strong> را با وضوح‌های مختلف ذخیره و گزارش کنیم. به عنوان مثال، من ممکن است بخواهم یک نمونه <strong>CPU</strong> برای سرورهای خود با وضوح یک نمونه در هر 10 ثانیه برای 30 دقیقه گذشته داشته باشم، تا بهتر به یک موقعیت که در حال حاضر در حال وقوع است، واکنش نشان دهم. از طرف دیگر، نمونه‌های <strong>CPU</strong> از سرورهای من از ماه گذشته احتمالاً فقط برای تجزیه و تحلیل روند کلی مورد نیاز هستند، بنابراین من ممکن است از محاسبه یک نمونه <strong>CPU</strong> متوسط بر اساس یک ساعت خوشحال باشم. این اغلب در پلتفرم‌های <strong>metrics</strong> استاندارد انجام می‌شود تا به کاهش زمان پرس‌وجو کمک کند و همچنین فضای ذخیره‌سازی داده‌ها را کاهش دهد. برای چیزی به سادگی نرخ <strong>CPU</strong>، این ممکن است خوب باشد، اما فرآیند تجمیع داده‌های قدیمی باعث می‌شود که ما اطلاعات را از دست بدهیم. مشکل با نیاز به تجمیع این داده‌ها این است که شما اغلب باید از قبل تصمیم بگیرید که چه چیزی را تجمیع کنید—شما باید از قبل حدس بزنید که چه اطلاعاتی را می‌توان از دست داد.
    </p>
    <p>
        ابزارهای <strong>metrics</strong> استاندارد می‌توانند برای درک روندها یا حالت‌های شکست ساده کاملاً مناسب باشند. در واقع، آنها می‌توانند حیاتی باشند. اما آنها اغلب به ما کمک نمی‌کنند تا سیستم‌هایمان را <strong>observable</strong>تر کنیم، زیرا آنها انواع سؤالاتی را که می‌خواهیم بپرسیم محدود می‌کنند. زمانی که ما از قطعات ساده اطلاعاتی مانند زمان پاسخگویی، <strong>CPU</strong>، یا استفاده از فضای دیسک به تفکر گسترده‌تر در مورد انواع اطلاعاتی که می‌خواهیم ثبت کنیم، می‌رویم، اوضاع جالب می‌شود.
    </p>
    <h4>Low versus high cardinality</h4>
    <p>
        بسیاری از ابزارها، به‌ویژه ابزارهای جدیدتر، برای پذیرش ذخیره‌سازی و بازیابی داده‌های با <strong>high-cardinality</strong> ساخته شده‌اند. راه‌هایی برای توصیف <strong>cardinality</strong> وجود دارد، اما می‌توانید آن را به‌عنوان تعداد فیلدهایی در نظر بگیرید که می‌توان به راحتی در یک نقطه داده داده شده پرس‌وجو کرد. هرچه فیلدهای بالقوه بیشتری داشته باشیم که ممکن است بخواهیم از داده‌های خود پرس‌وجو کنیم، <strong>cardinality</strong> بالاتری را باید پشتیبانی کنیم. اساساً، این امر به دلایلی که من در اینجا در مورد آنها توضیح نمی‌دهم، اما مربوط به نحوه ساخت بسیاری از این سیستم‌ها است، در پایگاه‌های داده سری زمانی مشکل‌سازتر می‌شود.
    </p>
    <p>
        به عنوان مثال، من ممکن است بخواهم نام <strong>microservice</strong>، <strong>customer ID</strong>، <strong>request ID</strong>، شماره ساخت نرم‌افزار، و <strong>product ID</strong> را در طول زمان ثبت و پرس‌وجو کنم. سپس من تصمیم می‌گیرم که اطلاعاتی را در مورد دستگاه در آن مرحله—سیستم عامل، معماری سیستم، ارائه‌دهنده <strong>cloud</strong>، و غیره—ثبت کنم. من ممکن است نیاز داشته باشم که تمام آن اطلاعات را برای هر نقطه داده‌ای که جمع‌آوری می‌کنم، ثبت کنم. با افزایش تعداد مواردی که ممکن است بخواهم در مورد آنها پرس‌وجو کنم، <strong>cardinality</strong> افزایش می‌یابد، و سیستم‌ها مشکلات بیشتری خواهند داشت که با در نظر گرفتن این مورد ساخته نشده‌اند. همانطور که <strong>Charity Majors</strong>،<sup>7</sup> بنیانگذار <strong>Honeycomb</strong>، توضیح می‌دهد:
    </p>
    <p>
        322 | Chapter 10: From Monitoring to Observability
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>