<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 167</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>با این حال، من هنوز هم طرفدار <em>XML</em> هستم. برخی از پشتیبانی‌های ابزار بهتر است. به عنوان مثال، اگر بخواهم فقط بخش‌های خاصی از <em>payload</em> را استخراج کنم (تکنیکی که در "<em>Handling Change Between Microservices</em>" در صفحه 144 بیشتر در مورد آن بحث خواهیم کرد)، می‌توانم از <em>XPATH</em> استفاده کنم، که یک استاندارد شناخته شده با پشتیبانی ابزار زیاد است، یا حتی <em>CSS selectors</em>، که بسیاری آن را آسان‌تر می‌دانند. با <em>JSON</em>، من <em>JSONPath</em> را دارم، اما این به طور گسترده پشتیبانی نمی‌شود. من این را عجیب می‌دانم که مردم <em>JSON</em> را انتخاب می‌کنند زیرا خوب و سبک وزن است اما سپس سعی می‌کنند مفاهیمی مانند کنترل‌های <em>hypermedia</em> را که از قبل در <em>XML</em> وجود دارد، به آن وارد کنند. با این حال، من می‌پذیرم که احتمالاً در اینجا در اقلیت هستم و <em>JSON</em> <em>format</em> مورد انتخاب بسیاری از مردم است!</p>
  <h4>Binary Formats</h4>
  <p>در حالی که <em>textual formats</em> مزایایی مانند آسان کردن خواندن آن‌ها برای انسان‌ها و ارائه <em>interoperability</em> زیاد با ابزارها و فناوری‌های مختلف دارند، دنیای <em>binary serialization protocols</em> جایی است که اگر شروع به نگرانی در مورد اندازه <em>payload</em> یا در مورد راندمان نوشتن و خواندن <em>payloads</em> کردید، باید در آن قرار بگیرید. <em>Protocol buffers</em> مدتی است که وجود دارند و اغلب خارج از محدوده <em>gRPC</em> استفاده می‌شوند—آن‌ها احتمالاً محبوب‌ترین <em>binary serialization format</em> را برای ارتباط مبتنی بر <em>microservice</em> نشان می‌دهند.</p>
  <p>با این حال، این فضا بزرگ است، و تعدادی از <em>formats</em> دیگر با در نظر گرفتن طیف وسیعی از الزامات توسعه یافته‌اند. <em>Simple Binary Encoding</em>، <em>Cap’n Proto</em>، و <em>FlatBuffers</em> همه به ذهن می‌آیند. اگرچه <em>benchmarks</em> برای هر یک از این <em>formats</em> وجود دارد، که مزایای مربوطه آن‌ها را در مقایسه با <em>protocol buffers</em>، <em>JSON</em>، یا <em>other formats</em> برجسته می‌کند، <em>benchmarks</em> از یک مشکل اساسی رنج می‌برند به این صورت که ممکن است لزوماً نشان‌دهنده نحوه استفاده شما از آن‌ها نباشند. اگر می‌خواهید آخرین چند بایت را از <em>serialization format</em> خود استخراج کنید، یا میکروثانیه‌ها را از زمانی که برای خواندن یا نوشتن این <em>payloads</em> صرف می‌شود، اصلاح کنید، من به شدت پیشنهاد می‌کنم مقایسه خود را از این <em>formats</em> مختلف انجام دهید. در تجربه من، اکثریت قریب به اتفاق سیستم‌ها به ندرت مجبورند نگران چنین بهینه‌سازی‌هایی باشند، زیرا آن‌ها اغلب می‌توانند بهبودهایی را که به دنبال آن هستند با ارسال داده‌های کمتر یا با عدم برقراری <em>call</em> به دست آورند. با این حال، اگر در حال ساخت یک سیستم توزیع شده با <em>ultra-low-latency</em> هستید، مطمئن شوید که برای شیرجه زدن به دنیای <em>binary serialization formats</em> آماده‌اید.</p>
  <h4>Schemas</h4>
  <p>بحثی که بارها و بارها مطرح می‌شود این است که آیا باید از <em>schemas</em> برای تعریف آنچه <em>endpoints</em> ما در معرض نمایش قرار می‌دهند و آنچه می‌پذیرند، استفاده کنیم یا خیر. <em>Schemas</em> می‌توانند در انواع مختلفی ارائه شوند، و انتخاب یک <em>serialization format</em> معمولاً فناوری <em>schema</em> را که می‌توانید از آن استفاده کنید، تعریف می‌کند. اگر با <em>raw XML</em> کار می‌کنید، از <em>XML Schema Definition (XSD)</em> استفاده می‌کنید؛ اگر با <em>raw JSON</em> کار می‌کنید، از <em>JSON Schema</em> استفاده می‌کنید. برخی از انتخاب‌های فناوری که ما به آن‌ها اشاره کردیم (به طور خاص، یک زیرمجموعه قابل توجه از گزینه‌های <em>RPC</em>) نیازمند استفاده از <em>explicit schemas</em> هستند، بنابراین اگر آن فناوری‌ها را انتخاب کردید، شما</p>
 </div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>