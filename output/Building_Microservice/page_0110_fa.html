<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 110</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>یکپارچگی داده‌ها</h4>
  <p>
   پایگاه‌های داده می‌توانند در اطمینان از یکپارچگی داده‌های ما مفید باشند. بازگشت به شکل 3-6، با وجود اینکه جداول <strong>Album</strong> و <strong>Ledger</strong> در یک پایگاه داده یکسان هستند، ما می‌توانیم (و احتمالاً انجام خواهیم داد) یک رابطه کلید خارجی بین ردیف‌های جدول <strong>Ledger</strong> و جدول <strong>Album</strong> تعریف کنیم. این امر اطمینان می‌دهد که ما همیشه می‌توانیم از یک رکورد در جدول <strong>Ledger</strong> به اطلاعاتی در مورد آلبوم فروخته شده، حرکت کنیم، زیرا اگر رکوردهایی در جدول <strong>Album</strong> به <strong>Ledger</strong> ارجاع داده شده‌اند، قادر به حذف آنها نخواهیم بود.
  </p>
  <p>
   با این جداول که اکنون در پایگاه‌های داده مختلف قرار دارند، ما دیگر اعمال یکپارچگی مدل داده‌های خود را نداریم. هیچ چیز مانع از حذف یک ردیف در جدول <strong>Album</strong> نمی‌شود و باعث ایجاد مشکلی می‌شود وقتی که ما سعی می‌کنیم دقیقاً دریابیم که چه کالایی فروخته شده است.
  </p>
  <p>
   تا حدی، شما به سادگی باید به این واقعیت عادت کنید که دیگر نمی‌توانید برای اجرای یکپارچگی روابط بین موجودیت‌ها به پایگاه داده خود اعتماد کنید. بدیهی است، برای داده‌هایی که در یک پایگاه داده واحد باقی می‌مانند، این یک مشکل نیست.
  </p>
  <p>
   تعدادی راه‌حل وجود دارد، اگرچه "الگوهای مقابله" اصطلاح بهتری برای راه‌هایی است که ما ممکن است با این مشکل برخورد کنیم. ما می‌توانیم از یک <strong>soft delete</strong> در جدول <strong>Album</strong> استفاده کنیم تا در واقع یک رکورد را حذف نکنیم، بلکه فقط آن را به عنوان حذف شده علامت‌گذاری کنیم. یک گزینه دیگر می‌تواند این باشد که نام آلبوم را هنگام فروش در جدول <strong>Ledger</strong> کپی کنیم، اما ما باید نحوه مدیریت همگام‌سازی تغییرات در نام آلبوم را حل کنیم.
  </p>
  <h4>تراکنش‌ها</h4>
  <p>
   بسیاری از ما به ضمانت‌هایی که از مدیریت داده‌ها در تراکنش‌ها دریافت می‌کنیم، تکیه کرده‌ایم. بر اساس آن اطمینان، ما برنامه‌هایی را به روشی خاص ساخته‌ایم، با این علم که می‌توانیم به پایگاه داده تکیه کنیم تا تعدادی از موارد را برای ما مدیریت کند. با این حال، هنگامی که شروع به تقسیم داده‌ها در چندین پایگاه داده می‌کنیم، ایمنی تراکنش‌های <strong>ACID</strong> را که به آنها عادت کرده‌ایم، از دست می‌دهیم. (من سرنام <strong>ACID</strong> را توضیح می‌دهم و در فصل 6 در مورد تراکنش‌های <strong>ACID</strong> با جزئیات بیشتری بحث می‌کنم.)
  </p>
  <p>
   برای افرادی که از سیستمی حرکت می‌کنند که در آن همه تغییرات <strong>state</strong> می‌توانست در یک <strong>transactional boundary</strong> واحد مدیریت شود، تغییر به سیستم‌های توزیع‌شده می‌تواند یک شوک باشد، و اغلب واکنش این است که به دنبال پیاده‌سازی تراکنش‌های توزیع‌شده بگردیم تا ضمانت‌هایی را که تراکنش‌های <strong>ACID</strong> به ما دادند را با معماری‌های ساده‌تر به دست آوریم. متأسفانه، همانطور که در “Database Transactions” در صفحه 175 به تفصیل بررسی خواهیم کرد، تراکنش‌های توزیع‌شده نه تنها در پیاده‌سازی پیچیده هستند، حتی زمانی که به خوبی انجام شوند، بلکه در واقع همان تضمین‌هایی را که ما انتظار داشتیم در تراکنش‌های پایگاه داده با دامنه محدودتر داشته باشیم، به ما نمی‌دهند.
  </p>
  <p>
   همانطور که در “<strong>Sagas</strong>” در صفحه 182 به بررسی آن می‌پردازیم، مکانیسم‌های جایگزین (و ترجیحی) برای تراکنش‌های توزیع‌شده برای مدیریت تغییرات <strong>state</strong> در چندین microservices وجود دارد، اما آنها منابع جدیدی از پیچیدگی را به همراه دارند. مانند یکپارچگی داده‌ها،
  </p>
  <p>84 | Chapter 3: Splitting the Monolith</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>