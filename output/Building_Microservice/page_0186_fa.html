<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 186</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>به طور خاص، می‌تواند رکوردهای <em>SRV</em> را ارائه دهد، که به شما هم <em>IP</em> و هم یک <em>port</em> را برای یک نام مشخص می‌دهد. این بدان معناست که اگر بخشی از سیستم شما از قبل از <em>DNS</em> استفاده می‌کند و می‌تواند از رکوردهای <em>SRV</em> پشتیبانی کند، می‌توانید فقط <em>Consul</em> را اضافه کنید و بدون هیچ تغییری در سیستم موجود خود شروع به استفاده از آن کنید.</p>
  <p><em>Consul</em> همچنین قابلیت‌های دیگری را در خود ایجاد می‌کند که ممکن است مفید بدانید، مانند توانایی انجام <em>health checks</em> بر روی <em>nodes</em>. بنابراین <em>Consul</em> می‌تواند به خوبی با قابلیت‌های ارائه شده توسط سایر ابزارهای مانیتورینگ اختصاصی همپوشانی داشته باشد، اگرچه احتمالاً از <em>Consul</em> به عنوان منبع این اطلاعات استفاده می‌کنید و سپس آن را در یک راه‌اندازی نظارت جامع‌تر وارد می‌کنید.
  <p><em>Consul</em> از یک <em>RESTful HTTP interface</em> برای همه چیز، از ثبت یک <em>service</em> گرفته تا <em>querying the key/value store</em> یا درج <em>health checks</em> استفاده می‌کند. این امر ادغام با <em>different technology stacks</em> را بسیار ساده می‌کند. <em>Consul</em> همچنین دارای مجموعه‌ای از ابزارها است که به خوبی با آن کار می‌کنند، و این باعث بهبود بیشتر مفید بودن آن می‌شود. یک نمونه <em>consul-template</em> است، که راهی برای به‌روزرسانی فایل‌های متنی بر اساس ورودی‌ها در <em>Consul</em> فراهم می‌کند. در نگاه اول، این خیلی جالب به نظر نمی‌رسد، تا زمانی که واقعیت را در نظر بگیرید که با <em>consul-template</em> اکنون می‌توانید یک مقدار را در <em>Consul</em> تغییر دهید—شاید مکان یک <em>microservice</em>، یا یک مقدار پیکربندی—و فایل‌های پیکربندی را در سراسر سیستم خود به صورت پویا به‌روزرسانی کنید. ناگهان، هر برنامه‌ای که پیکربندی خود را از یک فایل متنی می‌خواند، می‌تواند فایل‌های متنی خود را به صورت پویا به‌روزرسانی کند بدون اینکه نیازی به دانستن چیزی در مورد خود <em>Consul</em> داشته باشد. یک مورد استفاده عالی برای این کار، افزودن یا حذف پویا <em>nodes</em> به یک <em>load balancer pool</em> با استفاده از یک <em>software load balancer</em> مانند <em>HAProxy</em> خواهد بود.</p>
  <p>ابزار دیگری که به خوبی با <em>Consul</em> ادغام می‌شود، <em>Vault</em> است، یک ابزار مدیریت <em>secrets</em> که در "<em>Secrets</em>" در صفحه 356 دوباره به آن می‌پردازیم. مدیریت <em>secrets</em> می‌تواند دشوار باشد، اما ترکیب <em>Consul</em> و <em>Vault</em> قطعاً می‌تواند زندگی را آسان‌تر کند.</p>
  <h4>etcd and Kubernetes</h4>
  <p>اگر شما بر روی پلتفرمی در حال اجرا هستید که بارهای کاری <em>container</em> را برای شما مدیریت می‌کند، احتمالاً در حال حاضر یک مکانیسم <em>service discovery</em> برای شما فراهم شده است. <em>Kubernetes</em> تفاوتی ندارد، و تا حدی از <em>etcd</em>، یک <em>configuration management store</em> بسته‌بندی شده با <em>Kubernetes</em>، می‌آید. <em>etcd</em> دارای قابلیت‌هایی مشابه با <em>Consul</em> است، و <em>Kubernetes</em> از آن برای مدیریت طیف گسترده‌ای از اطلاعات پیکربندی استفاده می‌کند.</p>
  <p>ما <em>Kubernetes</em> را با جزئیات بیشتری در "<em>Kubernetes and Container Orchestration</em>" در صفحه 259 بررسی خواهیم کرد، اما به طور خلاصه، نحوه عملکرد <em>service discovery</em> در <em>Kubernetes</em> این است که شما یک <em>container</em> را در یک <em>pod</em> مستقر می‌کنید، و سپس یک <em>service</em> به صورت پویا مشخص می‌کند که کدام <em>pods</em> باید بخشی از یک <em>service</em> باشند با تطبیق الگو در <em>metadata</em> مرتبط با <em>pod</em>. این یک مکانیسم کاملاً زیبا است و می‌تواند بسیار قدرتمند باشد. سپس درخواست‌ها به یک <em>service</em> به یکی از <em>pods</em> که آن <em>service</em> را تشکیل می‌دهند، هدایت می‌شوند.
  <p>قابلیت‌هایی که شما از جعبه با <em>Kubernetes</em> دریافت می‌کنید، ممکن است منجر به این شود که شما فقط بخواهید با آنچه با پلتفرم اصلی ارائه می‌شود کار کنید، و از استفاده از ابزارهای اختصاصی مانند <em>Consul</em> اجتناب کنید، و برای بسیاری از افراد این منطقی است، به خصوص اگر</p>
 </div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>