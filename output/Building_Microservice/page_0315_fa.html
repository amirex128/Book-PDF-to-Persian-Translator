<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 315</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        چالش‌ها. اساساً، داشتن تیمی که مسئولیت تست‌ها را بر عهده دارد، جایی که افراد از یک تیم متفاوت می‌توانند باعث شکست این تست‌ها شوند، مشکل‌ساز است.
    </p>
    <p>
        گاهی اوقات سازمان‌ها با داشتن یک تیم اختصاصی به نوشتن این تست‌ها واکنش نشان می‌دهند. این می‌تواند فاجعه‌بار باشد. تیمی که نرم‌افزار را توسعه می‌دهد، به طور فزاینده‌ای از تست‌های مربوط به کد خود دور می‌شود. زمان چرخه‌ها افزایش می‌یابد، زیرا مالکان <strong>service</strong> در نهایت منتظر می‌مانند تا تیم تست، تست‌های <strong>end-to-end</strong> را برای <strong>functionality</strong> که اخیراً نوشته است، بنویسد. از آنجایی که تیم دیگری این تست‌ها را می‌نویسد، تیمی که <strong>service</strong> را نوشته است، کمتر درگیر است و بنابراین، احتمال کمتری دارد که بداند چگونه این تست‌ها را اجرا و رفع کند. اگرچه متاسفانه همچنان یک الگوی سازمانی رایج است، هر زمان که یک تیم از نوشتن تست‌ها برای کدی که در وهله اول نوشته است، دور می‌شود، آسیب‌های قابل توجهی می‌بینم.
    </p>
    <p>
        درست انجام دادن این جنبه واقعاً دشوار است. ما نمی‌خواهیم تلاش‌ها را تکرار کنیم، و همچنین نمی‌خواهیم این را کاملاً متمرکز کنیم تا جایی که تیم‌های سازنده <strong>services</strong>، خیلی از این مسائل دور شوند. اگر می‌توانید راهی پاک برای اختصاص تست‌های <strong>end-to-end</strong> به یک تیم خاص پیدا کنید، این کار را انجام دهید. اگر نه، و اگر نمی‌توانید راهی برای حذف تست‌های <strong>end-to-end</strong> و جایگزینی آنها با چیز دیگری پیدا کنید، احتمالاً باید با <strong>test suite end-to-end</strong> به عنوان یک پایگاه کد مشترک، اما با مالکیت مشترک رفتار کنید. تیم‌ها می‌توانند آزادانه در این <strong>suite</strong> <strong>check in</strong> کنند، اما مالکیت سلامت <strong>suite</strong> باید بین تیم‌هایی که خود <strong>services</strong> را توسعه می‌دهند، به اشتراک گذاشته شود. اگر می‌خواهید از تست‌های <strong>end-to-end</strong> با چندین تیم به طور گسترده استفاده کنید، فکر می‌کنم این رویکرد ضروری است، و با این حال، من آن را به ندرت دیده‌ام و هرگز بدون مشکل نبوده است. در نهایت، من متقاعد شده‌ام که در یک سطح خاص از مقیاس سازمانی، به همین دلیل باید از تست‌های <strong>end-to-end</strong> بین تیمی دور شوید.
    </p>
    <h4>How Long Should End-to-End Tests Run?</h4>
    <p>
        این تست‌های <strong>end-to-end</strong> می‌توانند مدتی طول بکشند. من دیده‌ام که اجرای آنها تا یک روز طول می‌کشد، اگر نه بیشتر، و در یک پروژه‌ای که روی آن کار می‌کردم، یک <strong>suite</strong> رگرسیون کامل شش هفته طول کشید! من به ندرت می‌بینم که تیم‌ها در واقع <strong>test suites end-to-end</strong> خود را برای کاهش همپوشانی در پوشش تست، انتخاب کنند یا زمان کافی را صرف سریع کردن آنها کنند.
    </p>
    <p>
        این کندی، همراه با این واقعیت که این تست‌ها اغلب می‌توانند <strong>flaky</strong> باشند، می‌تواند یک مشکل بزرگ باشد. یک <strong>test suite</strong> که تمام روز طول می‌کشد و اغلب خرابی‌هایی دارد که هیچ ربطی به <strong>broken functionality</strong> ندارند، یک فاجعه است. حتی اگر <strong>functionality</strong> شما خراب باشد، ممکن است ساعت‌ها طول بکشد تا متوجه شوید—در این مرحله احتمالاً قبلاً به فعالیت‌های دیگری رفته‌اید، و تغییر زمینه در انتقال مغزتان برای رفع مشکل دردناک خواهد بود.
    </p>
    <p>
        ما می‌توانیم با اجرای تست‌ها به صورت موازی، برخی از این موارد را بهبود بخشیم—به عنوان مثال، استفاده از ابزارهایی مانند <strong>Selenium Grid</strong>. با این حال، این رویکرد جایگزینی برای درک آنچه باید تست شود و حذف فعالانه تست‌هایی که دیگر مورد نیاز نیستند، نیست.
    </p>
    <p>
        Implementing (Those Tricky) End-to-End Tests | 289
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>