<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 136</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   در این حالت، <strong>event emitter</strong> نیازی به دانستن اینکه کدام microservicesهای پایین‌دست قادر به انجام چه کاری هستند، ندارد، و در واقع ممکن است حتی نداند که آنها وجود دارند—در نتیجه، <em>coupling</em> تا حد زیادی کاهش می‌یابد.
  </p>
  <p>
   توزیع مسئولیتی که ما با تعاملات <strong>event-driven</strong> خود می‌بینیم می‌تواند توزیع مسئولیتی را که با سازمان‌هایی که در تلاش برای ایجاد تیم‌های خودمختارتر هستند، منعکس کند. به جای نگه‌داشتن تمام مسئولیت‌ها به صورت مرکزی، ما می‌خواهیم آن را به خود تیم‌ها منتقل کنیم تا به آنها اجازه دهیم به روشی خودمختارتر عمل کنند—مفهومی که ما در فصل 15 به آن باز خواهیم گشت. در اینجا، ما مسئولیت را از <strong>Warehouse</strong> به <strong>Notifications</strong> و <strong>Payment</strong> منتقل می‌کنیم—این می‌تواند به ما در کاهش پیچیدگی microservicesها مانند <strong>Warehouse</strong> کمک کند و منجر به توزیع یکنواخت‌تری از "هوش" در سیستم ما شود. ما این ایده را با جزئیات بیشتری هنگام مقایسه <strong>choreography</strong> و <strong>orchestration</strong> در فصل 6 بررسی خواهیم کرد.
  </p>
  <h4>Events و Messages</h4>
  <p>
   من گاهی اوقات دیده‌ام که اصطلاحات <strong>messages</strong> و <strong>events</strong> با هم اشتباه گرفته می‌شوند. یک <strong>event</strong> یک واقعیت است—بیانیه‌ای مبنی بر اینکه چیزی اتفاق افتاده است، به همراه مقداری اطلاعات در مورد اینکه دقیقاً چه اتفاقی افتاده است. یک <strong>message</strong> چیزی است که ما از طریق یک مکانیسم ارتباط ناهمزمان، مانند یک <strong>message broker</strong>، ارسال می‌کنیم.
  </p>
  <p>
   با همکاری <strong>event-driven</strong>، ما می‌خواهیم آن <strong>event</strong> را پخش کنیم، و یک راه معمول برای پیاده‌سازی آن مکانیسم پخش، قرار دادن <strong>event</strong> در یک <strong>message</strong> است.
  </p>
  <p>
   <strong>Message</strong>، واسطه است. <strong>Event</strong>، <strong>payload</strong> است.
  </p>
  <p>
   به همین ترتیب، ما ممکن است بخواهیم یک <strong>request</strong> را به عنوان <strong>payload</strong> یک <strong>message</strong> ارسال کنیم—که در این صورت ما یک نوع از <strong>asynchronous request-response</strong> را پیاده‌سازی می‌کنیم.
  </p>
  <h4>پیاده‌سازی</h4>
  <p>
   دو جنبه اصلی وجود دارد که ما باید در اینجا در نظر بگیریم: راهی برای microservicesهای ما برای انتشار <strong>events</strong>، و راهی برای مصرف‌کنندگان ما برای فهمیدن اینکه این <strong>events</strong> اتفاق افتاده است.
  </p>
  <p>
   به طور سنتی، <strong>message brokers</strong>ها مانند <strong>RabbitMQ</strong> سعی می‌کنند هر دو مشکل را مدیریت کنند. <strong>Producers</strong> از یک <strong>API</strong> برای انتشار یک <strong>event</strong> به <strong>broker</strong> استفاده می‌کنند. <strong>Broker</strong> اشتراک‌ها را مدیریت می‌کند و به مصرف‌کنندگان اجازه می‌دهد تا هنگام رسیدن یک <strong>event</strong> مطلع شوند. این <strong>brokers</strong>ها حتی می‌توانند <strong>state</strong> مصرف‌کنندگان را مدیریت کنند—به عنوان مثال، با کمک به پیگیری اینکه چه پیام‌هایی را قبلاً دیده‌اند. این سیستم‌ها معمولاً به گونه‌ای طراحی شده‌اند که مقیاس‌پذیر و انعطاف‌پذیر باشند، اما این ویژگی رایگان نیست. این می‌تواند پیچیدگی را به فرآیند توسعه اضافه کند، زیرا این یک سیستم دیگر است که شما ممکن است برای توسعه و آزمایش <strong>services</strong> خود نیاز به اجرای آن داشته باشید. ممکن است به دستگاه‌ها و تخصص‌های اضافی نیز برای راه‌اندازی و اجرای این زیرساخت نیاز باشد. اما هنگامی که این کار انجام شد، می‌تواند یک راه فوق‌العاده مؤثر برای پیاده‌سازی معماری‌های <strong>loosely coupled</strong> و <strong>event-driven</strong> باشد. به طور کلی، من طرفدار آن هستم.
  </p>
  <p>109 | Chapter 4: Microservice Communication Styles</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>