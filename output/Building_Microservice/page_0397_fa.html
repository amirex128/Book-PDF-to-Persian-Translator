<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 397</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>شایان ذکر است که برخی از پروتکل‌های ارتباطی که از <em>HTTP</em> در زیرساخت خود استفاده می‌کنند، می‌توانند از <em>HTTPS</em> بهره‌مند شوند—بنابراین ما می‌توانیم به راحتی <em>SOAP</em> یا <em>gRPC</em> را بدون مشکل روی <em>HTTPS</em> اجرا کنیم. <em>HTTPS</em> همچنین حفاظت‌های اضافی را علاوه بر تأیید اینکه با چه کسی انتظار داریم صحبت کنیم، به ما می‌دهد. ما به زودی به آن خواهیم رسید.</p>
    <h5>Client identity (هویت کلاینت)</h5>
    <p>وقتی در این زمینه به <em>client identity</em> (هویت کلاینت) اشاره می‌کنیم، منظور ما <em>microservice</em> (ریز سرویس) است که یک فراخوانی را انجام می‌دهد—بنابراین ما در تلاشیم تا هویت <em>microservice</em> (ریز سرویس) بالادستی را تأیید و احراز هویت کنیم. ما کمی بعدتر به این موضوع خواهیم پرداخت که چگونه انسان‌ها (کاربران!) را احراز هویت می‌کنیم.</p>
    <p>ما می‌توانیم هویت یک <em>client</em> (کلاینت) را به چندین روش تأیید کنیم. ما می‌توانیم از <em>client</em> (کلاینت) بخواهیم که اطلاعاتی را در <em>request</em> (درخواست) برای ما ارسال کند که به ما بگوید آنها چه کسی هستند. یک مثال ممکن است استفاده از نوعی <em>shared secret</em> (راز مشترک) یا یک گواهی <em>client-side</em> (سمت کلاینت) برای امضای <em>request</em> (درخواست) باشد. هنگامی که سرور باید هویت <em>client</em> (کلاینت) را تأیید کند، ما می‌خواهیم این کار تا حد امکان کارآمد باشد—من برخی از راه‌حل‌ها (از جمله راه‌حل‌هایی که توسط فروشندگان <em>API gateway</em> (دروازه <em>API</em>) ارائه می‌شوند) را دیده‌ام که شامل این است که سرور باید با سرویس‌های مرکزی تماس بگیرد تا هویت <em>client</em> (کلاینت) را بررسی کند، که وقتی پیامدهای تأخیر را در نظر می‌گیرید، بسیار احمقانه است.</p>
    <p>من در تلاش هستم که به یک موقعیت فکر کنم که در آن هویت <em>client</em> (کلاینت) را بدون تأیید هویت سرور تأیید کنم—برای تأیید هر دو، شما معمولاً در نهایت یک نوع احراز هویت متقابل را پیاده‌سازی می‌کنید. با احراز هویت متقابل، هر دو طرف یکدیگر را احراز هویت می‌کنند. بنابراین در شکل 11-6، <em>Order Processor</em> (پردازشگر سفارش) <em>Payment microservice</em> (ریز سرویس پرداخت) را احراز هویت می‌کند، و <em>Payment microservice</em> (ریز سرویس پرداخت)، <em>Order Processor</em> (پردازشگر سفارش) را احراز هویت می‌کند.</p>
    <p>ما می‌توانیم این کار را از طریق استفاده از <em>mutual TLS</em> (امنیت لایه انتقال متقابل) انجام دهیم، که در این صورت هم <em>client</em> (کلاینت) و هم سرور از گواهی‌نامه‌ها استفاده می‌کنند. در اینترنت عمومی، تأیید هویت یک دستگاه <em>client</em> (کلاینت) معمولاً کمتر از تأیید هویت انسانی است که از آن دستگاه استفاده می‌کند. به همین دلیل، <em>mutual TLS</em> (امنیت لایه انتقال متقابل) به ندرت استفاده می‌شود. اما در معماری <em>microservice</em> (ریز سرویس) ما، به خصوص جایی که ممکن است در یک محیط <em>zero-trust</em> (اعتماد صفر) عمل کنیم، این بسیار رایج‌تر است.</p>
    <p>چالش پیاده‌سازی طرح‌هایی مانند <em>mutual TLS</em> (امنیت لایه انتقال متقابل) از نظر تاریخی، <em>tooling</em> (ابزارسازی) بوده است. امروزه این یک مسئله کمتری است. ابزارهایی مانند <em>Vault</em> می‌توانند توزیع گواهی‌نامه‌ها را بسیار آسان‌تر کنند، و تمایل به ساده‌سازی استفاده از <em>mutual TLS</em> (امنیت لایه انتقال متقابل) یکی از دلایل اصلی برای پیاده‌سازی <em>service meshes</em> (مش‌های سرویس) توسط افراد است، که ما در "<em>Service Meshes and API Gateways</em>" در صفحه 162 بررسی کردیم.</p>
    <h5>Visibility of data (دید داده‌ها)</h5>
    <p>وقتی داده‌ها را از یک <em>microservice</em> (ریز سرویس) به دیگری ارسال می‌کنیم، آیا کسی می‌تواند داده‌ها را مشاهده کند؟ برای برخی از اطلاعات، مانند قیمت آلبوم‌های <em>Peter Andre</em>، ممکن است ما زیاد اهمیت ندهیم زیرا داده‌ها در حال حاضر در حوزه عمومی هستند. از طرف دیگر، برخی از داده‌ها ممکن است شامل <em>PII</em> (اطلاعات شناسایی شخصی) باشند، که ما باید مطمئن شویم که محافظت می‌شوند.</p>
    <p><em>Securing Data | 371</em></p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>