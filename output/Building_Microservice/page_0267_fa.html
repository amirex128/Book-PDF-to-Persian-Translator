<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 267</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   مشکل مجازی سازی نوع 2 این است که هایپروایزر در اینجا نیاز دارد
   منابعی را برای انجام کارش کنار بگذارید. این <span style="color:blue">CPU</span>، <span style="color:blue">I/O</span> و حافظه ای را می گیرد که می تواند مورد استفاده قرار گیرد
   جای دیگری. هر چه میزبان هایپروایزر بیشتر مدیریت کند، به منابع بیشتری نیاز دارد. در یک
   یک نقطه خاص، این سربار به یک محدودیت در تقسیم زیرساخت فیزیکی شما تبدیل می شود
   ساختار بیشتر در عمل، این بدان معناست که اغلب بازدهی کاهنده وجود دارد
   در برش یک جعبه فیزیکی به قسمت های کوچکتر و کوچکتر، زیرا به نسبت بیشتر
   و منابع بیشتر وارد سربار هایپروایزر می شود.
  </p>
  <h4>برای <span style="color:blue">microservice</span> ها خوب است؟</h4>
  <p>
   با بازگشت به اصول ما، ماشین های مجازی از نظر انزوا بسیار خوب عمل می کنند،
   اما با هزینه. سهولت اتوماسیون آنها می تواند بر اساس فناوری دقیقی که مورد استفاده قرار می گیرد متفاوت باشد
   استفاده شده - <span style="color:blue">VM</span> های مدیریت شده در <span style="color:blue">Google Cloud</span>، <span style="color:blue">Azure</span>، یا <span style="color:blue">AWS</span>، به عنوان مثال، همه آسان هستند
   اتوماتیک کردن از طریق <span style="color:blue">API</span> های خوب پشتیبانی شده و یک اکوسیستم ابزاری که بر اساس این <span style="color:blue">API</span> ها ساخته شده است.
   علاوه بر این، این پلتفرم ها مفاهیمی مانند گروه های <span style="color:blue">autoscaling</span> را ارائه می دهند و به اجرا کمک می کنند
   مدیریت حالت مورد نظر استقرار بدون توقف قرار است کار بیشتری را انجام دهد، اما اگر
   پلتفرم <span style="color:blue">VM</span> که از آن استفاده می کنید، یک <span style="color:blue">API</span> خوب به شما می دهد، بلوک های ساختمانی وجود دارد.
   مسئله این است که بسیاری از مردم از <span style="color:blue">VM</span> های مدیریت شده ارائه شده توسط
   پلتفرم های مجازی سازی سنتی مانند آنهایی که توسط
   <span style="color:blue">VMware</span>، که، در حالی که از نظر تئوری ممکن است امکان اتوماسیون را فراهم کند، معمولاً نیست
   در این زمینه استفاده می شود. در عوض این پلتفرم ها تمایل دارند تحت کنترل مرکزی یک
   تیم عملیاتی اختصاصی، و توانایی اتوماسیون مستقیم در برابر آنها می تواند باشد
   در نتیجه محدود شد.
  </p>
  <p>
   اگرچه کانتینرها به طور کلی برای <span style="color:blue">microservice</span> ها محبوب تر می شوند
   بارهای کاری، بسیاری از سازمان ها از ماشین های مجازی برای اجرای در مقیاس بزرگ استفاده کرده اند
   سیستم های <span style="color:blue">microservice</span>، با اثر عالی. <span style="color:blue">Netflix</span>، یکی از بچه های پوستر برای <span style="color:blue">microser</span>-
   <span style="color:blue">vices</span>، بخش بزرگی از <span style="color:blue">microservice</span> های خود را بر روی ماشین های مجازی مدیریت شده <span style="color:blue">AWS</span> ساخت
   از طریق <span style="color:blue">EC2</span>. اگر به سطوح انزوای سخت تری که می توانند بیاورند نیاز دارید، یا شما ندارید
   توانایی <span style="color:blue">containerize</span> کردن برنامه خود را، <span style="color:blue">VM</span> ها می توانند یک انتخاب عالی باشند.
  </p>
  <h4>کانتینرها</h4>
  <p>
   از زمان انتشار اولین ویرایش این کتاب، کانتینرها به یک مفهوم غالب در
   استقرار نرم افزار سمت سرور و برای بسیاری انتخاب واقعی برای بسته بندی
   و اجرای معماری <span style="color:blue">microservice</span> ها. مفهوم کانتینر، که محبوبیت یافت
   <span style="color:blue">Docker</span>، و متحد با یک پلتفرم ارکستراسیون کانتینر پشتیبانی کننده مانند <span style="color:blue">Kuber</span>-
   <span style="color:blue">netes</span>، به انتخاب بسیاری از مردم برای اجرای معماری <span style="color:blue">microservice</span> ها تبدیل شده است
   در مقیاس.
  </p>
  <p>
   قبل از اینکه به دلیل وقوع این اتفاق و رابطه بین کانتینرها برسیم،
   <span style="color:blue">Kubernetes</span> و <span style="color:blue">Docker</span>، ابتدا باید بررسی کنیم که دقیقاً یک کانتینر چیست و نگاه کنیم
   به طور خاص چگونه با ماشین های مجازی متفاوت است.
  </p>
  <p>
   گزینه های استقرار
   |
   241
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>