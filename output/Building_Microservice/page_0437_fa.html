<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 437</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>خواندن در گره‌های متعدد <em>database</em> (پایگاه داده) برای اطمینان از <em>consistency</em> (انسجام). اما به‌طور کلی مردم <em>transactional reads</em> (خوانش تراکنشی) انجام نمی‌دهند، آیا انجام می‌دهند؟ زیرا <em>transactional reads</em> (خوانش تراکنشی) کند هستند. آنها به قفل نیاز دارند. یک خواندن می‌تواند یک سیستم کامل را مسدود کند.</p>
    <p>همانطور که قبلاً بحث کردیم، سیستم‌های توزیع‌شده باید انتظار شکست را داشته باشند. <em>transactional read</em> (خوانش تراکنشی) ما را در یک مجموعه از گره‌های منسجم در نظر بگیرید. من از یک گره از راه دور می‌خواهم تا یک رکورد معین را در حالی که خواندن آغاز می‌شود، قفل کند. من خواندن را تکمیل می‌کنم و از گره از راه دور می‌خواهم که قفل خود را رها کند، اما اکنون من نمی‌توانم با آن صحبت کنم. اکنون چه اتفاقی می‌افتد؟ حتی درست کردن قفل‌ها در یک سیستم تک فرآیندی واقعاً دشوار است و پیاده‌سازی خوب آنها در یک سیستم توزیع‌شده به‌طور قابل‌توجهی دشوارتر است.</p>
    <p>به یاد دارید که ما در فصل 6 در مورد <em>distributed transactions</em> (تراکنش‌های توزیع‌شده) صحبت کردیم؟ دلیل اصلی دشوار بودن آنها به دلیل این مشکل در اطمینان از <em>consistency</em> (انسجام) در گره‌های متعدد است.</p>
    <p>درست کردن <em>consistency</em> (انسجام) چند گره‌ای واقعاً سخت است، بنابراین من قویاً، قویاً پیشنهاد می‌کنم که اگر به آن نیاز دارید، سعی نکنید آن را خودتان اختراع کنید. در عوض، یک انبار داده یا سرویس قفل را انتخاب کنید که این ویژگی‌ها را ارائه می‌دهد. به عنوان مثال، <em>Consul</em>، که ما در "<em>Dynamic Service Registries</em>" در صفحه 159 در مورد آن بحث کردیم، یک انبار کلید-مقدار با <em>consistency</em> (انسجام) قوی پیاده‌سازی می‌کند که برای به اشتراک گذاشتن پیکربندی بین گره‌های متعدد طراحی شده است. همراه با "دوستان به دوستان اجازه نمی‌دهند که رمزنگاری خود را بنویسند" باید "دوستان به دوستان اجازه نمی‌دهند که انبار داده‌های منسجم توزیع‌شده خود را بنویسند." را اضافه کرد. اگر شما فکر می‌کنید که نیاز دارید که انبار داده <em>CP</em> خود را بنویسید، ابتدا تمام مقالات این موضوع را بخوانید، سپس دکترا بگیرید، و سپس مشتاقانه منتظر باشید که چند سال را صرف اشتباه انجام دادن آن کنید. در ضمن، من از چیزی که از قفسه خارج شده استفاده می‌کنم که این کار را برای من انجام می‌دهد، یا به احتمال زیاد تلاش می‌کنم سیستم‌های <em>AP</em> با <em>eventually consistent</em> (سازگاری نهایی) را بسازم.</p>
    <h5>Sacrificing Partition Tolerance (قربانی کردن تحمل پارتیشن)؟</h5>
    <p>ما باید دو مورد را انتخاب کنیم، درست است؟ بنابراین ما سیستم <em>AP</em> با <em>eventually consistent</em> (سازگاری نهایی) خود را داریم. ما سیستم <em>CP</em> منسجم اما دشوار برای ساخت و مقیاس‌بندی خود را داریم. چرا یک سیستم <em>CA</em> (منسجم و در دسترس) نه؟ خوب، ما چگونه می‌توانیم <em>partition tolerance</em> (تحمل پارتیشن) را قربانی کنیم؟ اگر سیستم ما هیچ <em>partition tolerance</em> (تحمل پارتیشن) نداشته باشد، نمی‌تواند بر روی یک شبکه اجرا شود. به عبارت دیگر، باید یک فرآیند واحد باشد که به‌صورت محلی کار می‌کند. سیستم‌های <em>CA</em> در سیستم‌های توزیع‌شده وجود ندارند.</p>
    <h5>AP or CP? (AP یا CP؟)</h5>
    <p>کدام درست است، <em>AP</em> یا <em>CP</em>؟ خوب، واقعیت این است که این بستگی دارد. به عنوان افرادی که سیستم را می‌سازیم، ما می‌دانیم که این مبادله وجود دارد. ما می‌دانیم که سیستم‌های <em>AP</em> راحت‌تر مقیاس می‌شوند و ساخت آنها ساده‌تر است، و ما می‌دانیم که یک سیستم <em>CP</em> به دلیل چالش‌های پشتیبانی از <em>distributed consistency</em> (انسجام توزیع‌شده) به کار بیشتری نیاز دارد. اما ما ممکن است تأثیر تجاری این <em>trade-off</em> (مبادله) را درک نکنیم. برای سیستم انبار ما، اگر یک رکورد پنج دقیقه از تاریخ گذشته باشد، آیا این مشکلی ندارد؟ اگر پاسخ مثبت است، یک سیستم <em>AP</em> ممکن است راه‌حل باشد. اما در مورد موجودی نگه داشته شده برای یک مشتری در یک بانک چطور؟ آیا این می‌تواند از تاریخ گذشته باشد؟ بدون دانستن زمینه‌ای که عملیات در آن استفاده می‌شود، ما نمی‌توانیم</p>
    <p><em>CAP Theorem | 411</em></p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>