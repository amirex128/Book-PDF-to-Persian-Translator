<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 430</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>به حالت عادی برگردند. نوشتن فرآیند برای باز و بسته کردن دستی یک <em>circuit breaker</em> (مدارشکن) به عنوان بخشی از یک فرآیند استقرار خودکار می‌تواند یک گام منطقی بعدی باشد.</p>
    <p><em>Circuit breakers</em> (مدارشکن‌ها) به <em>application</em> (برنامه) ما کمک می‌کنند سریع شکست بخورد—و سریع شکست خوردن همیشه بهتر از شکست کند است. <em>Circuit breakers</em> (مدارشکن‌ها) به ما اجازه می‌دهند قبل از اینکه زمان (و منابع) ارزشمند خود را صرف انتظار برای پاسخگویی یک <em>microservice</em> (ریز سرویس) ناسالم کنیم، شکست بخوریم. به جای اینکه منتظر بمانیم تا ما از <em>microservice</em> (ریز سرویس) پایین‌دستی استفاده کنیم تا شکست بخوریم، ما می‌توانیم وضعیت <em>circuit breakers</em> (مدارشکن‌های) خود را زودتر بررسی کنیم. اگر یک <em>microservice</em> (ریز سرویس) که ما در یک عملیات به آن تکیه می‌کنیم، در حال حاضر در دسترس نباشد، ما می‌توانیم عملیات را قبل از اینکه حتی شروع کنیم، متوقف کنیم.</p>
    <h5>Isolation (انزوا)</h5>
    <p>هرچه یک <em>microservice</em> (ریز سرویس) بیشتر به در دسترس بودن <em>microservice</em> (ریز سرویس) دیگری وابسته باشد، سلامت یکی بر توانایی دیگری در انجام کار خود تأثیر می‌گذارد. اگر ما بتوانیم از فناوری‌ای استفاده کنیم که به یک سرور پایین‌دستی اجازه می‌دهد که آفلاین باشد، به عنوان مثال، از طریق استفاده از <em>middleware</em> (میان‌افزار) یا نوع دیگری از سیستم بافر تماس، <em>microservices</em> (ریز سرویس‌های) بالادستی احتمال کمتری دارد که تحت تأثیر قطعی‌ها، برنامه‌ریزی شده یا برنامه‌ریزی نشده، <em>microservices</em> (ریز سرویس‌های) پایین‌دستی قرار گیرند.</p>
    <p>یک مزیت دیگر برای افزایش انزوا بین <em>services</em> (سرویس‌ها) وجود دارد. هنگامی که <em>services</em> (سرویس‌ها) از یکدیگر جدا می‌شوند، هماهنگی بسیار کمتری بین مالکان <em>service</em> (سرویس) مورد نیاز است. هرچه هماهنگی کمتری بین تیم‌ها مورد نیاز باشد، آن تیم‌ها استقلال بیشتری دارند، زیرا آنها قادر به عملکرد و تکامل <em>services</em> (سرویس‌های) خود به طور آزادانه‌تری هستند.</p>
    <p>انزوا همچنین از نظر چگونگی حرکت ما از منطقی به فیزیکی اعمال می‌شود. دو <em>microservices</em> (ریز سرویس) را در نظر بگیرید که به نظر می‌رسد کاملاً از یکدیگر جدا شده‌اند. آنها به هیچ وجه با یکدیگر ارتباط برقرار نمی‌کنند. یک مشکل با یکی از آنها نباید بر دیگری تأثیر بگذارد، درست است؟ اما اگر هر دو <em>microservices</em> (ریز سرویس‌ها) روی یک میزبان اجرا شوند، و یکی از <em>microservices</em> (ریز سرویس‌ها) شروع به استفاده از تمام <em>CPU</em> کند، و باعث ایجاد مشکل در آن میزبان شود، چه؟</p>
    <p>یک مثال دیگر را در نظر بگیرید. دو <em>microservices</em> (ریز سرویس) هر کدام <em>database</em> (پایگاه داده) منطقاً جداگانه خود را دارند. اما هر دو <em>databases</em> (پایگاه‌های داده) در همان زیرساخت <em>database</em> (پایگاه داده) مستقر شده‌اند. یک شکست در آن زیرساخت <em>database</em> (پایگاه داده) بر هر دو <em>microservices</em> (ریز سرویس‌ها) تأثیر می‌گذارد.</p>
    <p>وقتی ما در نظر می‌گیریم که چگونه می‌خواهیم <em>microservices</em> (ریز سرویس‌های) خود را مستقر کنیم، ما همچنین می‌خواهیم تلاش کنیم تا درجه‌ای از جداسازی شکست را تضمین کنیم تا از مشکلاتی مانند این جلوگیری کنیم. به عنوان مثال، اطمینان از اینکه <em>microservices</em> (ریز سرویس‌ها) در میزبان‌های مستقل با سیستم عامل و منابع محاسباتی خود در حال اجرا هستند، یک گام منطقی است—این همان چیزی است که ما هنگام اجرای نمونه‌های <em>microservice</em> (ریز سرویس) در ماشین مجازی یا <em>container</em> (کانتینر) خود به آن می‌رسیم. با این حال، این نوع انزوا می‌تواند هزینه‌بر باشد.</p>
    <p>ما می‌توانیم <em>microservices</em> (ریز سرویس‌های) خود را با اجرای آنها در ماشین‌های مختلف، به‌طور مؤثرتری از یکدیگر جدا کنیم. این به این معنی است که ما به زیرساخت و <em>tooling</em> (ابزارسازی) بیشتری برای مدیریت آن زیرساخت نیاز داریم. این یک هزینه مستقیم دارد و همچنین می‌تواند به پیچیدگی سیستم ما افزوده و راه‌های جدیدی از شکست احتمالی را آشکار کند. هر <em>microservice</em> (ریز سرویس) می‌تواند داشته باشد</p>
    <p><em>404 | Chapter 12: Resiliency</em></p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>