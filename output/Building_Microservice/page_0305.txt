to stick with the unit and service names despite their ambiguity, but much prefer call‐
ing UI tests end-to-end tests, which I’ll do from this point forward.
Virtually every team I’ve worked on has used different names for tests than the ones
that Cohn uses in the pyramid. Whatever you call them, the key takeaway is that you
will want functional automated tests of different scope for different purposes.
Given the confusion, it’s worth looking at what these different layers mean.
Let’s look at a worked example. In Figure 9-3, we have our helpdesk application and
our main website, both of which are interacting with our Customer microservice to
retrieve, review, and edit customer details. Our Customer microservice is in turn talk‐
ing to our Loyalty microservice, where our customers accrue points by buying Justin
Bieber CDs. Probably. This is obviously a sliver of our overall MusicCorp system, but
it is a good enough slice for us to dive into a few different scenarios we may want to
test.
Figure 9-3. Part of our music shop under test
Unit Tests
Unit tests typically test a single function or method call. The tests generated as a side
effect of test-driven design (TDD) will fall into this category, as do the sorts of tests
generated by techniques such as property-based testing. We’re not launching micro‐
services here and are limiting the use of external files or network connections. In gen‐
eral, you want a large number of these sorts of tests. Done right, they are very, very
fast, and on modern hardware you could expect to run many thousands of these in
less than a minute. I know many people who have these tests running automatically
when files are changed locally—especially with interpreted languages, this can give
very fast feedback cycles.
Unit tests help us developers and thus would be technology facing, not business fac‐
ing, in Marick’s terminology. They are also where we hope to catch most of our bugs.
Test Scope 
| 
279
