<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 490</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>الگو: <strong>Frontend Monolithic</strong> (ادامه)</h4>

  <p>3 <em>Cam Jackson</em>, “Micro Frontends,” martinfowler.com, June 19, 2019, <a href="https://oreil.ly/U3K40">https://oreil.ly/U3K40</a>.</p>

  <p>این مدل رایج‌ترین مدل برای افرادی است که برنامه‌های <strong>monolithic single-page</strong> را می‌سازند، که اغلب با یک تیم <strong>frontend</strong> اختصاصی همراه است. الزامات <strong>microservices</strong> ما بسیار ساده است—آنها فقط باید اطلاعات را به شکلی به اشتراک بگذارند که به راحتی توسط <strong>UI</strong> تفسیر شود. در مورد یک <strong>UI</strong> مبتنی بر وب، این بدان معناست که <strong>microservices</strong> ما احتمالاً باید داده‌ها را در یک قالب متنی ارائه کنند، که <strong>JSON</strong> محتمل‌ترین انتخاب است. سپس <strong>UI</strong> باید اجزای مختلفی را که رابط را تشکیل می‌دهند، ایجاد کند، و هماهنگ‌سازی وضعیت و موارد مشابه را با <strong>backend</strong> انجام دهد. استفاده از یک پروتکل باینری برای ارتباط <em>service-to-service</em> برای <strong>clients</strong> مبتنی بر وب دشوارتر خواهد بود، اما می‌تواند برای دستگاه‌های تلفن همراه بومی یا برنامه‌های دسکتاپ "<strong>thick</strong>" خوب باشد.</p>

  <h4>چه زمانی از آن استفاده کنیم</h4>

  <p>چند اشکال برای این رویکرد وجود دارد. اولاً، با توجه به ماهیت آن به عنوان یک موجودیت <strong>monolithic</strong>، می‌تواند به یک محرک برای (یا توسط) یک تیم <strong>frontend</strong> اختصاصی تبدیل شود. داشتن چندین تیم که مسئولیت این <strong>frontend monolithic</strong> را به اشتراک می‌گذارند، به دلیل منابع متعدد اختلاف، می‌تواند چالش‌برانگیز باشد. ثانیاً، ما توانایی کمی برای تنظیم پاسخ‌ها برای انواع مختلف دستگاه‌ها داریم. اگر از فناوری وب استفاده می‌کنیم، می‌توانیم طرح‌بندی یک صفحه را تغییر دهیم تا محدودیت‌های دستگاه‌های مختلف را در خود جای دهد، اما این لزوماً به تغییر تماس‌هایی که با <strong>microservices</strong> پشتیبان برقرار می‌شود، گسترش نمی‌یابد. <strong>client</strong> تلفن همراه من ممکن است فقط بتواند 10 فیلد از یک سفارش را نمایش دهد، اما اگر <strong>microservice</strong> تمام صد فیلد سفارش را دریافت کند، ما در نهایت داده‌های غیرضروری را بازیابی می‌کنیم.</p>

  <p>یک راه‌حل برای این رویکرد این است که رابط کاربری مشخص کند که هنگام درخواست، چه فیلدهایی را باید دریافت کند، اما این فرض را دارد که هر <strong>microservice</strong> پشتیبان از این شکل تعامل پشتیبانی می‌کند. در "<em>GraphQL</em>" در صفحه 488، ما به چگونگی استفاده از هر دو الگوی <strong>backend for frontend</strong> و <strong>GraphQL</strong> در این مورد نگاه خواهیم کرد.</p>

  <p>واقعاً، این الگو زمانی بهترین عملکرد را دارد که شما بخواهید تمام پیاده‌سازی و رفتار <strong>UI</strong> خود را در یک واحد قابل استقرار داشته باشید. برای یک تیم واحد که هم <strong>frontend</strong> و هم تمام <strong>microservices</strong> پشتیبان را توسعه می‌دهد، این ممکن است خوب باشد. شخصاً، اگر بیش از یک تیم روی <strong>software</strong> شما کار می‌کند، فکر می‌کنم شما باید با آن تمایل مبارزه کنید، زیرا می‌تواند منجر به این شود که شما به یک معماری لایه‌ای با <em>silos</em> سازمانی مرتبط با آن بلغزید. با این حال، اگر شما قادر به اجتناب از یک معماری لایه‌ای و ساختار سازمانی منطبق نیستید، این احتمالاً الگویی است که در نهایت از آن استفاده خواهید کرد.</p>

  <h4>الگو: <strong>Micro Frontends</strong></h4>

  <p>رویکرد <strong>micro frontend</strong> یک الگوی سازمانی است که به موجب آن می‌توان بر روی بخش‌های مختلفی از یک <strong>frontend</strong> کار کرد و آنها را به طور مستقل مستقر کرد. برای نقل قول از یک مقاله بسیار توصیه شده توسط <em>Cam Jackson</em> در این زمینه،3 ما می‌توانیم <strong>micro frontends</strong> را به عنوان</p>

  <p>464 | فصل 14: رابط‌های کاربری</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>