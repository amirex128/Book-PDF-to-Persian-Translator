<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 573</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>پلتفرم در مقیاس بزرگ</h4>

  <p>استفاده از قالب‌ها و فریم‌ورک‌های <strong>microservice</strong> داخلی، اغلب در سازمان‌هایی یافت می‌شود که تعداد زیادی <strong>microservices</strong> دارند. <em>Netflix</em> و <em>Monzo</em> دو نمونه از این سازمان‌ها هستند. هر کدام تصمیم گرفته‌اند که <em>technology stack</em> خود را تا حدودی استاندارد کنند (<em>JVM</em> در مورد <em>Netflix</em>، <em>Go</em> از نظر <em>Monzo</em>)، که به آنها اجازه می‌دهد تا ایجاد یک <strong>microservice</strong> جدید با رفتار استاندارد و مورد انتظار با استفاده از یک مجموعه ابزار مشترک را سرعت بخشند. با یک <em>technology stack</em> متنوع‌تر، داشتن یک قالب <strong>microservice</strong> استاندارد برای نیازهای خودتان دشوارتر می‌شود.</p>

  <p>اگر شما می‌خواهید <em>technology stacks</em> متعدد و متفاوتی را بپذیرید، شما به یک قالب <strong>microservice</strong> منطبق برای هر کدام نیاز دارید. این می‌تواند راهی برای محدود کردن ظریف انتخاب زبان در تیم‌های شما باشد. اگر قالب <strong>microservice</strong> داخلی فقط از <em>JVM</em> پشتیبانی می‌کند، در این صورت ممکن است افراد از انتخاب <em>stacks</em> جایگزین منصرف شوند، اگر مجبور باشند کارهای بیشتری را خودشان انجام دهند. به عنوان مثال، <em>Netflix</em> به‌ویژه نگران جنبه‌هایی مانند تحمل خطا است تا اطمینان حاصل شود که از کار افتادن یک بخش از سیستم آن نمی‌تواند همه چیز را از بین ببرد. برای رسیدگی به این موضوع، کارهای زیادی انجام شده است تا اطمینان حاصل شود که کتابخانه‌های <strong>client</strong> در <em>JVM</em> وجود دارد تا ابزارهایی را که تیم‌ها برای حفظ رفتار خوب <strong>microservice</strong> خود نیاز دارند، در اختیار آنها قرار دهد. معرفی یک <em>technology stack</em> جدید به معنای نیاز به بازتولید تمام این تلاش‌ها است. نگرانی اصلی <em>Netflix</em> کمتر در مورد تلاش تکراری است و بیشتر در مورد این واقعیت است که اشتباه گرفتن این موضوع بسیار آسان است.
   اگر <strong>microservice</strong> خطای تحمل <em>newly implemented</em> را اشتباه بگیرد، خطر زیادی وجود دارد اگر بتواند بر بخش‌های بیشتری از سیستم تأثیر بگذارد. <em>Netflix</em> با استفاده از "سرویس‌های <em>sidecar</em>" این موضوع را کاهش می‌دهد، که به صورت محلی با یک <em>JVM</em> ارتباط برقرار می‌کنند که از کتابخانه‌های مناسب استفاده می‌کند.</p>

  <p><em>Service meshes</em> یک راه بالقوه دیگر برای حذف رفتار مشترک به ما داده‌اند. برخی از عملکردهایی که معمولاً به عنوان مسئولیت یک <strong>microservice</strong> داخلی دیده می‌شد، اکنون می‌تواند به یک <em>microservice mesh</em> منتقل شود. این می‌تواند ثبات بیشتری را در رفتار در سراسر <strong>microservices</strong> نوشته شده در زبان‌های برنامه‌نویسی مختلف تضمین کند و همچنین مسئولیت‌های این قالب‌های <strong>microservice</strong> را کاهش دهد.</p>

  <h4><em>Technical Debt</em></h4>

  <p>ما اغلب در موقعیت‌هایی قرار می‌گیریم که نمی‌توانیم حرف به حرف از چشم‌انداز فنی خود پیروی کنیم. اغلب، ما باید انتخابی برای کوتاه کردن برخی از گوشه‌ها برای دریافت برخی از ویژگی‌های فوری داشته باشیم. این فقط یک مبادله دیگر است که ما خود را مجبور به انجام آن می‌دانیم. چشم‌انداز فنی ما به یک دلیل وجود دارد. اگر ما از این دلیل منحرف شویم، ممکن است یک مزیت کوتاه‌مدت داشته باشد اما هزینه‌ای بلندمدت داشته باشد. مفهومی که به ما در درک این مبادله کمک می‌کند، <em>technical debt</em> است. هنگامی که ما <em>technical debt</em> جمع می‌کنیم، درست مانند بدهی در دنیای واقعی، هزینه‌ای مداوم دارد و چیزی است که ما می‌خواهیم آن را پرداخت کنیم.</p>

  <p>گاهی اوقات <em>technical debt</em>، چیزی نیست که ما فقط با میانبر زدن ایجاد می‌کنیم. اگر دیدگاه ما برای سیستم تغییر کند، اما تمام سیستم ما مطابقت نداشته باشد، چه اتفاقی می‌افتد؟ در این شرایط نیز ما منابع جدیدی از <em>technical debt</em> ایجاد کرده‌ایم.</p>

  <p><em>Technical Debt</em> | 547</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>