<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 93</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   تغییرات سازمانی، فقط مستلزم این می‌شود که مالک یک microservice موجود تغییر کند. وضعیتی را در نظر بگیرید که در آن تیمی که مسئول عملیات انبارداری بود، قبلاً <strong>functionality</strong> را در اطراف تعیین تعداد اقلامی که باید از تامین‌کنندگان سفارش داده شوند، مدیریت می‌کرد. بیایید بگوییم که ما تصمیم گرفتیم این مسئولیت را به یک تیم پیش‌بینی اختصاصی منتقل کنیم که می‌خواهد اطلاعاتی را از فروش فعلی و تبلیغات برنامه‌ریزی‌شده برای تعیین آنچه که باید سفارش داده شود، بیرون بکشد. اگر تیم انبارداری یک microservice سفارش‌دهی تامین‌کننده اختصاصی داشت، این می‌توانست به سادگی به تیم پیش‌بینی جدید منتقل شود. از سوی دیگر، اگر این <strong>functionality</strong> قبلاً در یک سیستم با دامنه بزرگتر که متعلق به انبارداری بود، یکپارچه شده بود، در این صورت ممکن است لازم باشد که آن را تقسیم کنیم.
  </p>
  <p>
   حتی زمانی که ما در یک ساختار سازمانی موجود کار می‌کنیم، این خطر وجود دارد که ما <strong>boundaries</strong> خود را در جای مناسب قرار ندهیم. سال‌ها پیش، من و چند همکار در کالیفرنیا با یک مشتری کار می‌کردیم و به شرکت کمک می‌کردیم تا برخی از روش‌های کدنویسی پاک‌تر را اتخاذ کند و بیشتر به سمت <strong>automated testing</strong> حرکت کند. ما با مقداری از <strong>low-hanging fruit</strong>، مانند تجزیه <strong>service</strong> شروع کرده بودیم، که متوجه چیز نگران‌کننده‌تری شدیم. من نمی‌توانم به جزئیات زیادی در مورد آنچه برنامه انجام می‌داد بپردازم، اما این یک برنامه عمومی با یک پایگاه مشتری بزرگ و جهانی بود.
  </p>
  <p>
   تیم و سیستم، رشد کرده بودند. در اصل، دیدگاه یک نفر بود، سیستم ویژگی‌های بیشتری را در بر گرفته بود، و کاربران بیشتری را به خود اختصاص داده بود. سرانجام، سازمان تصمیم گرفت تا با داشتن یک گروه جدید از توسعه‌دهندگان مستقر در برزیل که بخشی از کار را بر عهده داشتند، ظرفیت تیم را افزایش دهد. سیستم تقسیم شد، و نیمه جلویی برنامه اساساً بدون <strong>state</strong> بود، و وب‌سایت عمومی را پیاده‌سازی می‌کرد، همانطور که در شکل 2-19 نشان داده شده است. نیمه پشتی سیستم به سادگی یک رابط <strong>remote procedure call (RPC)</strong> بر روی یک انبار داده بود. اساساً، تصور کنید که شما یک لایه <strong>repository</strong> را در <strong>codebase</strong> خود گرفته‌اید و این را یک <strong>service</strong> جداگانه کرده‌اید.
  </p>
  <p>
   تغییرات اغلب باید در هر دو <strong>services</strong> ایجاد می‌شد. هر دو <strong>services</strong> از نظر فراخوانی متدهای سطح پایین و سبک <strong>RPC</strong> صحبت می‌کردند، که بیش از حد شکننده بودند (ما این موضوع را در فصل 4 بیشتر مورد بحث قرار خواهیم داد). <strong>service interface</strong> نیز بسیار پرحرف بود، که منجر به مشکلات عملکردی شد. این امر منجر به نیاز به مکانیزم‌های <strong>RPC-batching</strong> مفصل شد. من این را "معماری پیاز" نامیدم، زیرا لایه‌های زیادی داشت و وقتی مجبور شدیم از آن عبور کنیم، گریه کردم.
  </p>
  <p>
   حالا، در ظاهر، ایده تقسیم سیستم قبلاً <strong>monolithic</strong> در امتداد خطوط جغرافیایی/سازمانی کاملاً منطقی است، همانطور که در فصل 15 در مورد آن بحث خواهیم کرد. با این حال، در اینجا، به جای گرفتن یک برش عمودی و متمرکز بر <strong>business</strong> از طریق <strong>stack</strong>، تیم چیزی را انتخاب کرد که قبلاً یک <strong>API</strong> در حال پردازش بود و یک برش افقی ایجاد کرد. یک مدل بهتر این بود که تیم در کالیفرنیا یک برش عمودی end-to-end داشته باشد، که شامل بخش‌های مرتبط <strong>frontend</strong> و <strong>data access functionality</strong> می‌شد، با تیم در برزیل که برش دیگری را می‌گرفت.
  </p>
  <p>Alternatives to Business Domain Boundaries | 67</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>