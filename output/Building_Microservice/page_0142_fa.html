<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 142</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>احتیاط کنید</h4>
  <p>
   برخی از این مطالب ناهمزمان، سرگرم‌کننده به نظر می‌رسند، درست است؟ به نظر می‌رسد که معماری‌های <strong>event-driven</strong> منجر به سیستم‌های بسیار <em>decoupled</em> و مقیاس‌پذیرتر می‌شوند. و می‌توانند این کار را انجام دهند. اما این سبک‌های ارتباطی منجر به افزایش پیچیدگی می‌شوند. این فقط پیچیدگی لازم برای مدیریت انتشار و اشتراک در پیام‌ها نیست، همانطور که ما فقط بحث کردیم، بلکه پیچیدگی در مشکلات دیگری نیز وجود دارد که ممکن است با آنها روبرو شویم. به عنوان مثال، هنگام در نظر گرفتن <strong>request-response</strong> <strong>async</strong> طولانی‌مدت، ما باید به این فکر کنیم که وقتی پاسخ برگشت، چه کاری انجام دهیم. آیا به همان <strong>node</strong> که درخواست را آغاز کرده است برمی‌گردد؟ اگر اینطور است، اگر آن <strong>node</strong> از کار افتاده باشد، چه اتفاقی می‌افتد؟ اگر نه، آیا من نیاز دارم که اطلاعات را در جایی ذخیره کنم تا بتوانم بر این اساس واکنش نشان دهم؟ <strong>Async</strong>های کوتاه‌مدت می‌تواند مدیریت آسان‌تری داشته باشند اگر <strong>APIs</strong> مناسبی دارید، اما با این وجود، این یک روش تفکر متفاوت برای برنامه‌نویسانی است که به فراخوانی‌های پیام <strong>synchronous</strong> درون فرآیندی عادت دارند.
  </p>
  <p>
   زمان یک داستان هشداردهنده فرا رسیده است. در سال 2006، من در حال کار بر روی ساخت یک سیستم قیمت‌گذاری برای یک بانک بودم. ما به رویدادهای بازار نگاه می‌کردیم و مشخص می‌کردیم که کدام کالاها در یک پرتفوی نیاز به قیمت‌گذاری مجدد دارند. هنگامی که فهرست مواردی را که باید بررسی می‌کردیم، مشخص کردیم، همه آنها را در یک صف پیام قرار دادیم. ما از یک شبکه برای ایجاد مجموعه‌ای از <strong>pricing workers</strong> استفاده می‌کردیم، که به ما امکان می‌داد مزرعه قیمت‌گذاری را در صورت درخواست مقیاس‌بندی کنیم.
  </p>
  <p>
   این <strong>workers</strong>ها از الگوی <strong>competing consumers</strong> استفاده می‌کردند، که هر کدام پیام‌ها را تا جایی که چیزی برای پردازش باقی نماند، با سرعت هر چه تمام‌تر می‌بلعیدند.
  </p>
  <p>
   با این حال، سیستم راه‌اندازی و در حال اجرا بود، و ما احساس غرور می‌کردیم. اما یک روز، درست پس از اینکه یک <strong>release</strong> را منتشر کردیم، به یک مشکل ناخوشایند برخورد کردیم: <strong>workers</strong>های ما مدام در حال از کار افتادن بودند.
  </p>
  <p>
   و از کار افتادن. و از کار افتادن.
  </p>
  <p>
   سرانجام، ما مشکل را ردیابی کردیم. یک باگ به وجود آمده بود که باعث می‌شد یک نوع خاص از درخواست قیمت‌گذاری باعث از کار افتادن یک <strong>worker</strong> شود. ما از یک صف <strong>transacted</strong> استفاده می‌کردیم: با از کار افتادن <strong>worker</strong>، قفل آن روی درخواست تمام شد، و درخواست قیمت‌گذاری دوباره در صف قرار گرفت—فقط برای اینکه <strong>worker</strong> دیگری آن را انتخاب کند و از کار بیفتد. این یک نمونه کلاسیک از چیزی بود که <strong>Martin Fowler</strong> آن را <strong>catastrophic failover</strong> می‌نامد.
  </p>
  <p>
   جدا از خود باگ، ما نتوانستیم یک محدودیت <strong>retry</strong> حداکثری را برای کار در صف مشخص کنیم. بنابراین ما باگ را برطرف کردیم، و یک <strong>retry</strong> حداکثری را پیکربندی کردیم. اما همچنین متوجه شدیم که به راهی برای مشاهده و احتمالاً پخش مجدد این پیام‌های بد نیاز داریم. ما در نهایت مجبور شدیم یک بیمارستان پیام (یا <strong>dead letter queue</strong>) را پیاده‌سازی کنیم، که در آن پیام‌ها در صورت شکست ارسال می‌شدند. ما همچنین یک <strong>UI</strong> برای مشاهده آن پیام‌ها و تکرار آنها در صورت نیاز ایجاد کردیم. این نوع مشکلات بلافاصله آشکار نمی‌شوند اگر شما فقط با ارتباط <strong>synchronous point-to-point</strong> آشنا هستید.
  </p>
  <p>
   پیچیدگی مرتبط با معماری‌های <strong>event-driven</strong> و برنامه‌نویسی ناهمزمان به طور کلی، من را بر این باور می‌کند که شما باید در مورد اینکه چقدر مشتاقانه این ایده‌ها را اتخاذ می‌کنید، محتاط باشید. اطمینان حاصل کنید که نظارت خوبی دارید، و استفاده از <strong>correlation IDs</strong> را به شدت در نظر بگیرید، که به شما امکان می‌دهد درخواست‌ها را در مرزهای فرآیند ردیابی کنید، همانطور که در فصل 10 به تفصیل بررسی خواهیم کرد.
  </p>
  <p>Pattern: Event-Driven Communication | 115</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>