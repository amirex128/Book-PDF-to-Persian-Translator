<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 515</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>الگو: <strong>Backend for Frontend (BFF)</strong> (ادامه)</h4>

  <p>کاهش <em>round trips</em>. یک <strong>query</strong> مانند این مستلزم آن است که ما انواع داده‌های مختلفی را که به آنها دسترسی داریم تعریف کنیم—تعریف صریح انواع، بخش کلیدی <em>GraphQL</em> است.</p>

  <p>برای پیاده‌سازی <em>GraphQL</em>، ما به یک <strong>resolver</strong> نیاز داریم تا <strong>queries</strong> را مدیریت کند. یک <strong>resolver GraphQL</strong> در سمت سرور قرار دارد و <strong>queries GraphQL</strong> را به تماس‌هایی برای دریافت اطلاعات، نگاشت می‌کند. بنابراین در مورد معماری <strong>microservice</strong>، ما به یک <strong>resolver</strong> نیاز داریم که قادر به نگاشت درخواست برای سفارش با <strong>ID</strong> 123 به یک تماس معادل با یک <strong>microservice</strong> باشد.</p>

  <p>به این ترتیب، ما می‌توانیم از <em>GraphQL</em> برای پیاده‌سازی یک <strong>aggregating gateway</strong>، یا حتی یک <strong>BFF</strong> استفاده کنیم. مزیت <em>GraphQL</em> این است که ما به راحتی می‌توانیم تجمیع و فیلتر کردن مورد نظر خود را به سادگی با تغییر <strong>query</strong> از سمت <strong>client</strong> تغییر دهیم. تا زمانی که انواع <em>GraphQL</em> از <strong>query</strong> مورد نظر ما پشتیبانی کنند، نیازی به تغییر در سمت سرور <em>GraphQL</em> نیست. اگر دیگر نمی‌خواستیم نام راننده را در <strong>query</strong> مثال مشاهده کنیم، می‌توانستیم به سادگی این را از خود <strong>query</strong> حذف کنیم و دیگر ارسال نمی‌شد. از سوی دیگر، اگر می‌خواستیم تعداد امتیازهایی را که برای این سفارش دریافت کرده‌ایم، ببینیم، با فرض اینکه این اطلاعات در نوع سفارش موجود است، می‌توانستیم این را به <strong>query</strong> اضافه کنیم و اطلاعات بازگردانده می‌شد. این یک مزیت قابل توجه نسبت به پیاده‌سازی‌های <strong>BFF</strong> است که نیاز به اعمال تغییرات در منطق تجمیع به خود <strong>BFF</strong> نیز دارد.</p>

  <p>انعطاف‌پذیری که <em>GraphQL</em> به دستگاه <strong>client</strong> می‌دهد تا به‌طور پویا <strong>queries</strong> را بدون تغییرات سمت سرور تغییر دهد، به این معنی است که احتمال کمتری وجود دارد که سرور <em>GraphQL</em> شما به یک منبع مشترک و مورد اختلاف تبدیل شود، همانطور که در مورد <strong>aggregating gateway</strong> با هدف عمومی بحث کردیم. با این حال، اگر شما نیاز به ارائه انواع جدید یا افزودن فیلدهایی به انواع موجود دارید، همچنان به تغییرات سمت سرور نیاز خواهید داشت. به این ترتیب، ممکن است همچنان به چندین <strong>backend</strong> سرور <em>GraphQL</em> نیاز داشته باشید تا با مرزهای تیم همسو شوید—بنابراین <em>GraphQL</em> به یک روش برای پیاده‌سازی یک <strong>BFF</strong> تبدیل می‌شود.</p>

  <p>من در مورد <em>GraphQL</em> نگرانی‌هایی دارم، که من آنها را با جزئیات در فصل 5 توضیح دادم. با این حال، این یک راه‌حل مناسب است که امکان <strong>querying</strong> پویا را برای مطابقت با نیازهای انواع مختلف رابط‌های کاربری فراهم می‌کند.</p>

  <h4>یک رویکرد ترکیبی</h4>

  <p>بسیاری از گزینه‌های ذکر شده نیازی نیست که <strong>one-size-fits-all</strong> باشند. من می‌توانم ببینم که یک سازمان رویکرد تجزیه مبتنی بر <strong>widget</strong> را برای ایجاد یک وب‌سایت اتخاذ می‌کند، اما هنگام استفاده از برنامه تلفن همراه خود، از رویکرد <strong>backend for frontend</strong> استفاده می‌کند. نکته کلیدی این است که ما باید انسجام قابلیت‌های اساسی را که به کاربران خود ارائه می‌دهیم، حفظ کنیم. ما باید اطمینان حاصل کنیم که منطق مرتبط با سفارش موسیقی یا تغییر جزئیات مشتری در داخل آن سرویس‌ها وجود دارد که آن عملیات را مدیریت می‌کنند و در سراسر سیستم ما پخش نمی‌شود. اجتناب از تله قرار دادن رفتار بیش از حد در هر لایه واسطه‌ای، یک عمل متعادل‌کننده دشوار است.</p>

  <p>یک رویکرد ترکیبی | 489</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>