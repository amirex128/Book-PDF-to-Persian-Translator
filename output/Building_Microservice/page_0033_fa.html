<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 33</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   3 برای معرفی عمیق به <strong>domain-driven design</strong>، کتاب <em>Domain-Driven Design</em> نوشته <strong>Eric Evans</strong> (Addison-Wesley) را ببینید—یا برای یک مرور کلی فشرده‌تر، کتاب <em>Domain-Driven Design Distilled</em> نوشته <strong>Vaughn Vernon</strong> (Addison-Wesley) را ببینید.
  </p>
  <p>
   تمایل به <strong>services</strong> <em>loosely coupled</em> با <strong>interfaces</strong> پایدار، تفکر ما را در مورد چگونگی یافتن <strong>microservice boundaries</strong> در وهله اول هدایت می‌کند.
  </p>
  <h4>مدل‌سازی شده حول یک <strong>Business Domain</strong></h4>
  <p>
   تکنیک‌هایی مانند <strong>domain-driven design</strong> می‌تواند به شما اجازه دهد تا کد خود را ساختاردهی کنید تا بهتر نشان‌دهنده <strong>real-world domain</strong> باشد که نرم‌افزار در آن کار می‌کند. 3 با معماری‌های microservice، ما از همین ایده برای تعریف <strong>service boundaries</strong> خود استفاده می‌کنیم. با مدل‌سازی <strong>services</strong> حول <strong>business domains</strong>، می‌توانیم راه‌اندازی قابلیت‌های جدید و ترکیب مجدد microservicesها را به روش‌های مختلف برای ارائه قابلیت‌های جدید به کاربرانمان آسان‌تر کنیم.
  </p>
  <p>
   راه‌اندازی یک ویژگی که نیاز به تغییراتی در بیش از یک microservice دارد، پرهزینه است. شما باید کار را در هر <strong>service</strong> (و به‌طور بالقوه در تیم‌های جداگانه) هماهنگ کنید و به دقت ترتیب استقرار نسخه‌های جدید این <strong>services</strong> را مدیریت کنید. این کار بسیار بیشتر از ایجاد همان تغییر در داخل یک <strong>service</strong> واحد (یا در داخل یک <strong>monolith</strong>، در این مورد) زمان می‌برد. بنابراین این نتیجه را دارد که ما می‌خواهیم راه‌هایی برای به حداقل رساندن تغییرات بین <strong>service</strong>ها پیدا کنیم.
  </p>
  <p>
   من اغلب معماری‌های لایه‌ای را می‌بینم، همانطور که معماری سه لایه در شکل 1-2 نشان داده شده است. در اینجا، هر لایه در معماری نشان دهنده یک <strong>service boundary</strong> متفاوت است، که هر <strong>service boundary</strong> بر اساس <strong>technical functionality</strong> مرتبط است. اگر من نیاز به ایجاد تغییری فقط در لایه ارائه در این مثال داشته باشم، این کار نسبتاً کارآمد خواهد بود. با این حال، تجربه نشان داده است که تغییرات در <strong>functionality</strong> معمولاً چندین لایه را در این نوع معماری‌ها در بر می‌گیرد—نیازمند تغییراتی در لایه‌های ارائه، برنامه و داده است. این مشکل در صورتی تشدید می‌شود که معماری حتی بیشتر از مثال ساده در شکل 1-2 لایه‌بندی شده باشد. اغلب هر لایه به لایه‌های بیشتر تقسیم می‌شود.
  </p>
  <p>
   با ایجاد <strong>services</strong> ما، برش‌های end-to-end از <strong>business functionality</strong>، ما اطمینان می‌دهیم که معماری ما به گونه‌ای تنظیم شده است که تغییرات در <strong>business functionality</strong> را تا حد امکان کارآمد کند. مسلماً، با microservices ما تصمیم گرفته‌ایم که <em>cohesion</em> بالای <strong>business functionality</strong> را بر <em>cohesion</em> بالای <strong>technical functionality</strong> اولویت دهیم.
  </p>
  <p>Key Concepts of Microservices | 7</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>