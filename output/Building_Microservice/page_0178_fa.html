<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 178</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p><em>templates</em>، اما از طرف دیگر، این رویکرد باعث می‌شود که همه چیز بسیار واضح شود و می‌تواند مسیریابی <em>request</em> را ساده کند.
  <p>برای <em>RPC</em>، اوضاع می‌تواند کمی پیچیده‌تر باشد. من این موضوع را با <em>protocol buffers</em> با قرار دادن متدهای خود در <em>namespaces</em> مختلف—به عنوان مثال، <code>v1.createCustomer</code> و <code>v2.createCustomer</code>—مدیریت کرده‌ام، اما وقتی سعی می‌کنید از نسخه‌های مختلف از همان <em>types</em> که از طریق شبکه ارسال می‌شوند پشتیبانی کنید، این رویکرد می‌تواند واقعاً دردناک شود.</p>
  <h4>Which Approach Do I Prefer?</h4>
  <p>برای موقعیت‌هایی که در آن‌ها همان تیم هم <em>microservice</em> و هم همه <em>consumers</em> را مدیریت می‌کند، من در مورد یک <em>lockstep release</em> در موقعیت‌های محدود تا حدودی راحت هستم. با فرض اینکه واقعاً یک موقعیت یک‌باره است، انجام این کار زمانی که تأثیر به یک تیم واحد محدود می‌شود، می‌تواند قابل توجیه باشد. با این حال، من در این مورد بسیار محتاط هستم، زیرا خطر این وجود دارد که یک فعالیت یک‌باره به روال عادی تبدیل شود، و استقلال استقرار از بین می‌رود. از <em>lockstep deployments</em> بیش از حد استفاده کنید، و خیلی زود به یک <em>distributed monolith</em> خواهید رسید.</p>
  <p>همانطور که بحث کردیم، همزیستی نسخه‌های مختلف از همان <em>microservice</em> می‌تواند مشکل‌ساز باشد. من فقط در موقعیت‌هایی که ما قصد داشتیم نسخه‌های <em>microservice</em> را فقط برای یک دوره زمانی کوتاه در کنار هم اجرا کنیم، این کار را در نظر می‌گیرم. واقعیت این است که وقتی شما نیاز دارید به مصرف‌کنندگان زمان بدهید تا ارتقا یابند، ممکن است هفته‌ها یا بیشتر به آن نگاه کنید. در موقعیت‌های دیگری که ممکن است نسخه‌های <em>microservice</em> را در کنار هم داشته باشید، شاید به عنوان بخشی از یک <em>blue-green deployment</em> یا <em>canary release</em>، مدت زمان‌های درگیر بسیار کوتاه‌تر است، که معایب این رویکرد را جبران می‌کند.</p>
  <p>ترجیح کلی من استفاده از شبیه‌سازی <em>old endpoints</em> در هر کجا که ممکن باشد است. چالش‌های پیاده‌سازی شبیه‌سازی، به نظر من، بسیار آسان‌تر از چالش‌های همزیستی نسخه‌های <em>microservice</em> هستند.</p>
  <h4>The Social Contract</h4>
  <p>اینکه کدام رویکرد را انتخاب می‌کنید، تا حد زیادی به انتظاراتی که <em>consumers</em> از نحوه ایجاد این تغییرات دارند، بستگی دارد. حفظ <em>old interface</em> می‌تواند هزینه‌ای داشته باشد، و در حالت ایده‌آل، شما می‌خواهید آن را خاموش کنید و کد و زیرساخت مرتبط را در اسرع وقت حذف کنید. از طرف دیگر، شما می‌خواهید تا حد امکان به مصرف‌کنندگان زمان بدهید تا تغییری ایجاد کنند. و به یاد داشته باشید، در بسیاری از موارد، <em>backward-incompatible changes</em> که شما ایجاد می‌کنید، اغلب چیزهایی هستند که توسط مصرف‌کنندگان درخواست شده‌اند و/یا در واقع در نهایت به نفع آن‌ها خواهد بود. البته، یک عمل متعادل‌کننده‌ای بین نیازهای نگه‌دارندگان <em>microservice</em> و نیازهای مصرف‌کنندگان وجود دارد، و این باید مورد بحث قرار گیرد.</p>
  <p>من متوجه شده‌ام که در بسیاری از موقعیت‌ها، نحوه رسیدگی به این تغییرات هرگز مورد بحث قرار نگرفته است، که منجر به انواع مختلف چالش‌ها می‌شود. همانطور که در مورد <em>schemas</em>، داشتن درجه‌ای از</p>
 </div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>