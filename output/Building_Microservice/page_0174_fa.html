<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 174</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>2 توجه داشته باشید که در واقع سه ابزار مختلف در این فضا با یک نام وجود دارد! ابزار <em>openapi-diff</em> در <em>https://github.com/Azure/openapi-diff</em> به نظر می‌رسد به ابزاری نزدیک‌تر می‌شود که در واقع سازگاری را پاس می‌کند یا رد می‌شود.</p>
  <p>این طرح <em>versioning</em> به ما امکان می‌دهد اطلاعات و انتظارات زیادی را فقط در سه <em>fields</em> بسته‌بندی کنیم. <em>full specification</em> به زبان بسیار ساده، انتظاراتی را که <em>clients</em> می‌توانند از تغییرات در این اعداد داشته باشند، مشخص می‌کند، و می‌تواند فرآیند برقراری ارتباط در مورد اینکه آیا تغییرات باید بر مصرف‌کنندگان تأثیر بگذارند یا خیر را ساده کند. متأسفانه، من این رویکرد را به اندازه کافی در سیستم‌های توزیع شده برای درک اثربخشی آن در آن زمینه ندیده‌ام—چیزی که از زمان اولین ویرایش این کتاب واقعاً تغییر نکرده است.</p>
  <h4>Catch Accidental Breaking Changes Early</h4>
  <p>بسیار مهم است که تغییراتی را که مصرف‌کنندگان را خراب می‌کنند در اسرع وقت شناسایی کنیم، زیرا حتی اگر بهترین فناوری ممکن را انتخاب کنیم، یک تغییر بی‌ضرر از یک <em>microservice</em> می‌تواند باعث شود که مصرف‌کنندگان خراب شوند. همانطور که قبلاً به آن اشاره کردیم، استفاده از <em>schemas</em> می‌تواند به ما در تشخیص <em>structural changes</em> کمک کند، با فرض اینکه ما از نوعی <em>tooling</em> برای کمک به مقایسه نسخه‌های <em>schema</em> استفاده کنیم. طیف گسترده‌ای از <em>tooling</em> در آنجا برای انجام این کار برای انواع <em>schema</em> مختلف وجود دارد. ما <em>Protolock</em> را برای <em>protocol buffers</em>، <em>json-schema-diff-validator</em> را برای <em>JSON Schema</em>، و <em>openapi-diff</em> را برای <em>OpenAPI specification</em> داریم.2 به نظر می‌رسد ابزارهای بیشتری همیشه در این فضا ظاهر می‌شوند. با این حال، آنچه شما به دنبال آن هستید، چیزی است که فقط تفاوت‌های بین دو <em>schemas</em> را گزارش نمی‌کند، بلکه بر اساس سازگاری پاس یا رد می‌شود؛ این به شما امکان می‌دهد اگر <em>incompatible schemas</em> یافت شد، یک ساخت <em>CI</em> را شکست دهید و اطمینان حاصل کنید که <em>microservice</em> شما مستقر نخواهد شد.</p>
  <p><em>Confluent Schema Registry</em> منبع باز از <em>JSON Schema</em>، <em>Avro</em> و <em>protocol buffers</em> پشتیبانی می‌کند و قادر به مقایسه نسخه‌های جدید آپلود شده برای <em>backward compatibility</em> است. اگرچه این برنامه برای کمک به عنوان بخشی از یک اکوسیستم که در آن از <em>Kafka</em> استفاده می‌شود، ساخته شده است و برای اجرا به <em>Kafka</em> نیاز دارد، هیچ چیز شما را از استفاده از آن برای ذخیره و اعتبارسنجی <em>schemas</em> که برای ارتباط مبتنی بر غیر <em>Kafka</em> استفاده می‌شوند، باز نمی‌دارد.</p>
  <p>ابزارهای مقایسه <em>Schema</em> می‌توانند به ما در تشخیص <em>structural breakages</em> کمک کنند، اما در مورد <em>semantic breakages</em> چطور؟ یا اگر شما در وهله اول از <em>schemas</em> استفاده نمی‌کنید چه؟ در این صورت، ما در حال نگاه کردن به <em>testing</em> هستیم. این موضوعی است که ما در "<em>Contract Tests and Consumer-Driven Contracts (CDCs)</em>" در صفحه 292 با جزئیات بیشتری بررسی خواهیم کرد، اما می‌خواستم <em>consumer-driven contract testing</em> را برجسته کنم، که صریحاً در این زمینه کمک می‌کند—<em>Pact</em> یک مثال عالی از یک ابزار است که به طور خاص برای این مشکل هدف‌گذاری شده است. فقط به یاد داشته باشید، اگر <em>schemas</em> ندارید، انتظار داشته باشید که <em>testing</em> شما برای تشخیص <em>breaking changes</em> باید کار بیشتری انجام دهد.</p>
  <p>اگر شما از چندین <em>client libraries</em> مختلف پشتیبانی می‌کنید، اجرای <em>tests</em> با استفاده از هر <em>library</em> که از آن پشتیبانی می‌کنید در برابر آخرین <em>service</em> یک تکنیک دیگر است که می‌تواند کمک کند. هنگامی که متوجه شدید که می‌خواهید یک <em>consumer</em> را خراب کنید، شما این انتخاب را دارید که یا سعی کنید</p>
 </div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>