<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 140</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   شکل 4-14. یک <strong>event</strong> با اطلاعات بیشتر در آن می‌تواند به microservicesهای دریافت‌کننده اجازه دهد که بدون نیاز به فراخوانی‌های بیشتر به منبع <strong>event</strong>، عمل کنند
  </p>
  <p>
   علاوه بر این واقعیت که <strong>events</strong> با اطلاعات بیشتر می‌توانند به <em>coupling</em> آزادتر اجازه دهند، <strong>events</strong> با اطلاعات بیشتر می‌توانند به عنوان یک سابقه تاریخی از آنچه برای یک موجودیت خاص اتفاق افتاده است، دو برابر شوند. این می‌تواند به شما در پیاده‌سازی یک سیستم حسابرسی کمک کند، یا شاید حتی توانایی بازسازی یک موجودیت را در نقاط مشخصی از زمان فراهم کند—به این معنی که این <strong>events</strong> می‌توانند به عنوان بخشی از یک <strong>event sourcing</strong>، مفهومی که ما در یک لحظه به طور خلاصه آن را بررسی خواهیم کرد، استفاده شوند.
  </p>
  <p>
   در حالی که این رویکرد قطعاً ترجیح من است، اما خالی از اشکال نیست. اولاً، اگر داده‌های مرتبط با یک <strong>event</strong> بزرگ باشد، ممکن است در مورد اندازه <strong>event</strong> نگران باشیم. <strong>Message brokers</strong>های مدرن (با فرض اینکه شما از یکی برای پیاده‌سازی مکانیسم انتشار <strong>event</strong> خود استفاده می‌کنید) محدودیت‌های کاملاً سخاوتمندانه‌ای برای اندازه پیام دارند. اندازه حداکثر پیش‌فرض برای یک پیام در <strong>Kafka</strong>، 1 مگابایت است، و آخرین نسخه <strong>RabbitMQ</strong> دارای یک حد بالای نظری 512 مگابایت برای یک پیام واحد است (کاهش از حد قبلی 2 گیگابایت!)، حتی اگر کسی انتظار داشته باشد که برخی از مسائل عملکردی جالب با پیام‌های بزرگی مانند این وجود داشته باشد. اما حتی 1 مگابایت که به ما به عنوان حداکثر اندازه یک پیام در <strong>Kafka</strong> اعطا می‌شود، به ما فضای زیادی برای ارسال مقدار زیادی از داده‌ها می‌دهد. در نهایت، اگر شما در حال ورود به فضایی هستید که در آن شروع به نگرانی در مورد اندازه <strong>events</strong> خود دارید، در این صورت رویکردی ترکیبی را توصیه می‌کنم که در آن مقداری از اطلاعات در <strong>event</strong> باشد، اما سایر داده‌های (بزرگتر) را می‌توان در صورت نیاز جستجو کرد.
  </p>
  <p>
   در شکل 4-14، <strong>Loyalty</strong> نیازی به دانستن آدرس ایمیل یا نام مشتری ندارد، و با این حال آن را از طریق <strong>event</strong> دریافت می‌کند. این می‌تواند منجر به نگرانی‌هایی شود اگر ما در تلاش برای محدود کردن دامنه microservicesهایی باشیم که می‌توانند چه نوع داده‌هایی را ببینند—به عنوان مثال، من ممکن است بخواهم محدود کنم که کدام microservicesها می‌توانند اطلاعات قابل شناسایی شخصی <strong>(PII)</strong>، جزئیات کارت پرداخت، یا داده‌های حساس مشابه را ببینند. یک راه برای حل این مشکل می‌تواند ارسال دو نوع مختلف <strong>events</strong> باشد—یکی که حاوی <strong>PII</strong> است و می‌تواند توسط برخی از microservicesها مشاهده شود، و دیگری که <strong>PII</strong> را حذف می‌کند و می‌تواند منتشر شود
  </p>
  <p>Pattern: Event-Driven Communication | 113</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0140/image_1.png" alt="Image from page 140" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>