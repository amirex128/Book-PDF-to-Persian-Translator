<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 35</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   پایگاه‌های داده را به اشتراک نگذارید، مگر اینکه واقعاً نیاز داشته باشید. و حتی در این صورت تا جایی که می‌توانید از آن اجتناب کنید. به نظر من، اشتراک‌گذاری پایگاه‌های داده یکی از بدترین کارهایی است که می‌توانید انجام دهید اگر سعی دارید به استقرار مستقل برسید.
  </p>
  <p>
   همانطور که در بخش قبل مورد بحث قرار گرفت، ما می‌خواهیم به <strong>services</strong> خود به عنوان برش‌های end-to-end از <strong>business functionality</strong> فکر کنیم که، در صورت لزوم، <strong>user interface (UI)</strong>، <strong>business logic</strong> و داده‌ها را کپسوله می‌کنند. این به این دلیل است که ما می‌خواهیم تلاش مورد نیاز برای تغییر <strong>business-related functionality</strong> را کاهش دهیم. کپسوله‌سازی داده‌ها و رفتار به این روش، <em>cohesion</em> بالایی از <strong>business functionality</strong> را به ما می‌دهد. با پنهان کردن پایگاه داده‌ای که از <strong>service</strong> ما پشتیبانی می‌کند، ما همچنین اطمینان حاصل می‌کنیم که <em>coupling</em> را کاهش می‌دهیم. ما در فصل 2 به <em>coupling</em> و <em>cohesion</em> برمی‌گردیم.
  </p>
  <h4>اندازه</h4>
  <p>
   "یک microservice چقدر باید بزرگ باشد؟" یکی از متداول‌ترین سوالاتی است که می‌شنوم. با توجه به اینکه کلمه "micro" درست در نام وجود دارد، این موضوع جای تعجب ندارد. با این حال، هنگامی که وارد این می‌شوید که چه چیزی باعث می‌شود microservices به عنوان یک نوع معماری کار کنند، مفهوم اندازه در واقع یکی از کم‌اهمیت‌ترین جنبه‌ها است.
  </p>
  <p>
   چگونه اندازه را اندازه‌گیری می‌کنید؟ با شمارش خطوط کد؟ این برای من منطقی نیست. چیزی که ممکن است 25 خط کد در جاوا نیاز داشته باشد، می‌تواند در 10 خط از Clojure نوشته شود. این بدان معنا نیست که Clojure بهتر یا بدتر از جاوا است. برخی از زبان‌ها به سادگی گویاتر از بقیه هستند.
  </p>
  <p>
   James Lewis، مدیر فنی در <strong>Thoughtworks</strong>، گفته است که "یک microservice باید به اندازه سر من باشد." در نگاه اول، این به نظر نمی‌رسد که خیلی مفید باشد. بالاخره سر جیمز دقیقاً چقدر بزرگ است؟ منطق پشت این بیانیه این است که یک microservice باید به اندازه‌ای نگه داشته شود که به راحتی قابل درک باشد.
  </p>
  <p>
   البته چالش این است که توانایی افراد مختلف برای درک چیزی همیشه یکسان نیست و به این ترتیب شما باید در مورد اندازه‌ای که برای شما مناسب است، قضاوت خود را انجام دهید. یک تیم باتجربه ممکن است بتواند یک <strong>codebase</strong> بزرگتر را بهتر از یک تیم دیگر مدیریت کند. بنابراین شاید بهتر باشد که نقل قول جیمز را در اینجا اینطور بخوانید: "یک microservice باید به اندازه سر شما باشد."
  </p>
  <p>
   فکر می‌کنم نزدیک‌ترین چیزی که به "اندازه" در ارتباط با microservices معنی دارد، چیزی است که <strong>Chris Richardson</strong>، نویسنده <em>Microservice Patterns</em> (<strong>Manning Publications</strong>)، یک بار گفت—هدف microservices داشتن "به کوچکی یک <strong>interface</strong> ممکن" است. این دوباره با مفهوم <strong>information hiding</strong> همسو است، اما نشان‌دهنده تلاشی برای یافتن معنا در اصطلاح "microservices" است که در ابتدا وجود نداشت. هنگامی که این اصطلاح برای اولین بار برای تعریف این معماری‌ها استفاده شد، تمرکز، حداقل در ابتدا، به‌طور خاص بر روی اندازه <strong>interfaces</strong> نبود.
  </p>
  <p>
   در نهایت، مفهوم اندازه بسیار وابسته به زمینه است. با فردی که 15 سال روی یک سیستم کار کرده است صحبت کنید، و آنها احساس خواهند کرد که سیستم آنها با 100000 خط
  </p>
  <p>Key Concepts of Microservices | 9</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0035/image_1.png" alt="Image from page 35" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>