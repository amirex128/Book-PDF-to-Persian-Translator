<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 137</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   با این حال، در مورد دنیای <strong>middleware</strong>، که <strong>message broker</strong> تنها بخش کوچکی از آن است، محتاط باشید. صف‌ها به خودی خود، چیزهای کاملاً معقول و مفیدی هستند. با این حال، فروشندگان تمایل دارند که نرم‌افزارهای زیادی را با آنها بسته‌بندی کنند، که می‌تواند منجر به این شود که هوش بیشتری به <strong>middleware</strong> وارد شود، همانطور که توسط مواردی مانند <strong>enterprise service bus</strong> مشهود است. مطمئن شوید که می‌دانید چه چیزی به دست می‌آورید: <strong>middleware</strong> خود را <strong>dumb</strong> نگه دارید، و هوش را در <strong>endpoints</strong> نگه دارید.
  </p>
  <p>
   رویکرد دیگر این است که سعی کنید از <strong>HTTP</strong> به عنوان راهی برای انتشار <strong>events</strong> استفاده کنید. <strong>Atom</strong> یک مشخصات سازگار با <strong>REST</strong> است که معناشناسی (از جمله موارد دیگر) را برای انتشار فیدهای <strong>resources</strong> تعریف می‌کند. بسیاری از کتابخانه‌های کلاینت وجود دارند که به ما امکان ایجاد و مصرف این فیدها را می‌دهند. بنابراین <strong>customer service</strong> ما می‌تواند هر زمان که <strong>customer service</strong> ما تغییر می‌کند، یک <strong>event</strong> را به چنین فید منتشر کند. مصرف‌کنندگان ما به سادگی فید را <strong>poll</strong> می‌کنند و به دنبال تغییرات هستند. از یک طرف، این واقعیت که ما می‌توانیم از مشخصات <strong>Atom</strong> موجود و هر کتابخانه مرتبط استفاده مجدد کنیم، مفید است، و ما می‌دانیم که <strong>HTTP</strong> مقیاس را خیلی خوب مدیریت می‌کند. با این حال، این استفاده از <strong>HTTP</strong> در <strong>low latency</strong> خوب نیست (جایی که برخی از <strong>message brokers</strong>ها عالی هستند)، و ما همچنان باید با این واقعیت مقابله کنیم که مصرف‌کنندگان باید پیگیری کنند که چه پیام‌هایی را دیده‌اند و برنامه <strong>polling</strong> خود را مدیریت کنند.
  </p>
  <p>
   من دیده‌ام که افراد زمان زیادی را صرف پیاده‌سازی رفتارهای بیشتری می‌کنند که شما از جعبه با یک <strong>message broker</strong> مناسب دریافت می‌کنید تا <strong>Atom</strong> برای برخی موارد استفاده کار کند. به عنوان مثال، الگوی <strong>competing consumer</strong> روشی را توصیف می‌کند که به موجب آن شما چندین نمونه کارگر را برای رقابت بر سر پیام‌ها بالا می‌آورید، که برای مقیاس‌بندی تعداد کارگران برای رسیدگی به فهرستی از مشاغل مستقل (ما در فصل بعد به آن باز خواهیم گشت) به خوبی کار می‌کند. با این حال، ما می‌خواهیم از این مورد اجتناب کنیم که در آن دو یا چند کارگر، یک پیام یکسان را ببینند، زیرا در نهایت کار یکسانی را بیشتر از آنچه نیاز داریم، انجام خواهیم داد. با یک <strong>message broker</strong>، یک صف استاندارد این کار را مدیریت خواهد کرد. با <strong>Atom</strong>، ما اکنون نیاز داریم که <strong>state</strong> مشترک خود را در میان همه کارگران مدیریت کنیم تا سعی کنیم شانس تکرار تلاش را کاهش دهیم.
  </p>
  <p>
   اگر از قبل یک <strong>message broker</strong> خوب و انعطاف‌پذیر در دسترس دارید، استفاده از آن را برای مدیریت انتشار و اشتراک در <strong>events</strong> در نظر بگیرید. اگر هنوز یکی ندارید، نگاهی به <strong>Atom</strong> بیندازید، اما از مغلطه هزینه مدفون آگاه باشید. اگر متوجه شدید که به پشتیبانی بیشتری که یک <strong>message broker</strong> به شما می‌دهد نیاز دارید، در یک نقطه مشخص ممکن است بخواهید رویکرد خود را تغییر دهید.
  </p>
  <p>
   از نظر آنچه که ما در واقع از طریق این <strong>protocols asynchronous</strong> ارسال می‌کنیم، همان ملاحظات با ارتباط <strong>synchronous</strong> اعمال می‌شود. اگر در حال حاضر از رمزگذاری درخواست‌ها و پاسخ‌ها با استفاده از <strong>JSON</strong> خوشحال هستید، به آن پایبند باشید.
  </p>
  <h4>یک <strong>Event</strong> در چه چیزی است؟</h4>
  <p>
   در شکل 4-12، ما یک <strong>event</strong> را می‌بینیم که از microservice <strong>Customer</strong> پخش می‌شود، و به طرف‌های ذینفع اطلاع می‌دهد که یک مشتری جدید با سیستم ثبت‌نام کرده است. دو مورد از microservicesهای پایین‌دست، <strong>Loyalty</strong> و <strong>Notifications</strong>، به این <strong>event</strong> اهمیت می‌دهند.
  </p>
  <p>
   microservice <strong>Loyalty</strong> با دریافت <strong>event</strong> با راه‌اندازی یک حساب برای
  </p>
  <p>Pattern: Event-Driven Communication | 111</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>