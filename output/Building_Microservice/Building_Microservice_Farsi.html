<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building_Microservice - فارسی</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            background-color: white;
        }
        .book-title {
            text-align: center;
            font-size: 24pt;
            margin: 3cm 0 1cm 0;
        }
        .book-subtitle {
            text-align: center;
            font-size: 18pt;
            margin-bottom: 3cm;
        }
        .toc {
            margin: 2cm 0;
            padding: 1cm;
            background-color: #f8f9fa;
            border-radius: 5px;
            page-break-after: always;
        }
        .toc h2 {
            margin-bottom: 1cm;
        }
        .toc ul {
            list-style-type: none;
            padding: 0;
        }
        .toc li {
            margin: 0.5cm 0;
            padding-right: 1cm;
        }
        .toc a {
            text-decoration: none;
            color: #2980b9;
        }
        .chapter {
            margin-bottom: 1cm;
            page-break-before: always;
        }
        .chapter:first-of-type {
            page-break-before: avoid;
        }
        .chapter-content {
            margin-bottom: 1cm;
        }
        .persian-translation {
            font-size: 14pt;
        }
        .page-images {
            text-align: center;
            margin: 1cm 0;
            page-break-before: always;
        }
        .page-images img {
            max-width: 100%;
            height: auto;
            margin: 0.5cm 0;
        }
        pre {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
            direction: ltr;
            text-align: left;
        }
        span[dir="ltr"] {
            display: inline-block;
            direction: ltr;
            text-align: left;
        }
        .page-number {
            text-align: center;
            margin-top: 1cm;
            font-size: 10pt;
            color: #7f8c8d;
        }
    </style>
</head>
<body>
    <h1 class="book-title">Building_Microservice</h1>
    <h2 class="book-subtitle">نسخه ترجمه شده</h2>
        <!-- Page 0001 -->
        <div class="chapter" id="page-0001">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>Sam Newman</h3>
<p>
<em>Building </em> 
        Microservices
        <br/>
        Designing Fine-Grained Systems
        <br/>
        Second 
        Edition
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 1" src="page_0001/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0001</div>
            </div>
        </div>
        <!-- Page 0003 -->
        <div class="chapter" id="page-0003">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>Sam Newman</h3>
<p>
        Building <strong>Microservices</strong>
<br/>
        Designing Fine-Grained Systems
    </p>
<h4>SECOND EDITION</h4>
<p>
        Boston
        <br/>
        Farnham
        <br/>
        Sebastopol
        <br/>
        Tokyo
        <br/>
        Beijing
    </p>
<p>
        Boston
        <br/>
        Farnham
        <br/>
        Sebastopol
        <br/>
        Tokyo
        <br/>
        Beijing
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0003</div>
            </div>
        </div>
        <!-- Page 0004 -->
        <div class="chapter" id="page-0004">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        978-1-492-03402-5
        <br/>
        [MBP]
        <br/>
        Building <strong>Microservices</strong>
<br/>
        by Sam Newman
    </p>
<p>
        Copyright © 2021 Sam Newman. All rights reserved.
        <br/>
        Printed in Canada.
        <br/>
        Published by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.
        <br/>
        O’Reilly books may be purchased for educational, business, or sales promotional use. Online editions are
        also available for most titles (http://oreilly.com). For more information, contact our corporate/institu‐
        tional sales department: 800-998-9938 or corporate@oreilly.com.
    </p>
<p>
        Acquisitions Editor: Melissa Duffield
        <br/>
        Indexer: Judith McConville
        <br/>
        Development Editor: Nicole Taché
        <br/>
        Interior Designer: David Futato
        <br/>
        Production Editor: Deborah Baker
        <br/>
        Cover Designer: Karen Montgomery
        <br/>
        Copyeditor: Arthur Johnson
        <br/>
        Illustrator: Kate Dullea
        <br/>
        Proofreader: Charles Roumeliotis
    </p>
<p>
        February 2015:
        <br/>
        First Edition
        <br/>
        August 2021:
        <br/>
        Second Edition
    </p>
<h4>Revision History for the Second Edition</h4>
<p>
        2021-07-23: First Release
        <br/>
        See http://oreilly.com/catalog/errata.csp?isbn=9781492034025 for release details.
    </p>
<p>
        The O’Reilly logo is a registered trademark of O’Reilly Media, Inc. Building Microservices, the cover
        image, and related trade dress are trademarks of O’Reilly Media, Inc.
    </p>
<p>
        The views expressed in this work are those of the author, and do not represent the publisher’s views.
        <br/>
        While the publisher and the author have used good faith efforts to ensure that the information and
        instructions contained in this work are accurate, the publisher and the author disclaim all responsibility
        for errors or omissions, including without limitation responsibility for damages resulting from the use of
        or reliance on this work. Use of the information and instructions contained in this work is at your own
        risk. If any code samples or other technology this work contains or describes is subject to open source
        licenses or the intellectual property rights of others, it is your responsibility to ensure that your use
        thereof complies with such licenses and/or rights.
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0004</div>
            </div>
        </div>
        <!-- Page 0005 -->
        <div class="chapter" id="page-0005">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>Table of Contents</h3>
<p>Preface. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xvii</p>
<h4>Part I. Foundation</h4>
<h4>1. What Are Microservices? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3</h4>
<p>Microservices at a Glance 3</p>
<p>Key Concepts of <strong>Microservices</strong> 6</p>
<ul>
<li>Independent Deployability 6</li>
<li>Modeled Around a Business Domain 7</li>
<li>Owning Their Own State 8</li>
<li>Size 9</li>
<li>Flexibility 10</li>
<li>Alignment of Architecture and Organization 10</li>
</ul>
<p>The Monolith 14</p>
<ul>
<li>The Single-Process Monolith 15</li>
<li>The Modular Monolith 16</li>
<li>The Distributed Monolith 17</li>
</ul>
<p>Monoliths and Delivery Contention 17</p>
<p>Advantages of Monoliths 18</p>
<p>Enabling Technology 18</p>
<ul>
<li>Log Aggregation and Distributed Tracing 19</li>
<li>Containers and Kubernetes 20</li>
<li>Streaming 21</li>
<li>Public Cloud and Serverless 21</li>
</ul>
<p>Advantages of Microservices 22</p>
<p>iii</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0005</div>
            </div>
        </div>
        <!-- Page 0006 -->
        <div class="chapter" id="page-0006">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>Technology Heterogeneity 22</p>
<p>Robustness 23</p>
<p>Scaling 24</p>
<p>Ease of Deployment 25</p>
<p>Organizational Alignment 25</p>
<p>Composability 26</p>
<p>Microservice Pain Points 26</p>
<ul>
<li>Developer Experience 26</li>
<li>Technology Overload 27</li>
<li>Cost 28</li>
<li>Reporting 28</li>
<li>Monitoring and Troubleshooting 29</li>
<li>Security 29</li>
<li>Testing 30</li>
<li>Latency 30</li>
<li>Data Consistency 31</li>
</ul>
<p>Should I Use Microservices? 31</p>
<ul>
<li>Whom They Might Not Work For 31</li>
<li>Where They Work Well 33</li>
</ul>
<p>Summary 34</p>
<h4>2. How to Model Microservices. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35</h4>
<p>Introducing MusicCorp 35</p>
<p>What Makes a Good Microservice Boundary? 36</p>
<ul>
<li>Information Hiding 36</li>
<li>Cohesion 38</li>
<li>Coupling 38</li>
</ul>
<p>The Interplay of Coupling and Cohesion 39</p>
<p>Types of Coupling 39</p>
<ul>
<li>Domain Coupling 41</li>
<li>Pass-Through Coupling 43</li>
<li>Common Coupling 46</li>
<li>Content Coupling 49</li>
</ul>
<p>Just Enough Domain-Driven Design 51</p>
<ul>
<li>Ubiquitous Language 52</li>
<li>Aggregate 53</li>
<li>Bounded Context 56</li>
</ul>
<p>Mapping Aggregates and Bounded Contexts to Microservices 58</p>
<p>Event Storming 59</p>
<p>The Case for Domain-Driven Design for Microservices 61</p>
<p>Alternatives to Business Domain Boundaries 62</p>
<p>iv | Table of Contents</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0006</div>
            </div>
        </div>
        <!-- Page 0007 -->
        <div class="chapter" id="page-0007">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>Volatility 62</p>
<p>Data 64</p>
<p>Technology 65</p>
<p>Organizational 66</p>
<p>Mixing Models and Exceptions 68</p>
<p>Summary 69</p>
<h4>3. Splitting the Monolith. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71</h4>
<p>Have a Goal 71</p>
<p>Incremental Migration 72</p>
<p>The Monolith Is Rarely the Enemy 73</p>
<p>The Dangers of Premature Decomposition 73</p>
<p>What to Split First? 74</p>
<p>Decomposition by Layer 76</p>
<ul>
<li>Code First 77</li>
<li>Data First 78</li>
</ul>
<p>Useful Decompositional Patterns 79</p>
<ul>
<li>Strangler Fig Pattern 79</li>
<li>Parallel Run 80</li>
<li>Feature Toggle 80</li>
</ul>
<p>Data Decomposition Concerns 81</p>
<ul>
<li>Performance 81</li>
<li>Data Integrity 84</li>
<li>Transactions 84</li>
</ul>
<p>Tooling 85</p>
<ul>
<li>Reporting Database 85</li>
</ul>
<p>Summary 86</p>
<h4>4. Microservice Communication Styles. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89</h4>
<p>From In-Process to Inter-Process 89</p>
<ul>
<li>Performance 90</li>
<li>Changing Interfaces 91</li>
<li>Error Handling 91</li>
</ul>
<p>Technology for Inter-Process Communication: So Many Choices 93</p>
<p>Styles of Microservice Communication 93</p>
<p>Mix and Match 95</p>
<p>Pattern: Synchronous Blocking 95</p>
<ul>
<li>Advantages 96</li>
<li>Disadvantages 96</li>
<li>Where to Use It 96</li>
</ul>
<p>Pattern: Asynchronous Nonblocking 98</p>
<p>v | Table of Contents</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0007</div>
            </div>
        </div>
        <!-- Page 0008 -->
        <div class="chapter" id="page-0008">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>Advantages 99</p>
<p>Disadvantages 100</p>
<p>Where to Use It 101</p>
<p>Pattern: Communication Through Common Data 101</p>
<ul>
<li>Implementation 102</li>
<li>Advantages 103</li>
<li>Disadvantages 103</li>
<li>Where to Use It 104</li>
</ul>
<p>Pattern: Request-Response Communication 104</p>
<ul>
<li>Implementation: Synchronous Versus Asynchronous 106</li>
<li>Where to Use It 108</li>
</ul>
<p>Pattern: Event-Driven Communication 108</p>
<ul>
<li>Implementation 110</li>
<li>What’s in an Event? 111</li>
<li>Where to Use It 115</li>
</ul>
<p>Proceed with Caution 116</p>
<p>Summary 117</p>
<h4>Part II. Implementation</h4>
<h4>5. Implementing Microservice Communication. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121</h4>
<p>Looking for the Ideal Technology 121</p>
<ul>
<li>Make Backward Compatibility Easy 121</li>
<li>Make Your Interface Explicit 122</li>
<li>Keep Your APIs Technology Agnostic 122</li>
<li>Make Your Service Simple for Consumers 122</li>
<li>Hide Internal Implementation Detail 123</li>
</ul>
<p>Technology Choices 123</p>
<ul>
<li>Remote Procedure Calls 123</li>
<li>REST 127</li>
<li>GraphQL 133</li>
<li>Message Brokers 135</li>
</ul>
<p>Serialization Formats 140</p>
<ul>
<li>Textual Formats 140</li>
<li>Binary Formats 141</li>
</ul>
<p>Schemas 141</p>
<p>Structural Versus Semantic Contract Breakages 142</p>
<p>Should You Use Schemas? 143</p>
<p>Handling Change Between Microservices 144</p>
<p>vi | Table of Contents</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0008</div>
            </div>
        </div>
        <!-- Page 0009 -->
        <div class="chapter" id="page-0009">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>Avoiding Breaking Changes 144</p>
<ul>
<li>Expansion Changes 145</li>
<li>Tolerant Reader 145</li>
<li>Right Technology 146</li>
<li>Explicit Interface 146</li>
<li>Catch Accidental Breaking Changes Early 148</li>
</ul>
<p>Managing Breaking Changes 149</p>
<ul>
<li>Lockstep Deployment 149</li>
<li>Coexist Incompatible Microservice Versions 149</li>
<li>Emulate the Old Interface 150</li>
</ul>
<p>Which Approach Do I Prefer? 152</p>
<p>The Social Contract 152</p>
<p>Tracking Usage 153</p>
<p>Extreme Measures 154</p>
<p>DRY and the Perils of Code Reuse in a Microservice World 154</p>
<ul>
<li>Sharing Code via Libraries 155</li>
</ul>
<p>Service Discovery 157</p>
<ul>
<li>Domain Name System (DNS) 157</li>
<li>Dynamic Service Registries 159</li>
</ul>
<p>Don’t Forget the Humans! 161</p>
<p>Service Meshes and API Gateways 162</p>
<ul>
<li>API Gateways 163</li>
<li>Service Meshes 166</li>
</ul>
<p>What About Other Protocols? 169</p>
<p>Documenting Services 169</p>
<ul>
<li>Explicit Schemas 169</li>
<li>The Self-Describing System 170</li>
</ul>
<p>Summary 173</p>
<h4>6. Workflow. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175</h4>
<p>Database Transactions 175</p>
<ul>
<li>ACID Transactions 176</li>
<li>Still ACID, but Lacking Atomicity? 177</li>
</ul>
<p>Distributed Transactions—Two-Phase Commits 179</p>
<p>Distributed Transactions—Just Say No 181</p>
<p>Sagas 182</p>
<ul>
<li>Saga Failure Modes 184</li>
<li>Implementing Sagas 189</li>
</ul>
<p>Sagas Versus Distributed Transactions 195</p>
<p>Summary 196</p>
<p>vii | Table of Contents</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0009</div>
            </div>
        </div>
        <!-- Page 0010 -->
        <div class="chapter" id="page-0010">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>7. Build. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197</h4>
<p>A Brief Introduction to Continuous Integration 197</p>
<p>Are You Really Doing CI? 198</p>
<p>Branching Models 199</p>
<p>Build Pipelines and Continuous Delivery 201</p>
<p>Tooling 203</p>
<p>Trade-Offs and Environments 203</p>
<p>Artifact Creation 204</p>
<p>Mapping Source Code and Builds to Microservices 205</p>
<p>One Giant Repo, One Giant Build 205</p>
<p>Pattern: One Repository per Microservice (aka Multirepo) 207</p>
<p>Pattern: Monorepo 210</p>
<p>Which Approach Would I Use? 217</p>
<p>Summary 217</p>
<h4>8. Deployment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219</h4>
<p>From Logical to Physical 219</p>
<p>Multiple Instances 220</p>
<p>The Database 222</p>
<p>Environments 225</p>
<p>Principles of Microservice Deployment 228</p>
<ul>
<li>Isolated Execution 228</li>
<li>Focus on Automation 231</li>
<li>Infrastructure as Code (IAC) 232</li>
<li>Zero-Downtime Deployment 233</li>
<li>Desired State Management 234</li>
</ul>
<p>Deployment Options 237</p>
<ul>
<li>Physical Machines 238</li>
<li>Virtual Machines 239</li>
<li>Containers 241</li>
<li>Application Containers 247</li>
<li>Platform as a Service (PaaS) 248</li>
<li>Function as a Service (FaaS) 249</li>
</ul>
<p>Which Deployment Option Is Right for You? 257</p>
<p>Kubernetes and Container Orchestration 259</p>
<ul>
<li>The Case for Container Orchestration 259</li>
<li>A Simplified View of Kubernetes Concepts 260</li>
<li>Multitenancy and Federation 262</li>
<li>The Cloud Native Computing Federation 265</li>
<li>Platforms and Portability 265</li>
</ul>
<p>viii | Table of Contents</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0010</div>
            </div>
        </div>
        <!-- Page 0011 -->
        <div class="chapter" id="page-0011">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>Helm, Operators, and CRDs, Oh My! 266</p>
<p>And Knative 267</p>
<p>The Future 268</p>
<p>Should You Use It? 268</p>
<p>Progressive Delivery 269</p>
<p>Separating Deployment from Release 270</p>
<p>On to Progressive Delivery 270</p>
<ul>
<li>Feature Toggles 271</li>
<li>Canary Release 271</li>
<li>Parallel Run 272</li>
</ul>
<p>Summary 273</p>
<h4>9. Testing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275</h4>
<p>Types of Tests 276</p>
<p>Test Scope 278</p>
<ul>
<li>Unit Tests 279</li>
<li>Service Tests 280</li>
<li>End-to-End Tests 281</li>
</ul>
<p>Trade-Offs 282</p>
<p>Implementing Service Tests 283</p>
<ul>
<li>Mocking or Stubbing 283</li>
<li>A Smarter Stub Service 284</li>
</ul>
<p>Implementing (Those Tricky) End-to-End Tests 285</p>
<p>Flaky and Brittle Tests 286</p>
<ul>
<li>Who Writes These End-to-End Tests? 287</li>
<li>How Long Should End-to-End Tests Run? 289</li>
</ul>
<p>The Great Pile-Up 290</p>
<p>The Metaversion 291</p>
<p>Lack of Independent Testability 291</p>
<p>Should You Avoid End-to-End Tests? 292</p>
<p>Contract Tests and Consumer-Driven Contracts (CDCs) 292</p>
<p>The Final Word 295</p>
<p>Developer Experience 296</p>
<p>From Preproduction to In-Production Testing 297</p>
<p>Types of In-Production Testing 298</p>
<p>Making Testing in Production Safe 298</p>
<p>Mean Time to Repair over Mean Time Between Failures? 299</p>
<p>Cross-Functional Testing 300</p>
<ul>
<li>Performance Tests 301</li>
<li>Robustness Tests 302</li>
</ul>
<p>Summary 303</p>
<p>ix | Table of Contents</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0011</div>
            </div>
        </div>
        <!-- Page 0012 -->
        <div class="chapter" id="page-0012">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>10. From Monitoring to Observability. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305</h4>
<p>Disruption, Panic, and Confusion 305</p>
<ul>
<li>Single Microservice, Single Server 306</li>
<li>Single Microservice, Multiple Servers 307</li>
<li>Multiple Services, Multiple Servers 308</li>
</ul>
<p>Observability Versus Monitoring 309</p>
<p>The Pillars of Observability? Not So Fast 310</p>
<p>Building Blocks for Observability 311</p>
<ul>
<li>Log Aggregation 312</li>
<li>Metrics Aggregation 321</li>
<li>Distributed Tracing 324</li>
</ul>
<p>Are We Doing OK? 327</p>
<p>Alerting 329</p>
<p>Semantic Monitoring 333</p>
<p>Testing in Production 335</p>
<p>Standardization 337</p>
<p>Selecting Tools 338</p>
<ul>
<li>Democratic 338</li>
<li>Easy to Integrate 339</li>
<li>Provide Context 339</li>
<li>Real-Time 339</li>
<li>Suitable for Your Scale 340</li>
<li>The Expert in the Machine 340</li>
</ul>
<p>Getting Started 341</p>
<p>Summary 342</p>
<h4>11. Security. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 345</h4>
<p>Core Principles 346</p>
<ul>
<li>Principle of Least Privilege 347</li>
<li>Defense in Depth 347</li>
<li>Automation 349</li>
</ul>
<p>Build Security into the Delivery Process 349</p>
<p>The Five Functions of Cybersecurity 350</p>
<ul>
<li>Identify 351</li>
<li>Protect 352</li>
<li>Detect 353</li>
<li>Respond 353</li>
<li>Recover 354</li>
</ul>
<p>Foundations of Application Security 354</p>
<ul>
<li>Credentials 354</li>
</ul>
<p>x | Table of Contents</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0012</div>
            </div>
        </div>
        <!-- Page 0013 -->
        <div class="chapter" id="page-0013">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>Patching 360</p>
<ul>
<li>Backups 363</li>
<li>Rebuild 364</li>
</ul>
<p>Implicit Trust Versus Zero Trust 365</p>
<ul>
<li>Implicit Trust 366</li>
<li>Zero Trust 366</li>
</ul>
<p>It’s a Spectrum 367</p>
<p>Securing Data 369</p>
<ul>
<li>Data in Transit 369</li>
<li>Data at Rest 372</li>
</ul>
<p>Authentication and Authorization 375</p>
<ul>
<li>Service-to-Service Authentication 375</li>
<li>Human Authentication 376</li>
</ul>
<p>Common Single Sign-On Implementations 376</p>
<ul>
<li>Single Sign-On Gateway 377</li>
</ul>
<p>Fine-Grained Authorization 379</p>
<p>The Confused Deputy Problem 380</p>
<ul>
<li>Centralized, Upstream Authorization 381</li>
<li>Decentralizing Authorization 382</li>
</ul>
<p>JSON Web Tokens 382</p>
<p>Summary 386</p>
<h4>12. Resiliency. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 387</h4>
<p>What Is Resiliency? 387</p>
<ul>
<li>Robustness 388</li>
<li>Rebound 389</li>
<li>Graceful Extensibility 390</li>
<li>Sustained Adaptability 390</li>
</ul>
<p>And Microservice Architecture 391</p>
<p>Failure Is Everywhere 391</p>
<p>How Much Is Too Much? 392</p>
<p>Degrading Functionality 394</p>
<p>Stability Patterns 395</p>
<ul>
<li>Time-Outs 397</li>
<li>Retries 399</li>
<li>Bulkheads 400</li>
<li>Circuit Breakers 401</li>
<li>Isolation 404</li>
<li>Redundancy 405</li>
<li>Middleware 405</li>
<li>Idempotency 406</li>
</ul>
<p>xi | Table of Contents</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0013</div>
            </div>
        </div>
        <!-- Page 0014 -->
        <div class="chapter" id="page-0014">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>Spreading Your Risk 407</p>
<ul>
<li>CAP Theorem 408</li>
<li>Sacrificing Consistency 410</li>
<li>Sacrificing Availability 410</li>
<li>Sacrificing Partition Tolerance? 411</li>
</ul>
<p>AP or CP? 411</p>
<p>It’s Not All or Nothing 412</p>
<p>And the Real World 412</p>
<p>Chaos Engineering 413</p>
<ul>
<li>Game Days 414</li>
<li>Production Experiments 415</li>
</ul>
<p>From Robustness to Beyond 415</p>
<p>Blame 415</p>
<p>Summary 417</p>
<h4>13. Scaling. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 419</h4>
<p>The Four Axes of Scaling 419</p>
<ul>
<li>Vertical Scaling 420</li>
<li>Horizontal Duplication 422</li>
<li>Data Partitioning 426</li>
<li>Functional Decomposition 430</li>
</ul>
<p>Combining Models 432</p>
<p>Start Small 433</p>
<p>Caching 435</p>
<ul>
<li>For Performance 436</li>
<li>For Scale 436</li>
<li>For Robustness 436</li>
</ul>
<p>Where to Cache 437</p>
<p>Invalidation 442</p>
<p>The Golden Rule of Caching 447</p>
<p>Freshness Versus Optimization 448</p>
<p>Cache Poisoning: A Cautionary Tale 448</p>
<p>Autoscaling 449</p>
<p>Starting Again 450</p>
<p>Summary 451</p>
<p>xii | Table of Contents</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0014</div>
            </div>
        </div>
        <!-- Page 0015 -->
        <div class="chapter" id="page-0015">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Part III. People</h4>
<h4>14. User Interfaces. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 455</h4>
<p>Toward Digital 456</p>
<p>Ownership Models 456</p>
<p>Drivers for Dedicated Frontend Teams 458</p>
<p>Toward Stream-Aligned Teams 459</p>
<p>Sharing Specialists 460</p>
<p>Ensuring Consistency 461</p>
<p>Working Through Technical Challenges 462</p>
<p>Pattern: Monolithic Frontend 463</p>
<p>When to Use It 464</p>
<p>Pattern: Micro Frontends 464</p>
<ul>
<li>Implementation 465</li>
<li>When to Use It 465</li>
</ul>
<p>Pattern: Page-Based Decomposition 467</p>
<p>Where to Use It 468</p>
<p>Pattern: Widget-Based Decomposition 469</p>
<ul>
<li>Implementation 470</li>
<li>When to Use It 473</li>
</ul>
<p>Constraints 474</p>
<p>Pattern: Central Aggregating Gateway 475</p>
<p>Ownership 476</p>
<p>Different Types of User Interfaces 477</p>
<p>Multiple Concerns 478</p>
<p>When to Use It 479</p>
<p>Pattern: Backend for Frontend (BFF) 480</p>
<ul>
<li>How Many BFFs? 481</li>
<li>Reuse and BFFs 483</li>
<li>BFFs for Desktop Web and Beyond 486</li>
<li>When to Use 487</li>
</ul>
<p>GraphQL 488</p>
<p>A Hybrid Approach 489</p>
<p>Summary 490</p>
<h4>15. Organizational Structures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 491</h4>
<p>Loosely Coupled Organizations 491</p>
<p>Conway’s Law 493</p>
<p>Evidence 493</p>
<p>Team Size 495</p>
<p>xiii | Table of Contents</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0015</div>
            </div>
        </div>
        <!-- Page 0016 -->
        <div class="chapter" id="page-0016">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>Understanding Conway’s Law 496</p>
<ul>
<li>Small Teams, Large Organization 496</li>
<li>On Autonomy 498</li>
</ul>
<p>Strong Versus Collective Ownership 499</p>
<ul>
<li>Strong Ownership 500</li>
<li>Collective Ownership 501</li>
</ul>
<p>At a Team Level Versus an Organizational Level 502</p>
<p>Balancing Models 502</p>
<p>Enabling Teams 503</p>
<p>Communities of Practice 505</p>
<p>The Platform 506</p>
<p>Shared Microservices 509</p>
<ul>
<li>Too Hard to Split 509</li>
<li>Cross-Cutting Changes 509</li>
<li>Delivery Bottlenecks 510</li>
</ul>
<p>Internal Open Source 511</p>
<ul>
<li>Role of the Core Committers 511</li>
<li>Maturity 512</li>
<li>Tooling 512</li>
</ul>
<p>Pluggable, Modular Microservices 513</p>
<p>Change Reviews 515</p>
<p>The Orphaned Service 518</p>
<p>Case Study: realestate.com.au 519</p>
<p>Geographical Distribution 521</p>
<p>Conway’s Law in Reverse 522</p>
<p>People 523</p>
<p>Summary 524</p>
<h4>16. The Evolutionary Architect. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 525</h4>
<p>What’s in a Name? 525</p>
<p>What Is Software Architecture? 527</p>
<p>Making Change Possible 529</p>
<p>An Evolutionary Vision for the Architect 529</p>
<p>Defining System Boundaries 530</p>
<p>A Social Construct 533</p>
<p>Habitability 534</p>
<p>A Principled Approach 536</p>
<ul>
<li>Strategic Goals 536</li>
<li>Principles 536</li>
<li>Practices 537</li>
<li>Combining Principles and Practices 537</li>
</ul>
<p>xiv | Table of Contents</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0016</div>
            </div>
        </div>
        <!-- Page 0017 -->
        <div class="chapter" id="page-0017">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>یک مثال دنیای واقعی</h3>
<p>538</p>
<h3>هدایت یک معماری تکاملی</h3>
<p>539</p>
<h3>معماری در یک سازمان Stream-Aligned</h3>
<p>540</p>
<h3>ساختن یک تیم</h3>
<p>542</p>
<h3>The Required Standard</h3>
<p>543</p>
<h3>Monitoring</h3>
<p>543</p>
<h3>Interfaces</h3>
<p>543</p>
<h3>Architectural Safety</h3>
<p>544</p>
<h3>Governance و Paved Road</h3>
<p>544</p>
<h3>Exemplars</h3>
<p>545</p>
<h3>Tailored Microservice Template</h3>
<p>545</p>
<h3>The Paved Road at Scale</h3>
<p>547</p>
<h3>Technical Debt</h3>
<p>547</p>
<h3>Exception Handling</h3>
<p>548</p>
<h3>خلاصه</h3>
<p>548</p>
<h3>Afterword: Bringing It All Together...</h3>
<p>551</p>
<h3>Bibliography</h3>
<p>563</p>
<h3>Glossary</h3>
<p>569</p>
<h3>Index</h3>
<p>575</p>
<h3>فهرست مطالب</h3>
<p>xv</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0017</div>
            </div>
        </div>
        <!-- Page 0019 -->
        <div class="chapter" id="page-0019">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>Preface</h3>
<p>
<strong>Microservices</strong> یک رویکرد برای سیستم‌های توزیع‌شده است که استفاده از
    <strong>services</strong> های دقیق را ترویج می‌کند که می‌توانند به طور مستقل تغییر،
    توسعه و منتشر شوند. برای سازمان‌هایی که به سمت سیستم‌های
    loosely coupled (کم‌اتصال) حرکت می‌کنند، با تیم‌های خودمختار که
    عملکردهای کاربرپسند را ارائه می‌دهند، <strong>microservices</strong> بسیار خوب عمل می‌کنند.
    فراتر از این، <strong>microservices</strong> تعداد زیادی گزینه برای ساخت سیستم‌ها در اختیار ما
    قرار می‌دهند و انعطاف‌پذیری زیادی را برای اطمینان از اینکه سیستم ما می‌تواند
    برای پاسخگویی به نیازهای کاربران تغییر کند، به ما می‌دهند.
  </p>
<p>
    با این حال، <strong>Microservices</strong> بدون معایب قابل توجه نیستند. به عنوان یک سیستم
    توزیع‌شده، آن‌ها پیچیدگی‌های زیادی به همراه دارند که بسیاری از آن‌ها ممکن است
    حتی برای توسعه‌دهندگان باتجربه نیز جدید باشد.
  </p>
<p>
    تجربیات مردم در سراسر جهان، همراه با ظهور فناوری‌های جدید، تأثیر عمیقی بر
    نحوه استفاده از <strong>microservices</strong> دارد. این کتاب این ایده‌ها را همراه با مثال‌های
    ملموس و دنیای واقعی جمع‌آوری می‌کند تا به شما کمک کند بفهمید آیا
    <strong>microservices</strong> برای شما مناسب هستند یا خیر.
  </p>
<h3>Who Should Read This Book (چه کسی باید این کتاب را بخواند)</h3>
<p>
    دامنه "Building Microservices" وسیع است، زیرا پیامدهای معماری
    <strong>microservice</strong> نیز گسترده است. به این ترتیب، این کتاب باید مورد توجه افرادی
    قرار گیرد که به جنبه‌های طراحی، توسعه، استقرار، تست و نگهداری سیستم‌ها
    علاقه‌مند هستند.
  </p>
<p>
    آن دسته از شما که قبلاً سفر به سمت معماری‌های دقیق‌تر را آغاز کرده‌اید، چه برای
    یک برنامه <strong>greenfield</strong> یا به عنوان بخشی از تجزیه یک سیستم موجود و
    monolithic، توصیه‌های عملی فراوانی برای کمک به شما پیدا خواهید کرد. این کتاب
    همچنین به آن دسته از شما که می‌خواهید بدانید چه خبر است، کمک می‌کند تا بتوانید
    تعیین کنید آیا <strong>microservices</strong> برای شما مناسب هستند یا خیر.
  </p>
<p>Preface | xvii</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0019</div>
            </div>
        </div>
        <!-- Page 0020 -->
        <div class="chapter" id="page-0020">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>Why I Wrote This Book (چرا این کتاب را نوشتم)</h3>
<p>
    در یک سطح، من این کتاب را نوشتم زیرا می‌خواستم مطمئن شوم که اطلاعات موجود
    در نسخه اول به‌روز، دقیق و مفید باقی می‌ماند. من نسخه اول را نوشتم زیرا ایده‌های
    واقعاً جالبی وجود داشت که می‌خواستم به اشتراک بگذارم. خوشبختانه در جایی بودم
    که زمان و پشتیبانی برای نوشتن نسخه اول را داشتم و می‌توانستم این کار را از یک
    دیدگاه نسبتاً بی‌طرفانه انجام دهم زیرا برای یک فروشنده بزرگ فناوری کار نمی‌کردم.
    من در حال فروش یک <strong>solution</strong> نبودم، و امیدوار بودم که <strong>microservices</strong> را هم
    نمی‌فروشم — من فقط ایده‌ها را جذاب یافتم و عاشق باز کردن مفهوم
    <strong>microservices</strong> و یافتن راه‌هایی برای به اشتراک گذاشتن آن به طور گسترده‌تر بودم.
  </p>
<p>
    وقتی واقعاً آن را تجزیه می‌کنم، من یک نسخه دوم را به دو دلیل اصلی نوشتم. اولاً،
    احساس کردم که می‌توانم این بار کار بهتری انجام دهم. من چیزهای بیشتری یاد
    گرفته‌ام و امیدوارم که کمی بهتر نویسنده باشم. اما من همچنین این نسخه دوم را
    نوشتم زیرا نقش کوچکی در کمک به این ایده‌ها برای رسیدن به جریان اصلی داشتم و
    به این ترتیب وظیفه دارم اطمینان حاصل کنم که آن‌ها به روشی معقول و متعادل
    ارائه می‌شوند. <strong>Microservices</strong> برای بسیاری، تبدیل به انتخاب معماری پیش‌فرض شده
    است. این چیزی است که فکر می‌کنم توجیه آن دشوار است و من می‌خواستم
    فرصتی برای به اشتراک گذاشتن دلیل آن داشته باشم.
  </p>
<p>
    این کتاب نه طرفدار <strong>microservices</strong> است و نه مخالف آن. من فقط می‌خواهم مطمئن
    شوم که من به درستی زمینه‌ای را که در آن این ایده‌ها به خوبی کار می‌کنند، بررسی
    کرده‌ام و مشکلات آن‌ها را به اشتراک گذاشته‌ام.
  </p>
<h3>What’s Changed Since the First Edition? (از زمان نسخه اول چه چیزی تغییر کرده
    است؟)</h3>
<p>
    من نسخه اول Building Microservices را در حدود یک سال نوشتم که از اوایل سال
    2014 شروع شد و این کتاب در فوریه 2015 منتشر شد. این در اوایل داستان
    <strong>microservices</strong> بود، حداقل از نظر آگاهی صنعت از این اصطلاح. از آن زمان،
    <strong>microservices</strong> به گونه‌ای رایج شده‌اند که من نمی‌توانستم پیش‌بینی کنم. با این
    رشد، مجموعه‌ای بسیار وسیع‌تر از تجربیات برای استفاده و فناوری‌های بیشتری برای
    کاوش به وجود آمده است.
  </p>
<p>
    همانطور که من با تیم‌های بیشتری در پی نسخه اول کار کردم، شروع به اصلاح
    تفکرم در مورد برخی از ایده‌های مرتبط با <strong>microservices</strong> کردم. در برخی موارد، این
    به این معنی بود که ایده‌هایی که فقط در حاشیه تفکر من بودند، مانند پنهان کردن
    اطلاعات، شروع به روشن شدن به عنوان مفاهیم اساسی کردند که نیاز به برجسته
    شدن بهتر داشتند. در مناطق دیگر، فناوری جدید هم راه‌حل‌های جدید و هم
    مشکلات جدیدی را برای سیستم‌های ما ارائه کرد. دیدن اینکه افراد زیادی به امید
    اینکه <strong>Kubernetes</strong> تمام مشکلات آن‌ها را با معماری‌های <strong>microservice</strong> حل
    می‌کند، قطعاً باعث شد من مکث کنم.
  </p>
<p>
    علاوه بر این، من نسخه اول Building Microservices را نوشتم تا نه تنها توضیحی در
    مورد <strong>microservices</strong> ارائه دهم، بلکه یک مرور کلی گسترده از چگونگی تغییر این
    رویکرد معماری در جنبه‌های توسعه نرم‌افزار ارائه دهم. بنابراین همانطور که من
    بیشتر به
  </p>
<p>xviii | Preface</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0020</div>
            </div>
        </div>
        <!-- Page 0021 -->
        <div class="chapter" id="page-0021">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
    aspects (جنبه‌ها) مربوط به <strong>security</strong> و <strong>resiliency</strong> را در نظر گرفتم،
    متوجه شدم که می‌خواهم برگردم و آن موضوعاتی را که به طور فزاینده‌ای برای
    توسعه نرم‌افزار مدرن مهم هستند، گسترش دهم.
  </p>
<p>
    بنابراین در این نسخه دوم، زمان بیشتری را صرف به اشتراک گذاشتن مثال‌های
    صریح برای توضیح بهتر ایده‌ها می‌کنم. هر فصل دوباره بررسی شده و هر جمله
    بازبینی شده است. از نظر نثر ملموس، بخش زیادی از نسخه اول باقی نمانده است،
    اما ایده‌ها هنوز هم در اینجا وجود دارند. من سعی کرده‌ام در نظرات خودم
    شفاف‌تر باشم، در حالی که هنوز تشخیص می‌دهم که اغلب راه‌های متعددی برای
    حل یک مشکل وجود دارد. این به معنای گسترش بحث در مورد ارتباطات بین فرآیندی
    بوده است که اکنون در سه فصل تقسیم شده است. من همچنین زمان بیشتری را صرف
    بررسی پیامدهای فناوری‌هایی مانند <strong>containers</strong>، <strong>Kubernetes</strong> و
    <strong>serverless</strong> می‌کنم. در نتیجه، اکنون فصل‌های جداگانه‌ای برای
    <strong>build</strong> و <strong>deployment</strong> وجود دارد.
  </p>
<p>
    امید من این بود که یک کتاب در حدود اندازه نسخه اول ایجاد کنم، در حالی که راهی
    برای بسته‌بندی ایده‌های بیشتر پیدا کنم. همانطور که می‌بینید، من در دستیابی به
    هدف خود شکست خوردم—این نسخه بزرگتر است! اما فکر می‌کنم در روشن‌تر
    بیان کردن ایده‌ها موفق شده‌ام.
  </p>
<h3>Navigating This Book (نحوه پیمایش این کتاب)</h3>
<p>
    این کتاب در درجه اول در یک قالب مبتنی بر موضوع سازماندهی شده است. من کتاب
    را طوری ساختار و نوشته‌ام که گویی آن را از ابتدا تا انتها می‌خوانید، اما البته
    ممکن است بخواهید به موضوعات خاصی که بیشتر مورد علاقه شما هستند، بپرید. اگر
    تصمیم دارید مستقیماً وارد یک فصل خاص شوید، ممکن است <strong>Glossary</strong> (واژه‌نامه)
    در پایان کتاب را در توضیح اصطلاحات جدید یا ناآشنا مفید بدانید. در مورد
    اصطلاحات، من در سراسر کتاب از <strong>microservice</strong> و <strong>service</strong> به جای هم
    استفاده می‌کنم. می‌توانید فرض کنید که این دو اصطلاح به یک چیز اشاره دارند، مگر
    اینکه صریحاً خلاف آن را بیان کنم. من همچنین برخی از توصیه‌های کلیدی کتاب را در
    <strong>Bibliography</strong> (کتاب‌شناسی) خلاصه می‌کنم، اگر واقعاً فقط می‌خواهید به
    انتها بروید—فقط به یاد داشته باشید که اگر این کار را انجام دهید، جزئیات زیادی را
    از دست خواهید داد!
  </p>
<p>
    بدنه اصلی کتاب به سه بخش جداگانه تقسیم شده است: <strong>Foundation</strong> (بنیاد)،
    <strong>Implementation</strong> (پیاده‌سازی) و <strong>People</strong> (مردم). بیایید نگاهی بیندازیم به
    اینکه هر بخش چه چیزی را پوشش می‌دهد.
  </p>
<h4>Part I, Foundation (بخش اول، بنیاد)</h4>
<p>
    در این بخش، من برخی از ایده‌های اصلی پشت <strong>microservices</strong> را توضیح می‌دهم.
  </p>
<p>
<strong>Chapter 1, What Are Microservices? (فصل 1، Microservices چیست؟)</strong>
</p>
<p>
    این یک مقدمه کلی بر <strong>microservices</strong> است که در آن به طور خلاصه در مورد تعدادی
    از موضوعاتی که بعداً در کتاب به آن‌ها خواهم پرداخت، بحث می‌کنم.
  </p>
<p>
<strong>Chapter 2, How to Model Microservices (فصل 2، نحوه مدل‌سازی Microservices)</strong>
</p>
<p>
    این فصل اهمیت مفاهیمی مانند پنهان کردن اطلاعات، <strong>coupling</strong> (اتصال)،
    <strong>cohesion</strong> (انسجام) و <strong>domain-driven design</strong> در کمک به یافتن
    مرزهای مناسب برای <strong>microservices</strong> شما را بررسی می‌کند.
  </p>
<p>Preface | xix</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0021</div>
            </div>
        </div>
        <!-- Page 0022 -->
        <div class="chapter" id="page-0022">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Chapter 3, Splitting the Monolith (فصل 3، تقسیم <strong>Monolith</strong>)</h4>
<p>
    این فصل مقداری راهنمایی در مورد چگونگی گرفتن یک برنامه monolithic موجود و
    شکستن آن به <strong>microservices</strong> ارائه می‌دهد.
  </p>
<h4>Chapter 4, Microservice Communication Styles (فصل 4، سبک‌های ارتباط
    Microservice)</h4>
<p>
    فصل آخر در این بخش، بحثی در مورد انواع مختلف ارتباطات <strong>microservice</strong>، از
    جمله تماس‌های asynchronous (ناهمزمان) در مقابل synchronous (همزمان) و سبک‌های
    همکاری request-response (درخواست-پاسخ) و event-driven (رویداد محور) ارائه
    می‌دهد.
  </p>
<h4>Part II, Implementation (بخش دوم، پیاده‌سازی)</h4>
<p>
    در این بخش با حرکت از مفاهیم سطح بالاتر به جزئیات پیاده‌سازی، به تکنیک‌ها و
    فناوری‌هایی می‌پردازیم که می‌توانند به شما کمک کنند تا بیشترین بهره را از
    <strong>microservices</strong> ببرید.
  </p>
<h4>Chapter 5, Implementing Microservice Communication (فصل 5، پیاده‌سازی
    ارتباطات Microservice)</h4>
<p>
    در این فصل به فناوری‌های خاصی که برای پیاده‌سازی ارتباطات بین
    <strong>microservice</strong> استفاده می‌شوند، عمیق‌تر می‌پردازیم.
  </p>
<h4>Chapter 6, Workflow (فصل 6، گردش کار)</h4>
<p>
    این فصل مقایسه‌ای از <strong>sagas</strong> و تراکنش‌های توزیع‌شده ارائه می‌دهد و در مورد
    کاربرد آن‌ها در مدل‌سازی فرآیندهای تجاری شامل <strong>microservices</strong> متعدد بحث
    می‌کند.
  </p>
<h4>Chapter 7, Build (فصل 7، ساخت)</h4>
<p>
    این فصل، نگاشت از یک <strong>microservice</strong> به <strong>repositories</strong> و ساخت‌ها را
    توضیح می‌دهد.
  </p>
<h4>Chapter 8, Deployment (فصل 8، استقرار)</h4>
<p>
    در این فصل بحث در مورد گزینه‌های بی‌شمار پیرامون استقرار یک
    <strong>microservice</strong>، از جمله نگاهی به <strong>containers</strong>، <strong>Kubernetes</strong> و
    <strong>FaaS</strong> را خواهید یافت.
  </p>
<h4>Chapter 9, Testing (فصل 9، تست)</h4>
<p>
    در اینجا من در مورد چالش‌های تست <strong>microservices</strong>، از جمله مسائل ناشی از
    تست‌های end-to-end (انتها به انتها) و اینکه چگونه قراردادهای مصرف‌کننده و
    تست در تولید می‌توانند کمک کنند، بحث می‌کنم.
  </p>
<h4>Chapter 10, From Monitoring to Observability (فصل 10، از مانیتورینگ تا
    Observability)</h4>
<p>
    این فصل تغییر از تمرکز بر فعالیت‌های <strong>monitoring</strong> استاتیک به تفکر
    گسترده‌تر در مورد چگونگی بهبود <strong>observability</strong> معماری‌های
    <strong>microservice</strong>، همراه با برخی توصیه‌های خاص در مورد ابزارها را پوشش می‌دهد.
  </p>
<h4>Chapter 11, Security (فصل 11، امنیت)</h4>
<p>
    معماری‌های <strong>microservice</strong> می‌توانند سطح حمله را افزایش دهند، اما همچنین
    فرصت بیشتری برای دفاع عمیق به ما می‌دهند. در این فصل، ما این تعادل را بررسی
    می‌کنیم.
  </p>
<h4>Chapter 12, Resiliency (فصل 12، انعطاف‌پذیری)</h4>
<p>
    این فصل نگاهی گسترده‌تر به آنچه <strong>resiliency</strong> (انعطاف پذیری) است و نقشی
    که <strong>microservices</strong> می‌توانند در بهبود <strong>resiliency</strong> برنامه‌های شما
    ایفا کنند، ارائه می‌دهد.
  </p>
<p>xx | Preface</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0022</div>
            </div>
        </div>
        <!-- Page 0023 -->
        <div class="chapter" id="page-0023">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Chapter 13, Scaling (فصل 13، مقیاس‌پذیری)</h4>
<p>
    در این فصل، من چهار محور <strong>scaling</strong> را شرح می‌دهم و نشان می‌دهم که چگونه
    می‌توانند در ترکیب برای مقیاس‌بندی معماری <strong>microservice</strong> استفاده شوند.
  </p>
<h4>Part III, People (بخش سوم، افراد)</h4>
<p>
    ایده‌ها و فناوری‌ها بدون افراد و سازمانی که از آن‌ها حمایت کنند، معنایی
    ندارند.
  </p>
<h4>Chapter 14, User Interfaces (فصل 14، رابط‌های کاربری)</h4>
<p>
    از دور شدن از تیم‌های <strong>frontend</strong> اختصاصی تا استفاده از <strong>BFFs</strong> و
    <strong>GraphQL</strong>، این فصل بررسی می‌کند که چگونه <strong>microservices</strong> و رابط‌های
    کاربری می‌توانند با هم کار کنند.
  </p>
<h4>Chapter 15, Organizational Structures (فصل 15، ساختارهای سازمانی)</h4>
<p>
    این فصل ماقبل آخر بر چگونگی عملکرد تیم‌های <strong>stream-aligned</strong> و فعال‌کننده در
    زمینه معماری‌های <strong>microservice</strong> تمرکز دارد.
  </p>
<h4>Chapter 16, The Evolutionary Architect (فصل 16، معمار تکاملی)</h4>
<p>
    معماری‌های <strong>microservice</strong> استاتیک نیستند، بنابراین دیدگاه شما نسبت به معماری
    سیستم ممکن است نیاز به تغییر داشته باشد—موضوعی که این فصل به طور
    عمقی به آن می‌پردازد.
  </p>
<h3>Conventions Used in This Book (قراردادهای استفاده شده در این کتاب)</h3>
<p>
    قراردادهای تایپوگرافی زیر در این کتاب استفاده شده است:
  </p>
<p><em>Italic</em></p>
<p>
    اصطلاحات جدید، <strong>URLs</strong>، آدرس‌های ایمیل، نام فایل‌ها و پسوندهای فایل را
    نشان می‌دهد.
  </p>
<p>Constant width</p>
<p>
    برای لیست‌های برنامه، و همچنین در داخل پاراگراف‌ها برای اشاره به عناصر
    برنامه مانند نام متغیرها یا توابع، پایگاه‌های داده، انواع داده، متغیرهای
    محیطی، عبارات و <strong>keywords</strong> استفاده می‌شود.
  </p>
<p>
<span style="font-weight: bold;">This element signifies a tip or suggestion.</span>
</p>
<p>
<span style="font-weight: bold;">This element signifies a general note.</span>
</p>
<p>Preface | xxi</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 23" src="page_0023/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 23" src="page_0023/image_2.png"/></div>
</div>
                <div class="page-number">صفحه 0023</div>
            </div>
        </div>
        <!-- Page 0024 -->
        <div class="chapter" id="page-0024">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<span style="font-weight: bold;">This element indicates a warning or caution.</span>
</p>
<h3>O’Reilly Online Learning</h3>
<p>
    برای بیش از 40 سال، O’Reilly Media آموزش فناوری و تجارت، دانش و بینش را برای
    کمک به موفقیت شرکت‌ها ارائه کرده است.
  </p>
<p>
    شبکه منحصربه‌فرد ما از کارشناسان و نوآوران دانش و تخصص خود را از طریق کتاب‌ها،
    مقالات و پلتفرم آموزش آنلاین ما به اشتراک می‌گذارند. پلتفرم آموزش آنلاین
    O’Reilly به شما امکان دسترسی درخواستی به دوره‌های آموزشی زنده، مسیرهای
    یادگیری عمیق، محیط‌های کدنویسی تعاملی و مجموعه وسیعی از متن و ویدئو از
    O’Reilly و 200+ ناشر دیگر را می‌دهد. برای اطلاعات بیشتر، به آدرس
    http://oreilly.com مراجعه کنید.
  </p>
<h3>How to Contact Us (چگونه با ما تماس بگیرید)</h3>
<p>
    لطفاً نظرات و سؤالات مربوط به این کتاب را به ناشر ارسال کنید:
  </p>
<p>O’Reilly Media, Inc.</p>
<p>1005 Gravenstein Highway North</p>
<p>Sebastopol, CA 95472</p>
<p>800-998-9938 (در ایالات متحده یا کانادا)</p>
<p>707-829-0515 (بین‌المللی یا محلی)</p>
<p>707-829-0104 (فکس)</p>
<p>
    ما یک صفحه وب برای این کتاب داریم که در آن خطاها، مثال‌ها و هر اطلاعات
    اضافی را فهرست می‌کنیم. شما می‌توانید به این صفحه در
    https://oreil.ly/Building_Microservices2 دسترسی داشته باشید.
  </p>
<p>
    برای نظر دادن یا پرسیدن سؤالات فنی در مورد این کتاب، به
    bookquestions@oreilly.com ایمیل بزنید.
  </p>
<p>
    برای اخبار و اطلاعات در مورد کتاب‌ها و دوره‌های ما، به
    http://oreilly.com مراجعه کنید.
  </p>
<p>ما را در Facebook بیابید: http://facebook.com/oreilly</p>
<p>ما را در Twitter دنبال کنید: http://twitter.com/oreillymedia</p>
<p>ما را در YouTube تماشا کنید: http://youtube.com/oreillymedia</p>
<p>xxii | Preface</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 24" src="page_0024/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 24" src="page_0024/image_2.png"/></div>
</div>
                <div class="page-number">صفحه 0024</div>
            </div>
        </div>
        <!-- Page 0025 -->
        <div class="chapter" id="page-0025">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>Acknowledgments (تشکر و قدردانی)</h3>
<p>
    من دائماً از حمایتی که از خانواده‌ام دریافت می‌کنم، به‌ویژه از همسرم، Lindy
    Stephens، که با لطف و بزرگواری بسیار زیادی تحمل می‌کند، شگفت‌زده
    هستم. اینکه بگویم این کتاب بدون او وجود نمی‌داشت، یک کم‌لطفی است، حتی اگر
    او همیشه وقتی به او می‌گویم باور نکند. این برای او است. همچنین برای پدرم، Jack،
    Josie، Kane و قبیله گسترده‌تر Gilmanco Staynes است.
  </p>
<p>
    بخش زیادی از این کتاب در طول یک بیماری همه‌گیر جهانی نوشته شد که در حالی که
    این تشکر و قدردانی را می‌نویسم، هنوز هم ادامه دارد. شاید زیاد معنی نداشته
    باشد، اما می‌خواهم از NHS (سرویس سلامت همگانی) در اینجا در بریتانیا و
    همچنین از همه مردم در سراسر جهان که با کار بر روی واکسن‌ها، درمان بیماران،
    تحویل غذای ما و کمک به هزاران روش دیگر که من نمی‌فهمم، از ما محافظت
    می‌کنند، تشکر کنم. این هم برای همه شماست.
  </p>
<p>
    این نسخه دوم بدون نسخه اول وجود نمی‌داشت، بنابراین می‌خواهم از همه کسانی
    که در طول فرآیند چالش‌برانگیز نوشتن اولین کتابم به من کمک کردند، از جمله
    بازبینان فنی Ben Christensen، Martin Fowler و Venkat Subra‐maniam؛ James
    Lewis برای مکالمات روشنگرانه ما؛ تیم O’Reilly شامل Brian MacDonald، Rachel
    Monaghan، Kristen Brown و Betsy Waliszewski؛ و بازخورد بررسی عالی از خوانندگان
    Anand Krishnaswamy، Kent McNeil، Charles Haynes، Chris Ford، Aidy Lewis، Will
    Thames، Jon Eaves، Rolf Russell، Badrinath Janakiraman، Daniel Bryant، Ian
    Robinson، Jim Webber، Stewart Gleadow، Evan Bottcher، Eric Sword و Olivia
    Leonard تشکر کنم. و از مایک لوکیدز هم تشکر می‌کنم، حدس می‌زنم، به خاطر اینکه
    من را در وهله اول وارد این آشفتگی کرد!
  </p>
<p>
    برای نسخه دوم، Martin Fowler بار دیگر به‌عنوان بازبین فنی بازگشت و به Daniel
    Bryant و Sarah Wells پیوست که در زمان و بازخورد خود سخاوتمند بودند. من
    همچنین می‌خواهم از Nicky Wrightson و Alexander von Zitzerwitz برای کمک به
    پیشبرد بررسی فنی در خط پایان تشکر کنم. در جبهه O’Reilly، کل فرآیند توسط
    سردبیر فوق‌العاده من، Nicole Taché، که بدون او قطعاً دیوانه می‌شدم، نظارت
    شد؛ Melissa Duffield، که به نظر می‌رسد کار مدیریت حجم کاری من را بهتر از
    خودم انجام می‌دهد؛ Deb Baker، Arthur Johnson و بقیه تیم تولید (متاسفم که
    همه نام‌های شما را نمی‌دانم، اما متشکرم!)؛ و Mary Treseler، برای هدایت کشتی
    در زمان‌های دشوار.
  </p>
<p>
    علاوه بر این، نسخه دوم به‌شدت از کمک‌ها و بینش‌های تعدادی از افراد، از جمله
    (به ترتیب خاصی نیست) Dave Coombes و تیم در Tyro، Dave Halsey و تیم در
    Money Supermarket، Tom Kerkhove، Erik Doer‐nenburg، Graham Tackley، Kent
    Beck، Kevlin Henney، Laura Bell، Adrian Mouat، Sarah Taraporewalla، Uwe
    Friedrichse، Liz Fong-Jones، Kane Stephens، Gilmanco Staynes، Adam Tornhill،
    Venkat Subramaniam، Susanne Kaiser، Jan Schaumann، Grady Booch، Pini Reznik،
    Nicole Forsgren، Jez Humble، Gene Kim، Manuel Pais، Matthew Skelton، و
    South Sydney Rabbitohs بهره‌مند شده است. در پایان، می‌خواهم از خوانندگان
    فوق‌العاده نسخه دسترسی زودهنگام کتاب تشکر کنم که
  </p>
<p>Preface | xxiii</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0025</div>
            </div>
        </div>
        <!-- Page 0026 -->
        <div class="chapter" id="page-0026">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
    feedback (بازخورد) ارائه کردند؛ آن‌ها شامل Felipe de Morais، Mark Gardner، David
    Lauzon، Assam Zafar، Michael Bleterman، Nicola Musatti، Eleonora Lester، Felipe de
    Morais، Nathan DiMauro، Daniel Lemke، Soner Eker، Ripple Shah، Joel Lim و
    Himanshu Pant هستند.
  </p>
<p>
    و در پایان، سلام به Jason Isaacs.
  </p>
<p>
    من بخش عمده این کتاب را در طول سال 2020 و در نیمه اول سال 2021 نوشتم. من از
    Visual Studio Code در macOS برای اکثر نوشته‌ها استفاده کردم، اگرچه در موارد
    نادر از Working Copy در iOS نیز استفاده کردم. OmniGraffle برای ایجاد تمام
    نمودارهای کتاب استفاده شد. AsciiDoc برای قالب‌بندی کتاب استفاده شد و در کل
    عالی بود، با ابزار Atlas O’Reilly که جادوی ظاهر شدن یک کتاب را در طرف دیگر
    انجام می‌دهد.
  </p>
<p>xxiv | Preface</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0026</div>
            </div>
        </div>
        <!-- Page 0027 -->
        <div class="chapter" id="page-0027">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>PART I</h3>
<p>Foundation</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0027</div>
            </div>
        </div>
        <!-- Page 0029 -->
        <div class="chapter" id="page-0029">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>CHAPTER 1</h3>
<h4>Microservices چیستند؟</h4>
<p>
   از زمانی که ویرایش اول این کتاب را نوشتم، Microservices به یک انتخاب معماری فزاینده محبوب در نیم دهه یا بیشتر تبدیل شده‌اند. من نمی‌توانم ادعای اعتباری برای انفجار بعدی در محبوبیت داشته باشم، اما هجوم برای استفاده از معماری‌های microservice به این معنی است که در حالی که بسیاری از ایده‌هایی که قبلاً ضبط کردم اکنون امتحان و آزمایش شده‌اند، ایده‌های جدیدی در عین حال وارد ترکیب شده‌اند که شیوه‌های قبلی از مد افتاده‌اند. بنابراین زمان آن فرا رسیده است که یک بار دیگر جوهر معماری microservice را تقطیر کنیم و در عین حال مفاهیم اصلی که باعث می‌شوند microservices کار کنند را برجسته کنیم.
  </p>
<p>
   این کتاب به طور کلی برای ارائه یک مرور کلی از تأثیری که microservices بر جنبه‌های مختلف تحویل نرم‌افزار دارند، طراحی شده است. برای شروع، این فصل به ایده‌های اصلی پشت microservices، هنر قبلی که ما را به اینجا رسانده است، و برخی از دلایلی که چرا این معماری‌ها به طور گسترده استفاده می‌شوند، نگاهی خواهد انداخت.
  </p>
<h4>Microservices در یک نگاه</h4>
<p>
   Microservices سرویس‌هایی هستند که به طور مستقل قابل انتشار هستند و حول یک <strong>business domain</strong> مدل‌سازی شده‌اند. یک <strong>service</strong> یک <em>عملکرد</em> را کپسوله می‌کند و آن را از طریق شبکه‌ها برای سایر سرویس‌ها در دسترس قرار می‌دهد—شما یک سیستم پیچیده‌تر از این بلوک‌های ساختمانی می‌سازید. یک microservice ممکن است <strong>inventory</strong> را نشان دهد، دیگری <strong>order management</strong> را و دیگری <strong>shipping</strong> را، اما در کنار هم ممکن است یک سیستم تجارت الکترونیک کامل را تشکیل دهند. Microservices یک انتخاب معماری است که بر ارائه گزینه‌های زیادی برای حل مشکلاتی که ممکن است با آن مواجه شوید، متمرکز است.
  </p>
<p>
   آنها نوعی از معماری <strong>service-oriented</strong> هستند، اگرچه یکی از این نظر که چگونه <em>مرزهای سرویس</em> باید ترسیم شوند، نظر دارد، و یکی که در آن استقرار مستقل کلیدی است. آنها از نظر فناوری خنثی هستند، که یکی از مزایایی است که ارائه می‌دهند.
  </p>
<p>
   از بیرون، یک microservice واحد به عنوان یک جعبه سیاه تلقی می‌شود. این <strong>business functionality</strong> را در یک یا چند <strong>network endpoint</strong> (به عنوان مثال، یک صف یا یک <strong>REST</strong>) میزبانی می‌کند.
  </p>
<p>3</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0029</div>
            </div>
        </div>
        <!-- Page 0030 -->
        <div class="chapter" id="page-0030">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   1 این مفهوم اولین بار توسط David Parnas در “Information Distribution Aspects of Design Methodol‐ogy” در 
   <em>Information Processing: Proceedings of the IFIP Congress 1971</em> (Amsterdam: North-Holland, 1972), 1:339–44 تشریح شد.
  </p>
<p>
<strong>API</strong>، همانطور که در شکل 1-1 نشان داده شده است، از طریق هر <strong>protocol</strong> که مناسب‌تر است. <strong>Consumers</strong>، چه microservicesهای دیگر باشند یا انواع دیگر برنامه‌ها، از طریق این <strong>networked endpoints</strong> به این <strong>functionality</strong> دسترسی پیدا می‌کنند. جزئیات پیاده‌سازی داخلی (مانند فناوری که <strong>service</strong> با آن نوشته شده است یا نحوه ذخیره داده‌ها) کاملاً از دنیای بیرون پنهان است. این بدان معناست که معماری‌های microservice از استفاده از پایگاه‌های داده مشترک در اکثر شرایط اجتناب می‌کنند. در عوض، هر microservice پایگاه داده خود را در صورت نیاز کپسوله می‌کند.
  </p>
<p>
   شکل 1-1. یک microservice که <strong>functionality</strong> خود را از طریق یک <strong>REST API</strong> و یک موضوع به نمایش می‌گذارد.
  </p>
<p>
   Microservices مفهوم <strong>information hiding</strong> را در بر می‌گیرند. 1 <strong>Information hiding</strong> به معنای پنهان کردن تا حد امکان اطلاعات در داخل یک کامپوننت و در معرض قرار دادن تا حد امکان کم از طریق <strong>external interfaces</strong> است. این امر امکان جداسازی واضح بین آنچه که می‌تواند به راحتی تغییر کند و آنچه که تغییر آن دشوارتر است را فراهم می‌کند. پیاده‌سازی که از طرف‌های خارجی پنهان شده است، تا زمانی که <strong>networked interfaces</strong> که microservice در معرض نمایش قرار می‌دهد، به روشی که با عقب سازگاری ندارد، تغییر نکنند، می‌تواند آزادانه تغییر کند. تغییرات در داخل یک <strong>microservice boundary</strong> (همانطور که در شکل 1-1 نشان داده شده است) نباید بر یک <strong>upstream</strong> تأثیر بگذارد.
  </p>
<p>4 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 30" src="page_0030/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0030</div>
            </div>
        </div>
        <!-- Page 0031 -->
        <div class="chapter" id="page-0031">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   2 Alistair Cockburn, “Hexagonal Architecture,” January 4, 2005, https://oreil.ly/NfvTP.
   <strong>consumer</strong>، امکان انتشار مستقل <strong>functionality</strong> را فراهم می‌کند. این امر در اجازه دادن به microservices ما برای کار در انزوا و انتشار <strong>on demand</strong> ضروری است. داشتن <strong>service boundaries</strong> روشن و پایدار که با تغییر پیاده‌سازی داخلی تغییر نمی‌کنند، منجر به سیستم‌هایی با <em>coupling</em> کمتر و <em>cohesion</em> قوی‌تر می‌شود.
  </p>
<p>
   در حالی که ما در مورد پنهان کردن <strong>internal implementation detail</strong> صحبت می‌کنیم، اگر از ذکر الگوی <strong>Hexagonal Architecture</strong>، که اولین بار توسط Alistair Cockburn شرح داده شد، خودداری کنم، کوتاهی کرده‌ام. 2 این الگو اهمیت جدا نگه داشتن پیاده‌سازی داخلی از <strong>external interfaces</strong> آن را توضیح می‌دهد، با این ایده که ممکن است بخواهید با همان <strong>functionality</strong> از طریق انواع مختلف <strong>interfaces</strong> تعامل داشته باشید. من microservicesهایم را تا حدی به عنوان شش ضلعی ترسیم می‌کنم تا آنها را از سرویس‌های "عادی" متمایز کنم، اما همچنین به عنوان ادای احترام به این اثر هنری قبلی.
  </p>
<h4>آیا <strong>Service-Oriented Architecture</strong> و Microservices چیزهای متفاوتی هستند؟</h4>
<p>
<strong>Service-oriented architecture (SOA)</strong> یک رویکرد طراحی است که در آن چندین <strong>service</strong> برای ارائه مجموعه‌ای از قابلیت‌های معین با هم همکاری می‌کنند. (یک <strong>service</strong> در اینجا معمولاً به معنای یک فرآیند سیستم عامل کاملاً جداگانه است.) ارتباط بین این <strong>services</strong> از طریق <strong>calls</strong> در سراسر یک شبکه رخ می‌دهد تا فراخوانی متدها در یک <strong>process boundary</strong>.
  </p>
<p>
<strong>SOA</strong> به عنوان یک رویکرد برای مبارزه با چالش‌های برنامه‌های بزرگ و <strong>monolithic</strong> ظهور کرد. این رویکرد با هدف ارتقای قابلیت استفاده مجدد از نرم‌افزار است. به عنوان مثال، دو یا چند برنامه کاربر نهایی می‌توانند از همان <strong>services</strong> استفاده کنند. <strong>SOA</strong> با هدف آسان‌تر کردن نگهداری یا بازنویسی نرم‌افزار است، زیرا از نظر تئوری می‌توانیم یک <strong>service</strong> را با <strong>service</strong> دیگری جایگزین کنیم بدون اینکه کسی متوجه شود، تا زمانی که معنای <strong>service</strong> خیلی تغییر نکند.
  </p>
<p>
<strong>SOA</strong> در قلب خود یک ایده منطقی است. با این حال، علیرغم تلاش‌های زیاد، اجماع خوبی در مورد چگونگی انجام خوب <strong>SOA</strong> وجود ندارد. به نظر من، بخش زیادی از صنعت نتوانستند به اندازه کافی به مشکل نگاهی جامع داشته باشند و جایگزینی قانع‌کننده برای روایت تعیین شده توسط فروشندگان مختلف در این فضا ارائه دهند.
  </p>
<p>
   بسیاری از مشکلاتی که در درگاه <strong>SOA</strong> قرار دارند، در واقع مشکلاتی با چیزهایی مانند <strong>communication protocols</strong> (به عنوان مثال، <strong>SOAP</strong>)، <strong>vendor middleware</strong>، کمبود راهنمایی در مورد <strong>service granularity</strong>، یا راهنمایی اشتباه در مورد انتخاب مکان‌هایی برای تقسیم سیستم شما هستند. یک بدبین ممکن است پیشنهاد کند که فروشندگان جنبش <strong>SOA</strong> را به عنوان راهی برای فروش محصولات بیشتر تصاحب (و در برخی موارد هدایت) کردند و همان محصولات در نهایت هدف <strong>SOA</strong> را تضعیف کردند.
  </p>
<h4>Microservices در یک نگاه</h4>
<p>5 |</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0031</div>
            </div>
        </div>
        <!-- Page 0032 -->
        <div class="chapter" id="page-0032">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   من مثال‌های زیادی از <strong>SOA</strong> را دیده‌ام که در آن‌ها تیم‌ها تلاش می‌کردند <strong>services</strong> را کوچک‌تر کنند، اما هنوز همه چیز را به یک پایگاه داده متصل کرده بودند و مجبور بودند همه چیز را با هم مستقر کنند. <strong>Service oriented</strong>؟ بله. اما microservices نیست.
  </p>
<p>
   رویکرد microservice از استفاده‌های دنیای واقعی ظهور کرده است و درک بهتری از سیستم‌ها و معماری را برای انجام خوب <strong>SOA</strong> به دست آورده است. شما باید به microservices به عنوان یک رویکرد خاص برای <strong>SOA</strong> فکر کنید، به همان روشی که <strong>Extreme Programming (XP)</strong> یا <strong>Scrum</strong> یک رویکرد خاص برای توسعه نرم‌افزار <strong>Agile</strong> است.
  </p>
<h4>مفاهیم کلیدی Microservices</h4>
<p>
   هنگامی که در حال بررسی microservices هستید، باید چند ایده اصلی را درک کنید. با توجه به اینکه برخی از جنبه‌ها اغلب نادیده گرفته می‌شوند، بررسی بیشتر این مفاهیم برای کمک به اطمینان از درک این نکته که دقیقاً چه چیزی باعث می‌شود microservices کار کنند، حیاتی است.
  </p>
<h4>استقرار مستقل</h4>
<p>
   استقرار مستقل این ایده است که ما می‌توانیم تغییری در یک microservice ایجاد کنیم، آن را مستقر کنیم و آن تغییر را برای کاربران خود منتشر کنیم، بدون اینکه مجبور باشیم هیچ microservice دیگری را مستقر کنیم. مهمتر از این، این فقط این واقعیت نیست که ما می‌توانیم این کار را انجام دهیم. این در واقع نحوه مدیریت استقرارها در سیستم شما است. این یک انضباط است که شما به عنوان رویکرد انتشار پیش‌فرض خود اتخاذ می‌کنید. این یک ایده ساده است که با این وجود در اجرا پیچیده است.
  </p>
<p>
   اگر فقط یک چیز از این کتاب و از مفهوم microservices به طور کلی دریافت می‌کنید، باید این باشد: اطمینان حاصل کنید که مفهوم استقرار مستقل microservices خود را در آغوش می‌گیرید.
  </p>
<p>
   به عادت استقرار و انتشار تغییرات در یک microservice واحد در تولید بدون نیاز به استقرار هیچ چیز دیگری عادت کنید. از این، چیزهای خوب زیادی حاصل خواهد شد.
  </p>
<p>
   برای اطمینان از استقرار مستقل، باید اطمینان حاصل کنیم که microservices ما <em>loosely coupled</em> هستند: ما باید بتوانیم یک <strong>service</strong> را بدون نیاز به تغییر هیچ چیز دیگری تغییر دهیم. این بدان معناست که ما به قراردادهای صریح، به خوبی تعریف شده و پایدار بین <strong>services</strong> نیاز داریم. برخی از انتخاب‌های پیاده‌سازی این کار را دشوار می‌کنند—به عنوان مثال، اشتراک‌گذاری پایگاه‌های داده، به‌ویژه مشکل‌ساز است.
  </p>
<p>
   استقرار مستقل به خودی خود، به وضوح بسیار ارزشمند است. اما برای دستیابی به استقرار مستقل، چیزهای دیگری وجود دارد که باید درست انجام دهید که به نوبه خود مزایای خود را دارند. بنابراین شما همچنین می‌توانید تمرکز بر استقرار مستقل را به عنوان یک <strong>forcing function</strong> ببینید—با تمرکز بر این به عنوان یک نتیجه، به تعدادی از مزایای جانبی دست خواهید یافت.
  </p>
<p>6 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 32" src="page_0032/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0032</div>
            </div>
        </div>
        <!-- Page 0033 -->
        <div class="chapter" id="page-0033">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   3 برای معرفی عمیق به <strong>domain-driven design</strong>، کتاب <em>Domain-Driven Design</em> نوشته <strong>Eric Evans</strong> (Addison-Wesley) را ببینید—یا برای یک مرور کلی فشرده‌تر، کتاب <em>Domain-Driven Design Distilled</em> نوشته <strong>Vaughn Vernon</strong> (Addison-Wesley) را ببینید.
  </p>
<p>
   تمایل به <strong>services</strong> <em>loosely coupled</em> با <strong>interfaces</strong> پایدار، تفکر ما را در مورد چگونگی یافتن <strong>microservice boundaries</strong> در وهله اول هدایت می‌کند.
  </p>
<h4>مدل‌سازی شده حول یک <strong>Business Domain</strong></h4>
<p>
   تکنیک‌هایی مانند <strong>domain-driven design</strong> می‌تواند به شما اجازه دهد تا کد خود را ساختاردهی کنید تا بهتر نشان‌دهنده <strong>real-world domain</strong> باشد که نرم‌افزار در آن کار می‌کند. 3 با معماری‌های microservice، ما از همین ایده برای تعریف <strong>service boundaries</strong> خود استفاده می‌کنیم. با مدل‌سازی <strong>services</strong> حول <strong>business domains</strong>، می‌توانیم راه‌اندازی قابلیت‌های جدید و ترکیب مجدد microservicesها را به روش‌های مختلف برای ارائه قابلیت‌های جدید به کاربرانمان آسان‌تر کنیم.
  </p>
<p>
   راه‌اندازی یک ویژگی که نیاز به تغییراتی در بیش از یک microservice دارد، پرهزینه است. شما باید کار را در هر <strong>service</strong> (و به‌طور بالقوه در تیم‌های جداگانه) هماهنگ کنید و به دقت ترتیب استقرار نسخه‌های جدید این <strong>services</strong> را مدیریت کنید. این کار بسیار بیشتر از ایجاد همان تغییر در داخل یک <strong>service</strong> واحد (یا در داخل یک <strong>monolith</strong>، در این مورد) زمان می‌برد. بنابراین این نتیجه را دارد که ما می‌خواهیم راه‌هایی برای به حداقل رساندن تغییرات بین <strong>service</strong>ها پیدا کنیم.
  </p>
<p>
   من اغلب معماری‌های لایه‌ای را می‌بینم، همانطور که معماری سه لایه در شکل 1-2 نشان داده شده است. در اینجا، هر لایه در معماری نشان دهنده یک <strong>service boundary</strong> متفاوت است، که هر <strong>service boundary</strong> بر اساس <strong>technical functionality</strong> مرتبط است. اگر من نیاز به ایجاد تغییری فقط در لایه ارائه در این مثال داشته باشم، این کار نسبتاً کارآمد خواهد بود. با این حال، تجربه نشان داده است که تغییرات در <strong>functionality</strong> معمولاً چندین لایه را در این نوع معماری‌ها در بر می‌گیرد—نیازمند تغییراتی در لایه‌های ارائه، برنامه و داده است. این مشکل در صورتی تشدید می‌شود که معماری حتی بیشتر از مثال ساده در شکل 1-2 لایه‌بندی شده باشد. اغلب هر لایه به لایه‌های بیشتر تقسیم می‌شود.
  </p>
<p>
   با ایجاد <strong>services</strong> ما، برش‌های end-to-end از <strong>business functionality</strong>، ما اطمینان می‌دهیم که معماری ما به گونه‌ای تنظیم شده است که تغییرات در <strong>business functionality</strong> را تا حد امکان کارآمد کند. مسلماً، با microservices ما تصمیم گرفته‌ایم که <em>cohesion</em> بالای <strong>business functionality</strong> را بر <em>cohesion</em> بالای <strong>technical functionality</strong> اولویت دهیم.
  </p>
<p>Key Concepts of Microservices | 7</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0033</div>
            </div>
        </div>
        <!-- Page 0034 -->
        <div class="chapter" id="page-0034">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 1-2. یک معماری سه لایه سنتی
  </p>
<p>
   ما در ادامه این فصل به تعامل <strong>domain-driven design</strong> و نحوه تعامل آن با طراحی سازمانی باز خواهیم گشت.
  </p>
<h4>مالکیت <strong>State</strong> خودشان</h4>
<p>
   یکی از چیزهایی که می‌بینم مردم بیشترین مشکل را با آن دارند این است که microservicesها باید از استفاده از پایگاه‌های داده مشترک اجتناب کنند. اگر یک microservice می‌خواهد به داده‌های نگهداری شده توسط microservice دیگری دسترسی داشته باشد، باید برود و از آن microservice دوم داده‌ها را بخواهد. این به microservicesها توانایی تصمیم‌گیری در مورد آنچه که به اشتراک گذاشته شده و آنچه پنهان شده است را می‌دهد، که به ما امکان می‌دهد <strong>functionality</strong> را که می‌تواند آزادانه تغییر کند (پیاده‌سازی داخلی ما) از <strong>functionality</strong> که می‌خواهیم به ندرت تغییر دهیم (قرارداد خارجی که <strong>consumers</strong> استفاده می‌کنند) جدا کنیم.
  </p>
<p>
   اگر می‌خواهیم استقرار مستقل را به واقعیت تبدیل کنیم، باید اطمینان حاصل کنیم که تغییرات <em>backward-incompatible</em> را به microservicesهای خود محدود می‌کنیم. اگر سازگاری با <strong>consumers</strong> بالادستی را از بین ببریم، آنها را نیز مجبور به تغییر می‌کنیم. داشتن یک تمایز شفاف بین جزئیات پیاده‌سازی داخلی و یک قرارداد خارجی برای یک microservice می‌تواند به کاهش نیاز به تغییرات <em>backward-incompatible</em> کمک کند.
  </p>
<p>
   پنهان کردن <strong>internal state</strong> در یک microservice مشابه با عمل <strong>encapsulation</strong> در برنامه‌نویسی شی‌گرا (<strong>OO</strong>) است. <strong>Encapsulation</strong> داده‌ها در سیستم‌های <strong>OO</strong> نمونه‌ای از <strong>information hiding</strong> در عمل است.
  </p>
<p>8 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 34" src="page_0034/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0034</div>
            </div>
        </div>
        <!-- Page 0035 -->
        <div class="chapter" id="page-0035">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   پایگاه‌های داده را به اشتراک نگذارید، مگر اینکه واقعاً نیاز داشته باشید. و حتی در این صورت تا جایی که می‌توانید از آن اجتناب کنید. به نظر من، اشتراک‌گذاری پایگاه‌های داده یکی از بدترین کارهایی است که می‌توانید انجام دهید اگر سعی دارید به استقرار مستقل برسید.
  </p>
<p>
   همانطور که در بخش قبل مورد بحث قرار گرفت، ما می‌خواهیم به <strong>services</strong> خود به عنوان برش‌های end-to-end از <strong>business functionality</strong> فکر کنیم که، در صورت لزوم، <strong>user interface (UI)</strong>، <strong>business logic</strong> و داده‌ها را کپسوله می‌کنند. این به این دلیل است که ما می‌خواهیم تلاش مورد نیاز برای تغییر <strong>business-related functionality</strong> را کاهش دهیم. کپسوله‌سازی داده‌ها و رفتار به این روش، <em>cohesion</em> بالایی از <strong>business functionality</strong> را به ما می‌دهد. با پنهان کردن پایگاه داده‌ای که از <strong>service</strong> ما پشتیبانی می‌کند، ما همچنین اطمینان حاصل می‌کنیم که <em>coupling</em> را کاهش می‌دهیم. ما در فصل 2 به <em>coupling</em> و <em>cohesion</em> برمی‌گردیم.
  </p>
<h4>اندازه</h4>
<p>
   "یک microservice چقدر باید بزرگ باشد؟" یکی از متداول‌ترین سوالاتی است که می‌شنوم. با توجه به اینکه کلمه "micro" درست در نام وجود دارد، این موضوع جای تعجب ندارد. با این حال، هنگامی که وارد این می‌شوید که چه چیزی باعث می‌شود microservices به عنوان یک نوع معماری کار کنند، مفهوم اندازه در واقع یکی از کم‌اهمیت‌ترین جنبه‌ها است.
  </p>
<p>
   چگونه اندازه را اندازه‌گیری می‌کنید؟ با شمارش خطوط کد؟ این برای من منطقی نیست. چیزی که ممکن است 25 خط کد در جاوا نیاز داشته باشد، می‌تواند در 10 خط از Clojure نوشته شود. این بدان معنا نیست که Clojure بهتر یا بدتر از جاوا است. برخی از زبان‌ها به سادگی گویاتر از بقیه هستند.
  </p>
<p>
   James Lewis، مدیر فنی در <strong>Thoughtworks</strong>، گفته است که "یک microservice باید به اندازه سر من باشد." در نگاه اول، این به نظر نمی‌رسد که خیلی مفید باشد. بالاخره سر جیمز دقیقاً چقدر بزرگ است؟ منطق پشت این بیانیه این است که یک microservice باید به اندازه‌ای نگه داشته شود که به راحتی قابل درک باشد.
  </p>
<p>
   البته چالش این است که توانایی افراد مختلف برای درک چیزی همیشه یکسان نیست و به این ترتیب شما باید در مورد اندازه‌ای که برای شما مناسب است، قضاوت خود را انجام دهید. یک تیم باتجربه ممکن است بتواند یک <strong>codebase</strong> بزرگتر را بهتر از یک تیم دیگر مدیریت کند. بنابراین شاید بهتر باشد که نقل قول جیمز را در اینجا اینطور بخوانید: "یک microservice باید به اندازه سر شما باشد."
  </p>
<p>
   فکر می‌کنم نزدیک‌ترین چیزی که به "اندازه" در ارتباط با microservices معنی دارد، چیزی است که <strong>Chris Richardson</strong>، نویسنده <em>Microservice Patterns</em> (<strong>Manning Publications</strong>)، یک بار گفت—هدف microservices داشتن "به کوچکی یک <strong>interface</strong> ممکن" است. این دوباره با مفهوم <strong>information hiding</strong> همسو است، اما نشان‌دهنده تلاشی برای یافتن معنا در اصطلاح "microservices" است که در ابتدا وجود نداشت. هنگامی که این اصطلاح برای اولین بار برای تعریف این معماری‌ها استفاده شد، تمرکز، حداقل در ابتدا، به‌طور خاص بر روی اندازه <strong>interfaces</strong> نبود.
  </p>
<p>
   در نهایت، مفهوم اندازه بسیار وابسته به زمینه است. با فردی که 15 سال روی یک سیستم کار کرده است صحبت کنید، و آنها احساس خواهند کرد که سیستم آنها با 100000 خط
  </p>
<p>Key Concepts of Microservices | 9</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 35" src="page_0035/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0035</div>
            </div>
        </div>
        <!-- Page 0036 -->
        <div class="chapter" id="page-0036">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   کد، در واقع به راحتی قابل درک است. نظر کسی را که تازه وارد پروژه شده است بپرسید، و آنها احساس خواهند کرد که خیلی بزرگ است. به همین ترتیب، از یک شرکت که به تازگی انتقال microservice خود را آغاز کرده و شاید 10 یا کمتر microservice دارد، سوال کنید، و پاسخ متفاوتی نسبت به شرکتی با اندازه مشابه دریافت خواهید کرد که microservices سالهاست که برای آن هنجار بوده است و اکنون صدها مورد دارد.
  </p>
<p>
   من از مردم می‌خواهم که نگران اندازه نباشند. هنگامی که برای اولین بار شروع می‌کنید، بسیار مهم‌تر است که روی دو چیز کلیدی تمرکز کنید. اول، چند microservice را می‌توانید مدیریت کنید؟ با داشتن <strong>services</strong> بیشتر، پیچیدگی سیستم شما افزایش می‌یابد و برای مقابله با این موضوع باید مهارت‌های جدیدی (و شاید فناوری جدیدی) را یاد بگیرید.
  </p>
<p>
   یک حرکت به سمت microservices، منابع جدیدی از پیچیدگی را معرفی می‌کند، با تمام چالش‌هایی که می‌تواند به همراه داشته باشد. به همین دلیل است که من از مهاجرت افزایشی به معماری microservice حمایت می‌کنم. دوم، چگونه <strong>microservice boundaries</strong> را تعریف می‌کنید تا بیشترین بهره را از آنها ببرید، بدون اینکه همه چیز به یک <strong>mess</strong> وحشتناک <em>coupled</em> تبدیل شود؟ این موضوعات هنگام شروع سفرتان، تمرکز بیشتری دارند.
  </p>
<h4>انعطاف پذیری</h4>
<p>
   نقل قول دیگری از James Lewis این است که "microservices به شما گزینه می‌دهند." Lewis در کلمات خود عمدی بود—آنها به شما گزینه می‌دهند. آنها هزینه‌ای دارند و شما باید تصمیم بگیرید که آیا هزینه ارزش گزینه‌هایی را که می‌خواهید انتخاب کنید، دارد یا خیر. انعطاف‌پذیری حاصل در تعدادی از محورها—سازمانی، فنی، مقیاس، استحکام—می‌تواند باورنکردنی جذاب باشد.
  </p>
<p>
   ما نمی‌دانیم آینده چه چیزی را در خود جای داده است، بنابراین ما می‌خواهیم یک معماری داشته باشیم که از نظر تئوری بتواند به ما در حل هر مشکلی که ممکن است در آینده با آن مواجه شویم، کمک کند. یافتن تعادل بین باز نگه داشتن گزینه‌های خود و تحمل هزینه معماری‌هایی مانند این می‌تواند یک هنر واقعی باشد.
  </p>
<p>
   فکر کنید پذیرش microservices کمتر شبیه زدن یک کلید است و بیشتر شبیه چرخاندن یک <em>dial</em> است. همانطور که <em>dial</em> را زیاد می‌کنید، و microservicesهای بیشتری دارید، انعطاف‌پذیری افزایش می‌یابد. اما احتمالاً نقاط درد را نیز افزایش می‌دهید. این یکی دیگر از دلایلی است که من به شدت از پذیرش تدریجی microservices حمایت می‌کنم. با افزایش تدریجی <em>dial</em>، شما می‌توانید بهتر تأثیر را در حین انجام ارزیابی کنید و در صورت نیاز متوقف شوید.
  </p>
<h4>هم‌ترازی معماری و سازمان</h4>
<p>
<strong>MusicCorp</strong>، یک شرکت تجارت الکترونیک که سی‌دی‌ها را به صورت آنلاین می‌فروشد، از معماری سه لایه ساده‌ای که قبلاً در شکل 1-2 نشان داده شده است، استفاده می‌کند. ما تصمیم گرفته‌ایم <strong>MusicCorp</strong> را با سر و صدا وارد قرن بیست و یکم کنیم، و به عنوان بخشی از آن، در حال ارزیابی معماری سیستم موجود هستیم. ما یک <strong>UI</strong> مبتنی بر وب، یک لایه <strong>business logic</strong> در قالب یک <strong>monolithic backend</strong> و ذخیره داده‌ها در یک پایگاه داده سنتی داریم. این لایه‌ها، همانطور که معمول است، متعلق به تیم‌های مختلف هستند. ما در سراسر کتاب به آزمایش‌ها و مشکلات <strong>MusicCorp</strong> باز خواهیم گشت.
  </p>
<p>10 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0036</div>
            </div>
        </div>
        <!-- Page 0037 -->
        <div class="chapter" id="page-0037">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   ما می‌خواهیم یک به‌روزرسانی ساده در <strong>functionality</strong> خود ایجاد کنیم: ما می‌خواهیم به مشتریان خود اجازه دهیم تا ژانر موسیقی مورد علاقه خود را مشخص کنند. این به‌روزرسانی مستلزم آن است که <strong>UI</strong> را برای نشان دادن <strong>genre choice UI</strong>، <strong>backend service</strong> برای اجازه دادن به ژانر برای نمایش در <strong>UI</strong> و برای تغییر مقدار، و پایگاه داده برای پذیرش این تغییر تغییر دهیم.
  </p>
<p>
   این تغییرات باید توسط هر تیم مدیریت شوند و به ترتیب صحیح مستقر شوند، همانطور که در شکل 1-3 نشان داده شده است.
  </p>
<p>
   شکل 1-3. ایجاد تغییر در هر سه لایه، شامل موارد بیشتری است
  </p>
<p>
   اکنون این معماری بد نیست. همه معماری‌ها در نهایت حول یک مجموعه از اهداف بهینه می‌شوند. معماری سه لایه تا حدی رایج است زیرا جهانی است - همه در مورد آن شنیده‌اند. بنابراین تمایل به انتخاب یک معماری رایج که ممکن است در جای دیگری دیده باشید، اغلب یکی از دلایلی است که ما همچنان این الگو را می‌بینیم. اما فکر می‌کنم بزرگترین دلیل اینکه ما این معماری را بارها و بارها می‌بینیم این است که بر اساس نحوه سازماندهی تیم‌هایمان است.
  </p>
<p>
   قانون معروف Conway's موارد زیر را بیان می‌کند:
  </p>
<p>
   سازمان‌هایی که سیستم‌ها را طراحی می‌کنند... محدود به تولید طرح‌هایی هستند که کپی‌هایی از ساختارهای ارتباطی این سازمان‌ها هستند.
  </p>
<p>
   —Melvin Conway, “How Do Committees Invent?”
  </p>
<p>
   معماری سه لایه نمونه خوبی از این قانون در عمل است. در گذشته، روش اصلی گروه‌بندی افراد در سازمان‌های <strong>IT</strong> بر اساس شایستگی اصلی آنها بود:
  </p>
<p>Key Concepts of Microservices | 11</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 37" src="page_0037/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0037</div>
            </div>
        </div>
        <!-- Page 0038 -->
        <div class="chapter" id="page-0038">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   مدیران پایگاه داده در یک تیم با سایر مدیران پایگاه داده بودند. توسعه‌دهندگان جاوا در یک تیم با سایر توسعه‌دهندگان جاوا بودند. و توسعه‌دهندگان <strong>frontend</strong> (که امروزه چیزهای عجیب و غریبی مانند <strong>JavaScript</strong> و توسعه برنامه تلفن همراه <strong>native</strong> را می‌دانند) در تیم دیگری بودند. ما افراد را بر اساس شایستگی اصلی آنها گروه‌بندی می‌کنیم، بنابراین ما دارایی‌های <strong>IT</strong> را ایجاد می‌کنیم که می‌توانند با آن تیم‌ها همسو شوند.
  </p>
<p>
   این توضیح می‌دهد که چرا این معماری بسیار رایج است. بد نیست. فقط حول یک مجموعه از نیروها—نحوه گروه‌بندی سنتی ما از افراد، حول آشنایی—بهینه شده است. اما نیروها تغییر کرده‌اند. آرزوهای ما در مورد نرم‌افزارمان تغییر کرده است. ما اکنون افراد را در تیم‌های چندمهارتی گروه‌بندی می‌کنیم تا <strong>handoffs</strong> و <strong>silos</strong> را کاهش دهیم. ما می‌خواهیم نرم‌افزار را بسیار سریعتر از همیشه منتشر کنیم. این امر ما را وادار می‌کند تا در مورد نحوه سازماندهی تیم‌هایمان تصمیمات متفاوتی بگیریم، به طوری که آنها را بر اساس نحوه جدا کردن سیستم‌هایمان سازماندهی کنیم.
  </p>
<p>
   بیشتر تغییراتی که از ما خواسته می‌شود در سیستم خود ایجاد کنیم، مربوط به تغییرات در <strong>business functionality</strong> است. اما در شکل 1-3، <strong>business functionality</strong> ما در واقع در همه سه لایه گسترش یافته است، و این احتمال را افزایش می‌دهد که تغییری در <strong>functionality</strong> از لایه‌ها عبور کند.
  </p>
<p>
   این معماری است که دارای <em>cohesion</em> بالایی از فناوری مرتبط است اما <em>cohesion</em> پایینی از <strong>business functionality</strong> دارد. اگر می‌خواهیم ایجاد تغییرات را آسان‌تر کنیم، در عوض باید نحوه گروه‌بندی کد را تغییر دهیم، و <em>cohesion</em> <strong>business functionality</strong> را به جای فناوری انتخاب کنیم. هر <strong>service</strong> ممکن است در نهایت حاوی ترکیبی از این سه لایه باشد یا نباشد، اما این یک نگرانی محلی در پیاده‌سازی <strong>service</strong> است.
  </p>
<p>
   بیایید این را با یک معماری جایگزین بالقوه، که در شکل 1-4 نشان داده شده است، مقایسه کنیم. به جای یک معماری و سازماندهی لایه‌بندی شده افقی، ما در عوض سازمان و معماری خود را در امتداد خطوط عمودی <strong>business</strong> تجزیه می‌کنیم. در اینجا ما یک تیم اختصاصی را می‌بینیم که مسئولیت کامل end-to-end را برای ایجاد تغییرات در جنبه‌های <strong>customer profile</strong> بر عهده دارد، که تضمین می‌کند که محدوده تغییر در این مثال به یک تیم محدود می‌شود.
  </p>
<p>
   به عنوان یک پیاده‌سازی، این می‌تواند از طریق یک microservice واحد که متعلق به تیم <strong>profile</strong> است و یک <strong>UI</strong> را برای مشتریان برای به‌روزرسانی اطلاعاتشان به نمایش می‌گذارد، همراه با <strong>state</strong> مشتری که در این microservice نیز ذخیره می‌شود، به دست آید. انتخاب یک ژانر مورد علاقه با یک مشتری معین مرتبط است، بنابراین این تغییر بسیار محلی‌تر است.
  </p>
<p>
   در شکل 1-5، ما همچنین فهرست ژانرهای موجود را که از یک <strong>Catalog microservice</strong> دریافت می‌شود، نشان می‌دهیم، چیزی که احتمالاً از قبل وجود داشته است. ما همچنین یک <strong>Recommendation microservice</strong> جدید را می‌بینیم که به اطلاعات ژانر مورد علاقه ما دسترسی دارد، چیزی که می‌تواند به راحتی در یک نسخه بعدی دنبال شود.
  </p>
<p>12 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0038</div>
            </div>
        </div>
        <!-- Page 0039 -->
        <div class="chapter" id="page-0039">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 1-4. <strong>UI</strong> از هم جدا شده است و متعلق به تیمی است که <strong>functionality</strong> سمت <strong>server</strong> را که از <strong>UI</strong> پشتیبانی می‌کند، نیز مدیریت می‌کند.
  </p>
<p>
   شکل 1-5. یک microservice اختصاصی <strong>Customer</strong> می‌تواند ثبت ژانر موسیقی مورد علاقه برای یک مشتری را بسیار آسان‌تر کند.
  </p>
<p>
   در چنین موقعیتی، microservice <strong>Customer</strong> ما یک برش نازک از هر یک از سه لایه را کپسوله می‌کند - کمی <strong>UI</strong> دارد، کمی منطق <strong>application</strong>، و کمی ذخیره داده. <strong>business domain</strong> ما به نیروی اولیه تبدیل می‌شود که معماری سیستم ما را هدایت می‌کند، و امیدواریم ایجاد تغییرات را آسان‌تر کند، و همچنین همسو کردن تیم‌هایمان با خطوط <strong>business</strong> در داخل سازمان را آسان‌تر کند.
  </p>
<p>Key Concepts of Microservices | 13</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 39" src="page_0039/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 39" src="page_0039/image_2.png"/></div>
</div>
                <div class="page-number">صفحه 0039</div>
            </div>
        </div>
        <!-- Page 0040 -->
        <div class="chapter" id="page-0040">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   4 Matthew Skelton and Manuel Pais, Team Topologies (Portland, OR: IT Revolution, 2019).
  </p>
<p>
   اغلب، <strong>UI</strong> مستقیماً توسط microservice ارائه نمی‌شود، اما حتی اگر این مورد هم باشد، ما انتظار داریم که بخش <strong>UI</strong> مربوط به این <strong>functionality</strong> همچنان متعلق به تیم <strong>Customer Profile</strong> باشد، همانطور که شکل 1-4 نشان می‌دهد. این مفهوم از یک تیم که مالک یک برش end-to-end از <strong>user-facing functionality</strong> است، در حال افزایش است. کتاب <strong>Team Topologies</strong>4 ایده یک تیم <strong>stream-aligned</strong> را معرفی می‌کند، که این مفهوم را در بر می‌گیرد:
  </p>
<p>
   یک تیم <strong>stream-aligned</strong> یک تیم است که با یک جریان کاری با ارزش واحد همسو است...[T]eam empowered to build and deliver customer or user value as quickly, safely, and independently as possible, without requiring hand-offs to other teams to perform parts of the work.
  </p>
<p>
   تیم‌های نشان داده شده در شکل 1-4 تیم‌های <strong>stream-aligned</strong> خواهند بود، مفهومی که ما در فصل‌های 14 و 15، از جمله نحوه عملکرد این نوع ساختارهای سازمانی در عمل، و نحوه همسویی آنها با microservices، با عمق بیشتری بررسی خواهیم کرد.
  </p>
<h4>یک یادداشت در مورد شرکت‌های "Fake"</h4>
<p>
   در سراسر کتاب، در مراحل مختلف، با <strong>MusicCorp</strong>، <strong>FinanceCo</strong>، <strong>FoodCo</strong>، <strong>AdvertCo</strong> و <strong>PaymentCo</strong> ملاقات خواهیم کرد.
  </p>
<p>
<strong>FoodCo</strong>، <strong>AdvertCo</strong> و <strong>PaymentCo</strong> شرکت‌های واقعی هستند که من نام آنها را به دلایل محرمانگی تغییر داده‌ام. علاوه بر این، هنگام اشتراک‌گذاری اطلاعات در مورد این شرکت‌ها، من اغلب برخی از جزئیات را برای ارائه وضوح بیشتر حذف کرده‌ام. دنیای واقعی اغلب درهم و برهم است. با این حال، من همیشه تلاش کرده‌ام تا فقط جزئیات بی‌ربطی را که مفید نخواهد بود حذف کنم، در حالی که همچنان از این اطمینان حاصل می‌کنم که واقعیت اساسی اوضاع باقی می‌ماند.
  </p>
<p>
   از طرف دیگر، <strong>MusicCorp</strong> یک شرکت <strong>fake</strong> است که ترکیبی از بسیاری از سازمان‌هایی است که با آنها کار کرده‌ام. داستان‌هایی که در مورد <strong>MusicCorp</strong> به اشتراک می‌گذارم، بازتابی از چیزهای واقعی است که دیده‌ام، اما همه آنها در یک شرکت واحد اتفاق نیفتاده‌اند!
  </p>
<h4>The Monolith</h4>
<p>
   ما در مورد microservices صحبت کردیم، اما microservices اغلب به عنوان یک رویکرد معماری که جایگزینی برای معماری <strong>monolithic</strong> است، مورد بحث قرار می‌گیرند. برای تمایز واضح‌تر معماری microservice، و برای کمک به شما در درک بهتر اینکه آیا microservices ارزش در نظر گرفتن دارند یا خیر، من همچنین باید در مورد اینکه دقیقاً منظور من از <strong>monoliths</strong> چیست، بحث کنم.
  </p>
<p>
   وقتی در طول این کتاب در مورد <strong>monoliths</strong> صحبت می‌کنم، در درجه اول به یک واحد استقرار اشاره می‌کنم. وقتی همه <strong>functionality</strong> در یک سیستم باید با هم مستقر شوند، من
  </p>
<p>14 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0040</div>
            </div>
        </div>
        <!-- Page 0041 -->
        <div class="chapter" id="page-0041">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   5 David Heinemeier Hansson, “The Majestic Monolith,” Signal v. Noise, February 29, 2016, https://oreil.ly/ WwG1C.
  </p>
<p>
   آن را یک <strong>monolith</strong> در نظر بگیرید. مسلماً، معماری‌های متعددی با این تعریف مطابقت دارند، اما من در مورد مواردی که اغلب می‌بینم بحث خواهم کرد: <strong>single-process monolith</strong>، <strong>modular monolith</strong> و <strong>distributed monolith</strong>.
  </p>
<h4>The Single-Process Monolith</h4>
<p>
   متداول‌ترین مثالی که هنگام بحث در مورد <strong>monoliths</strong> به ذهن می‌رسد، سیستمی است که در آن همه کد به عنوان یک <strong>single process</strong> مستقر می‌شود، همانطور که در شکل 1-6 نشان داده شده است. ممکن است چندین نمونه از این <strong>process</strong> را به دلایل استحکام یا مقیاس‌پذیری داشته باشید، اما اساساً تمام کد در یک <strong>single process</strong> بسته‌بندی شده است. در واقعیت، این سیستم‌های <strong>single-process</strong> می‌توانند سیستم‌های توزیع‌شده ساده‌ای به خودی خود باشند زیرا تقریباً همیشه در نهایت داده‌ها را از یک پایگاه داده می‌خوانند یا داده‌ها را در یک پایگاه داده ذخیره می‌کنند، یا اطلاعات را به برنامه‌های وب یا تلفن همراه ارائه می‌دهند.
  </p>
<p>
   شکل 1-6. در یک <strong>single-process monolith</strong>، همه کدها در یک <strong>single process</strong> بسته‌بندی می‌شوند
  </p>
<p>
   اگرچه این با درک اکثر مردم از یک <strong>classic monolith</strong> مطابقت دارد، اما اکثر سیستم‌هایی که با آنها روبرو می‌شوم، کمی پیچیده‌تر از این هستند. ممکن است دو یا چند <strong>monolith</strong> داشته باشید که به یکدیگر <em>tightly coupled</em> هستند، که احتمالاً برخی از نرم‌افزارهای فروشنده نیز در آن وجود دارد.
  </p>
<p>
   یک استقرار <strong>classic single-process monolithic</strong> می‌تواند برای بسیاری از سازمان‌ها منطقی باشد. David Heinemeier Hansson، خالق <strong>Ruby on Rails</strong>، به طور موثر این موضوع را مطرح کرده است که چنین معماری برای سازمان‌های کوچکتر منطقی است. 5 با این حال، حتی با رشد سازمان، <strong>monolith</strong> می‌تواند با آن رشد کند، که ما را به سمت <strong>modular monolith</strong> می‌برد.
  </p>
<p>The Monolith | 15</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 41" src="page_0041/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0041</div>
            </div>
        </div>
        <!-- Page 0042 -->
        <div class="chapter" id="page-0042">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   6 برای کسب اطلاعات مفید در مورد تفکر پشت استفاده <strong>Shopify</strong> از یک <strong>modular monolith</strong> به جای microservices، “Deconstructing the Monolith” را توسط Kirsten Westeinde تماشا کنید.
  </p>
<h4>The Modular Monolith</h4>
<p>
   به عنوان زیرمجموعه‌ای از <strong>single-process monolith</strong>، <strong>modular monolith</strong> نوعی است که در آن <strong>single process</strong> از ماژول‌های جداگانه تشکیل شده است. هر ماژول را می‌توان به طور مستقل روی آن کار کرد، اما همه آنها همچنان باید برای استقرار با هم ترکیب شوند، همانطور که در شکل 1-7 نشان داده شده است. مفهوم تقسیم نرم‌افزار به ماژول‌ها چیز جدیدی نیست. نرم‌افزار ماژولار ریشه در کارهایی دارد که در دهه 1970 و حتی قبل از آن در اطراف برنامه‌نویسی ساختاریافته انجام شده است. با این وجود، این رویکردی است که هنوز هم نمی‌بینم سازمان‌های زیادی به درستی با آن درگیر شوند.
  </p>
<p>
   شکل 1-7. در یک <strong>modular monolith</strong>، کد داخل <strong>process</strong> به ماژول‌ها تقسیم می‌شود
  </p>
<p>
   برای بسیاری از سازمان‌ها، <strong>modular monolith</strong> می‌تواند یک انتخاب عالی باشد. اگر <strong>module boundaries</strong> به خوبی تعریف شده باشند، می‌تواند درجه بالایی از کار موازی را فراهم کند، در حالی که از چالش‌های معماری microservice توزیع‌شده‌تر با داشتن یک توپولوژی استقرار بسیار ساده‌تر اجتناب می‌کند. <strong>Shopify</strong> نمونه‌ای عالی از سازمانی است که از این تکنیک به عنوان جایگزینی برای <strong>microservice decomposition</strong> استفاده کرده است و به نظر می‌رسد که برای آن شرکت واقعاً خوب عمل می‌کند.6
  </p>
<p>
   یکی از چالش‌های یک <strong>modular monolith</strong> این است که پایگاه داده تمایل دارد فاقد تجزیه‌ای باشد که ما در سطح کد پیدا می‌کنیم، که اگر بخواهید در آینده <strong>monolith</strong> را از هم جدا کنید، چالش‌های مهمی را به همراه دارد. من دیده‌ام که برخی از تیم‌ها سعی می‌کنند ایده <strong>modular monolith</strong> را با داشتن پایگاه داده که در امتداد همان خطوط ماژول‌ها تجزیه شده است، پیش ببرند، همانطور که در شکل 1-8 نشان داده شده است.
  </p>
<p>16 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 42" src="page_0042/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0042</div>
            </div>
        </div>
        <!-- Page 0043 -->
        <div class="chapter" id="page-0043">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   7 Leslie Lamport, email message to a <strong>DEC SRC bulletin board</strong> at 12:23:29 PDT on May 28, 1987.
  </p>
<p>
   شکل 1-8. یک <strong>modular monolith</strong> با یک پایگاه داده تجزیه‌شده
  </p>
<h4>The Distributed Monolith</h4>
<p>
   یک سیستم توزیع شده سیستمی است که در آن خرابی کامپیوتری که شما حتی نمی‌دانستید وجود دارد، می‌تواند کامپیوتر شما را غیرقابل استفاده کند.7
   —Leslie Lamport
  </p>
<p>
   یک <strong>distributed monolith</strong> سیستمی است که از چندین <strong>service</strong> تشکیل شده است، اما به هر دلیلی، کل سیستم باید با هم مستقر شود. یک <strong>distributed monolith</strong> ممکن است تعریف <strong>SOA</strong> را برآورده کند، اما متأسفانه، اغلب در تحقق وعده‌های <strong>SOA</strong> شکست می‌خورد. به تجربه من، یک <strong>distributed monolith</strong> تمام معایب یک سیستم توزیع‌شده و معایب یک <strong>single-process monolith</strong> را دارد، بدون اینکه به اندازه کافی از مزایای هر دو برخوردار باشد. برخورد با تعدادی از <strong>distributed monoliths</strong> در کارم، تا حد زیادی بر علاقه شخصی من به معماری microservice تأثیر گذاشته است.
  </p>
<p>
<strong>Distributed monoliths</strong> معمولاً در محیطی ظهور می‌کنند که در آن تمرکز کافی بر مفاهیمی مانند <strong>information hiding</strong> و <em>cohesion</em> <strong>business functionality</strong> نشده است. در عوض، معماری‌های <em>highly coupled</em> باعث می‌شوند تغییرات در سراسر <strong>service boundaries</strong> پخش شوند، و تغییرات ظاهراً بی‌ضرر که در محدوده محلی به نظر می‌رسند، قسمت‌های دیگر سیستم را خراب می‌کنند.
  </p>
<h4>Monoliths و Delivery Contention</h4>
<p>
   همانطور که افراد بیشتری در یک مکان کار می‌کنند، در مسیر یکدیگر قرار می‌گیرند—به عنوان مثال، توسعه‌دهندگان مختلفی که می‌خواهند همان قطعه کد را تغییر دهند، تیم‌های مختلفی که می‌خواهند <strong>functionality</strong> را در زمان‌های مختلف (یا به تأخیر انداختن استقرارها) <strong>live</strong> کنند، و سردرگمی در مورد اینکه چه کسی مالک چه چیزی است و چه کسی تصمیم می‌گیرد. تعداد زیادی از
  </p>
<p>The Monolith | 17</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 43" src="page_0043/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0043</div>
            </div>
        </div>
        <!-- Page 0044 -->
        <div class="chapter" id="page-0044">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   8 <strong>Microsoft Research</strong> مطالعاتی را در این فضا انجام داده است و من همه آنها را توصیه می‌کنم، اما به عنوان نقطه شروع، "Don’t Touch My Code! Examining the Effects of Ownership on Software Quality" نوشته Christian Bird و همکاران را پیشنهاد می‌کنم.
  </p>
<p>
   مطالعات نشان داده است که چالش‌های خطوط مالکیت گیج‌کننده.8 من به این مشکل به عنوان <strong>delivery contention</strong> اشاره می‌کنم.
  </p>
<p>
   داشتن یک <strong>monolith</strong> به این معنی نیست که شما قطعاً با چالش‌های <strong>delivery contention</strong> مواجه خواهید شد، همانطور که داشتن یک معماری microservice به این معنی نیست که هرگز با این مشکل مواجه نخواهید شد. اما یک معماری microservice به شما <strong>boundaries</strong> ملموس‌تری می‌دهد که در اطراف آن خطوط مالکیت را می‌توان در یک سیستم ترسیم کرد، که انعطاف‌پذیری بسیار بیشتری در هنگام کاهش این مشکل به شما می‌دهد.
  </p>
<h4>مزایای Monoliths</h4>
<p>
   برخی از <strong>monoliths</strong>، مانند <strong>single-process</strong> یا <strong>modular monoliths</strong>، نیز مزایای زیادی دارند. توپولوژی استقرار بسیار ساده‌تر آنها می‌تواند از بسیاری از <strong>pitfalls</strong> مرتبط با سیستم‌های توزیع‌شده اجتناب کند. این می‌تواند منجر به گردش‌های کاری بسیار ساده‌تر توسعه‌دهنده شود، و نظارت، عیب‌یابی، و فعالیت‌هایی مانند <strong>end-to-end testing</strong> نیز می‌تواند بسیار ساده شود.
  </p>
<p>
<strong>Monoliths</strong> همچنین می‌توانند استفاده مجدد از کد را در داخل خود <strong>monolith</strong> ساده کنند. اگر می‌خواهیم از کد در یک سیستم توزیع‌شده استفاده مجدد کنیم، باید تصمیم بگیریم که آیا می‌خواهیم کد را کپی کنیم، کتابخانه‌ها را جدا کنیم یا <strong>functionality</strong> مشترک را به یک <strong>service</strong> منتقل کنیم. با یک <strong>monolith</strong>، انتخاب‌های ما بسیار ساده‌تر هستند، و بسیاری از مردم این سادگی را دوست دارند—تمام کدها آنجا هستند. فقط از آن استفاده کنید!
  </p>
<p>
   متأسفانه، مردم به این دیدگاه رسیده‌اند که <strong>monolith</strong> چیزی است که باید از آن اجتناب کرد—چیزی که ذاتاً مشکل‌ساز است. من با افراد متعددی ملاقات کرده‌ام که برای آنها اصطلاح <strong>monolith</strong> مترادف با <strong>legacy</strong> است. این یک مشکل است. یک معماری <strong>monolithic</strong> یک انتخاب است و یک انتخاب معتبر در آن است. من فراتر می‌روم و می‌گویم که به نظر من، این انتخاب پیش‌فرض منطقی به عنوان یک سبک معماری است. به عبارت دیگر، من به دنبال دلیلی هستم که قانع شوم از microservices استفاده کنم، نه اینکه به دنبال دلیلی باشم که از آنها استفاده نکنم.
  </p>
<p>
   اگر در دام تضعیف سیستماتیک <strong>monolith</strong> به عنوان یک گزینه مناسب برای ارائه نرم‌افزار خود بیفتیم، در معرض خطر هستیم که حق خودمان یا کاربران نرم‌افزارمان را ادا نکنیم.
  </p>
<h4>فناوری فعال‌کننده</h4>
<p>
   همانطور که قبلاً اشاره کردم، فکر نمی‌کنم هنگام شروع استفاده از microservices به فناوری‌های جدید زیادی نیاز داشته باشید. در واقع، این می‌تواند نتیجه معکوس داشته باشد. در عوض، همانطور که معماری microservice خود را افزایش می‌دهید، باید دائماً به دنبال
  </p>
<p>18 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0044</div>
            </div>
        </div>
        <!-- Page 0045 -->
        <div class="chapter" id="page-0045">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   مسائلی که توسط سیستم به طور فزاینده توزیع‌شده شما ایجاد می‌شوند، و سپس برای فناوری که ممکن است کمک کند، بررسی کنید.
  </p>
<p>
   با این حال، فناوری نقش زیادی در پذیرش microservices به عنوان یک مفهوم داشته است. درک ابزارهایی که برای کمک به شما در به دست آوردن بیشترین بهره از این معماری در دسترس هستند، بخش اصلی موفقیت هر پیاده‌سازی از microservices خواهد بود. در واقع، من تا آنجا پیش می‌روم که بگویم microservices به درجه‌ای درک فناوری پشتیبان را می‌طلبد که تمایزهای قبلی بین معماری منطقی و فیزیکی می‌تواند مشکل‌ساز باشد—اگر در کمک به شکل‌دهی به یک معماری microservice مشارکت دارید، به درک گسترده‌ای از این دو جهان نیاز خواهید داشت.
  </p>
<p>
   ما در فصل‌های بعدی به تفصیل به بررسی بسیاری از این فناوری خواهیم پرداخت، اما قبل از آن، اجازه دهید به طور خلاصه برخی از فناوری‌های فعال‌کننده را که ممکن است در صورت تصمیم به استفاده از microservices به شما کمک کنند، معرفی کنیم.
  </p>
<h4>Log Aggregation و Distributed Tracing</h4>
<p>
   با افزایش تعداد <strong>processes</strong> که مدیریت می‌کنید، درک نحوه عملکرد سیستم شما در یک محیط تولید می‌تواند دشوار باشد. این امر به نوبه خود می‌تواند عیب‌یابی را بسیار دشوارتر کند. ما در فصل 10 به بررسی عمیق‌تر این ایده‌ها خواهیم پرداخت، اما حداقل، من قویاً از اجرای یک سیستم <strong>log aggregation</strong> به عنوان یک پیش‌نیاز برای اتخاذ معماری microservice حمایت می‌کنم.
  </p>
<p>
   هنگام شروع با microservices، مراقب باشید که فناوری جدید زیادی را قبول نکنید. با این حال، یک ابزار <strong>log aggregation</strong> آنقدر ضروری است که باید آن را یک پیش‌نیاز برای اتخاذ microservices در نظر بگیرید.
  </p>
<p>
   این سیستم‌ها به شما اجازه می‌دهند تا <strong>logs</strong> را از سراسر <strong>services</strong> خود جمع‌آوری و تجمیع کنید، و یک مکان مرکزی را در اختیار شما قرار می‌دهند که از آن می‌توان <strong>logs</strong> را تجزیه و تحلیل کرد، و حتی بخشی از یک مکانیسم هشدار فعال ساخت. بسیاری از گزینه‌ها در این فضا به موقعیت‌های متعددی پاسخ می‌دهند. من طرفدار بزرگ <strong>Humio</strong> به دلایل مختلف هستم، اما <strong>logging services</strong> ساده ارائه شده توسط فروشندگان اصلی <strong>public cloud</strong> ممکن است برای شروع کار شما کافی باشد.
  </p>
<p>
   شما می‌توانید با پیاده‌سازی <strong>correlation IDs</strong>، که در آن یک <strong>ID</strong> واحد برای مجموعه‌ای مرتبط از <strong>service calls</strong> استفاده می‌شود—به عنوان مثال، زنجیره تماس‌هایی که ممکن است به دلیل تعامل کاربر ایجاد شود—این ابزارهای <strong>log aggregation</strong> را حتی مفیدتر کنید. با ثبت این <strong>ID</strong> به عنوان بخشی از هر ورودی <strong>log</strong>، ایزوله کردن <strong>logs</strong> مرتبط با یک جریان مشخص از تماس‌ها بسیار آسان‌تر می‌شود، که به نوبه خود عیب‌یابی را بسیار آسان‌تر می‌کند.
  </p>
<p>
   با افزایش پیچیدگی سیستم شما، ضروری است که ابزارهایی را در نظر بگیرید که به شما امکان می‌دهند تا بهتر آنچه را که سیستم شما انجام می‌دهد بررسی کنید، که توانایی تجزیه و تحلیل <strong>traces</strong> در چندین <strong>service</strong> را فراهم می‌کند، گلوگاه‌ها را تشخیص می‌دهد، و از سیستم خود سؤال می‌کنید
  </p>
<p>Enabling Technology | 19</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 45" src="page_0045/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0045</div>
            </div>
        </div>
        <!-- Page 0046 -->
        <div class="chapter" id="page-0046">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   که نمی‌دانستید در وهله اول می‌خواهید بپرسید. ابزارهای <strong>open source</strong> می‌توانند برخی از این ویژگی‌ها را ارائه دهند. یک مثال <strong>Jaeger</strong> است که بر جنبه <strong>distributed tracing</strong> معادله متمرکز است.
  </p>
<p>
   اما محصولاتی مانند <strong>Lightstep</strong> و <strong>Honeycomb</strong> (که در شکل 1-9 نشان داده شده است) این ایده‌ها را بیشتر پیش می‌برند. آنها نشان‌دهنده نسل جدیدی از ابزارها هستند که فراتر از رویکردهای نظارت سنتی می‌روند و کاوش در وضعیت سیستم در حال اجرا را بسیار آسان‌تر می‌کنند.
  </p>
<p>
   شما ممکن است در حال حاضر ابزارهای متعارف‌تری در اختیار داشته باشید، اما واقعاً باید به قابلیت‌هایی که این محصولات ارائه می‌دهند نگاه کنید. آنها از ابتدا برای حل انواع مشکلاتی که <strong>operators</strong> معماری‌های microservice باید با آنها سروکار داشته باشند، ساخته شده‌اند.
  </p>
<p>
   شکل 1-9. یک <strong>distributed trace</strong> که در <strong>Honeycomb</strong> نشان داده شده است، به شما امکان می‌دهد تا مشخص کنید که زمان برای عملیات‌هایی که می‌توانند چندین microservices را در بر گیرند، کجا صرف می‌شود
  </p>
<h4>Containers و Kubernetes</h4>
<p>
   در حالت ایده‌آل، شما می‌خواهید هر نمونه microservice را در انزوا اجرا کنید. این تضمین می‌کند که مشکلات در یک microservice نمی‌تواند بر microservice دیگری تأثیر بگذارد—به عنوان مثال، با بلعیدن تمام <strong>CPU</strong>. <strong>Virtualization</strong> یک راه برای ایجاد محیط‌های اجرایی ایزوله شده بر روی سخت‌افزار موجود است، اما تکنیک‌های مجازی‌سازی معمولی می‌توانند زمانی که اندازه microservicesهایمان را در نظر می‌گیریم، بسیار سنگین باشند. از طرف دیگر، <strong>Containers</strong> یک راه بسیار سبک‌تر برای تهیه اجرای ایزوله برای نمونه‌های <strong>service</strong> ارائه می‌دهند که منجر به زمان راه‌اندازی سریع‌تر برای نمونه‌های <strong>container</strong> جدید، و همچنین مقرون به صرفه‌تر برای بسیاری از معماری‌ها می‌شود.
  </p>
<p>20 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 46" src="page_0046/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0046</div>
            </div>
        </div>
        <!-- Page 0047 -->
        <div class="chapter" id="page-0047">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   پس از اینکه شروع به بازی با <strong>containers</strong> کردید، متوجه خواهید شد که به چیزی نیاز دارید که به شما امکان می‌دهد این <strong>containers</strong> را در دستگاه‌های زیربنایی زیادی مدیریت کنید. پلتفرم‌های ارکستراسیون <strong>container</strong> مانند <strong>Kubernetes</strong> دقیقاً همین کار را انجام می‌دهند، به شما امکان می‌دهند نمونه‌های <strong>container</strong> را به گونه‌ای توزیع کنید که <strong>robustness</strong> و <strong>throughput</strong> مورد نیاز <strong>service</strong> شما را فراهم کند، در حالی که به شما امکان می‌دهد از دستگاه‌های زیربنایی به طور موثر استفاده کنید. در فصل 8 ما مفاهیم جداسازی عملیاتی، <strong>containers</strong> و <strong>Kubernetes</strong> را بررسی خواهیم کرد.
  </p>
<p>
   احساس نکنید که باید برای اتخاذ <strong>Kubernetes</strong>، یا حتی <strong>containers</strong>، عجله کنید. آنها قطعاً مزایای قابل توجهی نسبت به تکنیک‌های استقرار سنتی‌تر ارائه می‌دهند، اما توجیه پذیرش آنها در صورتی که فقط چند microservice دارید، دشوار است.
  </p>
<p>
   پس از اینکه سربار مدیریت استقرار شروع به سردرد قابل توجهی کرد، شروع به در نظر گرفتن <strong>containerization</strong> <strong>service</strong> خود و استفاده از <strong>Kubernetes</strong> کنید. اما اگر در نهایت این کار را انجام دادید، تمام تلاش خود را بکنید تا اطمینان حاصل کنید که شخص دیگری <strong>Kubernetes cluster</strong> را برای شما اجرا می‌کند، شاید با استفاده از یک <strong>managed service</strong> در یک <strong>public cloud provider</strong>. اجرای <strong>Kubernetes cluster</strong> خود می‌تواند مقدار قابل توجهی کار باشد!
  </p>
<h4>Streaming</h4>
<p>
   اگرچه با microservices ما از پایگاه‌های داده <strong>monolithic</strong> دور می‌شویم، اما همچنان باید راه‌هایی برای به اشتراک گذاشتن داده‌ها بین microservices پیدا کنیم. این در حالی اتفاق می‌افتد که سازمان‌ها می‌خواهند از عملیات گزارش‌دهی دسته‌ای و به سمت بازخورد <strong>real-time</strong> حرکت کنند، که به آنها اجازه می‌دهد سریع‌تر واکنش نشان دهند. بنابراین محصولاتی که امکان <strong>streaming</strong> و پردازش آسان آنچه اغلب حجم زیادی از داده‌ها را فراهم می‌کنند، در بین افرادی که از معماری‌های microservice استفاده می‌کنند، محبوب شده‌اند.
  </p>
<p>
   برای بسیاری از مردم، <strong>Apache Kafka</strong> به انتخاب <strong>de facto</strong> برای <strong>streaming</strong> داده‌ها در یک محیط microservice تبدیل شده است، و به دلایل خوبی هم هست. قابلیت‌هایی مانند <strong>message permanence</strong>، <strong>compaction</strong> و توانایی مقیاس‌پذیری برای رسیدگی به حجم زیادی از پیام‌ها می‌تواند فوق‌العاده مفید باشد. <strong>Kafka</strong> شروع به افزودن قابلیت‌های پردازش جریان در قالب <strong>KSQLDB</strong> کرده است، اما شما همچنین می‌توانید از آن با راه‌حل‌های پردازش جریان اختصاصی مانند <strong>Apache Flink</strong> استفاده کنید. <strong>Debezium</strong> یک ابزار <strong>open source</strong> است که برای کمک به <strong>stream</strong> داده‌ها از منابع داده موجود از طریق <strong>Kafka</strong> توسعه داده شده است، و به اطمینان از اینکه منابع داده سنتی می‌توانند بخشی از یک معماری مبتنی بر <strong>stream</strong> شوند، کمک می‌کند. در فصل 4 نگاهی به چگونگی نقش فناوری <strong>streaming</strong> در یکپارچه‌سازی microservice خواهیم داشت.
  </p>
<h4>Public Cloud و Serverless</h4>
<p>
<strong>Public cloud providers</strong>، یا به‌طور خاص‌تر سه ارائه‌دهنده اصلی—<strong>Google Cloud</strong>، <strong>Microsoft Azure</strong>، و <strong>Amazon Web Services (AWS)</strong>—مجموعه عظیمی از <strong>managed services</strong> و گزینه‌های استقرار را برای مدیریت برنامه شما ارائه می‌دهند. با رشد معماری microservice شما، کارهای بیشتری به فضای عملیاتی منتقل می‌شود. <strong>Public cloud providers</strong> میزبان <strong>managed services</strong>، از <strong>managed</strong>
</p>
<p>Enabling Technology | 21</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0047</div>
            </div>
        </div>
        <!-- Page 0048 -->
        <div class="chapter" id="page-0048">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   نمونه‌های پایگاه‌های داده یا <strong>Kubernetes clusters</strong> تا کارگزاران پیام یا <strong>filesystems</strong> توزیع‌شده. با استفاده از این <strong>managed services</strong>، شما مقدار زیادی از این کار را به یک شخص ثالث واگذار می‌کنید که مسلماً بهتر می‌تواند با این وظایف سروکار داشته باشد.
  </p>
<p>
   از جمله محصولات <strong>public cloud</strong>، محصولاتی که تحت عنوان <strong>serverless</strong> قرار دارند، از اهمیت ویژه‌ای برخوردار هستند. این محصولات ماشین‌های زیربنایی را پنهان می‌کنند، و به شما امکان می‌دهند در سطح انتزاعی بالاتری کار کنید. نمونه‌هایی از محصولات <strong>serverless</strong> شامل کارگزاران پیام، راه‌حل‌های ذخیره‌سازی و پایگاه‌های داده هستند. پلتفرم‌های <strong>Function as a Service (FaaS)</strong> از اهمیت ویژه‌ای برخوردار هستند زیرا یک انتزاع خوب را در اطراف استقرار کد ارائه می‌دهند. به جای نگرانی در مورد تعداد سرورهایی که برای اجرای <strong>service</strong> خود نیاز دارید، فقط کد خود را مستقر می‌کنید و به پلتفرم زیربنایی اجازه می‌دهید که نمونه‌هایی از کد شما را <strong>on demand</strong> راه‌اندازی کند. ما در فصل 8 با جزئیات بیشتری به <strong>serverless</strong> خواهیم پرداخت.
  </p>
<h4>مزایای Microservices</h4>
<p>
   مزایای microservices متعدد و متنوع است. بسیاری از این مزایا را می‌توان در هر سیستم توزیع‌شده قرار داد. با این حال، microservices تمایل دارند این مزایا را تا حد زیادی کسب کنند، عمدتاً به این دلیل که در نحوه تعریف <strong>service boundaries</strong> موضع‌گیری صریح‌تری دارند. با ترکیب مفاهیم <strong>information hiding</strong> و <strong>domain-driven design</strong> با قدرت سیستم‌های توزیع‌شده، microservices می‌توانند به دستیابی به پیشرفت‌های قابل توجهی نسبت به سایر اشکال معماری‌های توزیع‌شده کمک کنند.
  </p>
<h4>ناهمگونی فناوری</h4>
<p>
   با سیستمی که از چندین microservice همکار تشکیل شده است، می‌توانیم تصمیم بگیریم که از فناوری‌های مختلف در داخل هر کدام استفاده کنیم. این به ما امکان می‌دهد تا ابزار مناسب را برای هر کار انتخاب کنیم، به جای اینکه مجبور باشیم یک رویکرد استانداردتر و یک‌اندازه را انتخاب کنیم که اغلب به کمترین مخرج مشترک ختم می‌شود.
  </p>
<p>
   اگر یک بخش از سیستم ما نیاز به بهبود عملکرد خود دارد، ممکن است تصمیم بگیریم از یک پشته فناوری متفاوت استفاده کنیم که بهتر می‌تواند به سطوح عملکرد مورد نیاز دست یابد. ما همچنین ممکن است تصمیم بگیریم که نحوه ذخیره داده‌هایمان باید برای بخش‌های مختلف سیستم ما تغییر کند. به عنوان مثال، برای یک شبکه اجتماعی، ممکن است تعاملات کاربرانمان را در یک پایگاه داده <strong>graph-oriented</strong> ذخیره کنیم تا ماهیت بسیار به هم پیوسته یک نمودار اجتماعی را منعکس کنیم، اما شاید پست‌هایی که کاربران می‌نویسند را بتوان در یک انبار داده <strong>document-oriented</strong> ذخیره کرد و معماری ناهمگونی مانند معماری نشان داده شده در شکل 1-10 ایجاد کرد.
  </p>
<p>22 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0048</div>
            </div>
        </div>
        <!-- Page 0049 -->
        <div class="chapter" id="page-0049">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 1-10. Microservices می‌تواند به شما اجازه دهد تا فناوری‌های مختلف را راحت‌تر بپذیرید
  </p>
<p>
   با microservices، ما همچنین می‌توانیم فناوری‌ها را سریع‌تر بپذیریم و درک کنیم که پیشرفت‌های جدید چگونه می‌توانند به ما کمک کنند. یکی از بزرگترین موانع برای امتحان کردن و اتخاذ یک فناوری جدید، خطرات مرتبط با آن است. با یک برنامه <strong>monolithic</strong>، اگر بخواهم یک زبان برنامه‌نویسی، پایگاه داده یا فریم‌ورک جدید را امتحان کنم، هر تغییری بر بخش زیادی از سیستم من تأثیر می‌گذارد. با سیستمی که از چندین <strong>service</strong> تشکیل شده است، من مکان‌های جدید متعددی برای امتحان کردن یک فناوری جدید دارم. من می‌توانم یک microservice را با شاید کمترین خطر انتخاب کنم و از آن فناوری در آنجا استفاده کنم، با این علم که می‌توانم هرگونه تأثیر منفی احتمالی را محدود کنم. بسیاری از سازمان‌ها این توانایی را برای جذب سریع‌تر فناوری‌های جدید یک مزیت واقعی می‌دانند.
  </p>
<p>
   البته، پذیرش چندین فناوری بدون سربار نیست. برخی از سازمان‌ها انتخاب می‌کنند که برخی از محدودیت‌ها را در انتخاب زبان قرار دهند. به عنوان مثال، <strong>Netflix</strong> و <strong>Twitter</strong> بیشتر از <strong>Java Virtual Machine (JVM)</strong> به عنوان یک پلتفرم استفاده می‌کنند زیرا آن شرکت‌ها درک بسیار خوبی از قابلیت اطمینان و عملکرد آن سیستم دارند. آنها همچنین کتابخانه‌ها و ابزارهایی را برای <strong>JVM</strong> توسعه می‌دهند که عملکرد در مقیاس را بسیار آسان‌تر می‌کند، اما تکیه بر کتابخانه‌های خاص <strong>JVM</strong> کارها را برای <strong>services</strong> یا کلاینت‌های غیر مبتنی بر جاوا دشوارتر می‌کند. اما نه <strong>Twitter</strong> و نه <strong>Netflix</strong> از یک <strong>technology stack</strong> برای همه کارها استفاده نمی‌کنند.
  </p>
<p>
   این واقعیت که پیاده‌سازی فناوری داخلی از مصرف‌کنندگان پنهان شده است، همچنین می‌تواند ارتقاء فناوری‌ها را آسان‌تر کند. به عنوان مثال، کل معماری microservice شما ممکن است بر اساس <strong>Spring Boot</strong> باشد، اما شما می‌توانید نسخه <strong>JVM</strong> یا نسخه‌های فریم‌ورک را فقط برای یک microservice تغییر دهید، و مدیریت ریسک ارتقاء را آسان‌تر کنید.
  </p>
<h4>استحکام</h4>
<p>
   یک مفهوم کلیدی در بهبود <strong>robustness</strong> برنامه شما <strong>bulkhead</strong> است. یک جزء از یک سیستم ممکن است شکست بخورد، اما تا زمانی که آن شکست <strong>cascade</strong> نشود، می‌توانید مشکل را ایزوله کنید و بقیه سیستم به کار خود ادامه دهند. <strong>Service</strong>
</p>
<p>Advantages of Microservices | 23</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 49" src="page_0049/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0049</div>
            </div>
        </div>
        <!-- Page 0050 -->
        <div class="chapter" id="page-0050">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<strong>boundaries</strong> <strong>service</strong> شما به <strong>bulkheads</strong> واضح شما تبدیل می‌شوند. در یک <strong>service</strong> <strong>monolithic</strong>، اگر <strong>service</strong> شکست بخورد، همه چیز از کار می‌افتد. با یک سیستم <strong>monolithic</strong>، ما می‌توانیم بر روی چندین دستگاه اجرا کنیم تا شانس شکست خود را کاهش دهیم، اما با microservices، می‌توانیم سیستم‌هایی بسازیم که خرابی کامل برخی از <strong>services</strong> تشکیل‌دهنده را مدیریت کنند و <strong>functionality</strong> را بر این اساس کاهش دهند.
  </p>
<p>
   با این حال، ما باید مراقب باشیم. برای اطمینان از اینکه سیستم‌های microservice ما می‌توانند این <strong>robustness</strong> بهبود یافته را به درستی در آغوش بگیرند، باید منابع جدید شکست را که سیستم‌های توزیع‌شده باید با آنها مقابله کنند، درک کنیم. شبکه‌ها می‌توانند و شکست خواهند خورد، و ماشین‌ها نیز. ما باید بدانیم که چگونه چنین شکست‌هایی را مدیریت کنیم و تأثیری (در صورت وجود) که این شکست‌ها بر کاربران نهایی نرم‌افزار ما خواهد داشت. من مطمئناً با تیم‌هایی کار کرده‌ام که پس از مهاجرت به microservices به دلیل عدم جدی گرفتن این نگرانی‌ها، به یک سیستم با استحکام کمتر پایان داده‌اند.
  </p>
<h4>Scaling</h4>
<p>
   با یک <strong>service</strong> بزرگ و <strong>monolithic</strong>، ما باید همه چیز را با هم مقیاس‌بندی کنیم. شاید یک قسمت کوچک از سیستم کلی ما از نظر عملکرد محدود شده باشد، اما اگر آن رفتار در یک برنامه <strong>monolithic</strong> غول‌پیکر قفل شده باشد، باید همه چیز را به عنوان یک قطعه مقیاس‌بندی کنیم. با <strong>services</strong> کوچک‌تر، می‌توانیم فقط آن <strong>services</strong> را که نیاز به مقیاس‌پذیری دارند مقیاس‌بندی کنیم و به ما اجازه می‌دهیم بخش‌های دیگر سیستم را بر روی سخت‌افزار کوچک‌تر و کم‌قدرت‌تر اجرا کنیم، همانطور که در شکل 1-11 نشان داده شده است.
  </p>
<p>
   شکل 1-11. شما می‌توانید <strong>scaling</strong> را فقط برای microservicesهایی که به آن نیاز دارند هدف قرار دهید
  </p>
<p>24 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 50" src="page_0050/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0050</div>
            </div>
        </div>
        <!-- Page 0051 -->
        <div class="chapter" id="page-0051">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<strong>Gilt</strong>، یک خرده‌فروش مد آنلاین، microservices را دقیقاً به همین دلیل اتخاذ کرد. <strong>Gilt</strong> که در سال 2007 با یک برنامه <strong>monolithic Rails</strong> شروع به کار کرد، تا سال 2009 سیستمش قادر به مقابله با باری که بر آن وارد می‌شد، نبود. <strong>Gilt</strong> با جدا کردن بخش‌های اصلی سیستم خود، توانست با افزایش ترافیک خود بهتر مقابله کند، و امروزه بیش از 450 microservice دارد که هر کدام بر روی چندین دستگاه جداگانه اجرا می‌شوند.
  </p>
<p>
   هنگامی که سیستم‌های <strong>on-demand provisioning</strong> را مانند سیستم‌هایی که توسط <strong>AWS</strong> ارائه می‌شوند، در آغوش می‌گیریم، حتی می‌توانیم این <strong>scaling</strong> را بر اساس تقاضا برای قطعاتی که به آن نیاز دارند، اعمال کنیم. این به ما امکان می‌دهد تا هزینه‌های خود را به طور موثرتری کنترل کنیم. این اتفاق نمی‌افتد که یک رویکرد معماری بتواند آنقدر به صرفه‌جویی در هزینه تقریباً فوری مرتبط باشد.
  </p>
<p>
   در نهایت، ما می‌توانیم برنامه‌های خود را به روش‌های متعددی مقیاس‌بندی کنیم، و microservices می‌تواند بخش مؤثری از این امر باشد. ما در فصل 13 با جزئیات بیشتری به مقیاس‌بندی microservices خواهیم پرداخت.
  </p>
<h4>آسانی استقرار</h4>
<p>
   یک تغییر یک خطی در یک برنامه <strong>monolithic</strong> با یک میلیون خط نیاز دارد که کل برنامه برای انتشار تغییر مستقر شود. این می‌تواند یک استقرار با تأثیر زیاد و پرخطر باشد. در عمل، استقرارهایی مانند این به دلیل ترس قابل درک، به ندرت اتفاق می‌افتند. متأسفانه، این بدان معناست که تغییرات ما بین نسخه‌ها همچنان انباشته می‌شوند، تا اینکه نسخه جدید برنامه ما که وارد تولید می‌شود، حجم زیادی از تغییرات را داشته باشد. و هر چه تفاوت بین نسخه‌ها بیشتر باشد، خطر اشتباه انجام دادن چیزی بیشتر است!
  </p>
<p>
   با microservices، ما می‌توانیم تغییری در یک <strong>service</strong> واحد ایجاد کنیم و آن را به طور مستقل از بقیه سیستم مستقر کنیم. این به ما امکان می‌دهد کد خود را سریع‌تر مستقر کنیم.
  </p>
<p>
   اگر مشکلی پیش بیاید، می‌توان آن را به سرعت به یک <strong>service</strong> جداگانه ایزوله کرد، و بازگشت سریع را آسان کرد. این همچنین به این معنی است که ما می‌توانیم <strong>functionality</strong> جدید خود را سریع‌تر به دست مشتریان برسانیم. این یکی از دلایل اصلی است که سازمان‌هایی مانند <strong>Amazon</strong> و <strong>Netflix</strong> از این معماری‌ها استفاده می‌کنند—برای اطمینان از حذف تا حد امکان موانع برای خارج کردن نرم‌افزار.
  </p>
<h4>هم‌ترازی سازمانی</h4>
<p>
   بسیاری از ما مشکلات مرتبط با تیم‌های بزرگ و <strong>codebases</strong> بزرگ را تجربه کرده‌ایم. این مشکلات زمانی می‌توانند تشدید شوند که تیم توزیع شده باشد. ما همچنین می‌دانیم که تیم‌های کوچک‌تر که روی <strong>codebases</strong> کوچک‌تر کار می‌کنند، تمایل به تولید بیشتر دارند.
  </p>
<p>
   Microservices به ما اجازه می‌دهد تا معماری خود را با سازمانمان بهتر هماهنگ کنیم و به ما کمک می‌کند تا تعداد افرادی را که روی هر <strong>codebase</strong> کار می‌کنند، به حداقل برسانیم تا به نقطه مطلوب اندازه تیم و بهره‌وری برسیم. Microservices همچنین به ما این امکان را می‌دهد که مالکیت <strong>services</strong> را با تغییر سازمان تغییر دهیم—و به ما امکان می‌دهد تا همسویی بین معماری و سازمان را در آینده حفظ کنیم.
  </p>
<p>Advantages of Microservices | 25</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0051</div>
            </div>
        </div>
        <!-- Page 0052 -->
        <div class="chapter" id="page-0052">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Composability</h4>
<p>
   یکی از وعده‌های اصلی سیستم‌های توزیع‌شده و معماری‌های <strong>service-oriented</strong> این است که ما فرصت‌هایی را برای استفاده مجدد از <strong>functionality</strong> باز می‌کنیم. با microservices، ما اجازه می‌دهیم که <strong>functionality</strong> ما به روش‌های مختلف برای اهداف مختلف مصرف شود. این می‌تواند به‌ویژه زمانی مهم باشد که در مورد نحوه استفاده مصرف‌کنندگان ما از نرم‌افزارمان فکر می‌کنیم.
  </p>
<p>
   زمانی که ما می‌توانستیم با دقت در مورد وب‌سایت دسکتاپ یا برنامه تلفن همراه خود فکر کنیم، گذشته است. اکنون ما باید به راه‌های بی‌شماری فکر کنیم که ممکن است بخواهیم قابلیت‌ها را برای وب، برنامه <strong>native</strong>، وب موبایل، برنامه تبلت یا دستگاه پوشیدنی ترکیب کنیم. همانطور که سازمان‌ها از تفکر بر اساس کانال‌های محدود به پذیرش مفاهیم جامع‌تر <strong>customer engagement</strong> روی می‌آورند، ما به معماری‌هایی نیاز داریم که بتوانند با آن همگام شوند.
  </p>
<p>
   با microservices، به این فکر کنید که ما در حال باز کردن <strong>seams</strong> در سیستم خود هستیم که توسط طرف‌های خارجی قابل خطاب هستند. با تغییر شرایط، ما می‌توانیم برنامه‌ها را به روش‌های مختلف بسازیم. با یک برنامه <strong>monolithic</strong>، من اغلب یک <strong>seam</strong> درشت‌دانه دارم که می‌توان از بیرون استفاده کرد. اگر بخواهم آن را جدا کنم تا چیزی مفیدتر به دست آورم، به چکش نیاز دارم!
  </p>
<h4>نقاط درد Microservice</h4>
<p>
   همانطور که قبلاً دیدیم، معماری‌های microservice مزایای زیادی را به همراه دارند. اما آنها همچنین مجموعه‌ای از پیچیدگی‌ها را به همراه دارند. اگر در حال بررسی اتخاذ معماری microservice هستید، مهم است که بتوانید خوب را با بد مقایسه کنید. در واقعیت، بیشتر نقاط microservice را می‌توان به درگاه سیستم‌های توزیع‌شده نسبت داد و بنابراین به همان اندازه احتمالاً در یک <strong>distributed monolith</strong> وجود خواهد داشت، همانطور که در یک معماری microservice.
  </p>
<p>
   ما بسیاری از این مسائل را در طول بقیه کتاب به تفصیل پوشش خواهیم داد—در واقع، من استدلال می‌کنم که بخش عمده این کتاب در مورد مقابله با درد، رنج و وحشت مالکیت یک معماری microservice است.
  </p>
<h4>تجربه توسعه‌دهنده</h4>
<p>
   با داشتن <strong>services</strong> بیشتر و بیشتر، تجربه توسعه‌دهنده می‌تواند شروع به رنج کند. زمان‌های اجرای با منابع فشرده‌تر مانند <strong>JVM</strong> می‌تواند تعداد microservicesهایی را که می‌توانند در یک دستگاه توسعه‌دهنده واحد اجرا شوند، محدود کند. من احتمالاً می‌توانم چهار یا پنج microservice مبتنی بر <strong>JVM</strong> را به عنوان فرآیندهای جداگانه بر روی لپ‌تاپ خود اجرا کنم، اما آیا می‌توانم 10 یا 20 را اجرا کنم؟ به احتمال زیاد نه. حتی با زمان‌های اجرای کم‌هزینه‌تر، محدودیتی در تعداد چیزهایی که می‌توانید محلی اجرا کنید وجود دارد، که ناگزیر بحث‌هایی را در مورد اینکه وقتی نمی‌توانید کل سیستم را روی یک دستگاه اجرا کنید، شروع می‌کند. این می‌تواند حتی اگر از <strong>cloud services</strong> استفاده می‌کنید که نمی‌توانید محلی اجرا کنید، پیچیده‌تر شود.
  </p>
<p>26 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0052</div>
            </div>
        </div>
        <!-- Page 0053 -->
        <div class="chapter" id="page-0053">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   راه‌حل‌های افراطی می‌تواند شامل "توسعه در <strong>cloud</strong>" باشد، جایی که توسعه‌دهندگان دیگر از توانایی توسعه محلی دور می‌شوند. من طرفدار این نیستم، زیرا چرخه‌های بازخورد می‌توانند به شدت آسیب ببینند. در عوض، من فکر می‌کنم محدود کردن دامنه بخش‌هایی از یک سیستم که یک توسعه‌دهنده باید روی آن کار کند، احتمالاً رویکرد بسیار ساده‌تری خواهد بود. با این حال، این ممکن است مشکل‌ساز باشد اگر شما بخواهید از مدل "مالکیت جمعی" بیشتری استفاده کنید که در آن از هر توسعه‌دهنده انتظار می‌رود روی هر بخشی از سیستم کار کند.
  </p>
<h4>Overload فناوری</h4>
<p>
   وزن زیاد فناوری جدیدی که برای فعال کردن پذیرش معماری‌های microservice ایجاد شده است، می‌تواند طاقت‌فرسا باشد. من صادق خواهم بود و می‌گویم که بسیاری از این فناوری‌ها به تازگی به عنوان "<strong>microservice friendly</strong>" تغییر نام داده‌اند، اما برخی از پیشرفت‌ها به طور مشروع در برخورد با پیچیدگی این نوع معماری‌ها کمک کرده‌اند. با این حال، این خطر وجود دارد که این ثروت اسباب‌بازی‌های جدید می‌تواند منجر به نوعی فتیشیسم فناوری شود. من شرکت‌های زیادی را دیده‌ام که معماری microservice را اتخاذ کرده‌اند و تصمیم گرفتند که این بهترین زمان برای معرفی آرایه‌های وسیعی از فناوری‌های جدید و اغلب بیگانه است.
  </p>
<p>
   Microservices ممکن است به شما این گزینه را بدهند که هر microservice در یک زبان برنامه‌نویسی متفاوت نوشته شود، در یک زمان اجرا متفاوت اجرا شود، یا از یک پایگاه داده متفاوت استفاده کند—اما اینها گزینه‌ها هستند، نه الزامات. شما باید وسعت و پیچیدگی فناوری مورد استفاده خود را در برابر هزینه‌هایی که یک آرایه متنوع از فناوری می‌تواند به همراه داشته باشد، با دقت متعادل کنید.
  </p>
<p>
   هنگامی که شروع به اتخاذ microservices می‌کنید، برخی از چالش‌های اساسی اجتناب‌ناپذیر هستند: شما باید زمان زیادی را صرف درک مسائل مربوط به <em>data consistency</em>، <em>latency</em>، <em>service modeling</em> و موارد مشابه کنید. اگر می‌خواهید همزمان با درک این ایده‌ها، نحوه تفکر خود را در مورد توسعه نرم‌افزار تغییر دهید و در عین حال مقدار زیادی فناوری جدید را در آغوش بگیرید، زمان سختی خواهید داشت. همچنین شایان ذکر است که پهنای باندی که برای تلاش برای درک همه این فناوری‌های جدید صرف می‌شود، زمان شما را برای عرضه واقعی ویژگی‌ها به کاربران خود کاهش می‌دهد.
  </p>
<p>
   همانطور که شما (به تدریج) پیچیدگی معماری microservice خود را افزایش می‌دهید، به دنبال معرفی فناوری‌های جدید در صورت نیاز باشید. شما زمانی که سه <strong>service</strong> دارید به یک <strong>Kubernetes cluster</strong> نیاز ندارید! علاوه بر اطمینان از اینکه بیش از حد با پیچیدگی این ابزارهای جدید بارگذاری نشده‌اید، این افزایش تدریجی دارای مزیت اضافی است که به شما امکان می‌دهد راه‌های جدید و بهتری برای انجام کارها به دست آورید که بدون شک با گذشت زمان ظهور خواهند کرد.
  </p>
<p>Microservice Pain Points | 27</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0053</div>
            </div>
        </div>
        <!-- Page 0054 -->
        <div class="chapter" id="page-0054">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>هزینه</h4>
<p>
   بسیار محتمل است که حداقل در کوتاه مدت افزایش هزینه‌ها را از تعدادی عامل مشاهده کنید. اولاً، احتمالاً شما نیاز دارید که کارهای بیشتری انجام دهید—<strong>processes</strong> بیشتر، رایانه‌های بیشتر، شبکه بیشتر، فضای ذخیره‌سازی بیشتر، و نرم‌افزار پشتیبانی بیشتر (که هزینه‌های مجوز اضافی را متحمل خواهد شد).
  </p>
<p>
   ثانیاً، هر تغییری که در یک تیم یا یک سازمان معرفی می‌کنید، شما را در کوتاه مدت کند می‌کند. یادگیری ایده‌های جدید و یافتن راه‌های استفاده مؤثر از آنها زمان می‌برد. در حالی که این اتفاق می‌افتد، سایر فعالیت‌ها تحت تأثیر قرار خواهند گرفت. این امر منجر به کندی مستقیم در ارائه <strong>functionality</strong> جدید یا نیاز به اضافه کردن افراد بیشتر برای جبران این هزینه می‌شود.
  </p>
<p>
   به تجربه من، microservices انتخاب ضعیفی برای سازمانی است که در درجه اول نگران کاهش هزینه‌ها است، زیرا ذهنیت کاهش هزینه—جایی که <strong>IT</strong> به عنوان یک مرکز هزینه دیده می‌شود تا یک مرکز سود—همواره مانعی برای به دست آوردن بیشترین بهره از این معماری خواهد بود. از سوی دیگر، microservices می‌تواند به شما کمک کند تا پول بیشتری به دست آورید اگر بتوانید از این معماری‌ها برای دسترسی به مشتریان بیشتر یا توسعه <strong>functionality</strong> بیشتر به طور موازی استفاده کنید. پس آیا microservices راهی برای افزایش سود است؟ شاید.
  </p>
<p>
   آیا microservices راهی برای کاهش هزینه‌ها است؟ نه چندان.
  </p>
<h4>گزارش‌دهی</h4>
<p>
   با یک سیستم <strong>monolithic</strong>، شما معمولاً یک پایگاه داده <strong>monolithic</strong> دارید. این بدان معناست که ذینفعانی که می‌خواهند همه داده‌ها را با هم تجزیه و تحلیل کنند، اغلب شامل عملیات <strong>join</strong> بزرگ در داده‌ها می‌شود، یک <strong>schema</strong> آماده دارند که گزارش‌های خود را بر اساس آن اجرا کنند. آنها می‌توانند آنها را مستقیماً در برابر پایگاه داده <strong>monolithic</strong>، شاید در برابر یک <strong>read replica</strong>، همانطور که در شکل 1-12 نشان داده شده است، اجرا کنند.
  </p>
<p>
   شکل 1-12. گزارش‌دهی که مستقیماً در پایگاه داده یک <strong>monolith</strong> انجام می‌شود
  </p>
<p>28 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 54" src="page_0054/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0054</div>
            </div>
        </div>
        <!-- Page 0055 -->
        <div class="chapter" id="page-0055">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   با یک معماری microservice، ما این <strong>monolithic schema</strong> را از هم جدا کرده‌ایم. این بدان معنا نیست که نیاز به گزارش‌دهی در سراسر تمام داده‌های ما از بین رفته است. ما فقط این کار را بسیار دشوارتر کرده‌ایم، زیرا اکنون داده‌های ما در چندین <strong>schemas</strong> از نظر منطقی ایزوله شده پخش شده است.
  </p>
<p>
   رویکردهای مدرن‌تر برای گزارش‌دهی، مانند استفاده از <strong>streaming</strong> برای اجازه گزارش‌دهی <strong>real-time</strong> در حجم زیادی از داده‌ها، می‌توانند با معماری microservice به خوبی کار کنند، اما معمولاً مستلزم اتخاذ ایده‌ها و فناوری‌های مرتبط جدید هستند. از طرف دیگر، شما ممکن است به سادگی نیاز داشته باشید که داده‌ها را از microservices خود به پایگاه‌های داده گزارش‌دهی مرکزی (یا شاید دریاچه‌های داده‌ای ساختاریافته‌تر) منتشر کنید تا موارد استفاده از گزارش‌دهی را مجاز کنید.
  </p>
<h4>نظارت و عیب‌یابی</h4>
<p>
   با یک برنامه <strong>monolithic</strong> استاندارد، ما می‌توانیم یک رویکرد نسبتاً ساده به نظارت داشته باشیم. ما تعداد کمی دستگاه داریم که باید نگران آنها باشیم، و حالت خرابی برنامه تا حدودی باینری است—برنامه اغلب یا کاملاً بالا است یا کاملاً پایین. با معماری microservice، آیا ما تأثیر را درک می‌کنیم اگر فقط یک نمونه از یک <strong>service</strong> از کار بیفتد؟
  </p>
<p>
   با یک سیستم <strong>monolithic</strong>، اگر <strong>CPU</strong> ما برای مدت طولانی روی 100٪ گیر کند، می‌دانیم که این یک مشکل بزرگ است. با یک معماری microservice با ده‌ها یا صدها <strong>process</strong>، آیا می‌توانیم همین حرف را بزنیم؟ آیا ما نیاز داریم که کسی را ساعت 3 صبح بیدار کنیم وقتی فقط یک <strong>process</strong> روی 100٪ <strong>CPU</strong> گیر کرده است؟
  </p>
<p>
   خوشبختانه، ایده‌های زیادی در این فضا وجود دارد که می‌تواند کمک کند. اگر می‌خواهید این مفهوم را با جزئیات بیشتری بررسی کنید، من <em>Distributed Systems Observability</em> نوشته Cindy Sridharan (O’Reilly) را به عنوان یک نقطه شروع عالی توصیه می‌کنم، اگرچه ما همچنین در فصل 10 نگاهی به نظارت و قابلیت مشاهده خواهیم داشت.
  </p>
<h4>امنیت</h4>
<p>
   با یک سیستم <strong>monolithic</strong> تک <strong>process</strong>، بخش زیادی از اطلاعات ما در آن <strong>process</strong> جریان داشت. اکنون، اطلاعات بیشتری از طریق شبکه‌ها بین <strong>services</strong> ما جریان دارد. این می‌تواند داده‌های ما را در برابر مشاهده در حال انتقال و همچنین در برابر دستکاری احتمالی به عنوان بخشی از حملات <strong>man-in-the-middle</strong> آسیب‌پذیرتر کند. این بدان معناست که شما ممکن است نیاز داشته باشید که توجه بیشتری را به محافظت از داده‌ها در حال انتقال و اطمینان از محافظت از <strong>microservice endpoints</strong> خود معطوف کنید تا فقط طرف‌های مجاز بتوانند از آنها استفاده کنند. فصل 11 کاملاً به بررسی چالش‌های این فضا اختصاص دارد.
  </p>
<p>Microservice Pain Points | 29</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0055</div>
            </div>
        </div>
        <!-- Page 0056 -->
        <div class="chapter" id="page-0056">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Testing</h4>
<p>
   با هر نوع <strong>automated functional test</strong>، شما یک عمل متعادل‌سازی ظریف دارید. هر چه <strong>functionality</strong> بیشتری را یک <strong>test</strong> اجرا کند—یعنی، دامنه <strong>test</strong> گسترده‌تر باشد—شما اعتماد بیشتری به برنامه خود دارید. از سوی دیگر، هر چه دامنه <strong>test</strong> بزرگتر باشد، راه‌اندازی داده‌های <strong>test</strong> و <strong>supporting fixtures</strong> سخت‌تر است، اجرای <strong>test</strong> بیشتر طول می‌کشد، و مشخص کردن اینکه چه چیزی در صورت شکست خراب می‌شود، دشوارتر است. در فصل 9 من تعدادی از تکنیک‌ها را برای کارآمد کردن <strong>testing</strong> در این محیط چالش‌برانگیزتر به اشتراک خواهم گذاشت.
  </p>
<p>
<strong>End-to-end tests</strong> برای هر نوع سیستم در انتهای مقیاس از نظر <strong>functionality</strong> که پوشش می‌دهند، قرار دارند، و ما عادت کرده‌ایم که نوشتن و نگهداری آنها نسبت به <strong>unit tests</strong> با دامنه کوچکتر، مشکل‌سازتر باشد. اگرچه اغلب این ارزش دارد، زیرا ما می‌خواهیم به اعتمادی که از داشتن یک <strong>end-to-end test</strong> که از سیستم‌های ما به همان روشی که یک کاربر ممکن است استفاده کند، دست یابیم.
  </p>
<p>
   اما با یک معماری microservice، دامنه <strong>end-to-end tests</strong> ما بسیار بزرگ می‌شود. اکنون باید <strong>tests</strong> را در چندین <strong>process</strong> اجرا کنیم، که همه آنها باید مستقر شوند و برای سناریوهای <strong>test</strong> به‌درستی پیکربندی شوند. ما همچنین باید برای <strong>false negatives</strong> که زمانی رخ می‌دهند که مسائل محیطی، مانند از بین رفتن نمونه‌های <strong>service</strong> یا <strong>network time-outs</strong> استقرار ناموفق، باعث شکست <strong>tests</strong> ما می‌شوند، آماده باشیم.
  </p>
<p>
   این نیروها به این معنی است که با رشد معماری microservice شما، بازده سرمایه‌گذاری <em>(ROI)</em> کاهشی در مورد <strong>end-to-end testing</strong> دریافت خواهید کرد. <strong>Testing</strong> هزینه بیشتری خواهد داشت اما قادر نخواهد بود همان سطح اطمینان را که در گذشته داشت، به شما بدهد. این شما را به سمت اشکال جدیدی از <strong>testing</strong> سوق می‌دهد، مانند <strong>contract-driven testing</strong> یا <strong>testing in production</strong>، و همچنین بررسی تکنیک‌های <strong>progressive delivery</strong> مانند اجراهای موازی یا <strong>canary releases</strong>، که در فصل 8 به آنها خواهیم پرداخت.
  </p>
<h4>Latency</h4>
<p>
   با یک معماری microservice، پردازشی که قبلاً ممکن بود به صورت محلی بر روی یک پردازنده انجام شود، اکنون می‌تواند در چندین microservice جداگانه تقسیم شود. اطلاعاتی که قبلاً فقط در یک <strong>process</strong> واحد جریان داشت، اکنون باید <strong>serialized</strong>، منتقل و <strong>deserialized</strong> از طریق شبکه‌هایی شوند که ممکن است بیشتر از همیشه از آنها استفاده کنید. همه اینها می‌تواند منجر به بدتر شدن <strong>latency</strong> سیستم شما شود.
  </p>
<p>
   اگرچه اندازه‌گیری تأثیر دقیق بر <strong>latency</strong> عملیات در مرحله طراحی یا کدنویسی می‌تواند دشوار باشد، این یکی دیگر از دلایلی است که انجام هر گونه مهاجرت microservice به روشی افزایشی مهم است. یک تغییر کوچک ایجاد کنید و سپس تأثیر آن را اندازه‌گیری کنید. این فرض می‌کند که شما به نوعی اندازه‌گیری <strong>end-to-end latency</strong> برای عملیاتی که به آنها اهمیت می‌دهید دارید—ابزارهای <strong>distributed tracing</strong> مانند <strong>Jaeger</strong> می‌توانند در اینجا کمک کنند. اما شما همچنین باید درک کنید که <strong>latency</strong> چیست
  </p>
<p>30 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0056</div>
            </div>
        </div>
        <!-- Page 0057 -->
        <div class="chapter" id="page-0057">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   قابل قبول است. گاهی اوقات کندتر کردن یک <strong>operation</strong> کاملاً قابل قبول است، تا زمانی که هنوز به اندازه کافی سریع باشد!
  </p>
<h4>ثبات داده‌ها</h4>
<p>
   تغییر از یک سیستم <strong>monolithic</strong>، که در آن داده‌ها در یک پایگاه داده واحد ذخیره و مدیریت می‌شوند، به یک سیستم بسیار توزیع‌شده‌تر، که در آن فرآیندهای متعدد، <strong>state</strong> را در پایگاه‌های داده مختلف مدیریت می‌کنند، باعث ایجاد چالش‌های احتمالی در رابطه با ثبات داده‌ها می‌شود. در حالی که در گذشته ممکن است به <strong>database transactions</strong> برای مدیریت تغییرات <strong>state</strong> متکی بوده‌اید، باید درک کنید که ایمنی مشابه را نمی‌توان به راحتی در یک سیستم توزیع‌شده ارائه کرد. استفاده از تراکنش‌های توزیع‌شده در اکثر موارد بسیار مشکل‌ساز است در هماهنگی تغییرات <strong>state</strong>.
  </p>
<p>
   در عوض، شما ممکن است نیاز داشته باشید که از مفاهیمی مانند <strong>sagas</strong> (چیزی که من با جزئیات در فصل 6 توضیح خواهم داد) و <strong>eventual consistency</strong> برای مدیریت و استدلال در مورد <strong>state</strong> در سیستم خود استفاده کنید. این ایده‌ها می‌توانند تغییرات اساسی در نحوه تفکر شما در مورد داده‌ها در سیستم‌هایتان را ایجاب کنند، چیزی که هنگام مهاجرت سیستم‌های موجود می‌تواند بسیار دلهره‌آور باشد. باز هم، این دلیل دیگری است که باید در مورد سرعت تجزیه برنامه خود محتاط باشید. اتخاذ یک رویکرد افزایشی برای تجزیه، به طوری که شما قادر به ارزیابی تأثیر تغییرات در معماری خود در <strong>production</strong> باشید، واقعاً مهم است.
  </p>
<h4>آیا باید از Microservices استفاده کنم؟</h4>
<p>
   علیرغم تمایل در برخی محافل برای تبدیل معماری‌های microservice به رویکرد پیش‌فرض برای نرم‌افزار، من احساس می‌کنم که به دلیل چالش‌های متعددی که بیان کردم، پذیرش آنها همچنان نیاز به تفکر دقیق دارد. شما باید فضای مشکل، مهارت‌ها و چشم‌انداز فناوری خود را ارزیابی کنید و قبل از تصمیم‌گیری در مورد اینکه آیا microservices برای شما مناسب هستند یا خیر، بفهمید که چه چیزی را می‌خواهید به دست آورید. آنها یک رویکرد معماری هستند، نه رویکرد معماری. متن خود شما باید نقش مهمی در تصمیم شما برای رفتن به آن مسیر داشته باشد.
  </p>
<p>
   با این حال، من می‌خواهم چند موقعیت را شرح دهم که معمولاً من را از انتخاب microservices دور می‌کند—یا به سمت آن سوق می‌دهد.
  </p>
<h4>برای چه کسانی ممکن است کارساز نباشد</h4>
<p>
   با توجه به اهمیت تعریف <strong>service boundaries</strong> پایدار، من احساس می‌کنم که معماری‌های microservice اغلب انتخاب بدی برای محصولات یا استارتاپ‌های کاملاً جدید هستند. در هر دو مورد، <strong>domain</strong> که شما با آن کار می‌کنید، معمولاً در حال تغییرات اساسی است، زیرا شما در حال تکرار در اصول اولیه چیزی هستید که می‌خواهید بسازید. این تغییر در مدل‌های <strong>domain</strong>، به نوبه خود، منجر به ایجاد تغییرات بیشتر در <strong>service bound-</strong>
</p>
<p>Should I Use Microservices? | 31</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0057</div>
            </div>
        </div>
        <!-- Page 0058 -->
        <div class="chapter" id="page-0058">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<strong>undertaking</strong>. به طور کلی، من احساس می‌کنم که بهتر است صبر کنید تا مدل <strong>domain</strong> به اندازه کافی تثبیت شود قبل از اینکه به دنبال تعریف <strong>service boundaries</strong> باشید.
  </p>
<p>
   من وسوسه‌ای را برای استارتاپ‌ها می‌بینم که ابتدا به سراغ microservice می‌روند، استدلال این است که "اگر واقعاً موفق شویم، باید مقیاس‌پذیری کنیم!" مشکل این است که شما لزوماً نمی‌دانید که آیا کسی می‌خواهد از محصول جدید شما استفاده کند یا خیر. و حتی اگر به اندازه کافی موفق شوید که به یک معماری مقیاس‌پذیر نیاز داشته باشید، چیزی که در نهایت به کاربران خود ارائه می‌دهید ممکن است بسیار متفاوت از چیزی باشد که در ابتدا شروع به ساختن آن کرده‌اید. <strong>Uber</strong> در ابتدا بر لیموزین‌ها تمرکز داشت، و <strong>Flickr</strong> از تلاش برای ایجاد یک بازی آنلاین چند نفره بیرون آمد. فرآیند یافتن تناسب محصول با بازار به این معنی است که ممکن است در پایان با یک محصول بسیار متفاوت از آنچه فکر می‌کردید هنگام شروع کار بسازید، به پایان برسید.
  </p>
<p>
   استارتاپ‌ها معمولاً افراد کمتری برای ساخت سیستم در دسترس دارند، که چالش‌های بیشتری را در رابطه با microservices ایجاد می‌کند. Microservices منابعی از کار و پیچیدگی جدید را به همراه دارند، و این می‌تواند پهنای باند ارزشمند را به خود اختصاص دهد. هر چه تیم کوچک‌تر باشد، این هزینه برجسته‌تر خواهد بود. وقتی با تیم‌های کوچک‌تر با تعداد انگشت شماری توسعه‌دهنده کار می‌کنید، من به همین دلیل بسیار در پیشنهاد microservices تردید دارم.
  </p>
<p>
   چالش microservices برای استارتاپ‌ها با این واقعیت تشدید می‌شود که معمولاً بزرگترین محدودیت شما افراد هستند. برای یک تیم کوچک، معماری microservice می‌تواند توجیه آن دشوار باشد زیرا کاری لازم است فقط برای رسیدگی به استقرار و مدیریت خود microservices. برخی از افراد این را "مالیات microservice" توصیف کرده‌اند. وقتی آن سرمایه‌گذاری به نفع افراد زیادی باشد، توجیه آن آسان‌تر است. اما اگر یک نفر از تیم پنج نفره شما وقت خود را صرف این مسائل کند، این زمان ارزشمندی است که صرف ساختن محصول شما نمی‌شود. حرکت به سمت microservices در آینده، پس از اینکه متوجه شدید محدودیت‌ها در معماری شما کجا هستند و نقاط درد شما چیستند، بسیار آسان‌تر است—سپس می‌توانید انرژی خود را بر استفاده از microservices در مناسب‌ترین مکان‌ها متمرکز کنید.
  </p>
<p>
   در نهایت، سازمان‌هایی که نرم‌افزاری را ایجاد می‌کنند که توسط مشتریانشان مستقر و مدیریت می‌شود، ممکن است با microservices دست و پنجه نرم کنند. همانطور که قبلاً پوشش دادیم، معماری‌های microservice می‌توانند پیچیدگی زیادی را به <strong>domain</strong> استقرار و عملیاتی وارد کنند. اگر شما خودتان نرم‌افزار را اجرا می‌کنید، می‌توانید با اتخاذ فناوری جدید، توسعه مهارت‌های جدید و تغییر شیوه‌های کاری، این پیچیدگی جدید را جبران کنید. این چیزی نیست که شما انتظار داشته باشید مشتریانتان انجام دهند. اگر آنها عادت دارند که نرم‌افزار شما را به عنوان یک <strong>Windows installer</strong> دریافت کنند، وقتی نسخه بعدی نرم‌افزار خود را ارسال می‌کنید و می‌گویید، "فقط این 20 <strong>pod</strong> را روی <strong>Kubernetes cluster</strong> خود قرار دهید!" یک شوک وحشتناک خواهد بود. به احتمال زیاد، آنها نمی‌دانند <strong>pod</strong>، <strong>Kubernetes</strong> یا <strong>cluster</strong> چیست.
  </p>
<p>32 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0058</div>
            </div>
        </div>
        <!-- Page 0059 -->
        <div class="chapter" id="page-0059">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>کجاها خوب کار می‌کنند</h4>
<p>
   به تجربه من، شاید بزرگترین دلیل اینکه سازمان‌ها microservices را اتخاذ می‌کنند این است که به توسعه‌دهندگان بیشتری اجازه می‌دهند تا روی یک سیستم واحد کار کنند بدون اینکه مزاحم کار یکدیگر شوند. معماری و <strong>organizational boundaries</strong> خود را درست انجام دهید، و به افراد بیشتری اجازه می‌دهید که به طور مستقل از یکدیگر کار کنند، و <strong>delivery contention</strong> را کاهش دهید. یک استارتاپ پنج نفره احتمالاً معماری microservice را یک مانع خواهد یافت. مقیاس‌بندی صد نفره که به سرعت در حال رشد است، احتمالاً متوجه خواهد شد که رشد آن با معماری microservice که به درستی در اطراف تلاش‌های توسعه محصول آن قرار گرفته است، بسیار آسان‌تر است.
  </p>
<p>
   برنامه‌های <strong>Software as a Service (SaaS)</strong>، به طور کلی، نیز برای یک معماری microservice مناسب هستند. انتظار می‌رود این محصولات معمولاً 24 ساعته و 7 روز هفته کار کنند، که هنگام ارائه تغییرات، چالش‌هایی را ایجاد می‌کند. استقلال انتشار معماری‌های microservice یک مزیت بزرگ در این زمینه است. علاوه بر این، microservices را می‌توان در صورت نیاز مقیاس‌بندی کرد. این بدان معنی است که با ایجاد یک خط پایه منطقی برای ویژگی‌های بار سیستم خود، کنترل بیشتری بر اطمینان از مقیاس‌بندی سیستم خود به مقرون‌به‌صرفه‌ترین روش ممکن، به دست می‌آورید.
  </p>
<p>
   ماهیت <strong>technology-agnostic</strong> microservices تضمین می‌کند که شما می‌توانید بیشترین بهره را از پلتفرم‌های <strong>cloud</strong> ببرید. فروشندگان <strong>public cloud</strong> طیف گسترده‌ای از <strong>services</strong> و مکانیسم‌های استقرار را برای کد شما ارائه می‌دهند. شما می‌توانید بسیار آسان‌تر نیازهای <strong>services</strong> خاص را با <strong>cloud services</strong> که به شما در پیاده‌سازی آنها کمک می‌کنند، مطابقت دهید. به عنوان مثال، ممکن است تصمیم بگیرید که یک <strong>service</strong> را به عنوان مجموعه‌ای از توابع، دیگری را به عنوان یک ماشین مجازی <strong>(VM)</strong> مدیریت شده، و دیگری را بر روی یک پلتفرم <strong>Platform as a Service (PaaS)</strong> مدیریت شده مستقر کنید.
  </p>
<p>
   اگرچه شایان ذکر است که اتخاذ طیف گسترده‌ای از فناوری اغلب می‌تواند یک مشکل باشد، اما توانایی امتحان کردن فناوری جدید به راحتی، راهی خوب برای شناسایی سریع رویکردهای جدید است که ممکن است مزایایی داشته باشند. محبوبیت فزاینده پلتفرم‌های <strong>FaaS</strong> یک نمونه از این است. برای <strong>workloads</strong> مناسب، یک پلتفرم <strong>FaaS</strong> می‌تواند مقدار سربار عملیاتی را به شدت کاهش دهد، اما در حال حاضر، این یک مکانیسم استقراری نیست که در همه موارد مناسب باشد.
  </p>
<p>
   Microservices همچنین مزایای روشنی را برای سازمان‌هایی که به دنبال ارائه <strong>services</strong> به مشتریان خود از طریق انواع کانال‌های جدید هستند، ارائه می‌دهند. به نظر می‌رسد بسیاری از تلاش‌های <strong>digital transformation</strong> شامل تلاش برای باز کردن قفل <strong>functionality</strong> پنهان شده در سیستم‌های موجود است. تمایل این است که تجربیات مشتری جدیدی ایجاد شود که بتواند نیازهای کاربران را از طریق هر مکانیسم تعاملی که منطقی‌ترین است، پشتیبانی کند.
  </p>
<p>
   بیش از همه، یک معماری microservice معماری است که می‌تواند انعطاف‌پذیری زیادی را در حین تکامل سیستم خود به شما ارائه دهد. این انعطاف‌پذیری البته هزینه‌ای دارد، اما اگر می‌خواهید گزینه‌های خود را در رابطه با تغییراتی که ممکن است بخواهید در آینده ایجاد کنید، باز نگه دارید، ممکن است هزینه‌ای باشد که ارزش پرداختن داشته باشد.
  </p>
<p>Should I Use Microservices? | 33</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0059</div>
            </div>
        </div>
        <!-- Page 0060 -->
        <div class="chapter" id="page-0060">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>خلاصه</h4>
<p>
   معماری‌های microservice می‌توانند انعطاف‌پذیری زیادی در انتخاب فناوری، رسیدگی به استحکام و مقیاس‌بندی، سازماندهی تیم‌ها و موارد دیگر به شما بدهند. این انعطاف‌پذیری تا حدی دلیل پذیرش معماری‌های microservice توسط بسیاری از افراد است. اما microservices درجه قابل توجهی از پیچیدگی را به همراه دارند، و شما باید اطمینان حاصل کنید که این پیچیدگی موجه است. برای بسیاری، آنها به یک معماری سیستم پیش‌فرض تبدیل شده‌اند که تقریباً در همه موقعیت‌ها استفاده می‌شود. با این حال، من هنوز فکر می‌کنم که آنها یک انتخاب معماری هستند که استفاده از آنها باید با مشکلاتی که شما در تلاش برای حل آنها هستید توجیه شود. اغلب، رویکردهای ساده‌تر می‌توانند بسیار آسان‌تر ارائه شوند.
  </p>
<p>
   با این وجود، بسیاری از سازمان‌ها، به‌ویژه سازمان‌های بزرگ‌تر، نشان داده‌اند که microservices تا چه حد می‌توانند مؤثر باشند. هنگامی که مفاهیم اصلی microservices به درستی درک و پیاده‌سازی شوند، می‌توانند به ایجاد معماری‌های توانمند و مولد کمک کنند که می‌تواند به سیستم‌ها کمک کند تا چیزی بیش از مجموع اجزای خود شوند.
  </p>
<p>
   امیدوارم این فصل به عنوان یک مقدمه خوب برای این موضوعات عمل کرده باشد. در مرحله بعد، ما قصد داریم به چگونگی تعریف <strong>microservice boundaries</strong> بپردازیم و در طول مسیر، موضوعات برنامه‌نویسی ساخت‌یافته و <strong>domain-driven design</strong> را بررسی کنیم.
  </p>
<p>34 | Chapter 1: What Are Microservices?</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0060</div>
            </div>
        </div>
        <!-- Page 0061 -->
        <div class="chapter" id="page-0061">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>CHAPTER 2</h3>
<h4>چگونه Microservices را مدل‌سازی کنیم</h4>
<p>
   استدلال حریف من مرا به یاد بت‌پرست می‌اندازد که وقتی از او پرسیدند جهان بر چه استوار است، پاسخ داد: «روی یک لاک‌پشت». اما لاک‌پشت روی چه چیزی ایستاده است؟ «روی یک لاک‌پشت دیگر».
   —Rev. Joseph Frederick Berg (1854)
  </p>
<p>
   بنابراین شما می‌دانید microservices چیستند و، امیدوارم، حس مزایای کلیدی آنها را درک کرده‌اید. شما احتمالاً اکنون مشتاق هستید که بروید و شروع به ساختن آنها کنید، درست است؟ اما از کجا شروع کنیم؟ در این فصل، ما به برخی از مفاهیم بنیادی مانند <strong>information hiding</strong>، <em>coupling</em> و <em>cohesion</em> نگاهی می‌اندازیم و درک می‌کنیم که چگونه آنها تفکر ما را در مورد ترسیم <strong>boundaries</strong> در اطراف microservicesهایمان تغییر می‌دهند. ما همچنین به اشکال مختلف تجزیه نگاهی می‌اندازیم که ممکن است از آنها استفاده کنید، و همچنین بیشتر بر <strong>domain-driven design</strong> به عنوان یک تکنیک بسیار مفید در این فضا تمرکز می‌کنیم.
  </p>
<p>
   ما به این موضوع خواهیم پرداخت که چگونه در مورد <strong>boundaries</strong> microservices خود فکر کنیم تا مزایا را به حداکثر برسانیم و از برخی از معایب احتمالی اجتناب کنیم. اما ابتدا، ما به چیزی نیاز داریم که با آن کار کنیم.
  </p>
<h4>معرفی MusicCorp</h4>
<p>
   کتاب‌ها در مورد ایده‌ها با مثال‌ها بهتر عمل می‌کنند. در صورت امکان، من داستان‌هایی را از موقعیت‌های دنیای واقعی به اشتراک خواهم گذاشت، اما من متوجه شده‌ام که داشتن یک سناریوی داستانی برای کار نیز مفید است. در سراسر کتاب، ما به این سناریو باز خواهیم گشت و خواهیم دید که چگونه مفهوم microservices در این جهان عمل می‌کند.
  </p>
<p>
   بنابراین اجازه دهید توجه خود را به خرده‌فروش آنلاین پیشرفته MusicCorp معطوف کنیم. <strong>MusicCorp</strong> تا همین اواخر فقط یک خرده‌فروش آجری و ملاتی بود، اما پس از اینکه تجارت صفحات وینیل سقوط کرد، بیشتر و بیشتر تلاش‌های خود را بر روی اینترنت متمرکز کرد. این شرکت یک وب‌سایت دارد اما احساس می‌کند که اکنون زمان آن است که در دنیای آنلاین سرمایه‌گذاری کند.
  </p>
<p>
   به هر حال، آن گوشی‌های هوشمند برای موسیقی فقط یک مد زودگذر هستند <em>(Zunes</em> قطعاً بهتر هستند)، و طرفداران موسیقی کاملاً خوشحال هستند که منتظر رسیدن سی‌دی‌ها به خانه‌هایشان باشند.
  </p>
<p>35</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0061</div>
            </div>
        </div>
        <!-- Page 0062 -->
        <div class="chapter" id="page-0062">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   1 David, Parnas, “On the Criteria to Be Used in Decomposing Systems into Modules,” (journal contribution,
   Carnegie Mellon University, 1971), https://oreil.ly/BnVVg.
  </p>
<p>
   آستانه‌های درب منزل خود. کیفیت بالاتر از راحتی، درست است؟ و در حالی که ممکن است تازه متوجه شده باشد که <strong>Spotify</strong> در واقع یک سرویس موسیقی دیجیتال است تا نوعی درمان پوستی برای نوجوانان، <strong>MusicCorp</strong> از تمرکز خود بسیار خوشحال است و مطمئن است که این کسب و کار <strong>streaming</strong> به زودی تمام می‌شود.
  </p>
<p>
   علیرغم عقب افتادن کمی، <strong>MusicCorp</strong> جاه‌طلبی‌های بزرگی دارد. خوشبختانه، تصمیم گرفته است که بهترین شانس خود برای تسخیر جهان این است که اطمینان حاصل کند که می‌تواند تغییرات را تا حد امکان آسان کند. Microservices برای پیروزی!
  </p>
<h4>چه چیزی یک <strong>Microservice Boundary</strong> خوب را می‌سازد؟</h4>
<p>
   قبل از اینکه تیم <strong>MusicCorp</strong> به مسافت دور شود، و <strong>service</strong> پس از <strong>service</strong> را ایجاد کند در تلاش برای ارائه نوارهای هشت‌تراک به همه و غیره، اجازه دهید ترمزها را اعمال کنیم و کمی در مورد مهم‌ترین ایده اساسی که باید در نظر داشته باشیم صحبت کنیم.
  </p>
<p>
   ما می‌خواهیم microservicesهایمان بتوانند تغییر و مستقر شوند، و <strong>functionality</strong> آنها به طور مستقل برای کاربران ما منتشر شود. توانایی تغییر یک microservice به طور جداگانه از دیگری حیاتی است. بنابراین چه چیزهایی را باید در نظر داشته باشیم وقتی در مورد نحوه ترسیم <strong>boundaries</strong> در اطراف آنها فکر می‌کنیم؟
  </p>
<p>
   در اصل، microservices فقط شکل دیگری از تجزیه ماژولار هستند، اگرچه یکی از اینها تعامل مبتنی بر شبکه بین مدل‌ها و تمام چالش‌های مرتبط با آن را به همراه دارد. خوشبختانه، این بدان معنی است که ما می‌توانیم به هنر زیادی از قبل در فضای نرم‌افزار ماژولار و برنامه‌نویسی ساختاریافته تکیه کنیم تا به ما در مورد نحوه تعریف <strong>boundaries</strong> کمک کند. با در نظر گرفتن این موضوع، بیایید با دقت بیشتری به سه مفهوم کلیدی که ما به طور خلاصه در فصل 1 به آنها اشاره کردیم و برای درک این موضوع که چه چیزی باعث ایجاد یک <strong>microservice boundary</strong> خوب می‌شود، نگاهی بیندازیم—<strong>information hiding</strong>، <em>cohesion</em> و <em>coupling</em>.
  </p>
<h4>Information Hiding</h4>
<p>
<strong>Information hiding</strong> مفهومی است که توسط David Parnas برای بررسی مؤثرترین راه برای تعریف <strong>module boundaries</strong> ایجاد شده است. 1 <strong>Information hiding</strong> یک تمایل برای پنهان کردن تا حد امکان جزئیات در پشت یک <strong>module</strong> (یا، در مورد ما، microservice) <strong>boundary</strong> را توصیف می‌کند.
   <strong>Parnas</strong> به مزایایی که <strong>modules</strong> به طور تئوری باید به ما بدهند، نگاه کرد، یعنی:
  </p>
<ul>
<li>بهبود زمان توسعه</li>
</ul>
<p>
   با اجازه دادن به توسعه ماژول‌ها به طور مستقل، می‌توانیم به کارهای بیشتری اجازه دهیم تا به صورت موازی انجام شوند و تأثیر افزودن توسعه‌دهندگان بیشتر به یک پروژه را کاهش دهیم.
  </p>
<p>36 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0062</div>
            </div>
        </div>
        <!-- Page 0063 -->
        <div class="chapter" id="page-0063">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   2 نقطه شروع آشکار، خلاصه <strong>Adrian</strong> از “On the Criteria…” است، اما پوشش <strong>Adrian</strong> از کار قبلی <strong>Parnas</strong>، “Information Distribution Aspects of Design Methodology”، حاوی بینش‌های عالی به همراه نظرات خود <strong>Parnas</strong> است.
  </p>
<p>
   3 Parnas, “Information Distribution Aspects.”
  </p>
<h4>قابلیت فهم</h4>
<p>
   هر <strong>module</strong> را می‌توان به طور جداگانه بررسی و درک کرد. این به نوبه خود درک آنچه که سیستم به عنوان یک کل انجام می‌دهد را آسان‌تر می‌کند.
  </p>
<h4>انعطاف‌پذیری</h4>
<p>
<strong>Modules</strong> را می‌توان به طور مستقل از یکدیگر تغییر داد، و اجازه می‌دهد تغییراتی در <strong>functionality</strong> سیستم ایجاد شود بدون اینکه نیاز به تغییر <strong>modules</strong> دیگر داشته باشد. علاوه بر این، <strong>modules</strong> را می‌توان به روش‌های مختلفی برای ارائه <strong>functionality</strong> جدید ترکیب کرد.
  </p>
<p>
   این فهرست از ویژگی‌های مطلوب به خوبی مکمل چیزی است که ما در تلاش برای دستیابی به آن با معماری‌های microservice هستیم—و در واقع من اکنون microservices را فقط یک شکل دیگر از معماری ماژولار می‌بینم. <strong>Adrian Colyer</strong> در واقع به تعدادی از مقالات David Parnas از این دوره بازگشته و آنها را با توجه به microservices بررسی کرده است، و خواندن خلاصه‌های او بسیار ارزشمند است.2
  </p>
<p>
   واقعیت، همانطور که <strong>Parnas</strong> در بیشتر کارهایش بررسی کرد، این است که داشتن <strong>modules</strong> منجر به دستیابی شما به این نتایج نمی‌شود. خیلی چیزها به نحوه شکل‌گیری <strong>module boundaries</strong> بستگی دارد. از تحقیقات خودش، <strong>information hiding</strong> یک تکنیک کلیدی برای کمک به به دست آوردن بیشترین بهره از معماری‌های ماژولار بود، و با یک چشم مدرن، همین امر در مورد microservices نیز صدق می‌کند.
  </p>
<p>
   از مقاله دیگری از <strong>Parnas</strong>،3 ما این گوهر را داریم:
  </p>
<p>
   اتصالات بین <strong>modules</strong>، مفروضاتی هستند که <strong>modules</strong> در مورد یکدیگر ایجاد می‌کنند.
  </p>
<p>
   با کاهش تعداد مفروضاتی که یک <strong>module</strong> (یا microservice) در مورد دیگری ایجاد می‌کند، ما مستقیماً بر اتصالات بین آنها تأثیر می‌گذاریم. با کوچک نگه داشتن تعداد مفروضات، اطمینان از اینکه می‌توانیم یک <strong>module</strong> را بدون تأثیر بر دیگران تغییر دهیم، آسان‌تر است. اگر توسعه‌دهنده‌ای که در حال تغییر یک <strong>module</strong> است، درک روشنی از نحوه استفاده <strong>module</strong> توسط دیگران داشته باشد، تغییرات را با خیال راحت به گونه‌ای انجام خواهد داد که تماس‌گیرندگان بالادستی نیز مجبور به تغییر نشوند.
  </p>
<p>
   این در مورد microservices نیز صدق می‌کند، با این تفاوت که ما این فرصت را نیز داریم که آن microservice تغییر یافته را بدون نیاز به استقرار چیز دیگری مستقر کنیم، که مسلماً سه ویژگی مطلوب را که <strong>Parnas</strong> از آنها در مورد بهبود زمان توسعه، قابلیت فهم، و انعطاف‌پذیری، توصیف می‌کند، تقویت می‌کند.
  </p>
<p>
   پیامدهای <strong>information hiding</strong> به روش‌های زیادی ظاهر می‌شوند، و من این موضوع را در سراسر کتاب ادامه خواهم داد.
  </p>
<p>What Makes a Good Microservice Boundary? | 37</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0063</div>
            </div>
        </div>
        <!-- Page 0064 -->
        <div class="chapter" id="page-0064">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   4 متأسفانه، من نمی‌توانم منبع اصلی این تعریف را پیدا کنم.
  </p>
<h4>Cohesion</h4>
<p>
   یکی از مختصرترین تعاریفی که برای توصیف <em>cohesion</em> شنیده‌ام این است: "کدی که با هم تغییر می‌کند، با هم می‌ماند." 4 برای اهداف ما، این یک تعریف بسیار خوب است. همانطور که قبلاً بحث کردیم، ما در حال بهینه‌سازی معماری microservice خود در مورد سهولت ایجاد تغییرات در <strong>business functionality</strong> هستیم—بنابراین ما می‌خواهیم <strong>functionality</strong> را به گونه‌ای گروه‌بندی کنیم که بتوانیم تغییرات را در کمترین مکان ممکن ایجاد کنیم.
  </p>
<p>
   ما می‌خواهیم رفتار مرتبط با هم قرار گیرد، و رفتار نامرتبط در جای دیگر قرار گیرد.
  </p>
<p>
   چرا؟ خب، اگر بخواهیم رفتار را تغییر دهیم، می‌خواهیم بتوانیم آن را در یک مکان تغییر دهیم، و آن تغییر را در اسرع وقت منتشر کنیم. اگر مجبور باشیم آن رفتار را در مکان‌های مختلف زیادی تغییر دهیم، باید <strong>services</strong> زیادی را (شاید همزمان) منتشر کنیم تا آن تغییر را ارائه دهیم. ایجاد تغییرات در مکان‌های مختلف زیاد کندتر است، و استقرار <strong>services</strong> زیاد به طور همزمان خطرناک است—بنابراین ما می‌خواهیم از هر دو اجتناب کنیم.
  </p>
<p>
   بنابراین ما می‌خواهیم <strong>boundaries</strong> را در <strong>problem domain</strong> خود پیدا کنیم که به اطمینان از وجود رفتار مرتبط در یک مکان کمک می‌کند و تا حد امکان آزادانه با <strong>boundaries</strong> دیگر ارتباط برقرار می‌کند. اگر <strong>functionality</strong> مرتبط در سراسر سیستم پخش شود، ما می‌گوییم که <em>cohesion</em> ضعیف است—در حالی که برای معماری‌های microservice خود، ما به دنبال <em>cohesion</em> قوی هستیم.
  </p>
<h4>Coupling</h4>
<p>
   هنگامی که <strong>services</strong> <em>loosely coupled</em> هستند، تغییری در یک <strong>service</strong> نباید نیازمند تغییری در <strong>service</strong> دیگر باشد. تمام نکته یک microservice این است که بتواند تغییری در یک <strong>service</strong> ایجاد کند و آن را بدون نیاز به تغییر هیچ بخش دیگری از سیستم مستقر کند.
   این واقعاً بسیار مهم است.
  </p>
<p>
   چه چیزهایی باعث <em>tight coupling</em> می‌شوند؟ یک اشتباه کلاسیک این است که یک سبک <strong>integration</strong> را انتخاب کنید که یک <strong>service</strong> را به <strong>service</strong> دیگری محکم متصل می‌کند، و باعث می‌شود که تغییرات داخل <strong>service</strong>، نیازمند تغییری در <strong>consumers</strong> شود.
  </p>
<p>
   یک <strong>service</strong> <em>loosely coupled</em> تا حد امکان در مورد <strong>services</strong> که با آنها همکاری می‌کند، کم می‌داند. این بدان معناست که ما احتمالاً می‌خواهیم تعداد انواع مختلف تماس‌ها از یک <strong>service</strong> به <strong>service</strong> دیگر را محدود کنیم، زیرا فراتر از مشکل عملکرد احتمالی، ارتباطات <strong>chatty</strong> می‌تواند منجر به <em>tight coupling</em> شود.
  </p>
<p>
   با این حال، <em>coupling</em> به اشکال مختلفی ظاهر می‌شود، و من تعدادی از سوء تفاهم‌ها را در مورد ماهیت <em>coupling</em> در رابطه با یک معماری مبتنی بر <strong>service</strong> دیده‌ام. با در نظر گرفتن این موضوع، من فکر می‌کنم مهم است که ما این موضوع را با جزئیات بیشتری بررسی کنیم، چیزی که به زودی انجام خواهیم داد.
  </p>
<p>38 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0064</div>
            </div>
        </div>
        <!-- Page 0065 -->
        <div class="chapter" id="page-0065">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   5 در کتاب من <em>Monolith to Microservices</em> (O’Reilly) من این موضوع را به خود لری کنستانتین نسبت دادم. در حالی که این عبارت به زیبایی بخش زیادی از کار کنستانتین را در این فضا خلاصه می‌کند، نقل قول در واقع باید به آلبرت اِندرس و دیتر رومباخ، از کتاب 2003 آنها <em>A Handbook of Software and Systems Engineering</em> (Addison-Wesley) نسبت داده شود.
  </p>
<h4>The Interplay of Coupling and Cohesion</h4>
<p>
   همانطور که قبلاً اشاره کردیم، مفاهیم <em>coupling</em> و <em>cohesion</em> بدیهی است که با هم مرتبط هستند. از نظر منطقی، اگر <strong>functionality</strong> مرتبط در سراسر سیستم ما گسترش یابد، تغییرات در این <strong>functionality</strong> در سراسر این <strong>boundaries</strong> موج می‌زند، که به معنای <em>coupling</em> تنگ‌تر است. قانون کنستانتین، که به نام پیشگام طراحی ساختاریافته لری کنستانتین نامگذاری شده است، این موضوع را به زیبایی جمع‌بندی می‌کند:
  </p>
<p>
   یک ساختار پایدار است اگر <em>cohesion</em> قوی و <em>coupling</em> کم باشد.5
  </p>
<p>
   مفهوم پایداری در اینجا برای ما مهم است. برای اینکه <strong>microservice boundaries</strong> ما به وعده استقرار مستقل عمل کند، و به ما اجازه دهد روی microservices به طور موازی کار کنیم و میزان هماهنگی بین تیم‌های فعال در این <strong>services</strong> را کاهش دهیم، ما به درجه‌ای از پایداری در خود <strong>boundaries</strong> نیاز داریم. اگر قراردادی که یک microservice در معرض نمایش قرار می‌دهد، دائماً به روشی که با عقب سازگار نیست در حال تغییر است، این باعث می‌شود که <strong>consumers</strong> بالادستی نیز دائماً مجبور به تغییر شوند.
  </p>
<p>
<em>Coupling</em> و <em>cohesion</em> به شدت با هم مرتبط هستند و، حداقل در سطحی، قابل بحث است که یکسان هستند، به این معنا که هر دو مفهوم رابطه بین چیزها را توصیف می‌کنند. <em>Cohesion</em> در رابطه با چیزهای داخل یک <strong>boundary</strong> (یک microservice در زمینه ما) اعمال می‌شود، در حالی که <em>coupling</em> رابطه بین چیزها را در یک <strong>boundary</strong> توصیف می‌کند. هیچ بهترین راه مطلق برای سازماندهی کد ما وجود ندارد. <em>Coupling</em> و <em>cohesion</em> فقط یک راه برای بیان مبادله‌های مختلفی هستند که ما در مورد جایی که کد را گروه‌بندی می‌کنیم، و چرا، انجام می‌دهیم. تمام کاری که می‌توانیم انجام دهیم این است که تعادل درستی بین این دو ایده پیدا کنیم، ایده‌ای که بیشترین معنی را برای زمینه داده شده شما و مشکلاتی که در حال حاضر با آنها مواجه هستید، دارد.
  </p>
<p>
   به یاد داشته باشید، جهان ثابت نیست—این امکان وجود دارد که با تغییر الزامات سیستم شما، دلایلی برای بازبینی تصمیمات خود پیدا کنید. گاهی اوقات بخش‌هایی از سیستم شما ممکن است تغییرات زیادی را تجربه کنند که پایداری ممکن است غیرممکن باشد. ما در فصل 3 به مثالی از این موضوع نگاه خواهیم کرد، زمانی که من تجربیات تیم توسعه محصول پشت <strong>Snap CI</strong> را به اشتراک می‌گذارم.
  </p>
<h4>انواع Coupling</h4>
<p>
   شما می‌توانید از مرور کلی بالا استنباط کنید که همه <em>coupling</em> بد است. این کاملاً درست نیست. در نهایت، مقداری <em>coupling</em> در سیستم ما اجتناب‌ناپذیر خواهد بود. کاری که ما می‌خواهیم انجام دهیم این است که میزان <em>coupling</em> را که داریم کاهش دهیم.
  </p>
<p>Types of Coupling | 39</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0065</div>
            </div>
        </div>
        <!-- Page 0066 -->
        <div class="chapter" id="page-0066">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   6 Edward Yourdon and Larry L. Constantine, Structured Design (New York: Yourdon Press, 1976).
  </p>
<p>
   7 Meilir Page-Jones, The Practical Guide to Structured Systems Design (New York: Yourdon Press Computing,
   1980).
  </p>
<p>
   کارهای زیادی برای بررسی اشکال مختلف <em>coupling</em> در زمینه برنامه‌نویسی ساخت‌یافته انجام شده است، که تا حد زیادی نرم‌افزار ماژولار (غیرتوزیع‌شده، <strong>monolithic</strong>) را در نظر می‌گرفت. بسیاری از این مدل‌های مختلف برای ارزیابی <em>coupling</em> همپوشانی یا برخورد دارند، و در هر صورت آنها عمدتاً در مورد چیزهایی در سطح کد صحبت می‌کنند، نه اینکه تعاملات مبتنی بر <strong>service</strong> را در نظر بگیرند. از آنجایی که microservices یک سبک از معماری ماژولار هستند (اگرچه با پیچیدگی افزوده سیستم‌های توزیع‌شده)، ما می‌توانیم از بسیاری از این مفاهیم اصلی استفاده کنیم و آنها را در زمینه سیستم‌های مبتنی بر microservice خود اعمال کنیم.
  </p>
<h4>Prior Art در برنامه‌نویسی ساخت‌یافته</h4>
<p>
   بسیاری از کارهای ما در محاسبات شامل ساختن بر روی کارهایی است که قبلاً انجام شده است. گاهی اوقات تشخیص همه چیزهایی که قبلاً آمده است غیرممکن است، اما با این ویرایش دوم من قصد داشتم <strong>prior art</strong> را در جایی که می‌توانم برجسته کنم—تا حدی برای دادن اعتبار در جایی که اعتبار لازم است، تا حدی به عنوان راهی برای اطمینان از اینکه من چند خرده نان برای خوانندگانی که می‌خواهند موضوعات خاصی را با جزئیات بیشتری بررسی کنند، قرار می‌دهم، اما همچنین برای نشان دادن اینکه بسیاری از این ایده‌ها امتحان شده و آزمایش شده‌اند.
  </p>
<p>
   وقتی صحبت از ساختن روی کارهایی می‌شود که قبلاً انجام شده است، در این کتاب چند حوزه موضوعی وجود دارد که به اندازه برنامه‌نویسی ساخت‌یافته، <strong>prior art</strong> نداشته باشند. من قبلاً از لری کنستانتین نام برده‌ام. کتاب او با ادوارد یورون، <em>Structured Design</em>،6 یکی از مهم‌ترین متون در این زمینه محسوب می‌شود. <em>The Practical Guide to Structured Systems Design</em> نوشته میلیلر پیج-جونز7 نیز مفید است. متأسفانه، یک چیز که این کتاب‌ها در آن مشترک هستند این است که چقدر سخت می‌توان آنها را تهیه کرد، زیرا آنها دیگر چاپ نمی‌شوند و در قالب کتاب الکترونیکی در دسترس نیستند. دلیل دیگری برای حمایت از کتابخانه محلی شما!
  </p>
<p>
   همه ایده‌ها به طور مرتب نگاشت نمی‌شوند، بنابراین من تمام تلاش خود را کرده‌ام تا یک مدل کاری را برای انواع مختلف <em>coupling</em> برای microservices ترکیب کنم. جایی که این ایده‌ها به تعاریف قبلی به خوبی نگاشت می‌شوند، من با آن اصطلاحات باقی مانده‌ام. در جاهای دیگر مجبور شدم اصطلاحات جدیدی را ابداع کنم یا ایده‌هایی را از جای دیگری ترکیب کنم. بنابراین لطفاً آنچه را که در ادامه می‌آید، بر اساس <strong>prior art</strong> زیادی در این فضا در نظر بگیرید، که من در تلاش هستم تا در زمینه microservices معنای بیشتری به آن ببخشم.
  </p>
<p>
   در شکل 2-1 ما یک نمای کلی مختصر از انواع مختلف <em>coupling</em> را مشاهده می‌کنیم که از کم (مطلوب) به زیاد (نامطلوب) سازماندهی شده است.
  </p>
<p>
   در مرحله بعد، ما هر شکل از <em>coupling</em> را به نوبه خود بررسی خواهیم کرد، و به مثال‌هایی نگاه می‌کنیم که نشان می‌دهند این اشکال چگونه می‌توانند در معماری microservice ما تجلی پیدا کنند.
  </p>
<p>40 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0066</div>
            </div>
        </div>
        <!-- Page 0067 -->
        <div class="chapter" id="page-0067">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   8 این مفهوم مشابه <strong>domain application protocol</strong> است، که قوانینی را تعریف می‌کند که اجزا بر اساس آن در یک سیستم مبتنی بر <strong>REST</strong> تعامل دارند.
  </p>
<p>
   شکل 2-1. انواع مختلف <em>coupling</em>، از <em>loose</em> (کم) تا <em>tight</em> (زیاد)
  </p>
<h4>Domain Coupling</h4>
<p>
<strong>Domain coupling</strong> موقعیتی را توصیف می‌کند که در آن یک microservice نیاز به تعامل با microservice دیگری دارد، زیرا microservice اول باید از <strong>functionality</strong> که microservice دیگر ارائه می‌دهد استفاده کند.8
  </p>
<p>
   در شکل 2-2، ما بخشی از نحوه مدیریت سفارشات سی‌دی در داخل <strong>MusicCorp</strong> را می‌بینیم. در این مثال، <strong>Order Processor</strong> برای رزرو موجودی، <strong>Warehouse microservice</strong> را فراخوانی می‌کند و <strong>Payment microservice</strong> را برای دریافت پرداخت فراخوانی می‌کند. بنابراین <strong>Order Processor</strong> به microservicesهای <strong>Warehouse</strong> و <strong>Payment</strong> برای این عملیات وابسته است و به آنها <em>coupled</em> است. اگرچه ما چنین <em>coupling</em> را بین <strong>Warehouse</strong> و <strong>Payment</strong> مشاهده نمی‌کنیم، زیرا آنها با هم تعامل ندارند.
  </p>
<p>
   شکل 2-2. مثالی از <strong>domain coupling</strong>، جایی که <strong>Order Processor</strong> باید از <strong>functionality</strong> ارائه شده توسط microservicesهای دیگر استفاده کند.
  </p>
<p>Types of Coupling | 41</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 67" src="page_0067/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 67" src="page_0067/image_2.png"/></div>
</div>
                <div class="page-number">صفحه 0067</div>
            </div>
        </div>
        <!-- Page 0068 -->
        <div class="chapter" id="page-0068">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   در یک معماری microservice، این نوع تعامل تا حد زیادی اجتناب‌ناپذیر است. یک سیستم مبتنی بر microservice برای انجام کار خود به microservices متعدد متکی است که با هم همکاری می‌کنند. با این حال، ما هنوز می‌خواهیم این را به حداقل برسانیم. اگر می‌بینید که یک microservice واحد به چندین <strong>downstream services</strong> به این روش وابسته است، می‌تواند مایه نگرانی باشد—ممکن است به معنای یک microservice باشد که کار زیادی انجام می‌دهد.
  </p>
<p>
   به عنوان یک قانون کلی، <strong>domain coupling</strong> یک شکل <em>loose</em> از <em>coupling</em> در نظر گرفته می‌شود، اگرچه حتی در اینجا می‌توانیم به مشکلات برخورد کنیم. یک microservice که نیاز به صحبت با تعداد زیادی از microservicesهای <strong>downstream</strong> دارد، ممکن است به موقعیتی اشاره داشته باشد که در آن منطق بیش از حد متمرکز شده است. <strong>Domain coupling</strong> همچنین می‌تواند با ارسال مجموعه‌های پیچیده‌تری از داده‌ها بین <strong>services</strong>، مشکل‌ساز شود—این اغلب می‌تواند به اشکال <em>coupling</em> مشکل‌سازتر که به زودی بررسی خواهیم کرد، اشاره داشته باشد.
  </p>
<p>
   فقط اهمیت <strong>information hiding</strong> را به خاطر بسپارید. فقط آنچه را که مطلقاً باید به اشتراک بگذارید، به اشتراک بگذارید، و فقط حداقل مقدار داده‌ای را که نیاز دارید، ارسال کنید.
  </p>
<h4>یک یادداشت کوتاه در مورد Temporal Coupling</h4>
<p>
   شکل دیگری از <em>coupling</em> که ممکن است شنیده باشید، <strong>temporal coupling</strong> است. از یک دیدگاه کد محور از <em>coupling</em>، <strong>temporal coupling</strong> به موقعیتی اشاره دارد که در آن مفاهیم صرفاً به این دلیل که همزمان اتفاق می‌افتند، با هم جمع می‌شوند. <strong>Temporal coupling</strong> معنایی ظریفاً متفاوت در زمینه یک سیستم توزیع‌شده دارد، که در آن به موقعیتی اشاره دارد که در آن یک microservice نیاز دارد که microservice دیگری همزمان کاری را انجام دهد تا عملیات تکمیل شود.
  </p>
<p>
   هر دو microservices برای برقراری ارتباط با یکدیگر، باید همزمان در دسترس و در دسترس باشند تا عملیات تکمیل شود. بنابراین در شکل 2-3، جایی که <strong>Order Processor MusicCorp</strong> یک فراخوانی <strong>HTTP</strong> همزمان به <strong>Warehouse service</strong> انجام می‌دهد، <strong>Ware house</strong> باید در همان زمان که فراخوانی انجام می‌شود، بالا و در دسترس باشد.
  </p>
<p>
   شکل 2-3. مثالی از <strong>temporal coupling</strong>، که در آن <strong>Order Processor</strong> یک فراخوانی <strong>HTTP</strong> همزمان به <strong>Warehouse microservice</strong> انجام می‌دهد.
  </p>
<p>
   اگر به دلایلی <strong>Warehouse</strong> در دسترس <strong>Order Processor</strong> نباشد، آنگاه عملیات شکست می‌خورد، زیرا ما نمی‌توانیم سی‌دی‌ها را برای ارسال رزرو کنیم. <strong>Order Processor</strong> همچنین باید مسدود شود و منتظر پاسخ از <strong>Warehouse</strong> باشد، که به طور بالقوه باعث ایجاد مشکلاتی از نظر <strong>resource contention</strong> می‌شود.
  </p>
<p>42 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 68" src="page_0068/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0068</div>
            </div>
        </div>
        <!-- Page 0069 -->
        <div class="chapter" id="page-0069">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   9 <strong>Pass-through coupling</strong> نام من برای چیزی است که در اصل توسط <strong>Meilir Page-Jones</strong> در <em>The Practical Guide to Structured Systems Design</em> به عنوان "tramp coupling" توصیف شد. من تصمیم گرفتم از یک اصطلاح متفاوت در اینجا استفاده کنم زیرا متوجه شدم که اصطلاح اصلی تا حدودی مشکل‌ساز است و برای مخاطبان گسترده‌تر معنی چندانی ندارد.
  </p>
<p>
<strong>Temporal coupling</strong> همیشه بد نیست. فقط چیزی است که باید از آن آگاه باشید. با داشتن microservices بیشتر، با تعاملات پیچیده‌تر بین آنها، چالش‌های <strong>temporal coupling</strong> می‌تواند به حدی افزایش یابد که مقیاس‌بندی سیستم شما و حفظ عملکرد آن دشوارتر شود. یکی از راه‌های اجتناب از <strong>temporal coupling</strong> استفاده از نوعی ارتباط ناهمزمان، مانند یک <strong>message broker</strong> است.
  </p>
<h4>Pass-Through Coupling</h4>
<p>
   "<strong>Pass-through coupling</strong>"9 موقعیتی را توصیف می‌کند که در آن یک microservice داده‌ها را به microservice دیگری منتقل می‌کند، صرفاً به این دلیل که داده‌ها توسط microservice دیگری در پایین‌دست مورد نیاز است. از بسیاری جهات این یکی از مشکل‌سازترین اشکال <em>implementation coupling</em> است، زیرا نه تنها به این معنی است که تماس‌گیرنده نه تنها می‌داند که microservice که آن را فراخوانی می‌کند، microservice دیگری را فراخوانی می‌کند، بلکه به طور بالقوه باید بداند که این microservice که یک مرحله حذف شده است، چگونه کار می‌کند.
  </p>
<p>
   به عنوان مثالی از <strong>pass-through coupling</strong>، بیایید اکنون با دقت بیشتری به بخشی از نحوه عملکرد پردازش سفارش <strong>MusicCorp</strong> نگاه کنیم. در شکل 2-4، ما یک <strong>Order Processor</strong> داریم، که در حال ارسال درخواستی به <strong>Warehouse</strong> برای آماده‌سازی یک سفارش برای ارسال است. به عنوان بخشی از <strong>request payload</strong>، یک <strong>Shipping Manifest</strong> ارسال می‌کنیم. این <strong>Shipping Manifest</strong> نه تنها شامل آدرس مشتری بلکه نوع حمل و نقل را نیز شامل می‌شود. <strong>Warehouse</strong> فقط این <strong>manifest</strong> را به <strong>Shipping microservice</strong> پایین‌دست منتقل می‌کند.
  </p>
<p>
   شکل 2-4. <strong>Pass-through coupling</strong>، که در آن داده‌ها صرفاً به این دلیل که یک <strong>service</strong> دیگر در پایین‌دست به آن نیاز دارد، به یک microservice منتقل می‌شوند
  </p>
<p>Types of Coupling | 43</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 69" src="page_0069/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0069</div>
            </div>
        </div>
        <!-- Page 0070 -->
        <div class="chapter" id="page-0070">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   مشکل اصلی <strong>pass-through coupling</strong> این است که تغییری در داده‌های مورد نیاز در پایین‌دست می‌تواند باعث ایجاد تغییر قابل توجه‌تری در بالادست شود. در مثال ما، اگر <strong>Shipping</strong> اکنون نیاز به تغییر قالب یا محتوای داده‌ها داشته باشد، پس احتمالاً هم <strong>Warehouse</strong> و هم <strong>Order Processor</strong> نیاز به تغییر خواهند داشت.
  </p>
<p>
   چندین راه برای رفع این مشکل وجود دارد. اولین راه این است که در نظر بگیرید آیا منطقی است که microservice فراخوان، میانجی را دور بزند یا خیر. در مثال ما، این ممکن است به این معنی باشد که <strong>Order Processor</strong> مستقیماً با <strong>Shipping</strong> صحبت می‌کند، همانطور که در شکل 2-5 نشان داده شده است. با این حال، این باعث ایجاد برخی از مشکلات دیگر می‌شود. <strong>Order Processor</strong> ما <strong>domain coupling</strong> خود را افزایش می‌دهد، زیرا <strong>Shipping</strong> یک microservice دیگر است که باید در مورد آن بدانیم—اگر این تنها مشکل بود، این ممکن است همچنان خوب باشد، زیرا <strong>domain coupling</strong> البته شکل <em>coupling</em> آزادتر است. با این حال، این راه‌حل در اینجا پیچیده‌تر می‌شود، زیرا قبل از اینکه بسته را با استفاده از <strong>Shipping</strong> ارسال کنیم، باید موجودی را با <strong>Warehouse</strong> رزرو کنیم، و پس از اتمام حمل و نقل، باید موجودی را بر این اساس به‌روزرسانی کنیم. این امر پیچیدگی و منطق بیشتری را به <strong>Order Processor</strong> وارد می‌کند که قبلاً در داخل <strong>Warehouse</strong> پنهان شده بود.
  </p>
<p>
   شکل 2-5. یک راه برای دور زدن <strong>pass-through coupling</strong> شامل برقراری ارتباط مستقیم با <strong>service</strong> پایین‌دست است.
  </p>
<p>
   برای این مثال خاص، من ممکن است یک تغییر ساده‌تر (اگرچه ظریف‌تر) را در نظر بگیرم—یعنی، به‌طور کلی نیاز به یک <strong>Shipping Manifest</strong> را از <strong>Order Pro</strong>
   cessor پنهان کنم. ایده واگذاری کار مدیریت موجودی و ترتیب ارسال بسته به <strong>service Warehouse</strong> ما منطقی است، اما ما از این واقعیت که برخی از پیاده‌سازی‌های سطح پایین‌تر را لو داده‌ایم خوشمان نمی‌آید—یعنی، این واقعیت که
  </p>
<p>44 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 70" src="page_0070/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0070</div>
            </div>
        </div>
        <!-- Page 0071 -->
        <div class="chapter" id="page-0071">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<strong>Shipping microservice</strong> یک <strong>Shipping Manifest</strong> می‌خواهد. یک راه برای پنهان کردن این جزئیات این است که <strong>Warehouse</strong> اطلاعات مورد نیاز را به عنوان بخشی از قرارداد خود دریافت کند، و سپس آن را به صورت محلی بسازد، همانطور که در شکل 2-6 می‌بینیم.
  </p>
<p>
   این بدان معناست که اگر <strong>Shipping service</strong> قرارداد <strong>service</strong> خود را تغییر دهد، این تغییر از دیدگاه <strong>Order Processor</strong> نامرئی خواهد بود، تا زمانی که <strong>Warehouse</strong> داده‌های مورد نیاز را جمع‌آوری کند.
  </p>
<p>
   شکل 2-6. پنهان کردن نیاز به یک <strong>Shipping Manifest</strong> از <strong>Order Processor</strong>
</p>
<p>
   در حالی که این به محافظت از microservice <strong>Warehouse</strong> در برابر برخی تغییرات در <strong>Shipping</strong> کمک می‌کند، چیزهایی وجود دارد که هنوز هم نیازمند تغییر همه طرف‌ها هستند. بیایید این ایده را در نظر بگیریم که می‌خواهیم ارسال بین‌المللی را شروع کنیم. به عنوان بخشی از این، <strong>Shipping service</strong> نیاز به یک <strong>Customs Declaration</strong> دارد که در <strong>Shipping Mani</strong>
   fest گنجانده شود. اگر این یک پارامتر اختیاری باشد، ما می‌توانیم یک نسخه جدید از <strong>Shipping microservice</strong> را بدون مشکل مستقر کنیم. با این حال، اگر این یک پارامتر ضروری باشد، <strong>Warehouse</strong> باید یکی ایجاد کند. ممکن است بتواند این کار را با اطلاعات موجود که در اختیار دارد (یا به آن داده شده است) انجام دهد، یا ممکن است لازم باشد که اطلاعات اضافی توسط <strong>Order Processor</strong> به آن منتقل شود.
  </p>
<p>
   اگرچه در این مورد ما نیاز به ایجاد تغییرات در هر سه microservices را از بین نبرده‌ایم، اما قدرت بسیار بیشتری در مورد زمان و چگونگی ایجاد این تغییرات به ما داده شده است. اگر <em>coupling</em> تنگ (<strong>pass-through</strong>) مثال اولیه را داشتیم، افزودن این <strong>Customs Declaration</strong> جدید ممکن است نیاز به راه‌اندازی <strong>lockstep</strong> از هر سه microservices داشته باشد. حداقل با پنهان کردن این جزئیات، ما می‌توانیم استقرار را بسیار آسان‌تر فازبندی کنیم.
  </p>
<p>
   یک رویکرد نهایی که می‌تواند به کاهش <strong>pass-through coupling</strong> کمک کند این است که <strong>Order Processor</strong> همچنان <strong>Shipping Manifest</strong> را از طریق <strong>Warehouse</strong> به <strong>Shipping microser-vice</strong> ارسال کند، اما <strong>Warehouse</strong> کاملاً از ساختار خود <strong>Shipping Manifest</strong> بی‌اطلاع باشد. <strong>Order Processor</strong> مانیفست را به عنوان بخشی از
  </p>
<p>Types of Coupling | 45</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 71" src="page_0071/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0071</div>
            </div>
        </div>
        <!-- Page 0072 -->
        <div class="chapter" id="page-0072">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   درخواست سفارش، اما <strong>Warehouse</strong> هیچ تلاشی برای نگاه کردن یا پردازش فیلد انجام نمی‌دهد—فقط با آن مانند یک <strong>blob of data</strong> رفتار می‌کند و به محتویات آن اهمیتی نمی‌دهد. در عوض، فقط آن را ارسال می‌کند. تغییری در قالب <strong>Shipping Manifest</strong> همچنان نیازمند تغییری در <strong>Order Processor</strong> و <strong>Shipping microservice</strong> خواهد بود، اما از آنجایی که <strong>Warehouse</strong> به آنچه در واقع در <strong>manifest</strong> است اهمیتی نمی‌دهد، نیازی به تغییر ندارد.
  </p>
<h4>Common Coupling</h4>
<p>
<strong>Common coupling</strong> زمانی رخ می‌دهد که دو یا چند microservice از یک مجموعه داده مشترک استفاده می‌کنند. یک مثال ساده و رایج از این شکل از <em>coupling</em>، استفاده چندین microservice از یک پایگاه داده مشترک است، اما می‌تواند خود را در استفاده از حافظه مشترک یا یک سیستم فایل مشترک نیز نشان دهد.
  </p>
<p>
   مشکل اصلی <strong>common coupling</strong> این است که تغییرات در ساختار داده‌ها می‌تواند بر چندین microservice به طور همزمان تأثیر بگذارد. به مثال برخی از <strong>services MusicCorp</strong> در شکل 2-7 توجه کنید. همانطور که قبلاً بحث کردیم، <strong>MusicCorp</strong> در سراسر جهان فعالیت می‌کند، بنابراین به اطلاعات مختلفی در مورد کشورهایی که در آنها فعالیت می‌کند، نیاز دارد. در اینجا، چندین <strong>service</strong> در حال خواندن داده‌های مرجع ایستا از یک پایگاه داده مشترک هستند. اگر <strong>schema</strong> این پایگاه داده به روشی که با عقب سازگار نیست تغییر کند، این امر مستلزم تغییر در هر <strong>consumer</strong> پایگاه داده خواهد بود. در عمل، داده‌های مشترک مانند این، در نتیجه، تغییر آنها بسیار دشوار است.
  </p>
<p>
   شکل 2-7. چندین <strong>service</strong> که به داده‌های مرجع ایستا مشترک مرتبط با کشورها از یک پایگاه داده یکسان دسترسی دارند.
  </p>
<p>
   مثال در شکل 2-7، نسبتاً خوش‌خیم است. این به این دلیل است که داده‌های مرجع ایستا، به دلیل ماهیت خود، تمایل به تغییر مکرر ندارند، و همچنین به این دلیل که این داده‌ها فقط خواندنی هستند—در نتیجه من تمایل دارم در مورد به اشتراک گذاشتن داده‌های مرجع ایستا راحت باشم
  </p>
<p>46 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 72" src="page_0072/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0072</div>
            </div>
        </div>
        <!-- Page 0073 -->
        <div class="chapter" id="page-0073">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   به این ترتیب. با این حال، <strong>common coupling</strong> مشکل‌سازتر می‌شود، اگر ساختار داده‌های مشترک بیشتر تغییر کند، یا اگر چندین microservice در حال خواندن و نوشتن در همان داده‌ها باشند.
  </p>
<p>
   شکل 2-8 وضعیتی را نشان می‌دهد که در آن <strong>Order Processor</strong> و <strong>Warehouse service</strong> هر دو از یک جدول <strong>Order</strong> مشترک خوانده و در آن می‌نویسند تا به مدیریت فرآیند ارسال سی‌دی‌ها به مشتریان <strong>MusicCorp</strong> کمک کنند. هر دو microservices در حال به‌روزرسانی ستون <strong>Status</strong> هستند. <strong>Order Processor</strong> می‌تواند وضعیت‌های <strong>PLACED</strong>، <strong>PAID</strong>، و <strong>COMPLETED</strong> را تنظیم کند، در حالی که <strong>Warehouse</strong> وضعیت‌های <strong>PICKING</strong> یا <strong>SHIPPED</strong> را اعمال می‌کند.
  </p>
<p>
   شکل 2-8. مثالی از <strong>common coupling</strong> که در آن هر دو <strong>Order Processor</strong> و <strong>Ware house</strong> در حال به‌روزرسانی همان رکورد سفارش هستند.
  </p>
<p>
   اگرچه ممکن است شکل 2-8 را تا حدودی ساختگی در نظر بگیرید، این مثال ساده <strong>common coupling</strong> به هر حال به نشان دادن یک مشکل اساسی کمک می‌کند. از نظر مفهومی، ما هر دو microservices <strong>Order Processor</strong> و <strong>Warehouse</strong> داریم که جنبه‌های مختلف چرخه عمر یک سفارش را مدیریت می‌کنند. هنگام ایجاد تغییرات در <strong>Order Processor</strong>، آیا می‌توانم مطمئن باشم که داده‌های سفارش را به گونه‌ای تغییر نمی‌دهم که دیدگاه <strong>Warehouse</strong> از جهان را خراب کند، یا برعکس؟
  </p>
<p>
   یک راه برای اطمینان از اینکه وضعیت چیزی به روش صحیح تغییر می‌کند، ایجاد یک <strong>finite state machine</strong> است. یک <strong>state machine</strong> می‌تواند برای مدیریت انتقال یک موجودیت از یک <strong>state</strong> به <strong>state</strong> دیگر استفاده شود، و اطمینان حاصل شود که گذارهای <strong>state</strong> نامعتبر ممنوع هستند. در شکل 2-9، می‌توانید گذارهای مجاز <strong>state</strong> را برای یک سفارش در <strong>MusicCorp</strong> مشاهده کنید. یک سفارش می‌تواند مستقیماً از <strong>PLACED</strong> به <strong>PAID</strong> برود، اما نه مستقیماً از <strong>PLACED</strong> به <strong>PICKING</strong> (این <strong>state machine</strong> احتمالاً برای فرآیندهای <strong>business</strong> دنیای واقعی که درگیر خرید و حمل و نقل کامل کالا هستند کافی نخواهد بود، اما من می‌خواستم یک مثال ساده برای نشان دادن ایده ارائه کنم).
  </p>
<p>Types of Coupling | 47</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 73" src="page_0073/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0073</div>
            </div>
        </div>
        <!-- Page 0074 -->
        <div class="chapter" id="page-0074">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 2-9. مروری بر گذارهای <strong>state</strong> مجاز برای یک سفارش در <strong>MusicCorp</strong>
</p>
<p>
   مشکل در این مثال خاص این است که هر دو microserviceهای <strong>Warehouse</strong> و <strong>Order Processor</strong> مسئولیت‌های مدیریت این <strong>state machine</strong> را بر عهده دارند. چگونه اطمینان حاصل کنیم که آنها در مورد اینکه چه گذارهایی مجاز هستند، توافق دارند؟ راه‌هایی برای مدیریت فرآیندهایی مانند این در سراسر <strong>microservice boundaries</strong> وجود دارد. ما در فصل 6 به این موضوع بازخواهیم گشت، زمانی که در مورد <strong>sagas</strong> بحث می‌کنیم.
  </p>
<p>
   یک راه‌حل بالقوه در اینجا این است که اطمینان حاصل شود که یک microservice واحد، <strong>order state</strong> را مدیریت می‌کند. در شکل 2-10، یا <strong>Warehouse</strong> یا <strong>Order Processor</strong> می‌تواند درخواست‌های به‌روزرسانی وضعیت را به <strong>Order service</strong> ارسال کند. در اینجا، <strong>Order microservice</strong> منبع حقیقت برای هر سفارش است. در این شرایط، واقعاً مهم است که درخواست‌ها از <strong>Warehouse</strong> و <strong>Order Processor</strong> را فقط به همان اندازه که هستند—درخواست‌ها ببینیم. در این سناریو، این وظیفه <strong>Order service</strong> است که گذارهای <strong>state</strong> قابل قبول مرتبط با یک <strong>order aggregate</strong> را مدیریت کند. به این ترتیب، اگر <strong>Order service</strong> درخواستی از <strong>Order Processor</strong> برای انتقال یک وضعیت مستقیماً از <strong>PLACED</strong> به <strong>COMPLETED</strong> دریافت کرد، در صورت نامعتبر بودن آن تغییر، در رد آن درخواست آزاد است.
  </p>
<p>
   مطمئن شوید که درخواستی را که به یک microservice ارسال می‌شود، چیزی می‌بینید که microservice پایین‌دست می‌تواند آن را در صورت نامعتبر بودن رد کند.
  </p>
<p>
   یک رویکرد جایگزین که در چنین مواردی می‌بینم این است که <strong>Order service</strong> را به عنوان چیزی بیش از یک <strong>wrapper</strong> در اطراف عملیات <strong>database CRUD</strong> پیاده‌سازی کنید، که در آن درخواست‌ها مستقیماً به به‌روزرسانی‌های پایگاه داده نگاشت می‌شوند. این شبیه به یک <strong>object</strong> است که دارای فیلدهای خصوصی اما <strong>getters</strong> و <strong>setters</strong> عمومی است—رفتار از microservice به <strong>consumers</strong> بالادستی نشت کرده است (کاهش <em>cohesion</em>)، و ما دوباره به دنیای مدیریت گذارهای <strong>state</strong> قابل قبول در چندین <strong>services</strong> مختلف بازگشته‌ایم.
  </p>
<p>
   اگر یک microservice می‌بینید که فقط شبیه یک <strong>wrapper</strong> نازک در اطراف عملیات <strong>database CRUD</strong> است، این نشانه‌ای است که شما ممکن است <em>cohesion</em> ضعیف و <em>coupling</em> تنگ‌تری داشته باشید، زیرا منطقی که باید در آن <strong>service</strong> برای مدیریت داده‌ها باشد، در عوض در جای دیگری از سیستم شما گسترش یافته است.
  </p>
<p>48 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 74" src="page_0074/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 74" src="page_0074/image_2.png"/></div>
<div class="page-image"><img alt="Image from page 74" src="page_0074/image_3.png"/></div>
</div>
                <div class="page-number">صفحه 0074</div>
            </div>
        </div>
        <!-- Page 0075 -->
        <div class="chapter" id="page-0075">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   10 باشه، بیش از یک یا دو بار. خیلی بیشتر از یک یا دو بار…
  </p>
<p>
   شکل 2-10. هر دو <strong>Order Processor</strong> و <strong>Warehouse</strong> می‌توانند درخواست‌هایی را برای ایجاد تغییرات در یک سفارش ارسال کنند، اما <strong>Order microservice</strong> تصمیم می‌گیرد که کدام درخواست‌ها قابل قبول هستند
  </p>
<p>
   منابع <strong>common coupling</strong> نیز منابع بالقوه <strong>resource contention</strong> هستند. چندین microservices که از یک <strong>filesystem</strong> یا پایگاه داده یکسان استفاده می‌کنند، می‌توانند آن منبع مشترک را بیش از حد بارگذاری کنند، که به طور بالقوه باعث ایجاد مشکلات قابل توجهی می‌شود اگر منبع مشترک کند شود یا حتی به طور کامل در دسترس نباشد. یک پایگاه داده مشترک به ویژه مستعد این مشکل است، زیرا چندین <strong>consumers</strong> می‌توانند <strong>queries</strong> دلخواه را در برابر خود پایگاه داده اجرا کنند، که به نوبه خود می‌تواند ویژگی‌های عملکردی بسیار متفاوتی داشته باشد. من بیش از یک پایگاه داده را دیده‌ام که توسط یک <strong>SQL query</strong> گران‌قیمت به زانو درآمده است—شاید من حتی یک یا دو بار مقصر بوده‌ام.10
  </p>
<p>
   بنابراین <strong>common coupling</strong> گاهی اوقات خوب است، اما اغلب اینطور نیست. حتی زمانی که خوش‌خیم است، به این معنی است که ما در مورد تغییراتی که می‌توان در داده‌های مشترک ایجاد کرد، محدود هستیم، اما اغلب به کمبود <em>cohesion</em> در کد ما اشاره دارد. همچنین می‌تواند باعث ایجاد مشکلاتی از نظر <strong>operational contention</strong> شود. به همین دلایل است که ما <strong>common coupling</strong> را یکی از کمترین اشکال مطلوب <em>coupling</em> در نظر می‌گیریم—اما می‌تواند بدتر شود.
  </p>
<h4>Content Coupling</h4>
<p>
<strong>Content coupling</strong> موقعیتی را توصیف می‌کند که در آن یک <strong>service</strong> بالادستی به داخل <strong>internals</strong> یک <strong>service</strong> پایین‌دستی می‌رسد و <strong>internal state</strong> آن را تغییر می‌دهد. متداول‌ترین
  </p>
<p>Types of Coupling | 49</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 75" src="page_0075/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0075</div>
            </div>
        </div>
        <!-- Page 0076 -->
        <div class="chapter" id="page-0076">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   بارزترین نمود این است که یک <strong>service</strong> خارجی به پایگاه داده microservice دیگری دسترسی پیدا می‌کند و آن را مستقیماً تغییر می‌دهد. تفاوت‌های بین <strong>content coupling</strong> و <strong>common coupling</strong> ظریف است. در هر دو مورد، دو یا چند microservices در حال خواندن و نوشتن در مجموعه داده‌های یکسان هستند. با <strong>common coupling</strong>، شما درک می‌کنید که از یک وابستگی مشترک و خارجی استفاده می‌کنید. شما می‌دانید که این تحت کنترل شما نیست. با <strong>content coupling</strong>، خطوط مالکیت کمتر واضح می‌شود و تغییر سیستم برای توسعه‌دهندگان دشوارتر می‌شود.
  </p>
<p>
   بیایید مثال قبلی خود را از <strong>MusicCorp</strong> دوباره مرور کنیم. در شکل 2-11، ما یک <strong>Order service</strong> داریم که قرار است تغییرات وضعیت مجاز را برای سفارش‌ها در سیستم ما مدیریت کند. <strong>Order Processor</strong> در حال ارسال درخواست‌هایی به <strong>Order service</strong> است، که نه تنها دقیقاً تغییر <strong>state</strong> را که انجام می‌شود، بلکه مسئولیت تصمیم‌گیری در مورد اینکه چه تغییرات <strong>state</strong> مجاز هستند را تفویض می‌کند. از سوی دیگر، <strong>Warehouse service</strong> در حال به‌روزرسانی مستقیم جدولی است که داده‌های سفارش در آن ذخیره شده است، و هر گونه <strong>functionality</strong> را در <strong>Order service</strong> که ممکن است برای بررسی تغییرات مجاز استفاده شود، دور می‌زند. ما باید امیدوار باشیم که <strong>Warehouse service</strong> مجموعه‌ای از منطق‌ها را برای اطمینان از اینکه فقط تغییرات معتبر انجام می‌شود، دارد. در بهترین حالت، این نشان‌دهنده تکرار منطق است. در بدترین حالت، بررسی در مورد تغییرات مجاز در <strong>Warehouse</strong> با بررسی در <strong>Order service</strong> متفاوت است، و در نتیجه ما می‌توانیم سفارش‌هایی را در حالت‌های بسیار عجیب و گیج‌کننده به پایان برسانیم.
  </p>
<p>
   شکل 2-11. مثالی از <strong>content coupling</strong> که در آن <strong>Warehouse</strong> مستقیماً به داده‌های داخلی <strong>Order service</strong> دسترسی دارد.
  </p>
<p>50 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 76" src="page_0076/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0076</div>
            </div>
        </div>
        <!-- Page 0077 -->
        <div class="chapter" id="page-0077">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   11 Eric Evans, Domain-Driven Design: Tackling Complexity in the Heart of Software (Boston: Addison-Wesley,
   2004).
  </p>
<p>
   در این موقعیت، ما همچنین این مشکل را داریم که <strong>internal data structure</strong> جدول <strong>order</strong> ما در معرض دید یک طرف خارجی قرار دارد. هنگام تغییر <strong>Order service</strong>، ما اکنون باید در مورد ایجاد تغییرات در آن جدول خاص بسیار مراقب باشیم—این حتی فرض می‌کند که برای ما آشکار است که این جدول مستقیماً توسط یک طرف خارجی قابل دسترسی است. راه حل آسان در اینجا این است که <strong>Warehouse</strong> درخواست‌هایی را به خود <strong>Order service</strong> ارسال کند، جایی که ما می‌توانیم درخواست را بررسی کنیم اما جزئیات داخلی را نیز پنهان کنیم و تغییرات بعدی در <strong>Order service</strong> را بسیار آسان‌تر کنیم.
  </p>
<p>
   اگر روی یک microservice کار می‌کنید، ضروری است که یک جدایی واضح بین آنچه که می‌توان آزادانه تغییر داد و آنچه که نمی‌تواند داشته باشید. به صراحت، به عنوان یک توسعه‌دهنده شما باید بدانید چه زمانی در حال تغییر <strong>functionality</strong> هستید که بخشی از قراردادی است که <strong>service</strong> شما به دنیای بیرون نشان می‌دهد. شما باید اطمینان حاصل کنید که اگر تغییراتی ایجاد می‌کنید، <strong>consumers</strong> بالادستی را خراب نخواهید کرد. <strong>Functionality</strong> که بر قرارداد microservice شما تأثیری ندارد، می‌تواند بدون نگرانی تغییر کند.
  </p>
<p>
   مطمئناً اینطور است که مشکلاتی که با <strong>common coupling</strong> رخ می‌دهد، در مورد <strong>content coupling</strong> نیز صدق می‌کند، اما <strong>content coupling</strong> دارای سردردهای اضافی است که آن را به اندازه‌ای مشکل‌ساز می‌کند که برخی از افراد از آن به عنوان <strong>pathological coupling</strong> یاد می‌کنند.
  </p>
<p>
   وقتی به یک طرف خارجی اجازه می‌دهید مستقیماً به پایگاه داده شما دسترسی داشته باشد، پایگاه داده در واقع بخشی از آن قرارداد خارجی می‌شود، اگرچه جایی که شما نمی‌توانید به راحتی در مورد اینکه چه چیزی را می‌توان یا نمی‌توان تغییر داد، استدلال کنید. شما توانایی تعریف آنچه را که به اشتراک گذاشته شده است (و بنابراین نمی‌تواند به راحتی تغییر کند) و آنچه پنهان است، از دست داده‌اید. <strong>Information hiding</strong> از پنجره بیرون رفته است.
  </p>
<p>
   به طور خلاصه، از <strong>content coupling</strong> اجتناب کنید.
  </p>
<h4>Just Enough Domain-Driven Design</h4>
<p>
   همانطور که در فصل 1 معرفی کردم، مکانیسم اصلی که ما برای یافتن <strong>microservice boundaries</strong> استفاده می‌کنیم، در اطراف خود <strong>domain</strong> است، و از <strong>domain-driven design (DDD)</strong> برای کمک به ایجاد مدلی از <strong>domain</strong> خود استفاده می‌کنیم. بیایید اکنون درک خود را از نحوه عملکرد <strong>DDD</strong> در زمینه microservices گسترش دهیم.
  </p>
<p>
   تمایل به داشتن برنامه‌های ما که دنیای واقعی را که در آن فعالیت خواهند کرد بهتر نشان می‌دهد، چیز جدیدی نیست. زبان‌های برنامه‌نویسی شی‌گرا مانند <strong>Simula</strong> برای این توسعه داده شدند تا به ما اجازه دهند <strong>domains</strong> واقعی را مدل‌سازی کنیم. اما بیش از قابلیت‌های زبان برنامه‌نویسی برای تحقق این ایده لازم است.
  </p>
<p>
<em>Domain-Driven Design</em> نوشته <strong>Eric Evans</strong>11 مجموعه‌ای از ایده‌های مهم را ارائه کرد که به ما کمک کرد تا <strong>problem domain</strong> را در برنامه‌های خود بهتر نشان دهیم. بررسی کامل
  </p>
<p>Just Enough Domain-Driven Design | 51</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0077</div>
            </div>
        </div>
        <!-- Page 0078 -->
        <div class="chapter" id="page-0078">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   این ایده‌ها خارج از محدوده این کتاب است، اما برخی از مفاهیم اصلی <strong>DDD</strong> وجود دارد که ارزش برجسته کردن را دارند، از جمله:
  </p>
<ul>
<li>زبان فراگیر</li>
</ul>
<p>
   تعریف و اتخاذ یک زبان مشترک که در کد و در توصیف <strong>domain</strong> استفاده شود، برای کمک به ارتباطات.
  </p>
<ul>
<li>Aggregate</li>
</ul>
<p>
   مجموعه‌ای از <strong>objects</strong> که به عنوان یک موجودیت واحد مدیریت می‌شوند، که معمولاً به مفاهیم دنیای واقعی اشاره دارند.
  </p>
<ul>
<li>Bounded context</li>
</ul>
<p>
   یک <strong>boundary</strong> صریح در یک <strong>business domain</strong> که <strong>functionality</strong> را به سیستم گسترده‌تر ارائه می‌دهد اما پیچیدگی را نیز پنهان می‌کند.
  </p>
<h4>Ubiquitous Language</h4>
<p>
<strong>Ubiquitous language</strong> به این ایده اشاره دارد که ما باید تلاش کنیم تا از اصطلاحات یکسانی در کد خود استفاده کنیم که کاربران استفاده می‌کنند. ایده این است که داشتن یک زبان مشترک بین تیم تحویل و افراد واقعی، مدل‌سازی <strong>real-world domain</strong> را آسان‌تر می‌کند و همچنین باید ارتباطات را بهبود بخشد.
  </p>
<p>
   به عنوان یک مثال متقابل، من موقعیتی را به یاد می‌آورم که در یک بانک بزرگ و جهانی کار می‌کردم. ما در زمینه نقدینگی شرکت کار می‌کردیم، یک اصطلاح فانتزی که اساساً به توانایی انتقال پول بین حساب‌های مختلفی که توسط یک نهاد شرکتی واحد نگهداری می‌شود، اشاره دارد.
  </p>
<p>
   مالک محصول واقعاً برای کار کردن عالی بود، و او درک فوق‌العاده عمیقی از محصولات مختلفی داشت که می‌خواست به بازار عرضه کند. هنگام کار با او، ما بحث‌هایی در مورد چیزهایی مانند <strong>haircuts</strong> و <strong>end-of-day sweeps</strong> داشتیم، همه چیزهایی که در دنیای او منطقی بود و برای مشتریانش معنا داشت.
  </p>
<p>
   از سوی دیگر، کد، هیچ یک از این زبان را در خود نداشت. در مقطعی قبلاً، تصمیمی برای استفاده از یک <strong>data model</strong> استاندارد برای پایگاه داده گرفته شده بود. به طور گسترده‌ای از آن به عنوان "مدل بانکی <strong>IBM</strong>" یاد می‌شد، اما من به این نتیجه رسیدم که آیا این یک محصول استاندارد <strong>IBM</strong> است یا فقط خلقت یک مشاور از <strong>IBM</strong>. با تعریف مفهوم شل "ترتیب"، نظریه این بود که هر عملیات بانکی می‌تواند مدل‌سازی شود. گرفتن وام؟ این یک ترتیب بود. خرید یک سهم؟ این یک ترتیب است! درخواست کارت اعتباری؟ حدس بزنید—این هم یک ترتیب است!
  </p>
<p>
<strong>data model</strong> کد را تا حدی آلوده کرده بود که <strong>codebase</strong> از همه درک‌های واقعی از سیستمی که در حال ساخت آن بودیم، محروم شد. ما در حال ساختن یک برنامه بانکی عمومی نبودیم. ما در حال ساختن سیستمی بودیم که به طور خاص برای مدیریت نقدینگی شرکت بود. مشکل این بود که ما باید <strong>domain language</strong> غنی مالک محصول را به مفاهیم کد عمومی نگاشت می‌کردیم—به معنای کار زیاد در کمک به
  </p>
<p>52 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0078</div>
            </div>
        </div>
        <!-- Page 0079 -->
        <div class="chapter" id="page-0079">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   ترجمه کنیم. در نتیجه، تحلیل‌گران <strong>business</strong> ما اغلب وقت خود را صرف توضیح مکرر مفاهیم مشابه می‌کردند.
  </p>
<p>
   با وارد کردن زبان دنیای واقعی به کد، همه چیز بسیار آسان‌تر شد. یک توسعه‌دهنده با در دست گرفتن داستانی که با استفاده از اصطلاحاتی که مستقیماً از مالک محصول آمده بود نوشته شده بود، به احتمال زیاد منظور آن را درک می‌کند و متوجه می‌شود که چه کاری باید انجام شود.
  </p>
<h4>Aggregate</h4>
<p>
   در <strong>DDD</strong>، یک <strong>aggregate</strong> یک مفهوم تا حدودی گیج‌کننده است، با تعاریف مختلفی که وجود دارد. آیا این فقط یک مجموعه دلخواه از <strong>objects</strong> است؟ کوچکترین واحدی که باید از یک پایگاه داده خارج شود؟ مدلی که همیشه برای من کار کرده است این است که ابتدا یک <strong>aggregate</strong> را به عنوان نشان‌دهنده یک مفهوم <strong>domain</strong> واقعی در نظر بگیرید—به چیزی مانند یک <strong>Order</strong>، یک <strong>Invoice</strong>، یک <strong>Stock Item</strong> و غیره فکر کنید. <strong>Aggregates</strong> معمولاً یک چرخه عمر در اطراف خود دارند، که آنها را به سمت پیاده‌سازی به عنوان یک <strong>state machine</strong> باز می‌کند.
  </p>
<p>
   به عنوان مثال در <strong>MusicCorp domain</strong>، یک <strong>Order aggregate</strong> ممکن است شامل چندین <strong>line items</strong> باشد که نشان‌دهنده آیتم‌های موجود در سفارش هستند. آن <strong>line items</strong> فقط به عنوان بخشی از کل <strong>Order aggregate</strong> معنا دارند.
  </p>
<p>
   ما می‌خواهیم <strong>aggregates</strong> را به عنوان واحدهای خودمحور در نظر بگیریم. ما می‌خواهیم اطمینان حاصل کنیم که کدی که گذارهای <strong>state</strong> یک <strong>aggregate</strong> را مدیریت می‌کند، همراه با خود <strong>state</strong>، با هم گروه‌بندی شده‌اند. بنابراین یک <strong>aggregate</strong> باید توسط یک microservice مدیریت شود، اگرچه یک microservice واحد ممکن است مدیریت چندین <strong>aggregate</strong> را بر عهده داشته باشد.
  </p>
<p>
   به طور کلی، شما باید به یک <strong>aggregate</strong> به عنوان چیزی فکر کنید که دارای <strong>state</strong>، <strong>identity</strong>، یک چرخه عمر است که به عنوان بخشی از سیستم مدیریت می‌شود. <strong>Aggregates</strong> معمولاً به مفاهیم دنیای واقعی اشاره دارند.
  </p>
<p>
   یک microservice واحد، چرخه عمر و ذخیره‌سازی داده‌های یک یا چند نوع مختلف <strong>aggregates</strong> را مدیریت می‌کند. اگر <strong>functionality</strong> در <strong>service</strong> دیگری بخواهد یکی از این <strong>aggregates</strong> را تغییر دهد، باید یا مستقیماً درخواست تغییر در آن <strong>aggregate</strong> را بدهد یا این‌که خود <strong>aggregate</strong> به چیزهای دیگر در سیستم واکنش نشان دهد تا گذارهای <strong>state</strong> خود را آغاز کند، شاید با اشتراک در <strong>events</strong> صادر شده توسط microservices دیگر.
  </p>
<p>
   نکته کلیدی که باید در اینجا درک کنید این است که اگر یک طرف خارجی درخواست <strong>state transition</strong> را در یک <strong>aggregate</strong> بدهد، <strong>aggregate</strong> می‌تواند نه بگوید. شما در حالت ایده‌آل می‌خواهید <strong>aggregates</strong> خود را به گونه‌ای پیاده‌سازی کنید که گذارهای <strong>state</strong> غیرقانونی غیرممکن باشد.
  </p>
<p>
<strong>Aggregates</strong> می‌توانند با <strong>aggregates</strong> دیگر ارتباط داشته باشند. در شکل 2-12، ما یک <strong>Customer aggregate</strong> داریم که با یک یا چند <strong>Orders</strong> و یک یا چند <strong>Wishlists</strong> مرتبط است. این <strong>aggregates</strong> می‌توانند توسط همان microservice یا microservicesهای مختلف مدیریت شوند.
  </p>
<p>Just Enough Domain-Driven Design | 53</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0079</div>
            </div>
        </div>
        <!-- Page 0080 -->
        <div class="chapter" id="page-0080">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   12 من می‌دانم که برخی از افراد با استفاده از <strong>templated URIs</strong> در سیستم‌های <strong>REST</strong> مخالف هستند، و من می‌فهمم چرا—فقط می‌خواهم در این مثال، همه چیز را ساده نگه دارم.
  </p>
<p>
   شکل 2-12. یک <strong>Customer aggregate</strong> ممکن است با یک یا چند <strong>Order</strong> یا <strong>Wishlist aggregates</strong> مرتبط باشد
  </p>
<p>
   اگر این روابط بین <strong>aggregates</strong> در محدوده یک microservice واحد وجود داشته باشد، در صورت استفاده از یک پایگاه داده رابطه‌ای، می‌توان آنها را به راحتی با استفاده از چیزی مانند یک رابطه کلید خارجی ذخیره کرد. اگرچه روابط بین این <strong>aggregates</strong>، <strong>microservice boundaries</strong> را در بر می‌گیرد، ما به روشی برای مدل‌سازی روابط نیاز داریم.
  </p>
<p>
   اکنون، ما می‌توانیم به سادگی <strong>ID</strong> <strong>aggregate</strong> را مستقیماً در پایگاه داده محلی خود ذخیره کنیم. به عنوان مثال، یک microservice <strong>Finance</strong> را در نظر بگیرید که یک دفتر کل مالی را مدیریت می‌کند، که معاملات را در برابر یک مشتری ذخیره می‌کند. به صورت محلی، در داخل پایگاه داده microservice <strong>Finance</strong> ما می‌توانیم یک ستون <strong>CustID</strong> داشته باشیم که حاوی <strong>ID</strong> آن مشتری است. اگر می‌خواستیم اطلاعات بیشتری در مورد آن مشتری دریافت کنیم، باید از آن <strong>ID</strong> برای جستجو در برابر microservice <strong>Customer</strong> استفاده می‌کردیم.
  </p>
<p>
   مشکل این مفهوم این است که خیلی صریح نیست—در واقع، رابطه بین ستون <strong>CustID</strong> و مشتری از راه دور کاملاً ضمنی است. برای دانستن نحوه استفاده از آن <strong>ID</strong>، باید به کد خود microservice <strong>Finance</strong> نگاه می‌کردیم. خوب است اگر بتوانیم یک <strong>reference</strong> به یک <strong>foreign aggregate</strong> را به روشی ذخیره کنیم که آشکارتر باشد.
  </p>
<p>
   در شکل 2-13، ما چیزهایی را تغییر داده‌ایم تا رابطه را صریح کنیم. به جای یک <strong>ID</strong> ساده برای <strong>customer reference</strong>، ما در عوض یک <strong>URI</strong> را ذخیره می‌کنیم، که ممکن است در صورت ساخت یک سیستم مبتنی بر <strong>REST</strong> از آن استفاده کنیم.12
  </p>
<p>54 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 80" src="page_0080/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0080</div>
            </div>
        </div>
        <!-- Page 0081 -->
        <div class="chapter" id="page-0081">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   13 Phil Calçado, “Pattern: Using Pseudo-URIs with Microservices,” https://oreil.ly/xOYMr.
  </p>
<p>
   شکل 2-13. مثالی از نحوه پیاده‌سازی یک رابطه بین دو <strong>aggregates</strong> در microservicesهای مختلف
  </p>
<p>
   مزایای این رویکرد دوچندان است. ماهیت این رابطه صریح است، و در یک سیستم <strong>REST</strong> ما می‌توانیم مستقیماً این <strong>URI</strong> را <strong>dereference</strong> کنیم تا <strong>resource</strong> مرتبط را جستجو کنیم. اما اگر شما در حال ساخت یک سیستم <strong>REST</strong> نیستید چه؟ <strong>Phil Calçado</strong> نوعی از این رویکرد را که در <strong>SoundCloud</strong> استفاده می‌شود، توضیح می‌دهد،13 جایی که آنها یک طرح <strong>pseudo-URI</strong> برای <strong>cross-service references</strong> توسعه داده‌اند. به عنوان مثال، <strong>soundcloud:tracks:123</strong> به یک آهنگ با <strong>ID</strong> 123 اشاره دارد. این برای انسانی که به این شناسگر نگاه می‌کند بسیار صریح‌تر است، اما همچنین یک طرح به اندازه کافی مفید است که تصور ایجاد کدی که می‌تواند <strong>lookups aggregate cross-microservice</strong> را در صورت نیاز آسان‌تر کند، آسان باشد.
  </p>
<p>
   راه‌های زیادی برای تقسیم یک سیستم به <strong>aggregates</strong> وجود دارد، که برخی از انتخاب‌ها بسیار ذهنی هستند. شما ممکن است به دلایل عملکردی یا سهولت پیاده‌سازی، تصمیم به تغییر شکل <strong>aggregates</strong> در طول زمان بگیرید. با این حال، من نگرانی‌های پیاده‌سازی را ثانویه در نظر می‌گیرم. من با اجازه دادن به مدل ذهنی کاربران سیستم، به عنوان چراغ راهنمای خود در طراحی اولیه تا زمانی که عوامل دیگر وارد عمل شوند، شروع می‌کنم.
  </p>
<p>Just Enough Domain-Driven Design | 55</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 81" src="page_0081/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0081</div>
            </div>
        </div>
        <!-- Page 0082 -->
        <div class="chapter" id="page-0082">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Bounded Context</h4>
<p>
   یک <strong>bounded context</strong> معمولاً یک <strong>organizational boundary</strong> بزرگتر را نشان می‌دهد. در محدوده آن <strong>boundary</strong>، مسئولیت‌های صریح باید انجام شود. این کمی مبهم است، بنابراین بیایید به مثال دیگری نگاه کنیم.
  </p>
<p>
   در <strong>MusicCorp</strong>، انبار ما کانون فعالیت است—مدیریت سفارشات ارسال شده (و بازگشت‌های عجیب)، دریافت موجودی جدید، داشتن مسابقات کامیون لیفتراک، و غیره. در جای دیگر، بخش مالی شاید به اندازه کافی سرگرم‌کننده نباشد اما همچنان یک عملکرد مهم در داخل سازمان ما دارد، رسیدگی به حقوق و دستمزد، پرداخت هزینه‌های حمل و نقل، و مانند آن.
  </p>
<p>
<strong>Bounded contexts</strong> جزئیات پیاده‌سازی را پنهان می‌کنند. نگرانی‌های داخلی وجود دارد—به عنوان مثال، انواع کامیون‌های لیفتراک مورد استفاده برای هر کسی جز افراد انبار کم‌اهمیت است. این نگرانی‌های داخلی باید از دنیای بیرون پنهان شوند، که نیازی به دانستن آنها ندارد، و نباید به آنها اهمیت دهد.
  </p>
<p>
   از دیدگاه پیاده‌سازی، <strong>bounded contexts</strong> شامل یک یا چند <strong>aggregates</strong> هستند. برخی از <strong>aggregates</strong> ممکن است در خارج از <strong>bounded context</strong> در معرض دید قرار گیرند. بقیه ممکن است داخلی پنهان شوند. مانند <strong>aggregates</strong>، <strong>bounded contexts</strong> ممکن است روابطی با دیگر <strong>bounded contexts</strong> داشته باشند—هنگامی که به <strong>services</strong> نگاشت می‌شوند، این وابستگی‌ها به وابستگی‌های بین <strong>service</strong> تبدیل می‌شوند.
  </p>
<p>
   بیایید برای لحظه‌ای به <strong>MusicCorp business</strong> برگردیم. <strong>domain</strong> ما کل <strong>business</strong> است که در آن فعالیت می‌کنیم. این شامل همه چیز از انبار تا میز پذیرش، از امور مالی تا سفارش می‌شود. ما ممکن است همه اینها را در نرم‌افزار خود مدل‌سازی کنیم یا نکنیم، اما با این وجود <strong>domain</strong> است که ما در آن فعالیت می‌کنیم. بیایید در مورد بخش‌هایی از آن <strong>domain</strong> فکر کنیم که شبیه <strong>bounded contexts</strong> هستند که <strong>Eric Evans</strong> به آنها اشاره می‌کند.
  </p>
<h4>مدل‌های پنهان</h4>
<p>
   برای <strong>MusicCorp</strong>، ما می‌توانیم بخش مالی و انبار را دو <strong>bounded contexts</strong> جداگانه در نظر بگیریم. هر دوی آنها یک رابط صریح به دنیای بیرون دارند (از نظر گزارش‌های موجودی، فیش حقوقی و غیره)، و جزئیاتی دارند که فقط آنها باید در مورد آنها بدانند (کامیون‌های لیفتراک، ماشین حساب).
  </p>
<p>
   بخش مالی نیازی به دانستن جزئیات داخلی انبار ندارد. با این حال، به چیزهایی نیاز دارد. به عنوان مثال، برای به‌روز نگه‌داشتن حساب‌ها، باید از سطوح موجودی اطلاع داشته باشد. شکل 2-14 یک نمودار زمینه مثال را نشان می‌دهد. ما مفاهیمی را می‌بینیم که داخلی انبار هستند، مانند یک <strong>picker</strong> (کسی که سفارش‌ها را انتخاب می‌کند)، قفسه‌هایی که مکان‌های موجودی را نشان می‌دهند، و غیره. به همین ترتیب، ورودی‌های دفتر کل در امور مالی جدایی‌ناپذیر هستند اما در اینجا به صورت خارجی به اشتراک گذاشته نمی‌شوند.
  </p>
<p>56 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0082</div>
            </div>
        </div>
        <!-- Page 0083 -->
        <div class="chapter" id="page-0083">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 2-14. یک مدل مشترک بین بخش مالی و انبار
  </p>
<p>
   با این حال، برای اینکه بتوانیم ارزش‌گذاری شرکت را محاسبه کنیم، کارکنان بخش مالی به اطلاعاتی در مورد موجودی که داریم نیاز دارند. سپس، <strong>stock item</strong> به یک مدل مشترک بین دو <strong>context</strong> تبدیل می‌شود. با این حال، توجه داشته باشید که ما نیازی نداریم همه چیز را در مورد <strong>stock item</strong> از <strong>warehouse context</strong> کورکورانه نشان دهیم. در شکل 2-15، ما می‌بینیم که چگونه <strong>Stock Item</strong> در داخل <strong>warehouse bounded context</strong> حاوی <strong>references</strong> به مکان‌های قفسه است، اما <strong>shared representation</strong> فقط شامل یک تعداد است. بنابراین، یک نمایش داخلی وجود دارد و یک نمایش خارجی که ما نشان می‌دهیم. اغلب، وقتی <strong>representations</strong> داخلی و خارجی متفاوتی دارید، ممکن است مفید باشد که آنها را متفاوت نامگذاری کنید تا از سردرگمی جلوگیری شود—در این شرایط، یک رویکرد می‌تواند این باشد که <strong>Stock Item</strong> مشترک را در عوض <strong>Stock Count</strong> بنامیم.
  </p>
<p>
   شکل 2-15. یک مدل که به اشتراک گذاشته شده است، می‌تواند تصمیم بگیرد که اطلاعاتی را که نباید به صورت خارجی به اشتراک گذاشته شود، پنهان کند.
  </p>
<h4>Shared models</h4>
<p>
   ما همچنین می‌توانیم مفاهیمی داشته باشیم که در بیش از یک <strong>bounded context</strong> ظاهر می‌شوند. در شکل 2-14 ما دیدیم که یک مشتری در هر دو مکان وجود دارد. این به چه معناست؟ آیا مشتری کپی شده است؟ روشی که باید در مورد آن فکر کنید این است که از نظر مفهومی، هر دو بخش مالی
  </p>
<p>Just Enough Domain-Driven Design | 57</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 83" src="page_0083/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 83" src="page_0083/image_2.png"/></div>
</div>
                <div class="page-number">صفحه 0083</div>
            </div>
        </div>
        <!-- Page 0084 -->
        <div class="chapter" id="page-0084">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   و انبار نیاز به دانستن چیزی در مورد مشتری ما دارند. بخش مالی باید در مورد پرداخت‌های مالی انجام شده به یک مشتری بداند، در حالی که انبار باید در مورد مشتری به اندازه‌ای بداند که بداند چه بسته‌هایی ارسال شده است تا امکان ردیابی تحویل‌ها را فراهم کند.
  </p>
<p>
   وقتی چنین وضعیتی دارید، یک مدل مشترک مانند مشتری می‌تواند معانی متفاوتی در <strong>bounded contexts</strong> مختلف داشته باشد و بنابراین ممکن است به نام‌های مختلفی خوانده شود. ما ممکن است از حفظ نام "مشتری" در امور مالی خوشحال باشیم، اما در انبار ممکن است آنها را "دریافت‌کننده" بنامیم، زیرا این نقشی است که آنها در آن <strong>context</strong> ایفا می‌کنند.
  </p>
<p>
   ما اطلاعاتی را در مورد مشتری در هر دو مکان ذخیره می‌کنیم، اما اطلاعات متفاوت است. امور مالی اطلاعاتی را در مورد پرداخت‌های مالی مشتری (یا بازپرداخت‌ها) ذخیره می‌کند. انبار اطلاعات مربوط به کالاهای حمل شده را ذخیره می‌کند. ما همچنان ممکن است نیاز داشته باشیم که هر دو مفهوم محلی را به یک مشتری جهانی پیوند دهیم، و ممکن است بخواهیم اطلاعات مشترک و مشترک در مورد آن مشتری مانند نام یا آدرس ایمیل آنها را جستجو کنیم—ما می‌توانیم از تکنیکی مانند آنچه در شکل 2-13 نشان داده شده است برای دستیابی به این هدف استفاده کنیم.
  </p>
<h4>نگاشت <strong>Aggregates</strong> و <strong>Bounded Contexts</strong> به Microservices</h4>
<p>
   هم <strong>aggregate</strong> و هم <strong>bounded context</strong> به ما واحدهای <em>cohesion</em> را با <strong>interfaces</strong> کاملاً تعریف شده با سیستم گسترده‌تر می‌دهند. <strong>Aggregate</strong> یک <strong>state machine</strong> خودکفا است که بر یک مفهوم <strong>domain</strong> واحد در سیستم ما تمرکز می‌کند، در حالی که <strong>bounded context</strong> نشان‌دهنده مجموعه‌ای از <strong>aggregates</strong> مرتبط است، باز هم با یک <strong>interface</strong> صریح به دنیای گسترده‌تر.
  </p>
<p>
   بنابراین هر دو می‌توانند به خوبی به عنوان <strong>service boundaries</strong> کار کنند. همانطور که قبلاً ذکر کردم، هنگام شروع کار، می‌خواهید تعداد <strong>services</strong> را که با آنها کار می‌کنید، کاهش دهید. در نتیجه، شما احتمالاً باید <strong>services</strong> را هدف قرار دهید که کل <strong>bounded contexts</strong> را در بر می‌گیرند. همانطور که پای خود را پیدا می‌کنید و تصمیم به تقسیم این <strong>services</strong> به <strong>services</strong> کوچک‌تر می‌گیرید، باید به خاطر داشته باشید که <strong>aggregates</strong> خود نمی‌خواهند از هم جدا شوند—یک microservice می‌تواند یک یا چند <strong>aggregates</strong> را مدیریت کند، اما ما نمی‌خواهیم یک <strong>aggregate</strong> توسط بیش از یک microservice مدیریت شود.
  </p>
<h4>لاک‌پشت‌ها تا انتها</h4>
<p>
   در ابتدا، شما احتمالاً تعدادی از <strong>bounded contexts</strong> با <strong>coarse-grained</strong> را شناسایی خواهید کرد. اما این <strong>bounded contexts</strong> به نوبه خود می‌توانند <strong>bounded contexts</strong> بیشتری را شامل شوند. به عنوان مثال، شما می‌توانید انبار را به قابلیت‌های مرتبط با تکمیل سفارش، مدیریت موجودی، یا دریافت کالا تجزیه کنید. هنگام در نظر گرفتن <strong>boundaries</strong> microservicesهای خود، ابتدا از نظر <strong>contexts</strong> بزرگتر و <strong>coarse-grained</strong> فکر کنید، و سپس هنگام جستجوی مزایای تقسیم این <strong>seams</strong>، در امتداد این <strong>contexts</strong> تو در تو تقسیم کنید.
  </p>
<p>
   یک ترفند در اینجا این است که حتی اگر تصمیم دارید یک <strong>service</strong> را که یک <strong>bounded context</strong> کامل را مدل می‌کند به <strong>services</strong> کوچک‌تر در آینده تقسیم کنید، همچنان می‌توانید این تصمیم را از دنیای بیرون پنهان کنید—شاید با ارائه یک <strong>API</strong> با <strong>coarser-grained</strong> به مصرف‌کنندگان. تصمیم به
  </p>
<p>58 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0084</div>
            </div>
        </div>
        <!-- Page 0085 -->
        <div class="chapter" id="page-0085">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   تجزیه یک <strong>service</strong> به بخش‌های کوچک‌تر، به‌درستی یک تصمیم پیاده‌سازی است، بنابراین اگر بتوانیم، می‌توانیم آن را پنهان کنیم. در شکل 2-16 ما مثالی از این را می‌بینیم. ما <strong>Warehouse</strong> را به <strong>Inventory</strong> و <strong>Shipping</strong> تقسیم کرده‌ایم. تا آنجا که به دنیای بیرون مربوط می‌شود، هنوز فقط <strong>Warehouse microservice</strong> وجود دارد. با این حال، در داخل، ما موارد را بیشتر تجزیه کرده‌ایم تا به <strong>Inventory</strong> اجازه دهیم <strong>Stock Items</strong> را مدیریت کند و <strong>Shipping</strong>، <strong>Shipments</strong> را مدیریت کند. به یاد داشته باشید، ما می‌خواهیم مالکیت یک <strong>aggregate</strong> واحد را در داخل یک microservice واحد حفظ کنیم.
  </p>
<p>
   شکل 2-16. <strong>Warehouse service</strong> از نظر داخلی به microservicesهای <strong>Inventory</strong> و <strong>Ship ping</strong> تقسیم شده است
  </p>
<p>
   این شکل دیگری از <strong>information hiding</strong> است—ما تصمیمی را در مورد پیاده‌سازی داخلی به گونه‌ای پنهان کرده‌ایم که اگر این جزئیات پیاده‌سازی دوباره در آینده تغییر کند، <strong>consumers</strong> ما از آن بی‌اطلاع خواهند بود.
  </p>
<p>
   یکی دیگر از دلایلی که رویکرد تو در تو را ترجیح می‌دهیم می‌تواند این باشد که معماری خود را تکه‌تکه کنید تا آزمایش را ساده کنید. به عنوان مثال، هنگام آزمایش <strong>services</strong> که <strong>warehouse</strong> را مصرف می‌کنند، من مجبور نیستم هر <strong>service</strong> را در داخل <strong>warehouse context</strong> <strong>stub</strong> کنم—فقط <strong>API</strong> با <strong>coarse-grained</strong>تر. این همچنین می‌تواند به شما یک واحد جداسازی هنگام در نظر گرفتن <strong>tests</strong> با دامنه بزرگتر بدهد. به عنوان مثال، من ممکن است تصمیم بگیرم که <strong>end-to-end tests</strong> داشته باشم که در آنها تمام <strong>services</strong> را در داخل <strong>warehouse context</strong> راه‌اندازی می‌کنم، اما برای همه همکاران دیگر ممکن است آنها را <strong>stub</strong> کنم. ما در فصل 9 به بررسی بیشتر در مورد <strong>testing</strong> و جداسازی خواهیم پرداخت.
  </p>
<h4>Event Storming</h4>
<p>
<strong>Event storming</strong>، یک تکنیک توسعه‌یافته توسط <strong>Alberto Brandolini</strong>، یک تمرین <strong>brainstorming</strong> مشارکتی است که برای کمک به نشان دادن یک مدل <strong>domain</strong> طراحی شده است. به جای اینکه یک معمار در گوشه‌ای بنشیند و به <strong>representation</strong> خود از آنچه
  </p>
<p>Just Enough Domain-Driven Design | 59</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 85" src="page_0085/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0085</div>
            </div>
        </div>
        <!-- Page 0086 -->
        <div class="chapter" id="page-0086">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   14 اگر شما این کار را انجام می‌دهید، من بی‌احترامی نمی‌کنم—من خودم این کار را بیش از یک بار انجام داده‌ام.
  </p>
<p>
   15 منظورم این است، چرا زرد نه؟ این رایج‌ترین رنگ است!
  </p>
<p>
<strong>domain model</strong> است،14 <strong>event storming</strong> ذی‌نفعان فنی و غیرفنی را در یک تمرین مشترک گرد هم می‌آورد. ایده این است که با تبدیل توسعه <strong>domain model</strong> به یک فعالیت مشترک، شما در نهایت یک دیدگاه مشترک و یکپارچه از جهان خواهید داشت.
  </p>
<p>
   شایان ذکر است که در حالی که <strong>domain models</strong> تعریف شده از طریق <strong>event storming</strong> می‌تواند برای پیاده‌سازی سیستم‌های مبتنی بر <strong>event</strong> استفاده شود—و در واقع، نگاشت بسیار ساده است—شما همچنین می‌توانید از چنین <strong>domain model</strong> برای ساخت یک سیستم بیشتر مبتنی بر درخواست/پاسخ استفاده کنید.
  </p>
<h4>لجستیک</h4>
<p>
<strong>Alberto</strong> دیدگاه‌های بسیار خاصی در مورد نحوه اجرای <strong>event storming</strong> دارد، و در مورد برخی از این موارد من بسیار موافقم. اولاً، همه را در یک اتاق جمع کنید. این اغلب دشوارترین گام است—هماهنگ کردن تقویم افراد می‌تواند یک مشکل باشد، همانطور که یافتن یک اتاق به اندازه کافی بزرگ می‌تواند یک مشکل باشد. آن مسائل در یک دنیای قبل از <strong>COVID</strong> درست بود، اما همانطور که من این را در طول قرنطینه مرتبط با ویروس در بریتانیا می‌نویسم، می‌دانم که این مرحله ممکن است در آینده حتی مشکل‌سازتر باشد. با این حال، نکته کلیدی این است که همه ذی‌نفعان همزمان حضور داشته باشند. شما نمایندگانی از همه بخش‌های <strong>domain</strong> را که قصد دارید مدل‌سازی کنید می‌خواهید: کاربران، کارشناسان موضوع، مالکان محصول—هرکسی که بهترین موقعیت را برای کمک به نمایندگی از هر بخش <strong>domain</strong> دارد.
  </p>
<p>
   هنگامی که همه در یک اتاق جمع شدند، <strong>Alberto</strong> پیشنهاد می‌کند که همه صندلی‌ها را بردارید تا اطمینان حاصل شود که همه بلند می‌شوند و درگیر می‌شوند. به عنوان کسی که کمر درد دارد، در حالی که این استراتژی چیزی است که من درک می‌کنم، می‌دانم که ممکن است برای همه کارساز نباشد.
  </p>
<p>
   یک چیزی که من با <strong>Alberto</strong> در مورد آن موافقم، نیاز به داشتن یک فضای بزرگ است که در آن مدل‌سازی انجام شود. یک راه‌حل رایج این است که رول‌های بزرگی از کاغذ قهوه‌ای را به دیوارهای اتاق سنجاق کنید، و اجازه دهید از همه دیوارها برای ثبت اطلاعات استفاده شود.
  </p>
<p>
   ابزار مدل‌سازی اصلی، یادداشت‌های چسبنده برای ثبت مفاهیم مختلف است، و یادداشت‌های با رنگ‌های مختلف نشان‌دهنده مفاهیم مختلف هستند.
  </p>
<h4>فرآیند</h4>
<p>
   تمرین با شناسایی <strong>domain events</strong> توسط شرکت‌کنندگان شروع می‌شود. اینها نشان‌دهنده چیزهایی هستند که در سیستم اتفاق می‌افتند—آنها واقعیت‌هایی هستند که شما به آنها اهمیت می‌دهید. "<strong>Order Placed</strong>" رویدادی است که ما در زمینه <strong>MusicCorp</strong> به آن اهمیت می‌دهیم، همانطور که "<strong>Payment Received</strong>" نیز همینطور است. اینها روی یادداشت‌های چسبنده نارنجی ثبت شده‌اند. در این مرحله است که من یک اختلاف نظر دیگر با ساختار <strong>Alberto</strong> دارم، زیرا رویدادها دور و نزدیک به چیزهای متعددی هستند که شما ضبط می‌کنید، و به‌دست آوردن یادداشت‌های چسبنده نارنجی تعجب‌آور دشوار است.15
  </p>
<p>60 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0086</div>
            </div>
        </div>
        <!-- Page 0087 -->
        <div class="chapter" id="page-0087">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   16 <strong>Alberto Brandolini</strong>, <strong>EventStorming</strong> (Victoria, BC: Leanpub, forthcoming).
  </p>
<p>
   در مرحله بعد، شرکت‌کنندگان دستوراتی را شناسایی می‌کنند که باعث می‌شوند این <strong>events</strong> اتفاق بیفتند. یک <strong>command</strong> تصمیمی است که توسط یک انسان (یک کاربر نرم‌افزار) برای انجام کاری گرفته می‌شود. در اینجا شما در تلاشید تا <strong>boundary</strong> سیستم را درک کنید، و <strong>key human actors</strong> را در سیستم شناسایی کنید. <strong>Commands</strong> روی یادداشت‌های چسبنده آبی ثبت می‌شوند.
  </p>
<p>
   متخصصان فناوری در جلسه <strong>event storming</strong> باید به آنچه که همکاران غیرفنی خود در اینجا ارائه می‌دهند، گوش فرا دهند. یک بخش کلیدی از این تمرین این است که اجازه ندهید هیچ پیاده‌سازی فعلی، درک <strong>domain</strong> را تحریف کند (این بعداً خواهد آمد). در این مرحله شما می‌خواهید فضایی ایجاد کنید که در آن بتوانید مفاهیم را از ذهن ذی‌نفعان کلیدی خارج کنید و در معرض دید قرار دهید.
  </p>
<p>
   با ثبت <strong>events</strong> و <strong>commands</strong>، <strong>aggregates</strong> در مرحله بعد می‌آیند. <strong>events</strong> که در این مرحله دارید، نه تنها برای به اشتراک گذاشتن آنچه در سیستم اتفاق می‌افتد مفید هستند، بلکه شروع به برجسته کردن اینکه <strong>aggregates</strong> بالقوه چه چیزی می‌توانند باشند، می‌کنند. به رویداد <strong>domain</strong> ذکر شده "<strong>Order Placed</strong>" فکر کنید. اسم در اینجا—“<strong>Order</strong>”—می‌تواند یک <strong>aggregate</strong> بالقوه باشد. و "<strong>Placed</strong>" چیزی را توصیف می‌کند که می‌تواند برای یک سفارش اتفاق بیفتد، بنابراین این ممکن است بخشی از چرخه عمر <strong>aggregate</strong> باشد. <strong>Aggregates</strong> با یادداشت‌های چسبنده زرد نشان داده می‌شوند، و <strong>commands</strong> و <strong>events</strong> مرتبط با آن <strong>aggregate</strong> جابه‌جا می‌شوند و در اطراف <strong>aggregate</strong> خوشه‌بندی می‌شوند. این همچنین به شما کمک می‌کند تا درک کنید که <strong>aggregates</strong> چگونه با یکدیگر مرتبط هستند—<strong>events</strong> از یک <strong>aggregate</strong> ممکن است رفتاری را در دیگری ایجاد کند.
  </p>
<p>
   با شناسایی <strong>aggregates</strong>، آنها در <strong>bounded contexts</strong> گروه‌بندی می‌شوند. <strong>Bounded contexts</strong> معمولاً ساختار سازمانی یک شرکت را دنبال می‌کنند، و شرکت‌کنندگان در این تمرین در موقعیت خوبی قرار دارند تا درک کنند که چه <strong>aggregates</strong> توسط کدام بخش از سازمان استفاده می‌شود.
  </p>
<p>
   بیشتر از آنچه که من فقط توصیف کردم، برای <strong>event storming</strong> وجود دارد—این فقط به عنوان یک مرور اجمالی در نظر گرفته شده بود. برای نگاه دقیق‌تر به <strong>event storming</strong>، پیشنهاد می‌کنم کتاب (در حال حاضر در حال انجام) <strong>EventStorming</strong> توسط <strong>Alberto Brandolini</strong> (<strong>Leanpub</strong>) را مطالعه کنید.16
  </p>
<h4>The Case for Domain-Driven Design for Microservices</h4>
<p>
   ما بررسی کرده‌ایم که چگونه <strong>DDD</strong> می‌تواند در زمینه microservices کار کند، بنابراین بیایید خلاصه کنیم که چگونه این رویکرد برای ما مفید است.
  </p>
<p>
   اولاً، بخش بزرگی از آنچه که <strong>DDD</strong> را بسیار قدرتمند می‌کند این است که <strong>bounded contexts</strong>، که برای <strong>DDD</strong> بسیار مهم هستند، صریحاً در مورد پنهان کردن اطلاعات هستند—ارائه یک <strong>boundary</strong> روشن به سیستم گسترده‌تر در حالی که پیچیدگی داخلی را که می‌تواند بدون تأثیر بر سایر بخش‌های سیستم تغییر کند، پنهان می‌کند. این بدان معناست که وقتی ما از یک رویکرد <strong>DDD</strong> پیروی می‌کنیم، خواه متوجه آن شویم یا نه، ما همچنین <strong>information hiding</strong> را اتخاذ می‌کنیم—و همانطور که دیده‌ایم، این برای کمک به یافتن <strong>microservice boundaries</strong> پایدار حیاتی است.
  </p>
<p>The Case for Domain-Driven Design for Microservices | 61</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0087</div>
            </div>
        </div>
        <!-- Page 0088 -->
        <div class="chapter" id="page-0088">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   ثانیاً، تمرکز بر تعریف یک زبان مشترک و فراگیر، هنگام تعریف <strong>microservice endpoints</strong>، بسیار کمک می‌کند. این به طور مرتب یک واژگان مشترک را به ما می‌دهد که می‌توانیم هنگام ارائه <strong>APIs</strong>، قالب‌های رویداد، و موارد مشابه، از آن استفاده کنیم. همچنین به حل این مشکل کمک می‌کند که استانداردسازی <strong>APIs</strong> تا چه حد نیاز دارد که از نظر اجازه دادن به تغییر زبان در داخل <strong>bounded contexts</strong> پیش برود—تغییر در داخل یک <strong>boundary</strong> بر آن <strong>boundary</strong> تأثیر می‌گذارد.
  </p>
<p>
   تغییراتی که ما در سیستم خود پیاده‌سازی می‌کنیم اغلب در مورد تغییراتی است که <strong>business</strong> می‌خواهد در نحوه رفتار سیستم ایجاد کند. ما در حال تغییر <strong>functionality</strong>—قابلیت‌ها—هستیم که در معرض دید مشتریان ما قرار دارند. اگر سیستم‌های ما در امتداد <strong>bounded contexts</strong> که <strong>domain</strong> ما را نشان می‌دهند تجزیه شوند، احتمال اینکه هر تغییری که می‌خواهیم ایجاد کنیم به یک <strong>microservice boundary</strong> واحد منزوی شود، بیشتر است. این تعداد مکان‌هایی را که باید در آن تغییر ایجاد کنیم کاهش می‌دهد و به ما اجازه می‌دهد تا آن تغییر را سریعاً مستقر کنیم.
  </p>
<p>
   اساساً، <strong>DDD</strong>، <strong>business domain</strong> را در قلب نرم‌افزاری که در حال ساخت آن هستیم، قرار می‌دهد. تشویقی که به ما می‌دهد تا زبان <strong>business</strong> را وارد طراحی کد و <strong>service</strong> خود کنیم، به بهبود تخصص <strong>domain</strong> در بین افرادی که نرم‌افزار را می‌سازند کمک می‌کند. این به نوبه خود به ایجاد درک و همدلی برای کاربران نرم‌افزار ما کمک می‌کند و ارتباطات بیشتری را بین تحویل فنی، توسعه محصول و کاربران نهایی ایجاد می‌کند. اگر شما علاقه‌مند به حرکت به سمت تیم‌های <strong>stream-aligned</strong> هستید، <strong>DDD</strong> به عنوان یک مکانیسم برای کمک به همسو کردن معماری فنی با ساختار سازمانی گسترده‌تر، به خوبی عمل می‌کند. در جهانی که ما به طور فزاینده‌ای در تلاشیم تا سیلوها را بین <strong>IT</strong> و "<strong>business</strong>" از بین ببریم، این چیز بدی نیست.
  </p>
<h4>جایگزین‌هایی برای <strong>Business Domain Boundaries</strong></h4>
<p>
   همانطور که شرح دادم، <strong>DDD</strong> می‌تواند هنگام ساخت معماری‌های microservice بسیار مفید باشد، اما این اشتباه خواهد بود که فکر کنیم این تنها تکنیکی است که شما باید هنگام یافتن <strong>microservice boundaries</strong> در نظر بگیرید. در واقع، من اغلب از روش‌های متعددی در ارتباط با <strong>DDD</strong> برای کمک به شناسایی چگونگی (و اینکه آیا) یک سیستم باید تقسیم شود، استفاده می‌کنم. بیایید به برخی از عوامل دیگری که ممکن است هنگام یافتن <strong>boundaries</strong> در نظر بگیریم، نگاهی بیندازیم.
  </p>
<h4>فرّاریت</h4>
<p>
   من به طور فزاینده‌ای در مورد مخالفت با تجزیه <strong>domain-oriented</strong>، اغلب توسط طرفداران فرّاریت، شنیده‌ام که عامل اصلی تجزیه است. تجزیه مبتنی بر فرّاریت شما را وادار می‌کند تا بخش‌هایی از سیستم خود را که دچار تغییرات مکرر می‌شوند، شناسایی کنید و سپس آن <strong>functionality</strong> را به <strong>services</strong> خود استخراج کنید، جایی که می‌توانند به طور موثرتری روی آنها کار کرد. از نظر مفهومی، من با این موضوع مشکلی ندارم، اما ترویج آن به عنوان تنها راه انجام کارها مفید نیست، به خصوص زمانی که ما محرک‌های مختلفی را در نظر می‌گیریم که ممکن است ما را به سمت microservices سوق دهند. به عنوان مثال، اگر بزرگترین مشکل من مربوط به نیاز به مقیاس‌بندی برنامه من باشد، تجزیه و تحلیل مبتنی بر فرّاریت بعید است که مزایای زیادی را به همراه داشته باشد.
  </p>
<p>62 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0088</div>
            </div>
        </div>
        <!-- Page 0089 -->
        <div class="chapter" id="page-0089">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   ذهنیت پشت تجزیه مبتنی بر فرّاریت نیز در رویکردهایی مانند <strong>bimodal IT</strong> مشهود است. یک مفهوم که توسط <strong>Gartner</strong> مطرح شد، <strong>bimodal IT</strong> به زیبایی جهان را به دسته‌های نام‌های "حالت 1" (همچنین به عنوان <strong>Systems of Record</strong> شناخته می‌شود) و "حالت 2" (همچنین به عنوان <strong>Systems of Innovation</strong> شناخته می‌شود) بر اساس اینکه سیستم‌های مختلف با چه سرعتی (یا آهستگی) باید حرکت کنند، تقسیم می‌کند. به ما می‌گویند سیستم‌های حالت 1، زیاد تغییر نمی‌کنند و به مشارکت تجاری زیادی نیاز ندارند. حالت 2 جایی است که عملکرد در آن وجود دارد، با سیستم‌هایی که باید به سرعت تغییر کنند و نیاز به مشارکت نزدیک <strong>business</strong> دارند. صرف نظر از ساده‌سازی بیش از حد چشمگیر ذاتی در چنین طرح طبقه‌بندی، همچنین یک دیدگاه بسیار ثابت از جهان را نشان می‌دهد، و تضاد دارد با انواع تحولاتی که در سراسر صنعت مشهود است، زیرا شرکت‌ها به دنبال "دیجیتالی شدن" هستند. بخش‌هایی از سیستم‌های شرکت‌ها که در گذشته نیازی به تغییر چندانی نداشتند، ناگهان تغییر می‌کنند، تا فرصت‌های جدید بازار را باز کنند و <strong>services</strong> را به مشتریان خود به روش‌هایی ارائه دهند که قبلاً تصور نمی‌کردند.
  </p>
<p>
   بیایید به <strong>MusicCorp</strong> برگردیم. اولین ورود آن به آنچه که ما اکنون دیجیتال می‌نامیم، فقط داشتن یک صفحه وب بود. تمام چیزی که در اواسط دهه نود ارائه می‌داد، لیستی از آنچه برای فروش بود، اما شما باید با <strong>MusicCorp</strong> تماس می‌گرفتید تا سفارش را ثبت کنید. این چیزی بیش از یک آگهی در روزنامه نبود. سپس سفارش آنلاین تبدیل به یک چیز شد، و تمام انبار، که تا آن زمان فقط با کاغذ مدیریت می‌شد، باید دیجیتالی می‌شد. چه کسی می‌داند—شاید <strong>MusicCorp</strong> در مرحله‌ای مجبور شود در دسترس قرار دادن موسیقی به صورت دیجیتالی را در نظر بگیرد! اگرچه شما ممکن است در نظر بگیرید که <strong>MusicCorp</strong> عقب‌تر از زمان است، اما همچنان می‌توانید از میزان آشفتگی که شرکت‌ها متحمل شده‌اند، قدردانی کنید، زیرا آنها درک می‌کنند که چگونه تغییر فناوری و رفتار مشتری می‌تواند نیاز به تغییرات اساسی در بخش‌هایی از <strong>business</strong> داشته باشد که نمی‌توانستند به راحتی پیش‌بینی شوند.
  </p>
<p>
   من از <strong>bimodal IT</strong> به عنوان یک مفهوم متنفرم، زیرا این راهی می‌شود که افراد چیزهایی را که تغییر آنها دشوار است، در یک جعبه مرتب و زیبا بریزند و بگویند "ما نیازی به رسیدگی به مشکلات موجود در آنجا نداریم—این حالت 1 است." این مدل دیگری است که یک شرکت می‌تواند برای اطمینان از اینکه هیچ چیز واقعاً نیازی به تغییر ندارد، اتخاذ کند. همچنین از این واقعیت اجتناب می‌کند که اغلب تغییرات در <strong>functionality</strong>، نیازمند تغییراتی در "<strong>Systems of Record</strong>" (حالت 1) است تا امکان تغییرات در "<strong>Systems of Innovation</strong>" (حالت 2) را فراهم کند. به تجربه من، سازمان‌هایی که <strong>bimodal IT</strong> را اتخاذ می‌کنند، در نهایت دو سرعت دارند—آهسته و کندتر.
  </p>
<p>
   برای اینکه منصفانه به طرفداران تجزیه مبتنی بر فرّاریت عمل کنیم، بسیاری از آنها لزوماً چنین مدل‌های ساده‌ای مانند <strong>bimodal IT</strong> را توصیه نمی‌کنند. در واقع، من این تکنیک را بسیار مفید می‌دانم که به تعیین <strong>boundaries</strong> کمک می‌کند اگر محرک اصلی در مورد زمان سریع برای ورود به بازار باشد—استخراج <strong>functionality</strong> که در حال تغییر است یا نیاز به تغییر مکرر دارد، در چنین شرایطی کاملاً منطقی است. اما باز هم، هدف مکانیسم مناسب‌تر را تعیین می‌کند.
  </p>
<p>Alternatives to Business Domain Boundaries | 63</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0089</div>
            </div>
        </div>
        <!-- Page 0090 -->
        <div class="chapter" id="page-0090">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>داده‌ها</h4>
<p>
   ماهیت داده‌هایی که شما در اختیار دارید و مدیریت می‌کنید می‌تواند شما را به سمت اشکال مختلف تجزیه سوق دهد. به عنوان مثال، ممکن است بخواهید محدود کنید که کدام <strong>services</strong> اطلاعات شناسایی شخصی <strong>(PII)</strong> را مدیریت می‌کنند، هم برای کاهش خطر نقض داده‌های خود و هم برای ساده‌سازی نظارت و پیاده‌سازی چیزهایی مانند <strong>GDPR</strong>.
  </p>
<p>
   برای یکی از مشتریان اخیر من، یک شرکت پرداخت که ما آن را <strong>PaymentCo</strong> می‌نامیم، استفاده از انواع خاصی از داده‌ها مستقیماً بر تصمیماتی که در مورد تجزیه سیستم گرفتیم، تأثیر گذاشت. <strong>PaymentCo</strong> داده‌های کارت اعتباری را مدیریت می‌کند، به این معنی که سیستم آن باید با الزامات مختلف تعیین شده توسط استانداردهای صنعت کارت پرداخت <strong>(PCI)</strong> برای نحوه مدیریت این داده‌ها مطابقت داشته باشد. به عنوان بخشی از این انطباق، سیستم و فرآیندهای شرکت باید حسابرسی می‌شدند. <strong>PaymentCo</strong> نیاز به رسیدگی به داده‌های کامل کارت اعتباری داشت، و با حجمی که به این معنی بود که سیستم آن باید با <strong>PCI Level 1</strong> مطابقت داشته باشد، که سخت‌گیرانه‌ترین سطح است و نیاز به ارزیابی خارجی فصلی از سیستم‌ها و روش‌های مربوط به نحوه مدیریت داده‌ها دارد.
  </p>
<p>
   بسیاری از الزامات <strong>PCI</strong> عقل سلیم هستند، اما اطمینان از اینکه کل سیستم با این الزامات مطابقت دارد، نه کمترین نیاز به حسابرسی سیستم توسط یک طرف خارجی، بسیار دشوار بود. در نتیجه، این شرکت می‌خواست بخشی از سیستمی را که داده‌های کامل کارت اعتباری را مدیریت می‌کرد، جدا کند—به این معنی که فقط زیرمجموعه‌ای از سیستم به این سطح اضافی از نظارت نیاز داشت. در شکل 2-17، ما یک شکل ساده‌شده از طراحی که ارائه کردیم، را مشاهده می‌کنیم. <strong>Services</strong> که در <strong>green zone</strong> فعالیت می‌کنند (که با یک خط نقطه‌چین سبز محصور شده‌اند) هرگز هیچ اطلاعات کارت اعتباری را نمی‌بینند—آن داده‌ها به فرآیندها (و شبکه‌ها) در <strong>red zone</strong> (محاط شده با خطوط قرمز) محدود می‌شوند. <strong>gateway</strong>، <strong>calls</strong> را به <strong>services</strong> مناسب (و <strong>zone</strong> مناسب) منحرف می‌کند. با عبور اطلاعات کارت اعتباری از این <strong>gateway</strong>، در واقع نیز در <strong>red zone</strong> قرار دارد.
  </p>
<p>
   از آنجایی که اطلاعات کارت اعتباری هرگز به <strong>green zone</strong> وارد نمی‌شود، همه <strong>services</strong> در این ناحیه می‌توانند از یک حسابرسی کامل <strong>PCI</strong> معاف شوند. <strong>Services</strong> در <strong>red zone</strong> در محدوده این نظارت هستند. هنگام کار از طریق طراحی، ما تمام تلاش خود را کردیم تا آنچه را که باید در این <strong>red zone</strong> قرار گیرد، محدود کنیم. نکته کلیدی این است که ما باید اطمینان حاصل می‌کردیم که اطلاعات کارت اعتباری هرگز به <strong>green zone</strong> منتقل نمی‌شود—اگر یک microservice در <strong>green zone</strong> می‌توانست این اطلاعات را درخواست کند، یا اگر آن اطلاعات می‌توانست توسط یک microservice در <strong>red zone</strong> به <strong>green zone</strong> بازگردانده شود، در آن صورت خطوط واضح جداسازی از بین می‌رود.
  </p>
<p>
   جدا کردن داده‌ها اغلب توسط انواع نگرانی‌های حریم خصوصی و امنیتی هدایت می‌شود. ما در فصل 11 به این موضوع و مثال <strong>PaymentCo</strong> باز خواهیم گشت.
  </p>
<p>64 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0090</div>
            </div>
        </div>
        <!-- Page 0091 -->
        <div class="chapter" id="page-0091">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 2-17. <strong>PaymentCo</strong>، که فرآیندها را بر اساس استفاده از اطلاعات کارت اعتباری خود جدا می‌کند تا محدوده الزامات <strong>PCI</strong> را محدود کند
  </p>
<h4>فناوری</h4>
<p>
   نیاز به استفاده از فناوری‌های مختلف نیز می‌تواند یک عامل از نظر یافتن یک <strong>boundary</strong> باشد. شما می‌توانید پایگاه‌های داده مختلف را در یک microservice واحد در حال اجرا تطبیق دهید، اما اگر می‌خواهید مدل‌های <strong>runtime</strong> مختلف را ترکیب کنید، ممکن است با یک چالش مواجه شوید. اگر تعیین کنید که بخشی از <strong>functionality</strong> شما باید در یک <strong>runtime</strong> مانند <strong>Rust</strong> پیاده‌سازی شود، که به شما امکان می‌دهد بهبودهای عملکردی بیشتری داشته باشید، این یک عامل اجباری اصلی خواهد بود.
  </p>
<p>
   البته، ما باید از جایی که این می‌تواند ما را سوق دهد، اگر به عنوان یک وسیله عمومی از تجزیه اتخاذ شود، آگاه باشیم. معماری سه لایه کلاسیک که ما در فصل افتتاحیه در مورد آن بحث کردیم، و دوباره در شکل 2-18 نشان می‌دهیم، نمونه‌ای از فناوری مرتبط است که با هم گروه‌بندی شده است. همانطور که قبلاً بررسی کردیم، این اغلب یک معماری ایده‌آل نیست.
  </p>
<p>Alternatives to Business Domain Boundaries | 65</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 91" src="page_0091/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0091</div>
            </div>
        </div>
        <!-- Page 0092 -->
        <div class="chapter" id="page-0092">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 2-18. یک معماری سه لایه سنتی اغلب توسط <strong>technological boundaries</strong> هدایت می‌شود
  </p>
<h4>سازمانی</h4>
<p>
   همانطور که در فصل 1 <strong>Conway’s law</strong> را معرفی کردم، یک تعامل ذاتی بین ساختار سازمانی و معماری سیستمی که در نهایت به آن می‌رسید وجود دارد. جدا از مطالعاتی که این پیوند را نشان داده‌اند، در تجربه حکایتی خودم من بارها و بارها شاهد این موضوع بوده‌ام. نحوه سازماندهی شما در نهایت باعث می‌شود که معماری سیستم شما، چه خوب و چه بد، هدایت شود. وقتی صحبت از کمک به ما در تعریف <strong>service boundaries</strong> می‌شود، ما باید این را به عنوان یک بخش کلیدی از تصمیم‌گیری خود در نظر بگیریم.
  </p>
<p>
   تعریف یک <strong>service boundary</strong> که مالکیت آن از چندین تیم مختلف عبور کند، بعید است که نتایجی را که ما می‌خواهیم به دست آورد—همانطور که در فصل 15 بیشتر بررسی خواهیم کرد، مالکیت مشترک microservices یک امر مخاطره‌آمیز است. بنابراین نتیجه می‌گیریم که ما باید ساختار سازمانی موجود را هنگام در نظر گرفتن محل و زمان تعریف <strong>boundaries</strong> در نظر بگیریم، و در برخی شرایط، شاید حتی باید تغییر ساختار سازمانی را برای پشتیبانی از معماری که می‌خواهیم در نظر بگیریم.
  </p>
<p>
   البته، ما همچنین باید در نظر بگیریم که اگر ساختار سازمانی ما نیز تغییر کند، چه اتفاقی می‌افتد. آیا این بدان معناست که ما اکنون باید نرم‌افزار خود را دوباره معماری کنیم؟ خب، در بدترین حالت، ممکن است باعث شود که ما یک microservice موجود را که اکنون نیاز به تقسیم دارد، بررسی کنیم، زیرا حاوی <strong>functionality</strong> است که اکنون ممکن است متعلق به دو تیم جداگانه باشد، در حالی که قبلاً یک تیم واحد مسئول هر دو بخش بود. از سوی دیگر، اغلب
  </p>
<p>66 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 92" src="page_0092/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0092</div>
            </div>
        </div>
        <!-- Page 0093 -->
        <div class="chapter" id="page-0093">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   تغییرات سازمانی، فقط مستلزم این می‌شود که مالک یک microservice موجود تغییر کند. وضعیتی را در نظر بگیرید که در آن تیمی که مسئول عملیات انبارداری بود، قبلاً <strong>functionality</strong> را در اطراف تعیین تعداد اقلامی که باید از تامین‌کنندگان سفارش داده شوند، مدیریت می‌کرد. بیایید بگوییم که ما تصمیم گرفتیم این مسئولیت را به یک تیم پیش‌بینی اختصاصی منتقل کنیم که می‌خواهد اطلاعاتی را از فروش فعلی و تبلیغات برنامه‌ریزی‌شده برای تعیین آنچه که باید سفارش داده شود، بیرون بکشد. اگر تیم انبارداری یک microservice سفارش‌دهی تامین‌کننده اختصاصی داشت، این می‌توانست به سادگی به تیم پیش‌بینی جدید منتقل شود. از سوی دیگر، اگر این <strong>functionality</strong> قبلاً در یک سیستم با دامنه بزرگتر که متعلق به انبارداری بود، یکپارچه شده بود، در این صورت ممکن است لازم باشد که آن را تقسیم کنیم.
  </p>
<p>
   حتی زمانی که ما در یک ساختار سازمانی موجود کار می‌کنیم، این خطر وجود دارد که ما <strong>boundaries</strong> خود را در جای مناسب قرار ندهیم. سال‌ها پیش، من و چند همکار در کالیفرنیا با یک مشتری کار می‌کردیم و به شرکت کمک می‌کردیم تا برخی از روش‌های کدنویسی پاک‌تر را اتخاذ کند و بیشتر به سمت <strong>automated testing</strong> حرکت کند. ما با مقداری از <strong>low-hanging fruit</strong>، مانند تجزیه <strong>service</strong> شروع کرده بودیم، که متوجه چیز نگران‌کننده‌تری شدیم. من نمی‌توانم به جزئیات زیادی در مورد آنچه برنامه انجام می‌داد بپردازم، اما این یک برنامه عمومی با یک پایگاه مشتری بزرگ و جهانی بود.
  </p>
<p>
   تیم و سیستم، رشد کرده بودند. در اصل، دیدگاه یک نفر بود، سیستم ویژگی‌های بیشتری را در بر گرفته بود، و کاربران بیشتری را به خود اختصاص داده بود. سرانجام، سازمان تصمیم گرفت تا با داشتن یک گروه جدید از توسعه‌دهندگان مستقر در برزیل که بخشی از کار را بر عهده داشتند، ظرفیت تیم را افزایش دهد. سیستم تقسیم شد، و نیمه جلویی برنامه اساساً بدون <strong>state</strong> بود، و وب‌سایت عمومی را پیاده‌سازی می‌کرد، همانطور که در شکل 2-19 نشان داده شده است. نیمه پشتی سیستم به سادگی یک رابط <strong>remote procedure call (RPC)</strong> بر روی یک انبار داده بود. اساساً، تصور کنید که شما یک لایه <strong>repository</strong> را در <strong>codebase</strong> خود گرفته‌اید و این را یک <strong>service</strong> جداگانه کرده‌اید.
  </p>
<p>
   تغییرات اغلب باید در هر دو <strong>services</strong> ایجاد می‌شد. هر دو <strong>services</strong> از نظر فراخوانی متدهای سطح پایین و سبک <strong>RPC</strong> صحبت می‌کردند، که بیش از حد شکننده بودند (ما این موضوع را در فصل 4 بیشتر مورد بحث قرار خواهیم داد). <strong>service interface</strong> نیز بسیار پرحرف بود، که منجر به مشکلات عملکردی شد. این امر منجر به نیاز به مکانیزم‌های <strong>RPC-batching</strong> مفصل شد. من این را "معماری پیاز" نامیدم، زیرا لایه‌های زیادی داشت و وقتی مجبور شدیم از آن عبور کنیم، گریه کردم.
  </p>
<p>
   حالا، در ظاهر، ایده تقسیم سیستم قبلاً <strong>monolithic</strong> در امتداد خطوط جغرافیایی/سازمانی کاملاً منطقی است، همانطور که در فصل 15 در مورد آن بحث خواهیم کرد. با این حال، در اینجا، به جای گرفتن یک برش عمودی و متمرکز بر <strong>business</strong> از طریق <strong>stack</strong>، تیم چیزی را انتخاب کرد که قبلاً یک <strong>API</strong> در حال پردازش بود و یک برش افقی ایجاد کرد. یک مدل بهتر این بود که تیم در کالیفرنیا یک برش عمودی end-to-end داشته باشد، که شامل بخش‌های مرتبط <strong>frontend</strong> و <strong>data access functionality</strong> می‌شد، با تیم در برزیل که برش دیگری را می‌گرفت.
  </p>
<p>Alternatives to Business Domain Boundaries | 67</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0093</div>
            </div>
        </div>
        <!-- Page 0094 -->
        <div class="chapter" id="page-0094">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 2-19. یک <strong>service boundary</strong> که در سراسر <strong>technical seams</strong> تقسیم شده است
  </p>
<h4>Layering Inside Versus Layering Outside</h4>
<p>
   همانطور که امیدوارم تا الان دیده باشید، من طرفدار معماری لایه‌بندی شده افقی نیستم.
   با این حال، <strong>Layering</strong> می‌تواند جایگاه خود را داشته باشد. در داخل یک <strong>microservice boundary</strong>، کاملاً منطقی است که بین لایه‌های مختلف تمایز قائل شوید تا مدیریت کد آسان‌تر شود. اما مشکل زمانی پیش می‌آید که این <strong>layering</strong> به مکانیزمی تبدیل می‌شود که <strong>microservice</strong> و <strong>ownership boundaries</strong> شما بر اساس آن ترسیم می‌شوند.
  </p>
<h4>Mixing Models and Exceptions</h4>
<p>
   همانطور که امیدوارم تا به اینجا مشخص شده باشد، من از نظر چگونگی یافتن این <strong>boundaries</strong> متعصب نیستم. اگر از دستورالعمل‌های <strong>information hiding</strong> پیروی کنید و تعامل <em>coupling</em> و <em>cohesion</em> را درک کنید، احتمالاً از برخی از بدترین <strong>pitfalls</strong> هر مکانیسمی که انتخاب می‌کنید، اجتناب خواهید کرد. من فکر می‌کنم که با تمرکز بر این ایده‌ها، احتمال بیشتری دارد که به یک معماری <strong>domain-oriented</strong> ختم شوید، اما این در حال حاضر مطرح نیست.
  </p>
<p>
   با این حال، واقعیت این است که اغلب دلایلی برای ترکیب مدل‌ها وجود دارد، حتی اگر "<strong>domain-oriented</strong>" همان چیزی باشد که شما تصمیم می‌گیرید به عنوان مکانیسم اصلی خود برای تعریف <strong>microservice boundaries</strong> انتخاب کنید.
  </p>
<p>
   مکانیسم‌های مختلفی که تاکنون توضیح داده‌ایم نیز پتانسیل تعامل زیادی با یکدیگر دارند. خیلی محدود بودن در انتخاب‌های خود باعث می‌شود که شما از تعصب پیروی کنید تا اینکه کار درست را انجام دهید. تجزیه مبتنی بر فرّاریت می‌تواند
  </p>
<p>68 | Chapter 2: How to Model Microservices</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 94" src="page_0094/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0094</div>
            </div>
        </div>
        <!-- Page 0095 -->
        <div class="chapter" id="page-0095">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   17 Vaughn Vernon, Implementing Domain-Driven Design (Upper Saddle River, NJ: Addison-Wesley, 2013).
  </p>
<p>
   18 Vaughn Vernon, Domain-Driven Design Distilled (Boston: Addison-Wesley, 2016).
  </p>
<p>
   اگر تمرکز شما بر بهبود سرعت تحویل باشد، منطق زیادی دارد، اما اگر این باعث شود که <strong>service</strong> را استخراج کنید که از <strong>organizational boundaries</strong> عبور می‌کند، انتظار داشته باشید که سرعت تغییر شما به دلیل <strong>delivery contention</strong> آسیب ببیند.
  </p>
<p>
   من ممکن است یک <strong>Warehouse service</strong> خوب را بر اساس درک خود از <strong>business domain</strong> تعریف کنم، اما اگر بخشی از آن سیستم نیاز به پیاده‌سازی در <strong>C++</strong> و بخش دیگری در <strong>Kotlin</strong> داشته باشد، باید این‌بار براساس این خطوط فنی بیشتر تجزیه کنید.
  </p>
<p>
<strong>Organizational</strong> و <strong>domain-driven service boundaries</strong>، نقطه شروع من هستند. اما این فقط رویکرد پیش‌فرض من است. معمولاً، تعدادی از عواملی که در اینجا شرح داده‌ام وارد عمل می‌شوند، و اینکه کدام یک بر تصمیمات شما تأثیر می‌گذارد، بر اساس مشکلاتی است که شما در تلاش برای حل آنها هستید. شما باید به شرایط خاص خود نگاه کنید تا تعیین کنید چه چیزی برای شما بهترین است—و امیدوارم که چند گزینه مختلف برای در نظر گرفتن به شما داده باشم. فقط به یاد داشته باشید، اگر کسی بگوید "تنها راه انجام این کار X است!"، احتمالاً فقط در حال فروش تعصب بیشتری به شما هستند. شما می‌توانید بهتر از این عمل کنید.
  </p>
<p>
   با تمام این گفته‌ها، بیایید با بررسی <strong>domain-driven design</strong> با جزئیات بیشتر، به موضوع <strong>domain modeling</strong> بپردازیم.
  </p>
<h4>خلاصه</h4>
<p>
   در این فصل، شما کمی در مورد اینکه چه چیزی یک <strong>microservice boundary</strong> خوب را می‌سازد، و نحوه یافتن <strong>seams</strong> در <strong>problem space</strong> ما که مزایای دوگانه <em>coupling</em> کم و <em>cohesion</em> قوی را به ما می‌دهد، آموخته‌اید. داشتن درک دقیقی از <strong>domain</strong> ما می‌تواند یک ابزار حیاتی در کمک به ما در یافتن این <strong>seams</strong> باشد، و با همسو کردن microservicesهای خود با این <strong>boundaries</strong> ما اطمینان می‌دهیم که سیستم حاصل، تمام شانس خود را برای حفظ آن فضایل دست نخورده دارد. ما همچنین نکاتی در مورد چگونگی تقسیم بیشتر microservicesهایمان نیز دریافت کرده‌ایم.
  </p>
<p>
   ایده‌های ارائه شده در <em>Domain-Driven Design</em> نوشته <strong>Eric Evans</strong>، برای یافتن <strong>boundaries</strong> منطقی برای <strong>services</strong> ما بسیار مفید هستند، و من فقط در اینجا به آن اشاره کردم—کتاب <strong>Eric</strong> به جزئیات بیشتری می‌پردازد. اگر می‌خواهید عمیق‌تر شوید، می‌توانم کتاب <strong>Vaughn Vernon’s Implementing Domain-Driven Design</strong>17 را توصیه کنم تا به شما کمک کند تا جنبه‌های عملی این رویکرد را درک کنید، در حالی که <strong>Domain-Driven Design Distilled</strong> نوشته <strong>Vernon</strong>18 یک مرور کلی عالی است اگر به دنبال چیزی مختصرتر هستید.
  </p>
<p>
   بخش زیادی از این فصل نحوه یافتن <strong>boundary</strong> برای microservicesهایمان را توصیف کرده است. اما اگر در حال حاضر یک برنامه <strong>monolithic</strong> دارید و به دنبال مهاجرت به سمت معماری microservice هستید چه؟ این چیزی است که ما در فصل بعد با جزئیات بیشتری به آن خواهیم پرداخت.
  </p>
<p>Summary | 69</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0095</div>
            </div>
        </div>
        <!-- Page 0097 -->
        <div class="chapter" id="page-0097">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>CHAPTER 3</h3>
<h4>تقسیم <strong>Monolith</strong></h4>
<p>
   بسیاری از شما که این کتاب را می‌خوانید، احتمالاً یک صفحه خالی برای طراحی سیستم خود ندارید، و حتی اگر داشتید، شروع با microservices ممکن است ایده خوبی نباشد، به دلایلی که در فصل 1 بررسی کردیم. بسیاری از شما از قبل یک سیستم موجود دارید، شاید نوعی معماری <strong>monolithic</strong>، که به دنبال انتقال به یک معماری microservice هستید.
  </p>
<p>
   در این فصل، من چند مرحله اول، الگوها، و نکات کلی را برای کمک به شما در هدایت انتقال به معماری microservice بیان خواهم کرد.
  </p>
<h4>یک هدف داشته باشید</h4>
<p>
   Microservicesها هدف نیستند. شما با داشتن microservices "برنده" نمی‌شوید. اتخاذ یک معماری microservice باید یک تصمیم آگاهانه باشد، تصمیمی مبتنی بر تصمیم‌گیری منطقی. شما باید به فکر مهاجرت به یک معماری microservice باشید، فقط اگر نتوانید هیچ راه آسان‌تری برای حرکت به سمت هدف نهایی خود با معماری فعلی خود پیدا کنید.
  </p>
<p>
   بدون درک روشنی از آنچه که در تلاش برای دستیابی به آن هستید، ممکن است در دام سردرگمی فعالیت با نتیجه بیفتید. من تیم‌هایی را دیده‌ام که به ایجاد microservices وسواس داشتند، بدون اینکه هرگز بپرسند چرا. این بسیار مشکل‌ساز است با توجه به منابع جدید پیچیدگی که microservices می‌توانند معرفی کنند.
  </p>
<p>
   ثابت ماندن بر روی microservices به جای هدف نهایی، همچنین به این معنی است که شما احتمالاً از فکر کردن به راه‌های دیگری که ممکن است تغییر مورد نظر خود را ایجاد کنید، دست خواهید کشید. به عنوان مثال، microservices می‌تواند به شما در مقیاس‌بندی سیستم خود کمک کند، اما اغلب تعدادی از تکنیک‌های مقیاس‌بندی جایگزین وجود دارد که ابتدا باید به آنها نگاه کرد. راه‌اندازی چند کپی دیگر از سیستم <strong>monolithic</strong> موجود خود در پشت یک <strong>load balancer</strong> ممکن است به شما در مقیاس‌بندی سیستم خود بسیار مؤثرتر از گذراندن یک تجزیه پیچیده و طولانی به microservices کمک کند.
  </p>
<p>71</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0097</div>
            </div>
        </div>
        <!-- Page 0098 -->
        <div class="chapter" id="page-0098">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   Microservices آسان نیستند. ابتدا موارد ساده را امتحان کنید.
  </p>
<p>
   در نهایت، بدون یک هدف روشن، دانستن اینکه از کجا شروع کنیم دشوار می‌شود. کدام microservice را باید اول ایجاد کنید؟ بدون درک کلی از آنچه که در تلاش برای دستیابی به آن هستید، شما کورکورانه در حال پرواز هستید.
  </p>
<p>
   بنابراین در مورد تغییری که می‌خواهید به دست آورید روشن باشید، و راه‌های آسان‌تری را برای دستیابی به آن هدف نهایی قبل از در نظر گرفتن microservices در نظر بگیرید. اگر microservices واقعاً بهترین راه برای حرکت به جلو هستند، پیشرفت خود را در برابر آن هدف نهایی دنبال کنید و در صورت لزوم مسیر را تغییر دهید.
  </p>
<h4>مهاجرت افزایشی</h4>
<p>
   اگر یک بازنویسی <strong>big-bang</strong> انجام دهید، تنها چیزی که برای آن تضمین شده‌اید، یک <strong>big bang</strong> است.
   —Martin Fowler
  </p>
<p>
   اگر به این نتیجه رسیدید که جدا کردن سیستم <strong>monolithic</strong> موجود شما کار درستی است، من به شدت به شما توصیه می‌کنم که <strong>monolith</strong> را خرد کنید، و هر بار کمی از آن را استخراج کنید. یک رویکرد افزایشی به شما کمک می‌کند تا در حین پیشروی در مورد microservices اطلاعات کسب کنید و همچنین تأثیر اشتباه انجام دادن چیزی را محدود می‌کند (و شما مرتکب اشتباه خواهید شد!). <strong>Monolith</strong> ما را به عنوان یک بلوک مرمر در نظر بگیرید. ما می‌توانستیم کل آن را منفجر کنیم، اما این به ندرت خوب پیش می‌رود. بسیار منطقی‌تر است که فقط به صورت افزایشی آن را خرد کنیم.
  </p>
<p>
   شکستن چیزها به قطعات کوچکتر نیز به شما امکان می‌دهد تا برنده شدن‌های سریع را شناسایی کرده و از آنها یاد بگیرید. این می‌تواند به آسان‌تر شدن گام بعدی کمک کند و می‌تواند به ایجاد شتاب کمک کند.
  </p>
<p>
   با جدا کردن microservicesها یک به یک، شما همچنین ارزش آنها را به صورت افزایشی باز می‌کنید، به جای اینکه مجبور شوید منتظر یک استقرار <strong>big bang</strong> باشید.
  </p>
<p>
   همه اینها منجر به توصیه‌های من برای افرادی می‌شود که به microservices نگاه می‌کنند: اگر فکر می‌کنید microservices یک ایده خوب است، از یک نقطه کوچک شروع کنید. یک یا دو حوزه <strong>functionality</strong> را انتخاب کنید، آنها را به عنوان microservices پیاده‌سازی کنید، آنها را در تولید مستقر کنید، و سپس در مورد اینکه آیا ایجاد microservicesهای جدید شما به شما کمک کرده است که به هدف نهایی خود نزدیک‌تر شوید، تأمل کنید.
  </p>
<p>72 | Chapter 3: Splitting the Monolith</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 98" src="page_0098/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0098</div>
            </div>
        </div>
        <!-- Page 0099 -->
        <div class="chapter" id="page-0099">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شما قدر رعب و وحشت، درد و رنجی را که یک معماری microservice می‌تواند به ارمغان بیاورد، درک نخواهید کرد، تا زمانی که در <strong>production</strong> در حال اجرا باشید.
  </p>
<h4><strong>Monolith</strong> به ندرت دشمن است</h4>
<p>
   در حالی که من قبلاً در ابتدای کتاب این موضوع را مطرح کردم که برخی از اشکال معماری <strong>monolithic</strong> می‌تواند یک انتخاب کاملاً معتبر باشد، تکرار این نکته ضروری است که یک معماری <strong>monolithic</strong> ذاتاً بد نیست و بنابراین نباید به عنوان دشمن دیده شود.
  </p>
<p>
   بر روی "نداشتن <strong>monolith</strong>" تمرکز نکنید. در عوض، بر مزایایی که انتظار دارید تغییر معماری شما به ارمغان بیاورد، تمرکز کنید.
  </p>
<p>
   متداول است که معماری <strong>monolithic</strong> موجود پس از تغییر به سمت microservices باقی بماند، اگرچه اغلب در ظرفیت کاهش‌یافته است. به عنوان مثال، یک حرکت برای بهبود توانایی برنامه در رسیدگی به بار بیشتر ممکن است با حذف 10٪ از <strong>functionality</strong> که در حال حاضر گلوگاه است، برآورده شود، و 90٪ باقیمانده را در سیستم <strong>monolithic</strong> باقی بگذارد.
  </p>
<p>
   بسیاری از مردم واقعیت همزیستی یک <strong>monolith</strong> و microservices را "درهم و برهم" می‌دانند—اما معماری یک سیستم در حال اجرا در دنیای واقعی هرگز پاک یا دست‌نخورده نیست. اگر یک معماری "پاک" می‌خواهید، به هر وسیله‌ای یک نسخه ایده‌آل شده از معماری سیستم را که ممکن است داشته‌اید لمینت کنید، اگر فقط بینش کاملی و بودجه نامحدودی داشتید. معماری سیستم واقعی یک چیز دائماً در حال تکامل است که باید با تغییر نیازها و دانش، سازگار شود. مهارت در این ایده استفاده می‌شود، چیزی که من در فصل 16 به آن باز خواهم گشت.
  </p>
<p>
   با تبدیل مهاجرت خود به microservices به یک سفر افزایشی، شما می‌توانید معماری <strong>monolithic</strong> موجود را خرد کنید، و در طول مسیر بهبودهایی را ارائه دهید، در حالی که همچنین، مهمتر از همه، می‌دانید چه زمانی متوقف شوید.
  </p>
<p>
   در شرایطی که به طرز شگفت‌انگیزی نادر است، از بین رفتن <strong>monolith</strong> ممکن است یک نیاز سخت باشد. به تجربه من، این اغلب به موقعیت‌هایی محدود می‌شود که در آنها <strong>monolith</strong> موجود بر اساس فناوری مرده یا در حال مرگ است، به زیرساخت‌هایی گره خورده است که باید بازنشسته شود، یا شاید یک سیستم شخص ثالث گران‌قیمت باشد که می‌خواهید آن را کنار بگذارید. حتی در این شرایط، یک رویکرد افزایشی برای تجزیه به دلایلی که شرح داده‌ام، موجه است.
  </p>
<h4>خطرات تجزیه زودهنگام</h4>
<p>
   ایجاد microservices زمانی که شما درک روشنی از <strong>domain</strong> ندارید، خطرناک است. مثالی از مشکلاتی که این امر می‌تواند ایجاد کند از شرکت قبلی من، <strong>Thoughtworks</strong>، می‌آید. یکی از محصولات آن <strong>Snap CI</strong> بود، یک ابزار یکپارچه‌سازی مداوم و تحویل مداوم میزبانی شده (ما در فصل 7 در مورد آن مفاهیم بحث خواهیم کرد).
  </p>
<p>The Monolith Is Rarely the Enemy | 73</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 99" src="page_0099/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0099</div>
            </div>
        </div>
        <!-- Page 0100 -->
        <div class="chapter" id="page-0100">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   تیم قبلاً روی یک ابزار مشابه، <strong>GoCD</strong>، که اکنون یک ابزار تحویل مداوم <strong>open source</strong> است که می‌تواند به صورت محلی مستقر شود، به جای میزبانی در <strong>cloud</strong>، کار می‌کرد.
  </p>
<p>
   اگرچه در مراحل اولیه مقداری استفاده مجدد از کد بین پروژه‌های <strong>Snap CI</strong> و <strong>GoCD</strong> وجود داشت، اما در پایان <strong>Snap CI</strong> به یک <strong>codebase</strong> کاملاً جدید تبدیل شد. با این وجود، تجربه قبلی تیم در <strong>domain</strong> ابزار <strong>CD</strong> آنها را بر آن داشت تا در شناسایی <strong>boundaries</strong> و ساخت سیستم خود به عنوان مجموعه‌ای از microservices سریعتر عمل کنند.
  </p>
<p>
   با این حال، پس از گذشت چند ماه، مشخص شد که موارد استفاده از <strong>Snap CI</strong> به اندازه کافی متفاوت است که برداشت اولیه از <strong>service boundaries</strong> کاملاً درست نبود.
  </p>
<p>
   این امر منجر به ایجاد تغییرات زیادی در <strong>services</strong> شد، و یک هزینه مرتبط با تغییر زیاد. در نهایت، تیم <strong>services</strong> را دوباره در یک سیستم <strong>monolithic</strong> ادغام کرد، و به اعضای تیم زمان داد تا بهتر درک کنند که <strong>boundaries</strong> باید در کجا وجود داشته باشد. یک سال بعد، تیم توانست سیستم <strong>monolithic</strong> را به microservices تقسیم کند، که <strong>boundaries</strong> آن بسیار پایدارتر بود. این به هیچ وجه تنها نمونه از این وضعیت نیست که من دیده‌ام. تجزیه زودرس یک سیستم به microservices می‌تواند پرهزینه باشد، به خصوص اگر شما در <strong>domain</strong> جدید هستید. از بسیاری جهات، داشتن یک <strong>codebase</strong> موجود که می‌خواهید به microservices تجزیه کنید، به همین دلیل بسیار آسان‌تر است تا اینکه بخواهید از ابتدا به سمت microservices بروید.
  </p>
<h4>چه چیزی را ابتدا تقسیم کنیم؟</h4>
<p>
   هنگامی که شما درک کاملی از اینکه چرا فکر می‌کنید microservices یک ایده خوب است، دارید، می‌توانید از این درک برای کمک به اولویت‌بندی microservicesهایی که ابتدا ایجاد می‌کنید، استفاده کنید. آیا می‌خواهید برنامه را مقیاس‌بندی کنید؟ <strong>Functionality</strong> که در حال حاضر توانایی سیستم را در رسیدگی به بار محدود می‌کند، در صدر فهرست قرار خواهد داشت. آیا می‌خواهید زمان ورود به بازار را بهبود ببخشید؟ به فرّاریت سیستم نگاه کنید تا قطعات <strong>functionality</strong> را که بیشتر تغییر می‌کنند، شناسایی کنید، و ببینید که آیا آنها می‌توانند به عنوان microservices کار کنند یا خیر. شما می‌توانید از ابزارهای <strong>static analysis</strong> مانند <strong>CodeScene</strong> برای یافتن سریع بخش‌های فرّار <strong>codebase</strong> خود استفاده کنید. شما می‌توانید نمونه‌ای از یک نمای <strong>CodeScene</strong> را در شکل 3-1 ببینید، که در آن نقاط داغ را در پروژه <strong>open source Apache Zookeeper</strong> مشاهده می‌کنیم.
  </p>
<p>
   اما شما همچنین باید در نظر بگیرید که چه تجزیه‌هایی امکان‌پذیر هستند. برخی از <strong>functionality</strong>ها می‌توانند به قدری عمیق در برنامه <strong>monolithic</strong> موجود قرار گیرند که دیدن نحوه جدا شدن آنها غیرممکن است. یا شاید <strong>functionality</strong> مورد نظر برای برنامه بسیار حیاتی است که هر تغییری پرخطر تلقی می‌شود. از طرف دیگر، <strong>functionality</strong> که می‌خواهید مهاجرت کنید، ممکن است از قبل تا حدودی خودمحور باشد، و بنابراین استخراج آن بسیار ساده به نظر می‌رسد.
  </p>
<p>74 | Chapter 3: Splitting the Monolith</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0100</div>
            </div>
        </div>
        <!-- Page 0101 -->
        <div class="chapter" id="page-0101">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 3-1. نمای <strong>hotspot</strong> در <strong>CodeScene</strong>، که به شناسایی بخش‌هایی از <strong>codebase</strong> کمک می‌کند که مکرراً تغییر می‌کنند
  </p>
<p>
   اساساً، تصمیم در مورد اینکه کدام <strong>functionality</strong> را باید به یک microservice تقسیم کرد، در نهایت تعادلی بین این دو نیرو خواهد بود—چقدر استخراج آسان است در مقابل مزیت استخراج microservice در وهله اول.
  </p>
<p>
   توصیه من برای چند microservice اول این است که چیزهایی را انتخاب کنید که کمی بیشتر به سمت انتهای "آسان" طیف تمایل داشته باشند—یک microservice که ما فکر می‌کنیم از نظر دستیابی به هدف <strong>end-to-end</strong> ما تأثیری دارد، مطمئناً، اما چیزی که ما در نظر داریم که <strong>low-hanging fruit</strong> باشد. در یک انتقال مانند این، به خصوص انتقالی که می‌تواند ماه‌ها یا سال‌ها طول بکشد، کسب حس <strong>momentum</strong> در اوایل کار مهم است. بنابراین شما به برخی از بردهای سریع در زیر کمربند خود نیاز دارید.
  </p>
<p>
   از سوی دیگر، اگر سعی کنید آنچه را که ساده‌ترین microservice می‌دانید استخراج کنید و نتوانید آن را عملی کنید، ممکن است ارزش داشته باشد که دوباره در نظر بگیرید که آیا microservicesها واقعاً برای شما و سازمان شما مناسب هستند یا خیر.
  </p>
<p>What to Split First? | 75</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 101" src="page_0101/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0101</div>
            </div>
        </div>
        <!-- Page 0102 -->
        <div class="chapter" id="page-0102">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   با چند موفقیت و درس آموخته‌شده، شما در موقعیت بسیار بهتری برای مقابله با استخراج‌های پیچیده‌تر قرار خواهید گرفت، که ممکن است در حوزه‌های حیاتی‌تری از <strong>functionality</strong> نیز فعالیت کنند.
  </p>
<h4>تجزیه بر اساس لایه</h4>
<p>
   بنابراین شما اولین microservice خود را برای استخراج شناسایی کرده‌اید. قدم بعدی چیست؟ خب، ما می‌توانیم آن تجزیه را به مراحل کوچک‌تر دیگری تقسیم کنیم.
  </p>
<p>
   اگر سه لایه سنتی یک <strong>stack</strong> مبتنی بر <strong>web-based services</strong> را در نظر بگیریم، می‌توانیم به <strong>functionality</strong> که می‌خواهیم استخراج کنیم از نظر <strong>user interface</strong>، کد <strong>application backend</strong> و داده‌های آن نگاه کنیم.
  </p>
<p>
   نگاشت از یک microservice به یک <strong>user interface</strong> اغلب 1:1 نیست (این موضوعی است که ما در فصل 14 با عمق بیشتری بررسی می‌کنیم). به این ترتیب، استخراج <strong>user interface functionality</strong> مربوط به microservice می‌تواند یک گام جداگانه در نظر گرفته شود. من در اینجا در مورد نادیده گرفتن بخش <strong>user interface</strong> از معادله هشدار می‌دهم.
  </p>
<p>
   من سازمان‌های زیادی را دیده‌ام که فقط به مزایای تجزیه <strong>backend functionality</strong> نگاه می‌کنند، که اغلب منجر به یک رویکرد بیش از حد <strong>siloed</strong> برای هرگونه <strong>architectural restructuring</strong> می‌شود. گاهی اوقات بزرگترین مزایا می‌تواند از تجزیه <strong>UI</strong> حاصل شود، بنابراین این را به خطر خود نادیده بگیرید. اغلب تجزیه <strong>UI</strong> تمایل دارد که از تجزیه <strong>backend</strong> به microservices عقب بماند، زیرا تا زمانی که microservices در دسترس نباشند، دیدن امکانات تجزیه <strong>UI</strong> دشوار است. فقط مطمئن شوید که بیش از حد عقب نمی‌ماند.
  </p>
<p>
   اگر سپس به کد <strong>backend</strong> و <strong>storage</strong> مرتبط نگاه کنیم، برای هر دو بسیار حیاتی است که هنگام استخراج یک microservice در محدوده قرار داشته باشند. بیایید شکل 3-2 را در نظر بگیریم، که در آن ما به دنبال استخراج <strong>functionality</strong> مرتبط با مدیریت <strong>wishlist</strong> یک مشتری هستیم. مقداری کد <strong>application</strong> وجود دارد که در <strong>monolith</strong> وجود دارد، و مقداری ذخیره‌سازی داده‌های مرتبط در پایگاه داده وجود دارد. پس کدام بخش را باید ابتدا استخراج کنیم؟
  </p>
<p>76 | Chapter 3: Splitting the Monolith</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0102</div>
            </div>
        </div>
        <!-- Page 0103 -->
        <div class="chapter" id="page-0103">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 3-2. کد و داده‌های <strong>wishlist</strong> در برنامه <strong>monolithic</strong> موجود
  </p>
<h4>ابتدا کد</h4>
<p>
   در شکل 3-3، ما کد مرتبط با <strong>wishlist functionality</strong> را به یک microservice جدید استخراج کرده‌ایم. داده‌های مربوط به <strong>wishlist</strong> در این مرحله در پایگاه داده <strong>monolithic</strong> باقی می‌ماند—ما تجزیه را کامل نکرده‌ایم تا زمانی که داده‌های مرتبط با microservice <strong>Wishlist</strong> جدید را نیز منتقل کنیم.
  </p>
<p>
   شکل 3-3. ابتدا کد <strong>wishlist</strong> را به یک microservice جدید منتقل می‌کنیم و داده‌ها را در پایگاه داده <strong>monolithic</strong> باقی می‌گذاریم.
  </p>
<p>Decomposition by Layer | 77</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 103" src="page_0103/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 103" src="page_0103/image_2.png"/></div>
</div>
                <div class="page-number">صفحه 0103</div>
            </div>
        </div>
        <!-- Page 0104 -->
        <div class="chapter" id="page-0104">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   به تجربه من، این معمولاً رایج‌ترین گام اول است. دلیل اصلی این امر این است که تمایل دارد مزایای بیشتری در کوتاه مدت ارائه دهد. اگر داده‌ها را در پایگاه داده <strong>monolithic</strong> باقی بگذاریم، رنج زیادی را برای آینده ذخیره می‌کنیم، بنابراین این هم باید مورد توجه قرار گیرد، اما ما از microservice جدید خود سود زیادی برده‌ایم.
  </p>
<p>
   استخراج کد <strong>application</strong> معمولاً آسان‌تر از استخراج چیزها از پایگاه داده است. اگر متوجه شدیم که استخراج تمیز کد <strong>application</strong> غیرممکن است، می‌توانیم هر کار دیگری را متوقف کنیم و از نیاز به جداسازی پایگاه داده اجتناب کنیم. با این حال، اگر کد <strong>application</strong> به طور تمیز استخراج شود اما استخراج داده‌ها غیرممکن شود، ممکن است دچار مشکل شویم—بنابراین ضروری است که حتی اگر تصمیم دارید کد <strong>application</strong> را قبل از داده‌ها استخراج کنید، باید به <strong>data storage</strong> مرتبط نگاه کرده باشید و ایده‌ای داشته باشید که آیا استخراج امکان‌پذیر است و چگونه می‌خواهید آن را انجام دهید. بنابراین کارهای لازم را انجام دهید تا نحوه استخراج کد <strong>application</strong> و داده‌ها را قبل از شروع، ترسیم کنید.
  </p>
<h4>ابتدا داده‌ها</h4>
<p>
   در شکل 3-4، ما می‌بینیم که داده‌ها ابتدا، قبل از کد <strong>application</strong> استخراج می‌شوند. من این رویکرد را کمتر می‌بینم، اما در موقعیت‌هایی که شما مطمئن نیستید آیا داده‌ها را می‌توان به طور تمیز جدا کرد، می‌تواند مفید باشد. در اینجا، شما ثابت می‌کنید که این کار را می‌توان قبل از ادامه کار در استخراج کد <strong>application</strong> که امیدوارانه آسان‌تر است، انجام داد.
  </p>
<p>
   شکل 3-4. جداول مرتبط با <strong>wishlist functionality</strong> ابتدا استخراج می‌شوند
  </p>
<p>
   مزیت اصلی این رویکرد در کوتاه مدت، کاهش خطر استخراج کامل microservice است. شما را مجبور می‌کند که از قبل با مسائلی مانند از دست رفتن یکپارچگی داده‌های اعمال شده در پایگاه داده خود یا کمبود عملیات <strong>transactional</strong> در هر دو مجموعه داده‌ها مقابله کنید.
  </p>
<p>
   ما بعداً در این فصل به طور خلاصه به پیامدهای هر دو موضوع اشاره خواهیم کرد.
  </p>
<p>78 | Chapter 3: Splitting the Monolith</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 104" src="page_0104/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0104</div>
            </div>
        </div>
        <!-- Page 0105 -->
        <div class="chapter" id="page-0105">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   1 <strong>Sam Newman</strong>, Monolith to Microservices (Sebastopol: O’Reilly, 2019).
  </p>
<h4>الگوهای تجزیه مفید</h4>
<p>
   تعدادی از الگوها می‌توانند در کمک به جدا کردن یک سیستم موجود مفید باشند. بسیاری از این موارد با جزئیات در کتاب من <em>Monolith to Microservices</em> بررسی شده است.1 به جای تکرار همه آنها در اینجا، من مروری بر برخی از آنها را به اشتراک خواهم گذاشت تا به شما ایده‌ای از آنچه امکان‌پذیر است، ارائه دهم.
  </p>
<h4>Strangler Fig Pattern</h4>
<p>
   یک تکنیک که در طول بازنویسی سیستم مورد استفاده مکرر قرار گرفته است، <strong>strangler fig pattern</strong> است، اصطلاحی که توسط <strong>Martin Fowler</strong> ابداع شده است. این الگو که از نوعی گیاه الهام گرفته شده است، فرآیند پیچیدن یک سیستم قدیمی با سیستم جدید را در طول زمان توصیف می‌کند، و به سیستم جدید اجازه می‌دهد که به طور فزاینده‌ای ویژگی‌های بیشتری از سیستم قدیمی را در اختیار بگیرد.
  </p>
<p>
   رویکرد همانطور که در شکل 3-5 نشان داده شده است، ساده است. شما تماس‌ها را به سیستم موجود—در مورد ما برنامه <strong>monolithic</strong> موجود—رهگیری می‌کنید. اگر فراخوانی به آن بخش از <strong>functionality</strong> در معماری microservice جدید ما پیاده‌سازی شود، به microservice هدایت می‌شود. اگر <strong>functionality</strong> هنوز توسط <strong>monolith</strong> ارائه می‌شود، به تماس اجازه داده می‌شود که به خود <strong>monolith</strong> ادامه دهد.
  </p>
<p>
   شکل 3-5. مروری بر <strong>strangler fig pattern</strong>
</p>
<p>Useful Decompositional Patterns | 79</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 105" src="page_0105/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0105</div>
            </div>
        </div>
        <!-- Page 0106 -->
        <div class="chapter" id="page-0106">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   2 Pete Hodgson, “Feature Toggles (aka Feature Flags),” martinfowler.com, October 9, 2017, https://oreil.ly/
   XiU2t.
  </p>
<p>
   زیبایی این الگو این است که اغلب می‌تواند بدون ایجاد هیچ تغییری در برنامه <strong>monolithic</strong> زیربنایی انجام شود. <strong>Monolith</strong> از اینکه حتی با یک سیستم جدیدتر "محصور" شده است، بی‌اطلاع است.
  </p>
<h4>اجرای موازی</h4>
<p>
   هنگام تغییر از <strong>functionality</strong> ارائه شده توسط یک معماری <strong>application architecture</strong> موجود و آزمایش‌شده به یک معماری جدید مبتنی بر microservice، ممکن است مقداری عصبی‌شدن وجود داشته باشد، به خصوص اگر <strong>functionality</strong> که در حال مهاجرت است برای سازمان شما حیاتی باشد.
  </p>
<p>
   یک راه برای اطمینان از اینکه <strong>functionality</strong> جدید به خوبی کار می‌کند، بدون به خطر انداختن رفتار سیستم موجود، استفاده از الگوی <strong>parallel run</strong> است: اجرای همزمان پیاده‌سازی <strong>monolithic</strong> <strong>functionality</strong> شما و پیاده‌سازی microservice جدید، ارائه درخواست‌های یکسان، و مقایسه نتایج. ما این الگو را با جزئیات بیشتری در “<strong>Parallel Run</strong>” در صفحه 272 بررسی خواهیم کرد.
  </p>
<h4>Feature Toggle</h4>
<p>
   یک <strong>feature toggle</strong> یک مکانیسم است که به یک ویژگی اجازه می‌دهد خاموش یا روشن شود، یا بین دو پیاده‌سازی مختلف از برخی <strong>functionality</strong> جابه‌جا شود. <strong>feature toggle</strong> یک الگو است که قابلیت کاربرد عمومی خوبی دارد، اما می‌تواند به ویژه به عنوان بخشی از یک مهاجرت microservice مفید باشد.
  </p>
<p>
   همانطور که با <strong>strangler fig application</strong> توضیح دادم، ما اغلب <strong>functionality</strong> موجود را در طول انتقال در جای خود در <strong>monolith</strong> باقی می‌گذاریم، و ما می‌خواهیم توانایی جابه‌جایی بین نسخه‌های <strong>functionality</strong>—<strong>functionality</strong> در <strong>monolith</strong> و آن در microservice جدید—را داشته باشیم. با مثال <strong>strangler fig pattern</strong> با استفاده از یک <strong>HTTP proxy</strong>، می‌توانیم <strong>feature toggle</strong> را در لایه <strong>proxy</strong> پیاده‌سازی کنیم تا امکان کنترل ساده‌ای برای جابه‌جایی بین پیاده‌سازی‌ها فراهم کنیم.
  </p>
<p>
   برای معرفی گسترده‌تر به <strong>feature toggles</strong>، من مقاله <strong>“Feature Toggles (aka Feature Flags)”</strong> نوشته <strong>Pete Hodgson</strong> را توصیه می‌کنم.2
  </p>
<p>80 | Chapter 3: Splitting the Monolith</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0106</div>
            </div>
        </div>
        <!-- Page 0107 -->
        <div class="chapter" id="page-0107">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   3 بدیهی است، این یک ساده‌سازی از شکل یک سیستم دنیای واقعی خواهد بود. به عنوان مثال، منطقی به نظر می‌رسد که ما ثبت کنیم که یک کالا را با چه قیمتی فروخته‌ایم در یک <strong>financial ledger</strong>!
  </p>
<h4>نگرانی‌های تجزیه داده‌ها</h4>
<p>
   وقتی شروع به جدا کردن پایگاه‌های داده می‌کنیم، می‌توانیم باعث ایجاد تعدادی مشکل شویم. در اینجا چند مورد از چالش‌هایی وجود دارد که ممکن است با آنها روبرو شوید، و برخی نکات برای کمک.
  </p>
<h4>عملکرد</h4>
<p>
   پایگاه‌های داده، به ویژه پایگاه‌های داده رابطه‌ای، در اتصال داده‌ها در جداول مختلف خوب هستند. خیلی خوب. در واقع، آنقدر خوب است که ما این را بدیهی می‌گیریم. با این حال، اغلب، وقتی پایگاه‌های داده را به نام microservices از هم جدا می‌کنیم، در نهایت باید عملیات <strong>join</strong> را از <strong>data tier</strong> به خود microservices منتقل کنیم. و با وجود تلاش ما، بعید است که این کار به همان سرعتی انجام شود.
  </p>
<p>
   شکل 3-6 را در نظر بگیرید، که موقعیتی را نشان می‌دهد که ما در رابطه با <strong>MusicCorp</strong> در آن قرار داریم. ما تصمیم گرفته‌ایم <strong>catalog functionality</strong> خود را استخراج کنیم—چیزی که می‌تواند اطلاعاتی در مورد هنرمندان، آهنگ‌ها، و آلبوم‌ها مدیریت و ارائه دهد. در حال حاضر، کد مرتبط با کاتالوگ ما در داخل <strong>monolith</strong> از یک جدول <strong>Albums</strong> برای ذخیره اطلاعات در مورد سی‌دی‌هایی که ممکن است برای فروش داشته باشیم، استفاده می‌کند. این آلبوم‌ها در نهایت در جدول <strong>Ledger</strong> ما <strong>referenced</strong> می‌شوند، که در آن ما تمام فروش‌ها را پیگیری می‌کنیم. ردیف‌ها در جدول <strong>Ledger</strong> تاریخ فروش یک کالا را به همراه یک شناسه که به کالای فروخته شده اشاره دارد، ثبت می‌کنند. شناسه در مثال ما، <strong>SKU (stock keeping unit)</strong> نامیده می‌شود، یک عمل رایج در سیستم‌های خرده‌فروشی.3
  </p>
<p>
   در پایان هر ماه، ما باید گزارشی را تولید کنیم که پرفروش‌ترین سی‌دی‌های ما را نشان دهد. جدول <strong>Ledger</strong> به ما کمک می‌کند تا بفهمیم کدام <strong>SKU</strong> بیشترین تعداد کپی را فروخته است، اما اطلاعات مربوط به آن <strong>SKU</strong> در جدول <strong>Albums</strong> است. ما می‌خواهیم گزارش‌ها را زیبا و آسان بخوانیم، بنابراین به جای اینکه بگوییم، "ما 400 نسخه از <strong>SKU 123</strong> فروختیم و 1596 دلار درآمد داشتیم"، اطلاعات بیشتری در مورد آنچه فروخته شده است، اضافه می‌کنیم و در عوض می‌گوییم، "ما 400 نسخه از <strong>Now That’s What I Call Death Polka</strong> فروختیم و 1596 دلار درآمد داشتیم." برای انجام این کار، <strong>database query</strong> که توسط کد مالی ما فعال می‌شود، باید اطلاعات را از جدول <strong>Ledger</strong> به جدول <strong>Albums</strong> متصل کند، همانطور که شکل 3-6 نشان می‌دهد.
  </p>
<p>Data Decomposition Concerns | 81</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0107</div>
            </div>
        </div>
        <!-- Page 0108 -->
        <div class="chapter" id="page-0108">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 3-6. یک عملیات <strong>join</strong> در پایگاه داده <strong>monolithic</strong>
</p>
<p>
   در دنیای جدید مبتنی بر microservice، microservice <strong>Finance</strong> جدید ما مسئولیت تولید گزارش پرفروش‌ترین‌ها را دارد، اما داده‌های آلبوم را به صورت محلی ندارد. بنابراین باید این داده‌ها را از microservice جدید <strong>Catalog</strong> خود واکشی کند، همانطور که در شکل 3-7 نشان داده شده است. هنگام تولید گزارش، microservice <strong>Finance</strong> ابتدا جدول <strong>Ledger</strong> را <strong>queries</strong> می‌کند، و فهرستی از پرفروش‌ترین <strong>SKUs</strong> را برای ماه گذشته استخراج می‌کند. در این مرحله، تنها اطلاعاتی که ما به صورت محلی داریم، فهرستی از <strong>SKUs</strong> و تعداد نسخه‌های فروخته شده برای هر <strong>SKU</strong> است.
  </p>
<p>82 | Chapter 3: Splitting the Monolith</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 108" src="page_0108/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0108</div>
            </div>
        </div>
        <!-- Page 0109 -->
        <div class="chapter" id="page-0109">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 3-7. جایگزینی یک عملیات <strong>database join</strong> با <strong>service calls</strong>
</p>
<p>
   بعد، ما باید microservice <strong>Catalog</strong> را فراخوانی کنیم و اطلاعاتی را در مورد هر یک از این <strong>SKUs</strong> درخواست کنیم. این درخواست به نوبه خود باعث می‌شود که microservice <strong>Catalog</strong> خود، <strong>SELECT</strong> محلی خود را در پایگاه داده خود انجام دهد.
  </p>
<p>
   از نظر منطقی، عملیات <strong>join</strong> هنوز در حال وقوع است، اما اکنون در داخل microservice <strong>Finance</strong> به جای پایگاه داده در حال انجام است. <strong>join</strong> از <strong>data tier</strong> به <strong>application code tier</strong> رفته است. متأسفانه، این عملیات به هیچ وجه نزدیک به کارآمدی نخواهد بود، اگر <strong>join</strong> در پایگاه داده باقی می‌ماند.
  </p>
<p>
   ما از جهانی که در آن یک دستور <strong>SELECT</strong> واحد داریم، به یک دنیای جدید رفته‌ایم که در آن یک <strong>SELECT query</strong> در برابر جدول <strong>Ledger</strong> داریم، و به دنبال آن یک فراخوانی به microservice <strong>Catalog</strong>، که به نوبه خود یک عبارت <strong>SELECT</strong> را در برابر جدول <strong>Albums</strong> فعال می‌کند، همانطور که در شکل 3-7 می‌بینیم.
  </p>
<p>
   در این شرایط، من بسیار شگفت‌زده می‌شوم اگر <strong>latency</strong> کلی این عملیات افزایش نیابد. این ممکن است در این مورد خاص مشکل چندانی نباشد، زیرا این گزارش ماهانه تولید می‌شود و بنابراین می‌تواند با شدت ذخیره شود (ما این موضوع را با جزئیات بیشتری در "<strong>Caching</strong>" در صفحه 435 بررسی خواهیم کرد). اما اگر این یک عملیات مکرر باشد، این می‌تواند مشکل‌سازتر باشد. ما می‌توانیم تأثیر احتمالی این افزایش <strong>latency</strong> را با اجازه دادن به <strong>SKUs</strong> برای جستجو در microservice <strong>Catalog</strong> به صورت <strong>bulk</strong>، یا شاید حتی با <strong>caching</strong> اطلاعات آلبوم مورد نیاز به صورت محلی، کاهش دهیم.
  </p>
<p>Data Decomposition Concerns | 83</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 109" src="page_0109/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0109</div>
            </div>
        </div>
        <!-- Page 0110 -->
        <div class="chapter" id="page-0110">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>یکپارچگی داده‌ها</h4>
<p>
   پایگاه‌های داده می‌توانند در اطمینان از یکپارچگی داده‌های ما مفید باشند. بازگشت به شکل 3-6، با وجود اینکه جداول <strong>Album</strong> و <strong>Ledger</strong> در یک پایگاه داده یکسان هستند، ما می‌توانیم (و احتمالاً انجام خواهیم داد) یک رابطه کلید خارجی بین ردیف‌های جدول <strong>Ledger</strong> و جدول <strong>Album</strong> تعریف کنیم. این امر اطمینان می‌دهد که ما همیشه می‌توانیم از یک رکورد در جدول <strong>Ledger</strong> به اطلاعاتی در مورد آلبوم فروخته شده، حرکت کنیم، زیرا اگر رکوردهایی در جدول <strong>Album</strong> به <strong>Ledger</strong> ارجاع داده شده‌اند، قادر به حذف آنها نخواهیم بود.
  </p>
<p>
   با این جداول که اکنون در پایگاه‌های داده مختلف قرار دارند، ما دیگر اعمال یکپارچگی مدل داده‌های خود را نداریم. هیچ چیز مانع از حذف یک ردیف در جدول <strong>Album</strong> نمی‌شود و باعث ایجاد مشکلی می‌شود وقتی که ما سعی می‌کنیم دقیقاً دریابیم که چه کالایی فروخته شده است.
  </p>
<p>
   تا حدی، شما به سادگی باید به این واقعیت عادت کنید که دیگر نمی‌توانید برای اجرای یکپارچگی روابط بین موجودیت‌ها به پایگاه داده خود اعتماد کنید. بدیهی است، برای داده‌هایی که در یک پایگاه داده واحد باقی می‌مانند، این یک مشکل نیست.
  </p>
<p>
   تعدادی راه‌حل وجود دارد، اگرچه "الگوهای مقابله" اصطلاح بهتری برای راه‌هایی است که ما ممکن است با این مشکل برخورد کنیم. ما می‌توانیم از یک <strong>soft delete</strong> در جدول <strong>Album</strong> استفاده کنیم تا در واقع یک رکورد را حذف نکنیم، بلکه فقط آن را به عنوان حذف شده علامت‌گذاری کنیم. یک گزینه دیگر می‌تواند این باشد که نام آلبوم را هنگام فروش در جدول <strong>Ledger</strong> کپی کنیم، اما ما باید نحوه مدیریت همگام‌سازی تغییرات در نام آلبوم را حل کنیم.
  </p>
<h4>تراکنش‌ها</h4>
<p>
   بسیاری از ما به ضمانت‌هایی که از مدیریت داده‌ها در تراکنش‌ها دریافت می‌کنیم، تکیه کرده‌ایم. بر اساس آن اطمینان، ما برنامه‌هایی را به روشی خاص ساخته‌ایم، با این علم که می‌توانیم به پایگاه داده تکیه کنیم تا تعدادی از موارد را برای ما مدیریت کند. با این حال، هنگامی که شروع به تقسیم داده‌ها در چندین پایگاه داده می‌کنیم، ایمنی تراکنش‌های <strong>ACID</strong> را که به آنها عادت کرده‌ایم، از دست می‌دهیم. (من سرنام <strong>ACID</strong> را توضیح می‌دهم و در فصل 6 در مورد تراکنش‌های <strong>ACID</strong> با جزئیات بیشتری بحث می‌کنم.)
  </p>
<p>
   برای افرادی که از سیستمی حرکت می‌کنند که در آن همه تغییرات <strong>state</strong> می‌توانست در یک <strong>transactional boundary</strong> واحد مدیریت شود، تغییر به سیستم‌های توزیع‌شده می‌تواند یک شوک باشد، و اغلب واکنش این است که به دنبال پیاده‌سازی تراکنش‌های توزیع‌شده بگردیم تا ضمانت‌هایی را که تراکنش‌های <strong>ACID</strong> به ما دادند را با معماری‌های ساده‌تر به دست آوریم. متأسفانه، همانطور که در “Database Transactions” در صفحه 175 به تفصیل بررسی خواهیم کرد، تراکنش‌های توزیع‌شده نه تنها در پیاده‌سازی پیچیده هستند، حتی زمانی که به خوبی انجام شوند، بلکه در واقع همان تضمین‌هایی را که ما انتظار داشتیم در تراکنش‌های پایگاه داده با دامنه محدودتر داشته باشیم، به ما نمی‌دهند.
  </p>
<p>
   همانطور که در “<strong>Sagas</strong>” در صفحه 182 به بررسی آن می‌پردازیم، مکانیسم‌های جایگزین (و ترجیحی) برای تراکنش‌های توزیع‌شده برای مدیریت تغییرات <strong>state</strong> در چندین microservices وجود دارد، اما آنها منابع جدیدی از پیچیدگی را به همراه دارند. مانند یکپارچگی داده‌ها،
  </p>
<p>84 | Chapter 3: Splitting the Monolith</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0110</div>
            </div>
        </div>
        <!-- Page 0111 -->
        <div class="chapter" id="page-0111">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   ما باید با این واقعیت کنار بیاییم که با جدا کردن پایگاه‌های داده خود به دلایلی که ممکن است بسیار خوب باشند، با مجموعه جدیدی از مشکلات مواجه خواهیم شد.
  </p>
<h4>ابزارها</h4>
<p>
   تغییر پایگاه‌های داده به دلایل زیادی دشوار است، که یکی از آنها این است که ابزارهای محدودی برای ایجاد تغییرات آسان در دسترس هستند. با کد، ما ابزارهای <strong>refactoring</strong> را در <strong>IDEs</strong> خود ساخته‌ایم، و ما این مزیت را داریم که سیستم‌هایی که در حال تغییر آنها هستیم اساساً <strong>stateless</strong> هستند. با یک پایگاه داده، چیزهایی که ما در حال تغییر آنها هستیم، <strong>state</strong> دارند، و ما همچنین فاقد ابزارهای مناسب از نوع <strong>refactoring</strong> هستیم.
  </p>
<p>
   ابزارهای زیادی وجود دارد که به شما کمک می‌کند تا فرآیند تغییر <strong>schema</strong> یک پایگاه داده رابطه‌ای را مدیریت کنید، اما بیشتر آنها از الگوی یکسانی پیروی می‌کنند. هر تغییر <strong>schema</strong> در یک اسکریپت <strong>delta</strong> کنترل‌شده با نسخه تعریف می‌شود. سپس این اسکریپت‌ها به ترتیب دقیق و به روشی <strong>idempotent</strong> اجرا می‌شوند. <strong>Rails migrations</strong> به این ترتیب کار می‌کنند، همانطور که <strong>DBDeploy</strong>، ابزاری که من سال‌ها پیش در ایجاد آن کمک کردم، اینگونه بود.
  </p>
<p>
   امروزه من افراد را به <strong>Flyway</strong> یا <strong>Liquibase</strong> ارجاع می‌دهم تا به همان نتیجه برسند، اگر از قبل ابزاری ندارند که به این ترتیب کار کند.
  </p>
<h4>پایگاه داده گزارش‌دهی</h4>
<p>
   به عنوان بخشی از استخراج microservices از برنامه <strong>monolithic</strong> ما، ما همچنین پایگاه‌های داده خود را از هم جدا می‌کنیم، زیرا می‌خواهیم دسترسی به <strong>data storage</strong> داخلی خود را پنهان کنیم. با پنهان کردن دسترسی مستقیم به پایگاه‌های داده خود، ما قادر به ایجاد <strong>interfaces</strong> پایدارتر هستیم، که <strong>independent deployability</strong> را ممکن می‌سازد. متأسفانه، این امر باعث ایجاد مشکلاتی می‌شود زمانی که ما موارد استفاده مشروعی برای دسترسی به داده‌ها از بیش از یک microservice داریم، یا زمانی که آن داده‌ها بهتر است در یک پایگاه داده، و نه از طریق چیزی مانند یک <strong>REST API</strong>، در دسترس قرار گیرند.
  </p>
<p>
   با یک پایگاه داده گزارش‌دهی، ما در عوض یک پایگاه داده اختصاصی ایجاد می‌کنیم که برای دسترسی خارجی طراحی شده است، و ما مسئولیت push داده‌ها را از <strong>internal storage</strong> به پایگاه داده گزارش‌دهی که از بیرون قابل دسترسی است، می‌کنیم، همانطور که در شکل 3-8 مشاهده می‌شود.
  </p>
<p>
   پایگاه داده گزارش‌دهی به ما امکان می‌دهد مدیریت <strong>internal state</strong> را پنهان کنیم، در حالی که هنوز داده‌ها را در یک پایگاه داده ارائه می‌کنیم—چیزی که می‌تواند بسیار مفید باشد. به عنوان مثال، شما ممکن است بخواهید به افراد اجازه دهید که <strong>queries SQL</strong> تعریف شده را اجرا کنند، <strong>joins</strong> در مقیاس بزرگ را اجرا کنند، یا از <strong>toolchains</strong> موجود که انتظار دارند به یک <strong>SQL endpoint</strong> دسترسی داشته باشند، استفاده کنند.
  </p>
<p>
   پایگاه داده گزارش‌دهی یک راه‌حل خوب برای این مشکل است.
  </p>
<p>Data Decomposition Concerns | 85</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0111</div>
            </div>
        </div>
        <!-- Page 0112 -->
        <div class="chapter" id="page-0112">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 3-8. مروری بر الگوی پایگاه داده گزارش‌دهی
  </p>
<p>
   دو نکته کلیدی وجود دارد که باید در اینجا برجسته شوند. اولاً، ما هنوز می‌خواهیم <strong>information hiding</strong> را تمرین کنیم. بنابراین ما باید فقط حداقل داده‌ها را در پایگاه داده گزارش‌دهی نشان دهیم. این بدان معناست که آنچه در پایگاه داده گزارش‌دهی وجود دارد، ممکن است فقط یک زیرمجموعه از داده‌هایی باشد که microservice ذخیره می‌کند. با این حال، از آنجایی که این یک نگاشت مستقیم نیست، این فرصت را ایجاد می‌کند که یک طراحی <strong>schema</strong> برای پایگاه داده گزارش‌دهی ایجاد کنید که دقیقاً متناسب با الزامات <strong>consumers</strong> باشد—این می‌تواند شامل استفاده از یک <strong>schema</strong> کاملاً متفاوت، یا شاید حتی یک نوع فناوری پایگاه داده متفاوت به طور کلی باشد.
  </p>
<p>
   نکته کلیدی دوم این است که باید با پایگاه داده گزارش‌دهی مانند هر <strong>microservice endpoint</strong> دیگری رفتار شود، و این کار، وظیفه نگه‌دارنده microservice است که اطمینان حاصل کند که سازگاری این <strong>endpoint</strong> حفظ می‌شود، حتی اگر microservice جزئیات پیاده‌سازی داخلی خود را تغییر دهد. نگاشت از <strong>internal state</strong> به پایگاه داده گزارش‌دهی، مسئولیت افرادی است که خود microservice را توسعه می‌دهند.
  </p>
<h4>خلاصه</h4>
<p>
   بنابراین، برای تقطیر مطالب، هنگام شروع کار برای انتقال <strong>functionality</strong> از یک معماری <strong>monolithic</strong> به یک معماری microservice، شما باید درک روشنی از آنچه که انتظار دارید به دست آورید، داشته باشید. این هدف، نحوه انجام کار را شکل می‌دهد و همچنین به شما کمک می‌کند تا درک کنید که آیا در مسیر درست حرکت می‌کنید یا خیر.
  </p>
<p>
   مهاجرت باید افزایشی باشد. یک تغییر ایجاد کنید، آن تغییر را اجرا کنید، ارزیابی کنید، و دوباره انجام دهید. حتی عمل جدا کردن یک microservice می‌تواند خود به یک سری مراحل کوچک شکسته شود.
  </p>
<p>86 | Chapter 3: Splitting the Monolith</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 112" src="page_0112/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0112</div>
            </div>
        </div>
        <!-- Page 0113 -->
        <div class="chapter" id="page-0113">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   اگر می‌خواهید هر یک از مفاهیم این فصل را با جزئیات بیشتری بررسی کنید، کتاب دیگری که من نوشته‌ام، <em>Monolith to Microservices</em> (O’Reilly)، یک غواصی عمیق در این موضوع است.
  </p>
<p>
   بسیاری از این فصل تا حدودی در مرور کلی خود در سطح بالا بوده است. با این حال، در فصل بعد، ما شروع به فنی‌تر شدن می‌کنیم وقتی که به نحوه ارتباط microservices با یکدیگر نگاه می‌کنیم.
  </p>
<p>Summary | 87</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0113</div>
            </div>
        </div>
        <!-- Page 0115 -->
        <div class="chapter" id="page-0115">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>CHAPTER 4</h3>
<h4>سبک‌های ارتباطی Microservice</h4>
<p>
   به نظر من، برقراری ارتباط صحیح بین microservicesها برای بسیاری از افراد مشکل‌ساز است، تا حد زیادی به این دلیل که مردم به یک رویکرد تکنولوژیکی انتخاب‌شده گرایش پیدا می‌کنند، بدون اینکه ابتدا انواع مختلف ارتباطی را که ممکن است بخواهند در نظر بگیرند. در این فصل، من سعی خواهم کرد سبک‌های مختلف ارتباطی را از هم جدا کنم تا به شما در درک مزایا و معایب هر کدام کمک کنم، و همچنین رویکردی را که به بهترین وجه با فضای مشکل شما مطابقت دارد، درک کنید.
  </p>
<p>
   ما به مکانیسم‌های ارتباطی <em>synchronous blocking</em> و <em>asynchronous nonblocking</em>، و همچنین مقایسه همکاری <strong>request-response</strong> با همکاری <strong>event-driven</strong> نگاه خواهیم کرد.
  </p>
<p>
   تا پایان این فصل، شما باید آمادگی بسیار بیشتری برای درک گزینه‌های مختلف موجود داشته باشید و دانش بنیادی خواهید داشت که هنگام شروع بررسی نگرانی‌های پیاده‌سازی دقیق‌تر در فصل‌های بعدی، کمک خواهد کرد.
  </p>
<h4>از In-Process به Inter-Process</h4>
<p>
   خوب، بیایید ابتدا موارد آسان را از سر راه برداریم—یا حداقل آنچه امیدوارم آسان باشد.
   یعنی، فراخوانی‌ها بین فرآیندهای مختلف در سراسر یک شبکه (<strong>inter-process</strong>) با فراخوانی‌ها در یک فرآیند واحد (<strong>in-process</strong>) بسیار متفاوت هستند. در یک سطح، ما می‌توانیم این تمایز را نادیده بگیریم. به عنوان مثال، فکر کردن به یک <strong>object</strong> که یک متد را در یک <strong>object</strong> دیگر فراخوانی می‌کند و سپس این تعامل را به دو microservices که از طریق یک شبکه ارتباط برقرار می‌کنند، نگاشت کنیم، آسان است. با کنار گذاشتن این واقعیت که microservicesها فقط <strong>objects</strong> نیستند، این تفکر می‌تواند ما را به دردسر بیندازد.
  </p>
<p>
   بیایید به برخی از این تفاوت‌ها و نحوه تغییر آنها در مورد نحوه تفکر شما در مورد تعاملات بین microservicesهایتان نگاهی بیندازیم.
  </p>
<p>89</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0115</div>
            </div>
        </div>
        <!-- Page 0116 -->
        <div class="chapter" id="page-0116">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>عملکرد</h4>
<p>
   عملکرد یک فراخوانی <strong>in-process</strong> با عملکرد یک فراخوانی <strong>inter-process</strong> اساساً متفاوت است. هنگامی که من یک فراخوانی <strong>in-process</strong> انجام می‌دهم، کامپایلر و <strong>runtime</strong> زیربنایی می‌توانند مجموعه‌ای از بهینه‌سازی‌ها را برای کاهش تأثیر فراخوانی انجام دهند، از جمله <strong>inlining</strong> فراخوانی به طوری که انگار هرگز در وهله اول فراخوانی وجود نداشته است. هیچ بهینه‌سازی از این دست با فراخوانی‌های <strong>inter-process</strong> امکان‌پذیر نیست. بسته‌ها باید ارسال شوند. انتظار داشته باشید که سربار یک فراخوانی <strong>inter-process</strong> در مقایسه با سربار یک فراخوانی <strong>in-process</strong> قابل توجه باشد. اولی بسیار قابل اندازه‌گیری است—فقط یک بسته واحد در یک مرکز داده در میلی‌ثانیه اندازه‌گیری می‌شود—در حالی که شما نیازی به نگرانی در مورد سربار انجام یک فراخوانی متد ندارید.
  </p>
<p>
   این اغلب می‌تواند شما را به این سمت سوق دهد که <strong>APIs</strong> را دوباره ارزیابی کنید. یک <strong>API</strong> که در <strong>in-process</strong> منطقی است، ممکن است در موقعیت‌های <strong>inter-process</strong> منطقی نباشد. من می‌توانم هزار فراخوانی را در یک <strong>API boundary</strong> در <strong>in-process</strong> بدون نگرانی انجام دهم. آیا می‌خواهم هزار فراخوانی شبکه را بین دو microservices انجام دهم؟ شاید نه.
  </p>
<p>
   هنگامی که من یک <strong>parameter</strong> را به یک متد منتقل می‌کنم، ساختار داده‌ای که منتقل می‌کنم معمولاً حرکت نمی‌کند—آنچه محتمل‌تر است این است که من یک <strong>pointer</strong> به یک مکان حافظه را منتقل می‌کنم. عبور از یک <strong>object</strong> یا ساختار داده به متد دیگر، مستلزم تخصیص حافظه بیشتر برای کپی کردن داده‌ها نیست.
  </p>
<p>
   از سوی دیگر، هنگام برقراری تماس بین microservicesها از طریق یک شبکه، داده‌ها در واقع باید به شکلی <strong>serialized</strong> شوند که بتوان آنها را از طریق یک شبکه منتقل کرد. سپس داده‌ها باید در انتهای دیگر ارسال و <strong>deserialized</strong> شوند. بنابراین ما ممکن است نیاز داشته باشیم که نسبت به اندازه <strong>payloads</strong> که بین فرآیندها ارسال می‌شود، بیشتر توجه داشته باشیم. آخرین باری که از اندازه یک ساختار داده که در داخل یک فرآیند منتقل می‌کردید، خبر داشتید چه زمانی بود؟ واقعیت این است که شما احتمالاً نیازی به دانستن نداشتید. اکنون شما می‌دانید. این ممکن است شما را به کاهش مقدار داده‌های ارسالی یا دریافتی سوق دهد (شاید اگر در مورد <strong>information hiding</strong> فکر کنیم چیز بدی نباشد)، مکانیسم‌های <strong>serialization</strong> کارآمدتری را انتخاب کنید، یا حتی داده‌ها را به یک سیستم فایل منتقل کنید و در عوض یک <strong>reference</strong> به آن مکان فایل را منتقل کنید.
  </p>
<p>
   این تفاوت‌ها ممکن است فوراً باعث ایجاد مشکل نشوند، اما شما قطعاً باید از آنها آگاه باشید. من تلاش‌های زیادی را برای پنهان کردن این واقعیت که حتی یک فراخوانی شبکه در حال انجام است، از توسعه‌دهنده، دیده‌ام. تمایل ما به ایجاد انتزاع‌ها برای پنهان کردن جزئیات بخش بزرگی از آنچه به ما اجازه می‌دهد تا کارهای بیشتری را به طور مؤثرتر انجام دهیم، اما گاهی اوقات ما انتزاع‌هایی ایجاد می‌کنیم که بیش از حد پنهان می‌کنند. یک توسعه‌دهنده باید بداند که آیا در حال انجام کاری است که منجر به یک فراخوانی شبکه می‌شود یا خیر. در غیر این صورت، نباید تعجب کنید اگر در ادامه با برخی از گلوگاه‌های عملکردی ناخوشایند مواجه شوید که ناشی از تعاملات عجیب و غریب بین <strong>service</strong> است که برای توسعه‌دهنده نوشتن کد قابل مشاهده نبود.
  </p>
<p>90 | Chapter 4: Microservice Communication Styles</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0116</div>
            </div>
        </div>
        <!-- Page 0117 -->
        <div class="chapter" id="page-0117">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   1 داستان واقعی.
  </p>
<p>
   2 Maarten van Steen and Andrew S. Tanenbaum, Distributed Systems, 3rd ed. (Scotts Valley, CA: CreateSpace
   Independent Publishing Platform, 2017).
  </p>
<h4>تغییر <strong>Interfaces</strong></h4>
<p>
   هنگامی که ما تغییراتی را در یک <strong>interface</strong> در داخل یک فرآیند در نظر می‌گیریم، عمل راه‌اندازی تغییر ساده است. کدی که <strong>interface</strong> را پیاده‌سازی می‌کند و کدی که <strong>interface</strong> را فراخوانی می‌کند، همگی در یک فرآیند بسته‌بندی شده‌اند. در واقع، اگر من یک <strong>method signature</strong> را با استفاده از یک <strong>IDE</strong> با قابلیت <strong>refactoring</strong> تغییر دهم، اغلب خود <strong>IDE</strong> به طور خودکار فراخوانی‌ها به این متد در حال تغییر را <strong>refactor</strong> می‌کند. راه‌اندازی چنین تغییری را می‌توان به صورت اتمی انجام داد—هر دو طرف <strong>interface</strong> در یک فرآیند واحد بسته‌بندی شده‌اند.
  </p>
<p>
   با ارتباط بین microservicesها، با این حال، microservice که یک <strong>interface</strong> را به نمایش می‌گذارد و microservicesهای مصرف‌کننده که از آن <strong>interface</strong> استفاده می‌کنند، microservicesهایی هستند که به طور جداگانه قابل استقرار هستند. هنگام ایجاد یک تغییر <em>backward-incompatible</em> در یک <strong>microservice interface</strong>، ما یا باید یک استقرار <strong>lockstep</strong> با <strong>consumers</strong> انجام دهیم و اطمینان حاصل کنیم که آنها برای استفاده از <strong>interface</strong> جدید به‌روز شده‌اند، یا راهی برای فازبندی راه‌اندازی قرارداد microservice جدید پیدا کنیم. ما این مفهوم را با جزئیات بیشتری در ادامه این فصل بررسی خواهیم کرد.
  </p>
<h4>Error Handling</h4>
<p>
   در داخل یک فرآیند، اگر من یک متد را فراخوانی کنم، ماهیت خطاها تمایل دارد که کاملاً سرراست باشد. به طور ساده، خطاها یا مورد انتظار هستند و به راحتی قابل رسیدگی هستند، یا فاجعه‌بار هستند تا جایی که ما فقط خطا را به <strong>call stack</strong> منتقل می‌کنیم. خطاها، در کل، قطعی هستند.
  </p>
<p>
   با یک سیستم توزیع‌شده، ماهیت خطاها می‌تواند متفاوت باشد. شما در برابر مجموعه‌ای از خطاها آسیب‌پذیر هستید که خارج از کنترل شما هستند. شبکه‌ها زمان‌بندی می‌کنند. microservicesهای پایین‌دست ممکن است موقتاً در دسترس نباشند. شبکه‌ها قطع می‌شوند، <strong>containers</strong> به دلیل مصرف بیش از حد حافظه کشته می‌شوند، و در شرایط حاد، بخش‌هایی از <strong>data center</strong> شما می‌تواند آتش بگیرد.1
  </p>
<p>
   در کتاب <em>Distributed Systems</em>،2 <strong>Andrew Tanenbaum</strong> و <strong>Maarten Steen</strong>، حالت‌های شکست پنج گانه را که می‌توانید هنگام نگاه کردن به یک ارتباط <strong>inter-process</strong> مشاهده کنید، شکسته‌اند. در اینجا یک نسخه ساده شده است:
  </p>
<ul>
<li>شکست <strong>Crash</strong></li>
</ul>
<p>
   همه چیز خوب بود تا اینکه سرور خراب شد. راه‌اندازی مجدد!
  </p>
<p>From In-Process to Inter-Process | 91</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0117</div>
            </div>
        </div>
        <!-- Page 0118 -->
        <div class="chapter" id="page-0118">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<ul>
<li>شکست <strong>Omission</strong></li>
</ul>
<p>
   شما چیزی ارسال کردید، اما پاسخی دریافت نکردید. همچنین شامل موقعیت‌هایی می‌شود که در آنها انتظار دارید یک microservice پایین‌دست پیام‌هایی را منتشر کند (شاید شامل رویدادها باشد)، و به سادگی متوقف می‌شود.
  </p>
<ul>
<li>شکست Timing</li>
</ul>
<p>
   چیزی خیلی دیر اتفاق افتاد (شما آن را به موقع دریافت نکردید)، یا چیزی خیلی زود اتفاق افتاد!
  </p>
<ul>
<li>شکست Response</li>
</ul>
<p>
   شما یک پاسخ دریافت کردید، اما به نظر می‌رسد که اشتباه است. به عنوان مثال، شما درخواست خلاصه سفارش را کردید، اما قطعات اطلاعات مورد نیاز در پاسخ وجود ندارد.
  </p>
<ul>
<li>شکست Arbitrary</li>
</ul>
<p>
   در غیر این صورت به عنوان <strong>Byzantine failure</strong> شناخته می‌شود، این زمانی است که مشکلی پیش آمده است، اما شرکت‌کنندگان نمی‌توانند توافق کنند که آیا شکست رخ داده است (یا چرا). همانطور که به نظر می‌رسد، این یک زمان بد در همه زمینه‌ها است.
  </p>
<p>
   بسیاری از این خطاها اغلب ماهیت گذرا دارند—آنها مشکلات کوتاه‌مدتی هستند که ممکن است از بین بروند. وضعیتی را در نظر بگیرید که در آن ما درخواستی را به یک microservice ارسال می‌کنیم اما پاسخی دریافت نمی‌کنیم (نوعی شکست <strong>omission</strong>). این می‌تواند به این معنی باشد که microservice پایین‌دست در وهله اول درخواست را دریافت نکرده است، بنابراین ما باید دوباره آن را ارسال کنیم. مشکلات دیگر را نمی‌توان به راحتی برطرف کرد و ممکن است نیاز به مداخله یک <strong>human operator</strong> داشته باشند. در نتیجه، داشتن مجموعه‌ای غنی‌تر از معناشناسی برای بازگرداندن خطاها به گونه‌ای که به مشتریان اجازه می‌دهد اقدام مناسبی را انجام دهند، می‌تواند مهم شود.
  </p>
<p>
<strong>HTTP</strong> نمونه‌ای از <strong>protocol</strong> است که اهمیت این موضوع را درک می‌کند. هر پاسخ <strong>HTTP</strong> دارای یک کد است، که کدهای سری 400 و 500 برای خطاها رزرو شده‌اند. کدهای خطای سری 400 خطاهای درخواست هستند—اساساً، یک <strong>service</strong> پایین‌دست به کلاینت می‌گوید که در درخواست اصلی مشکلی وجود دارد. به این ترتیب، احتمالاً چیزی است که باید از آن صرفنظر کنید—آیا مثلاً تلاشی مجدد برای <strong>404 Not Found</strong> وجود دارد؟ کدهای پاسخ سری 500 مربوط به مسائل پایین‌دست هستند، که زیرمجموعه‌ای از آنها به کلاینت نشان می‌دهد که این مشکل ممکن است موقتی باشد. به عنوان مثال، <strong>503 Service Unavailable</strong> نشان می‌دهد که سرور پایین‌دست قادر به رسیدگی به درخواست نیست، اما ممکن است یک حالت موقت باشد، که در این صورت یک کلاینت بالادست ممکن است تصمیم بگیرد که درخواست را دوباره امتحان کند. از سوی دیگر، اگر یک کلاینت پاسخ <strong>501 Not Imple-mented</strong> را دریافت کند، احتمال کمی وجود دارد که تلاش مجدد کمک زیادی کند.
  </p>
<p>
   صرف نظر از اینکه شما یک <strong>protocol</strong> مبتنی بر <strong>HTTP</strong> را برای ارتباط بین microservices انتخاب می‌کنید یا خیر، اگر مجموعه‌ای غنی از معناشناسی را در مورد ماهیت خطا داشته باشید، این کار را برای مشتریان آسان‌تر می‌کند تا اقدامات جبرانی را انجام دهند، که به نوبه خود باید به شما در ساخت سیستم‌های مستحکم‌تر کمک کند.
  </p>
<p>92 | Chapter 4: Microservice Communication Styles</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0118</div>
            </div>
        </div>
        <!-- Page 0119 -->
        <div class="chapter" id="page-0119">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   1 <strong>Seth Godin</strong>.
  </p>
<p>
   دامنه فناوری موجود برای ارتباط بین فرآیندی ما وسیع است. در نتیجه، ما اغلب می‌توانیم با انتخاب بیش از حد بار سنگینی را تحمل کنیم. من اغلب متوجه می‌شوم که افراد به فناوری‌ای گرایش پیدا می‌کنند که برای آنها آشنا است، یا شاید فقط به جدیدترین فناوری داغی که از یک کنفرانس در مورد آن یاد گرفته‌اند. مشکل این است که وقتی شما به یک انتخاب فناوری خاص وارد می‌شوید، اغلب به مجموعه‌ای از ایده‌ها و محدودیت‌هایی وارد می‌شوید که همراه با آن می‌آیند. این محدودیت‌ها ممکن است برای شما مناسب نباشند—و طرز فکر پشت فناوری ممکن است در واقع با مشکلی که در حال حل آن هستید، همخوانی نداشته باشد.
  </p>
<p>
   اگر شما در حال تلاش برای ساخت یک وب‌سایت هستید، فناوری <strong>single page app</strong> مانند <strong>Angular</strong> یا <strong>React</strong> مناسب نیست. به همین ترتیب، تلاش برای استفاده از <strong>Kafka</strong> برای <strong>request-response</strong> واقعاً ایده خوبی نیست، زیرا برای تعاملات بیشتر مبتنی بر <strong>event</strong> طراحی شده است (موضوعاتی که ما در یک لحظه به آنها می‌پردازیم). و با این حال من بارها و بارها می‌بینم که فناوری در جای اشتباه استفاده می‌شود.
  </p>
<p>
   مردم فناوری جدید و براق را انتخاب می‌کنند (مانند microservices!) بدون در نظر گرفتن اینکه آیا واقعاً با مشکل آنها مطابقت دارد یا خیر.
  </p>
<p>
   بنابراین وقتی صحبت از آرایه گیج‌کننده فناوری موجود برای ارتباط بین microservices می‌شود، فکر می‌کنم مهم است که ابتدا در مورد سبک ارتباطی مورد نظر خود صحبت کنید، و تنها پس از آن به دنبال فناوری مناسب برای پیاده‌سازی آن سبک باشید. با در نظر گرفتن این موضوع، بیایید نگاهی به مدلی بیندازیم که من چندین سال است برای کمک به تمایز بین رویکردهای مختلف برای ارتباط microservice-to-microservice استفاده می‌کنم، که به نوبه خود می‌تواند به شما در فیلتر کردن گزینه‌های فناوری که می‌خواهید به آنها نگاه کنید، کمک کند.
  </p>
<h4>سبک‌های ارتباطی Microservice</h4>
<p>
   در شکل 4-1 ما طرح کلی مدلی را می‌بینیم که من برای تفکر در مورد سبک‌های مختلف ارتباطی استفاده می‌کنم. این مدل قرار نیست کاملاً جامع باشد (من در اینجا در تلاش برای ارائه یک نظریه متحد بزرگ از ارتباط بین فرآیندی نیستم)، اما یک نمای کلی سطح بالا را برای در نظر گرفتن سبک‌های مختلف ارتباطی که به طور گسترده برای معماری‌های microservice استفاده می‌شوند، ارائه می‌دهد.
  </p>
<p>Technology for Inter-Process Communication: So Many Choices | 93</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0119</div>
            </div>
        </div>
        <!-- Page 0120 -->
        <div class="chapter" id="page-0120">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 4-1. سبک‌های مختلف ارتباط <strong>inter-microservice</strong> به همراه فناوری‌های پیاده‌سازی مثال
  </p>
<p>
   ما به زودی با جزئیات بیشتری به عناصر مختلف این مدل نگاه خواهیم کرد، اما ابتدا می‌خواهم به طور خلاصه آنها را شرح دهم:
  </p>
<ul>
<li>Synchronous blocking</li>
</ul>
<p>
   یک microservice، یک <strong>call</strong> به microservice دیگری انجام می‌دهد و برای دریافت پاسخ عملیات را مسدود می‌کند.
  </p>
<ul>
<li>Asynchronous nonblocking</li>
</ul>
<p>
   microservice که یک <strong>call</strong> را منتشر می‌کند، چه <strong>call</strong> دریافت شود یا نشود، قادر به ادامه پردازش است.
  </p>
<ul>
<li>Request-response</li>
</ul>
<p>
   یک microservice، درخواستی را به microservice دیگری ارسال می‌کند و از او می‌خواهد کاری را انجام دهد. انتظار دارد پاسخی دریافت کند که آن را از نتیجه مطلع می‌کند.
  </p>
<ul>
<li>Event-driven</li>
</ul>
<p>
   Microservicesها <strong>events</strong> را منتشر می‌کنند، که microservicesهای دیگر آنها را مصرف می‌کنند و بر اساس آنها واکنش نشان می‌دهند. microservice که <strong>event</strong> را منتشر می‌کند، از اینکه کدام microservicesها، در صورت وجود، <strong>events</strong> منتشر شده توسط آن را مصرف می‌کنند، بی‌اطلاع است.
  </p>
<ul>
<li>داده‌های مشترک</li>
</ul>
<p>
   اغلب به عنوان یک سبک ارتباطی دیده نمی‌شود، microservicesها از طریق برخی از منبع داده‌های مشترک با هم همکاری می‌کنند.
  </p>
<p>
   هنگام استفاده از این مدل برای کمک به تیم‌ها در تصمیم‌گیری در مورد رویکرد درست، من زمان زیادی را صرف درک زمینه فعالیت آنها می‌کنم. نیازهای آنها از نظر ارتباطات قابل اعتماد، <strong>acceptable latency</strong>، و حجم ارتباطات، همگی در انتخاب فناوری نقش خواهند داشت. اما به طور کلی، من تمایل دارم با تصمیم‌گیری در مورد اینکه آیا یک سبک همکاری <strong>request-response</strong> یا <strong>event-driven</strong> برای موقعیت داده شده مناسب‌تر است، شروع کنم. اگر من به <strong>request-response</strong> نگاه می‌کنم، آنگاه پیاده‌سازی‌های <strong>synchronous</strong> و <strong>asynchronous</strong> همچنان برای من در دسترس هستند، بنابراین من یک
  </p>
<p>94 | Chapter 4: Microservice Communication Styles</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 120" src="page_0120/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0120</div>
            </div>
        </div>
        <!-- Page 0121 -->
        <div class="chapter" id="page-0121">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   دومین انتخاب. اگر سبک همکاری <strong>event-driven</strong> را انتخاب می‌کنید، با این حال، انتخاب‌های پیاده‌سازی من به انتخاب‌های <strong>asynchronous</strong> <strong>nonblocking</strong> محدود می‌شود.
  </p>
<p>
   هنگام انتخاب فناوری مناسب، مجموعه‌ای از ملاحظات دیگر نیز وارد عمل می‌شوند که فراتر از سبک ارتباط هستند—به عنوان مثال، نیاز به ارتباط با <strong>lower-latency</strong>، جنبه‌های مربوط به امنیت، یا توانایی مقیاس‌پذیری. بعید است که شما بتوانید یک انتخاب فناوری منطقی داشته باشید بدون اینکه الزامات (و محدودیت‌های) فضای مشکل خاص خود را در نظر بگیرید. وقتی در فصل 5 به گزینه‌های فناوری نگاه می‌کنیم، در مورد برخی از این مسائل بحث خواهیم کرد.
  </p>
<h4>ترکیب و تطبیق</h4>
<p>
   مهم است که توجه داشته باشید که یک معماری microservice به طور کلی ممکن است ترکیبی از سبک‌های همکاری داشته باشد، و این معمولاً هنجار است. برخی از تعاملات، منطقی هستند به عنوان <strong>request-response</strong>، در حالی که برخی دیگر به عنوان <strong>event-driven</strong> منطقی هستند. در واقع، برای یک microservice واحد معمول است که بیش از یک شکل از همکاری را پیاده‌سازی کند.
  </p>
<p>
   یک microservice <strong>Order</strong> را در نظر بگیرید که یک <strong>request-response API</strong> را ارائه می‌دهد که به سفارشات اجازه می‌دهد قرار داده شوند یا تغییر داده شوند و سپس زمانی که این تغییرات انجام می‌شوند، رویدادها را منتشر می‌کند.
  </p>
<p>
   با این اوصاف، بیایید با جزئیات بیشتری به این سبک‌های مختلف ارتباط نگاه کنیم.
  </p>
<h4>الگو: Synchronous Blocking</h4>
<p>
   با یک <strong>synchronous blocking call</strong>، یک microservice نوعی <strong>call</strong> را به یک فرآیند <strong>downstream</strong> (احتمالاً یک microservice دیگر) ارسال می‌کند و تا زمان تکمیل <strong>call</strong>، و احتمالاً تا دریافت پاسخ، عملیات را مسدود می‌کند. در شکل 4-2، <strong>Order Processor</strong> یک <strong>call</strong> را به microservice <strong>Loyalty</strong> ارسال می‌کند تا به آن اطلاع دهد که مقداری امتیاز باید به حساب مشتری اضافه شود.
  </p>
<p>
   شکل 4-2. <strong>Order Processor</strong> یک <strong>synchronous call</strong> را به microservice <strong>Loyalty</strong> ارسال می‌کند، عملیات را مسدود می‌کند، و منتظر پاسخ می‌ماند
  </p>
<p>
   به طور معمول، یک <strong>synchronous blocking call</strong>، فراخوانی است که منتظر پاسخی از فرآیند <strong>downstream</strong> است. این ممکن است به این دلیل باشد که نتیجه <strong>call</strong> برای برخی از عملیات‌های دیگر مورد نیاز است، یا فقط به این دلیل که می‌خواهد مطمئن شود که <strong>call</strong> کار کرده است و در صورت عدم موفقیت، نوعی تلاش مجدد را انجام دهد. در نتیجه، تقریباً هر <strong>synchronous blocking call</strong> که من می‌بینم، همچنین یک <strong>request-response call</strong> را نیز تشکیل می‌دهد، چیزی که ما به زودی به آن نگاه خواهیم کرد.
  </p>
<p>Pattern: Synchronous Blocking | 95</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 121" src="page_0121/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0121</div>
            </div>
        </div>
        <!-- Page 0122 -->
        <div class="chapter" id="page-0122">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مزایا</h4>
<p>
   چیزی ساده و آشنا در مورد یک فراخوانی <strong>blocking</strong>، <strong>synchronous</strong> وجود دارد. بسیاری از ما در یک سبک اساساً <strong>synchronous</strong> برنامه‌نویسی آموختیم—خواندن یک قطعه کد مانند یک اسکریپت، که هر خط به نوبه خود اجرا می‌شود، و خط بعدی کد منتظر نوبت خود برای انجام کاری است. اکثر موقعیت‌هایی که در آنها از فراخوانی‌های بین فرآیندی استفاده می‌کنید احتمالاً به سبک <strong>synchronous</strong>، <strong>blocking</strong> انجام شده‌اند—به عنوان مثال، اجرای یک <strong>SQL query</strong> در یک پایگاه داده، یا انجام یک درخواست <strong>HTTP</strong> از یک <strong>API</strong> پایین‌دست.
  </p>
<p>
   هنگام حرکت از یک معماری کمتر توزیع‌شده، مانند یک <strong>monolith</strong> تک فرآیندی، پایبندی به آن ایده‌هایی که آشنا هستند، در حالی که چیزهای جدید دیگری نیز در حال انجام است، می‌تواند منطقی باشد.
  </p>
<h4>معایب</h4>
<p>
   چالش اصلی با فراخوانی‌های <strong>synchronous</strong>، <em>temporal coupling</em> ذاتی است که رخ می‌دهد، موضوعی که ما در فصل 2 به طور خلاصه بررسی کردیم. هنگامی که <strong>Order Processor</strong> در مثال قبلی به <strong>Loyalty</strong> فراخوانی می‌کند، microservice <strong>Loyalty</strong> باید برای کار کردن <strong>call</strong> قابل دسترس باشد. اگر microservice <strong>Loyalty</strong> در دسترس نباشد، <strong>call</strong> شکست می‌خورد، و <strong>Order Processor</strong> نیاز دارد که مشخص کند چه نوع اقدام جبرانی را باید انجام دهد—این ممکن است شامل یک تلاش مجدد فوری، <strong>buffering</strong> <strong>call</strong> برای تلاش مجدد در آینده، یا شاید به طور کلی صرف نظر کردن باشد.
  </p>
<p>
   این <em>coupling</em> دو طرفه است. با این سبک از ادغام، پاسخ معمولاً از طریق همان اتصال شبکه ورودی به microservice بالادستی ارسال می‌شود. بنابراین اگر microservice <strong>Loyalty</strong> بخواهد پاسخی را به <strong>Order Processor</strong> بازگرداند، اما نمونه بالادستی متعاقباً از بین رفته باشد، پاسخ از بین خواهد رفت. <em>Temporal coupling</em> در اینجا فقط بین دو microservices نیست. این بین دو نمونه خاص از این microservices است.
  </p>
<p>
   از آنجایی که فرستنده <strong>call</strong> در حال <strong>blocking</strong> است و منتظر پاسخ microservice پایین‌دست است، همچنین نتیجه می‌دهد که اگر microservice پایین‌دست به کندی پاسخ دهد، یا اگر مشکلی در <strong>latency</strong> شبکه وجود داشته باشد، فرستنده <strong>call</strong> برای مدت طولانی در انتظار پاسخ مسدود خواهد شد. اگر microservice <strong>Loyalty</strong> تحت بار قابل توجهی باشد و به درخواست‌ها به کندی پاسخ دهد، این به نوبه خود باعث می‌شود که <strong>Order Processor</strong> به کندی پاسخ دهد.
  </p>
<p>
   بنابراین استفاده از فراخوانی‌های <strong>synchronous</strong> می‌تواند یک سیستم را به مشکلات <strong>cascading</strong> ناشی از قطعی‌های پایین‌دست آسیب‌پذیرتر کند تا استفاده از فراخوانی‌های <strong>asynchronous</strong>.
  </p>
<h4>کجا از آن استفاده کنیم</h4>
<p>
   برای معماری‌های microservice ساده، من مشکل زیادی با استفاده از فراخوانی‌های <strong>synchronous</strong>، <strong>blocking</strong> ندارم. آشنایی آنها برای بسیاری از افراد یک مزیت هنگام مقابله با سیستم‌های توزیع‌شده است.
  </p>
<p>96 | Chapter 4: Microservice Communication Styles</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0122</div>
            </div>
        </div>
        <!-- Page 0123 -->
        <div class="chapter" id="page-0123">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   برای من، این نوع <strong>calls</strong> زمانی مشکل‌ساز می‌شوند که شما شروع به داشتن زنجیره‌های بیشتری از <strong>calls</strong> می‌کنید—به عنوان مثال، در شکل 4-3، ما یک جریان مثال از <strong>MusicCorp</strong> داریم، که در آن ما در حال بررسی یک پرداخت برای فعالیت‌های بالقوه کلاهبرداری هستیم. <strong>Order Processor</strong>، microservice <strong>Payment</strong> را فراخوانی می‌کند تا پرداخت را انجام دهد. microservice <strong>Payment</strong> به نوبه خود می‌خواهد با microservice <strong>Fraud Detection</strong> بررسی کند که آیا این باید مجاز باشد یا خیر. microservice <strong>Fraud Detection</strong> به نوبه خود نیاز به دریافت اطلاعات از microservice <strong>Customer</strong> دارد.
  </p>
<p>
   شکل 4-3. بررسی رفتار بالقوه کلاهبرداری به عنوان بخشی از جریان پردازش سفارش
  </p>
<p>
   اگر همه این <strong>calls</strong> <strong>synchronous</strong> و <strong>blocking</strong> باشند، تعدادی مشکل وجود دارد که ممکن است با آنها مواجه شویم. یک مشکل در هر یک از چهار microservices درگیر، یا در <strong>network calls</strong> بین آنها، می‌تواند باعث شکست کل عملیات شود. این جدا از این واقعیت است که این نوع زنجیره‌های طولانی می‌تواند باعث <strong>resource contention</strong> قابل توجهی شود. در پشت صحنه، <strong>Order Processor</strong> احتمالاً یک اتصال شبکه باز دارد که منتظر است تا از <strong>Payment</strong> پاسخ دریافت کند. <strong>Payment</strong> به نوبه خود یک اتصال شبکه باز دارد که منتظر پاسخ از <strong>Fraud Detection</strong> است، و غیره. داشتن تعداد زیادی اتصال که باید باز نگه داشته شوند می‌تواند بر سیستم در حال اجرا تأثیر بگذارد—شما احتمالاً بیشتر مشکلاتی را تجربه خواهید کرد که در آن اتصالات در دسترس شما تمام می‌شود یا در نتیجه از ازدحام شبکه افزایش یافته رنج می‌برید.
  </p>
<p>
   برای بهبود این وضعیت، ما می‌توانیم در وهله اول تعاملات بین microservicesها را دوباره بررسی کنیم. به عنوان مثال، شاید ما از استفاده از <strong>Fraud Detection</strong> از جریان خرید اصلی، همانطور که در شکل 4-4 نشان داده شده است، صرف نظر کنیم، و در عوض آن را در پس‌زمینه اجرا کنیم. اگر مشکلی را با یک مشتری خاص پیدا کرد، سوابق آنها بر این اساس به‌روزرسانی می‌شود، و این چیزی است که می‌تواند در اوایل فرآیند پرداخت بررسی شود. در واقع، این بدان معناست که ما مقداری از این کار را به صورت موازی انجام می‌دهیم. با کاهش طول زنجیره <strong>call</strong>، ما بهبود <strong>latency</strong> کلی عملیات را خواهیم دید، و ما یکی از microservicesهای خود (<strong>Fraud Detection</strong>) را از مسیر بحرانی برای جریان خرید خارج می‌کنیم، که یکی وابستگی کمتر را به ما می‌دهد تا در مورد آن نگران باشیم برای آنچه یک عملیات حیاتی است.
  </p>
<p>Pattern: Synchronous Blocking | 97</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 123" src="page_0123/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0123</div>
            </div>
        </div>
        <!-- Page 0124 -->
        <div class="chapter" id="page-0124">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 4-4. انتقال <strong>Fraud Detection</strong> به یک فرآیند پس‌زمینه می‌تواند نگرانی‌ها در مورد طول زنجیره <strong>call</strong> را کاهش دهد
  </p>
<p>
   البته، ما همچنین می‌توانستیم استفاده از فراخوانی‌های <strong>blocking</strong> را با نوعی تعامل <strong>nonblocking</strong> ناهمزمان جایگزین کنیم، بدون اینکه گردش کار را در اینجا تغییر دهیم، رویکردی که در ادامه به بررسی آن خواهیم پرداخت.
  </p>
<h4>الگو: Asynchronous Nonblocking</h4>
<p>
   با ارتباط ناهمزمان، عمل ارسال یک <strong>call</strong> در سراسر شبکه، microservice که <strong>call</strong> را صادر می‌کند، مسدود نمی‌کند. این امکان را دارد که به پردازش‌های دیگر خود ادامه دهد بدون اینکه منتظر پاسخ بماند. ارتباط ناهمزمان <strong>nonblocking</strong> به شکل‌های مختلفی وجود دارد، اما ما با جزئیات بیشتری به سه سبک رایج‌تر که در معماری microservice مشاهده می‌کنم، نگاه خواهیم کرد. آنها عبارتند از:
  </p>
<ul>
<li>ارتباط از طریق داده‌های مشترک</li>
</ul>
<p>
   microservice بالادستی مقداری داده مشترک را تغییر می‌دهد، که یک یا چند microservice بعداً از آن استفاده می‌کنند.
  </p>
<ul>
<li>Request-response</li>
</ul>
<p>
   یک microservice، درخواستی را به microservice دیگری ارسال می‌کند و از او می‌خواهد کاری را انجام دهد. هنگامی که عملیات درخواستی تکمیل شد، چه با موفقیت و چه نه، microservice بالادستی پاسخ را دریافت می‌کند. به طور خاص، هر نمونه از microservice بالادستی باید بتواند پاسخ را مدیریت کند.
  </p>
<ul>
<li>تعامل Event-driven</li>
</ul>
<p>
   یک microservice، یک <strong>event</strong> را منتشر می‌کند، که می‌توان آن را به عنوان یک اظهارنامه واقعی در مورد چیزی که اتفاق افتاده است، در نظر گرفت. سایر microservicesها می‌توانند به <strong>events</strong> مورد علاقه خود گوش دهند و بر این اساس واکنش نشان دهند.
  </p>
<p>98 | Chapter 4: Microservice Communication Styles</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 124" src="page_0124/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0124</div>
            </div>
        </div>
        <!-- Page 0125 -->
        <div class="chapter" id="page-0125">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مزایا</h4>
<p>
   با ارتباط ناهمزمان <strong>nonblocking</strong>، microservice که <strong>call</strong> اولیه را انجام می‌دهد و microserviceها (یا microservicesها) که <strong>call</strong> را دریافت می‌کنند، به طور موقت از هم جدا می‌شوند. microservicesهایی که <strong>call</strong> را دریافت می‌کنند، نیازی ندارند که همزمان با انجام <strong>call</strong> قابل دسترس باشند. این بدان معناست که ما از نگرانی‌های <strong>temporal decoupling</strong> که در فصل 2 (به "A Brief Note on Temporal Coupling" در صفحه 42 مراجعه کنید) بحث کردیم، اجتناب می‌کنیم.
  </p>
<p>
   این سبک ارتباطی نیز در صورتی که <strong>functionality</strong> که توسط یک <strong>call</strong> فعال می‌شود، زمان زیادی را برای پردازش صرف کند، مفید است. بیایید به مثال <strong>MusicCorp</strong>، و به طور خاص فرآیند ارسال یک بسته برگردیم. در شکل 4-5، <strong>Order Processor</strong> پرداخت را انجام داده است و تصمیم گرفته است که زمان ارسال بسته فرا رسیده است، بنابراین یک <strong>call</strong> را به <strong>Warehouse microservice</strong> ارسال می‌کند. فرآیند یافتن سی‌دی‌ها، برداشتن آنها از قفسه، بسته‌بندی آنها و حمل آنها می‌تواند ساعت‌ها، و احتمالاً حتی روزها طول بکشد، بسته به نحوه عملکرد فرآیند ارسال واقعی. بنابراین منطقی است که <strong>Order Processor</strong> یک <strong>nonblocking</strong> <strong>asynchronous call</strong> را به <strong>Warehouse</strong> صادر کند و <strong>Warehouse</strong> بعداً برای اطلاع <strong>Order Processor</strong> از پیشرفت خود تماس بگیرد. این شکلی از ارتباط ناهمزمان <strong>request-response</strong> است.
  </p>
<p>
   شکل 4-5. <strong>Order Processor</strong> فرآیند بسته‌بندی و ارسال یک سفارش را آغاز می‌کند، که به روشی ناهمزمان انجام می‌شود.
  </p>
<p>
   اگر ما سعی می‌کردیم کاری مشابه را با فراخوانی‌های <strong>synchronous blocking</strong> انجام دهیم، آنگاه مجبور می‌شدیم تعاملات بین <strong>Order Processor</strong> و <strong>Warehouse</strong> را دوباره ساختار دهیم—برای <strong>Order Processor</strong> باز کردن یک اتصال، ارسال یک درخواست، مسدود کردن هرگونه عملیات بیشتر در فراخوانی <strong>thread</strong>، و انتظار برای پاسخ برای آنچه ممکن است ساعت‌ها یا روزها باشد، امکان‌پذیر نبود.
  </p>
<p>Pattern: Asynchronous Nonblocking | 99</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 125" src="page_0125/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0125</div>
            </div>
        </div>
        <!-- Page 0126 -->
        <div class="chapter" id="page-0126">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>معایب</h4>
<p>
   معایب اصلی ارتباط ناهمزمان <strong>nonblocking</strong>، نسبت به ارتباط <strong>synchronous blocking</strong>، سطح پیچیدگی و دامنه انتخاب است. همانطور که قبلاً توضیح دادیم، سبک‌های مختلفی از ارتباط ناهمزمان برای انتخاب وجود دارد—کدام یک برای شما مناسب است؟ وقتی شروع به بررسی نحوه پیاده‌سازی این سبک‌های مختلف ارتباط می‌کنیم، یک فهرست بالقوه گیج‌کننده از فناوری وجود دارد که می‌توانیم به آن نگاه کنیم.
  </p>
<p>
   اگر ارتباط ناهمزمان با مدل‌های ذهنی شما از محاسبات همخوانی ندارد، اتخاذ یک سبک ارتباطی ناهمزمان در ابتدا چالش‌برانگیز خواهد بود. و همانطور که ما در ادامه به تفصیل به سبک‌های مختلف ارتباط ناهمزمان نگاه می‌کنیم، راه‌های جالب و متفاوتی وجود دارد که می‌توانید خود را در مشکلات زیادی گرفتار کنید.
  </p>
<h4>Async/Await و زمانی که Asynchronous همچنان در حال Blocking است</h4>
<p>
   همانند بسیاری از حوزه‌های محاسباتی، ما می‌توانیم از یک اصطلاح یکسان در زمینه‌های مختلف استفاده کنیم تا معانی بسیار متفاوتی داشته باشیم. یک سبک برنامه‌نویسی که به نظر می‌رسد به‌ویژه محبوب است، استفاده از سازه‌هایی مانند <strong>async/await</strong> برای کار با یک منبع داده بالقوه ناهمزمان اما به سبک <strong>blocking</strong> و <strong>synchronous</strong> است.
  </p>
<p>
   در مثال 4-1، ما یک مثال <strong>JavaScript</strong> بسیار ساده از این در عمل می‌بینیم. نرخ‌های ارز در طول روز نوسان دارند، و ما اینها را از طریق یک <strong>message broker</strong> دریافت می‌کنیم. ما یک <strong>Promise</strong> را تعریف می‌کنیم. به طور کلی، یک <strong>promise</strong> چیزی است که در مقطعی در آینده به یک <strong>state</strong> ختم می‌شود. در مورد ما، <strong>eurToGbp</strong> ما در نهایت به عنوان نرخ ارز <strong>euro-to-GBP</strong> بعدی حل خواهد شد.
  </p>
<p>
   مثال 4-1. مثالی از کار با یک فراخوانی بالقوه ناهمزمان به روشی <strong>blocking</strong>، <strong>synchronous</strong>
</p>
<pre><code class="language-javascript">async function f() {
  let eurToGbp = new Promise((resolve, reject) =&gt; {
    //code to fetch latest exchange rate between EUR and GBP
    ...
  });
  var latestRate = await eurToGbp; 
  process(latestRate); 
}
Wait until the latest EUR-to-GBP exchange rate is fetched.
Won’t run until the promise is fulfilled.
</code></pre>
<p>100 | Chapter 4: Microservice Communication Styles</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0126</div>
            </div>
        </div>
        <!-- Page 0127 -->
        <div class="chapter" id="page-0127">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   3 لطفاً توجه داشته باشید، این بسیار ساده شده است—به عنوان مثال، من کد <strong>error-handling</strong> را کاملاً حذف کرده‌ام. اگر می‌خواهید در مورد <strong>async/await</strong>، به طور خاص در <strong>JavaScript</strong>، اطلاعات بیشتری کسب کنید، <em>The Modern JavaScript Tutorial</em> مکان خوبی برای شروع است.
  </p>
<p>
   هنگامی که ما با استفاده از <strong>await</strong> به <strong>eurToGbp</strong> <strong>reference</strong> می‌کنیم، ما <strong>block</strong> می‌کنیم تا زمانی که <strong>state</strong> <strong>latestRate</strong> <strong>fulfilled</strong> شود—به <strong>process</strong> نمی‌رسیم تا زمانی که <strong>state</strong> <strong>eurToGbp</strong> را حل کنیم.3
  </p>
<p>
   حتی اگر نرخ‌های ارز ما به روشی ناهمزمان دریافت می‌شوند، استفاده از <strong>await</strong> در این زمینه به این معنی است که ما تا زمانی که <strong>state</strong> <strong>latestRate</strong> حل شود، <strong>blocking</strong> می‌کنیم. بنابراین حتی اگر فناوری اساسی که ما برای دریافت نرخ استفاده می‌کنیم، می‌تواند ذاتاً ناهمزمان در نظر گرفته شود (به عنوان مثال، منتظر ماندن برای نرخ)، از نظر کد ما، این ذاتاً یک تعامل <strong>synchronous</strong> و <strong>blocking</strong> است.
  </p>
<h4>کجا از آن استفاده کنیم</h4>
<p>
   در نهایت، هنگامی که در نظر می‌گیرید که آیا ارتباط ناهمزمان برای شما مناسب است یا خیر، شما همچنین باید در نظر بگیرید که کدام نوع از ارتباط ناهمزمان را می‌خواهید انتخاب کنید، زیرا هر نوع مزایای خاص خود را دارد. با این حال، به طور کلی، برخی موارد استفاده خاص وجود دارد که من را وادار می‌کند تا به دنبال نوعی از ارتباط ناهمزمان بروم. فرآیندهای طولانی مدت یک کاندیدای آشکار هستند، همانطور که در شکل 4-5 بررسی کردیم.
  </p>
<p>
   همچنین، موقعیت‌هایی که در آنها زنجیره‌های تماس طولانی دارید که نمی‌توانید به راحتی آنها را دوباره ساختار دهید، می‌تواند یک کاندیدای خوب باشد. ما در مورد این موضوع زمانی که به سه شکل رایج‌تر ارتباط ناهمزمان—فراخوانی‌های <strong>request-response</strong>، ارتباط <strong>event-driven</strong>، و ارتباط از طریق داده‌های مشترک—نگاه می‌کنیم، عمیق‌تر خواهیم شد.
  </p>
<h4>الگو: Communication Through Common Data</h4>
<p>
   یک سبک ارتباطی که طیف وسیعی از پیاده‌سازی‌ها را در بر می‌گیرد، ارتباط از طریق داده‌های مشترک است. از این الگو زمانی استفاده می‌شود که یک microservice داده‌ها را در یک مکان تعریف‌شده قرار می‌دهد، و microservice دیگری (یا به طور بالقوه microservicesهای متعدد) سپس از داده‌ها استفاده می‌کند. این می‌تواند به سادگی یک microservice باشد که فایلی را در یک مکان قرار می‌دهد، و در مقطعی بعد، microservice دیگری آن فایل را برمی‌دارد و با آن کاری انجام می‌دهد. این سبک ادغام اساساً ماهیتی ناهمزمان دارد.
  </p>
<p>
   مثالی از این سبک را می‌توان در شکل 4-6 مشاهده کرد، جایی که <strong>New Product Importer</strong> فایلی را ایجاد می‌کند که سپس توسط microservicesهای <strong>Inventory</strong> و <strong>Catalog</strong> خوانده می‌شود.
  </p>
<p>Pattern: Communication Through Common Data | 101</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0127</div>
            </div>
        </div>
        <!-- Page 0128 -->
        <div class="chapter" id="page-0128">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 4-6. یک microservice فایلی را می‌نویسد که microservicesهای دیگر از آن استفاده می‌کنند
  </p>
<p>
   این الگو از جهاتی رایج‌ترین الگوی عمومی ارتباط بین فرآیندی است که شما خواهید دید، و با این حال ما گاهی اوقات نمی‌توانیم آن را به عنوان یک الگوی ارتباطی در نظر بگیریم—من فکر می‌کنم عمدتاً به این دلیل که ارتباط بین فرآیندها اغلب آنقدر غیرمستقیم است که تشخیص آن دشوار است.
  </p>
<h4>پیاده‌سازی</h4>
<p>
   برای پیاده‌سازی این الگو، شما به نوعی <strong>persistent store</strong> برای داده‌ها نیاز دارید. در بسیاری از موارد، یک <strong>filesystem</strong> می‌تواند کافی باشد. من سیستم‌های زیادی را ساخته‌ام که فقط دوره‌ای یک <strong>filesystem</strong> را اسکن می‌کنند، وجود یک فایل جدید را یادداشت می‌کنند، و بر این اساس به آن واکنش نشان می‌دهند. شما همچنین می‌توانید از نوعی حافظه توزیع‌شده <strong>memory store</strong> استفاده کنید. لازم به ذکر است که هر microservice پایین‌دست که قرار است بر اساس این داده‌ها عمل کند، به مکانیزم خود برای شناسایی در دسترس بودن داده‌های جدید نیاز دارد—<strong>polling</strong> یک راه‌حل مکرر برای این مشکل است.
  </p>
<p>
   دو مثال رایج از این الگو، <strong>data lake</strong> و <strong>data warehouse</strong> هستند. در هر دو مورد، این راه‌حل‌ها معمولاً برای کمک به پردازش حجم زیادی از داده‌ها طراحی شده‌اند، اما می‌توان گفت که آنها در انتهای مخالف طیف از نظر <em>coupling</em> وجود دارند.
  </p>
<p>
   با یک <strong>data lake</strong>، منابع داده‌های خام را با هر فرمتی که مناسب می‌دانند آپلود می‌کنند، و از مصرف‌کنندگان پایین‌دست این داده‌های خام انتظار می‌رود که بدانند چگونه اطلاعات را پردازش کنند. با یک <strong>data warehouse</strong>، خود <strong>warehouse</strong> یک انبار داده ساختاریافته است.
  </p>
<p>
   Microservices که داده‌ها را به <strong>data warehouse</strong> منتقل می‌کنند، باید ساختار <strong>data warehouse</strong> را بدانند—اگر ساختار به روشی که با عقب سازگار نیست تغییر کند، این تولیدکنندگان باید به‌روز شوند.
  </p>
<p>
   با هر دو <strong>data warehouse</strong> و <strong>data lake</strong>، این فرض وجود دارد که جریان اطلاعات در یک جهت واحد است. یک microservice داده‌ها را به انبار داده‌های مشترک منتشر می‌کند، و <strong>consumers</strong> پایین‌دست آن داده‌ها را می‌خوانند و اقدامات مناسب را انجام می‌دهند. این جریان یک‌طرفه می‌تواند <strong>reasoning</strong> را در مورد جریان
  </p>
<p>102 | Chapter 4: Microservice Communication Styles</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 128" src="page_0128/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0128</div>
            </div>
        </div>
        <!-- Page 0129 -->
        <div class="chapter" id="page-0129">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   اطلاعات. یک پیاده‌سازی مشکل‌سازتر، استفاده از یک پایگاه داده مشترک خواهد بود که در آن microservicesهای متعدد هم در حال خواندن و هم در حال نوشتن در <strong>data store</strong> یکسان هستند، مثالی از این را ما در فصل 2، هنگامی که <em>common coupling</em> را بررسی کردیم، مورد بحث قرار دادیم—شکل 4-7 نشان می‌دهد که هر دو <strong>Order Processor</strong> و <strong>Warehouse</strong> در حال به‌روزرسانی همان رکورد هستند.
  </p>
<p>
   شکل 4-7. مثالی از <strong>common coupling</strong> که در آن هر دو <strong>Order Processor</strong> و <strong>Ware house</strong> در حال به‌روزرسانی همان رکورد سفارش هستند.
  </p>
<h4>مزایا</h4>
<p>
   این الگو را می‌توان با استفاده از فناوری‌های متداولاً درک شده، بسیار ساده پیاده‌سازی کرد. اگر شما می‌توانید فایلی را بخوانید یا در آن بنویسید یا در یک پایگاه داده بخوانید و بنویسید، می‌توانید از این الگو استفاده کنید. استفاده از فناوری رایج و به خوبی درک شده همچنین قابلیت همکاری بین انواع مختلف سیستم‌ها، از جمله برنامه‌های قدیمی <strong>mainframe</strong> یا محصولات نرم‌افزاری <strong>customizable off-the-shelf (COTS)</strong> را امکان‌پذیر می‌کند. حجم داده‌ها نیز در اینجا کمتر نگران‌کننده است—اگر شما مقدار زیادی داده را در یکباره ارسال می‌کنید، این الگو می‌تواند خوب عمل کند.
  </p>
<h4>معایب</h4>
<p>
   microservicesهای مصرف‌کننده پایین‌دست معمولاً از وجود داده‌های جدید برای پردازش از طریق نوعی مکانیسم <strong>polling</strong>، یا شاید از طریق یک کار زمان‌بندی‌شده که دوره‌ای فعال می‌شود، آگاه خواهند بود. این بدان معناست که این مکانیسم بعید است که در موقعیت‌های با <strong>low-latency</strong> مفید باشد. البته شما می‌توانید این الگو را با نوع دیگری از <strong>call</strong> ترکیب کنید که یک microservice پایین‌دست را از در دسترس بودن داده‌های جدید مطلع می‌کند. به عنوان مثال، من می‌توانم فایلی را در یک <strong>filesystem</strong> مشترک بنویسم و سپس یک <strong>call</strong> به microservice مورد نظر ارسال کنم و به آن اطلاع دهم که داده‌های جدیدی وجود دارد که ممکن است بخواهد. این می‌تواند شکاف بین انتشار داده‌ها و پردازش داده‌ها را از بین ببرد. به طور کلی، با این حال، اگر شما از این الگو برای حجم بسیار زیادی از داده‌ها استفاده می‌کنید، احتمال کمتری وجود دارد که <strong>low latency</strong> در اولویت باشد
  </p>
<p>Pattern: Communication Through Common Data | 103</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 129" src="page_0129/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0129</div>
            </div>
        </div>
        <!-- Page 0130 -->
        <div class="chapter" id="page-0130">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   در لیست الزامات شما. اگر شما علاقه‌مند به ارسال حجم زیادی از داده‌ها هستید و می‌خواهید آنها را بیشتر در "زمان واقعی" پردازش کنید، در این صورت استفاده از نوعی فناوری <strong>streaming</strong> مانند <strong>Kafka</strong> مناسب‌تر است.
  </p>
<p>
   یکی دیگر از معایب بزرگ، و چیزی که اگر به یاد داشته باشید به بررسی <em>common coupling</em> در شکل 4-7 برمی‌گردد، این است که <strong>data store</strong> مشترک، به یک منبع بالقوه <em>coupling</em> تبدیل می‌شود. اگر <strong>data store</strong> ساختار خود را به نحوی تغییر دهد، می‌تواند ارتباط بین microservicesها را مختل کند.
  </p>
<p>
   استحکام ارتباط نیز به استحکام <strong>data store</strong> زیربنایی بستگی خواهد داشت. این از نظر محدودیت، یک نقطه ضعف نیست، اما چیزی است که باید از آن آگاه بود. اگر فایلی را در یک <strong>filesystem</strong> قرار می‌دهید، ممکن است بخواهید مطمئن شوید که خود <strong>filesystem</strong> به روش‌های جالب شکست نخواهد خورد.
  </p>
<h4>کجا از آن استفاده کنیم</h4>
<p>
   جایی که این الگو واقعاً می‌درخشد، در فعال کردن قابلیت همکاری بین فرآیندهایی است که ممکن است محدودیت‌هایی در مورد فناوری که می‌توانند استفاده کنند داشته باشند. داشتن یک سیستم موجود برای صحبت با <strong>interface GRPC</strong> microservice شما یا اشتراک در موضوع <strong>Kafka</strong> آن ممکن است از دیدگاه microservice مناسب‌تر باشد، اما از دیدگاه یک <strong>consumer</strong> مناسب نیست. سیستم‌های قدیمی‌تر ممکن است محدودیت‌هایی در مورد فناوری که می‌توانند پشتیبانی کنند داشته باشند و ممکن است هزینه‌های تغییر بالایی داشته باشند. از سوی دیگر، حتی سیستم‌های قدیمی <strong>mainframe</strong> نیز باید بتوانند داده‌ها را از یک فایل بخوانند. البته این همه به استفاده از فناوری <strong>data store</strong> که به طور گسترده پشتیبانی می‌شود بستگی دارد—من همچنین می‌توانم این الگو را با استفاده از چیزی مانند یک کش <strong>Redis</strong> پیاده‌سازی کنم. اما آیا سیستم قدیمی <strong>mainframe</strong> شما می‌تواند با <strong>Redis</strong> صحبت کند؟
  </p>
<p>
   یکی دیگر از نقاط شیرین اصلی برای این الگو، به اشتراک گذاشتن حجم زیادی از داده‌ها است. اگر شما نیاز به ارسال یک فایل چند گیگابایتی به یک <strong>filesystem</strong> یا بارگذاری چند میلیون ردیف در یک پایگاه داده دارید، این الگو راهی است که باید بروید.
  </p>
<h4>الگو: Request-Response Communication</h4>
<p>
   با <strong>request-response</strong>، یک microservice درخواستی را به یک <strong>service</strong> پایین‌دست ارسال می‌کند و از آن می‌خواهد کاری را انجام دهد و انتظار دارد که پاسخی با نتیجه درخواست دریافت کند. این تعامل می‌تواند از طریق یک فراخوانی <strong>synchronous blocking</strong> انجام شود، یا می‌توان آن را به روشی ناهمزمان <strong>nonblocking</strong> پیاده‌سازی کرد. یک مثال ساده از این تعامل در شکل 4-8 نشان داده شده است، جایی که microservice <strong>Chart</strong>، که پرفروش‌ترین سی‌دی‌ها را برای ژانرهای مختلف جمع‌آوری می‌کند، درخواستی را به <strong>Inventory service</strong> ارسال می‌کند و سطح موجودی فعلی را برای برخی از سی‌دی‌ها درخواست می‌کند.
  </p>
<p>
   شکل 4-8. <strong>Chart</strong>، یک درخواست همزمان را به microservice <strong>Inventory</strong> ارسال می‌کند.
  </p>
<p>104 | Chapter 4: Microservice Communication Styles</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0130</div>
            </div>
        </div>
        <!-- Page 0131 -->
        <div class="chapter" id="page-0131">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 4-8. microservice <strong>Chart</strong> درخواستی را به <strong>Inventory</strong> ارسال می‌کند و سطح موجودی را درخواست می‌کند
  </p>
<p>
   بازیابی داده‌ها از microservicesهای دیگر مانند این، یک مورد استفاده رایج برای یک <strong>request-response call</strong> است. با این حال، گاهی اوقات، شما فقط باید مطمئن شوید که کاری انجام می‌شود.
  </p>
<p>
   در شکل 4-9، <strong>Warehouse microservice</strong> درخواستی را از <strong>Order Processor</strong> دریافت می‌کند که از آن می‌خواهد موجودی را رزرو کند. <strong>Order Processor</strong> فقط باید بداند که سهام با موفقیت رزرو شده است تا قبل از اینکه بتواند به دریافت پرداخت ادامه دهد. اگر سهام نتواند رزرو شود—شاید به این دلیل که یک کالا دیگر در دسترس نیست—در این صورت پرداخت می‌تواند لغو شود. استفاده از فراخوانی‌های <strong>request-response</strong> در موقعیت‌هایی مانند این که <strong>calls</strong> باید به ترتیب معینی تکمیل شوند، رایج است.
  </p>
<p>
   شکل 4-9. <strong>Order Processor</strong> باید اطمینان حاصل کند که سهام قبل از دریافت پرداخت قابل رزرو است.
  </p>
<p>Pattern: Request-Response Communication | 105</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 131" src="page_0131/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 131" src="page_0131/image_2.png"/></div>
</div>
                <div class="page-number">صفحه 0131</div>
            </div>
        </div>
        <!-- Page 0132 -->
        <div class="chapter" id="page-0132">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Commands Versus Requests</h4>
<p>
   من از برخی از افراد شنیده‌ام که در مورد ارسال <strong>commands</strong>، به جای <strong>requests</strong>، به طور خاص در زمینه ارتباط <strong>asynchronous request-response</strong> صحبت می‌کنند. قصد پشت اصطلاح <strong>command</strong>، تا حدودی همانند قصد <strong>request</strong> است—یعنی، یک microservice بالادستی از یک microservice پایین‌دست می‌خواهد کاری را انجام دهد.
  </p>
<p>
   با این حال، شخصاً من اصطلاح <strong>request</strong> را خیلی بیشتر ترجیح می‌دهم. یک <strong>command</strong> به معنای یک دستورالعمل است که باید اطاعت شود، و می‌تواند منجر به وضعیتی شود که در آن افراد احساس کنند که باید بر اساس <strong>command</strong> عمل شود. یک <strong>request</strong> به معنای چیزی است که می‌توان آن را رد کرد. درست است که یک microservice هر <strong>request</strong> را بر اساس شایستگی‌های خود بررسی می‌کند و بر اساس منطق داخلی خود، تصمیم می‌گیرد که آیا باید بر اساس <strong>request</strong> عمل شود یا خیر. اگر <strong>request</strong> که برای آن ارسال شده است، منطق داخلی را نقض کند، microservice باید آن را رد کند. اگرچه این یک تفاوت ظریف است، اما من احساس نمی‌کنم که اصطلاح <strong>command</strong> معنای یکسانی را منتقل کند.
  </p>
<p>
   من از استفاده از <strong>request</strong> به جای <strong>command</strong> استفاده خواهم کرد، اما هر اصطلاحی که شما تصمیم به استفاده از آن دارید، فقط به یاد داشته باشید که یک microservice می‌تواند <strong>request/command</strong> را در صورت مناسب رد کند.
  </p>
<h4>پیاده‌سازی: Synchronous Versus Asynchronous</h4>
<p>
   فراخوانی‌های <strong>request-response</strong> مانند این را می‌توان به سبک <strong>blocking synchronous</strong> یا سبک ناهمزمان <strong>nonblocking</strong> پیاده‌سازی کرد. با یک <strong>synchronous call</strong>، آنچه معمولاً مشاهده می‌کنید، باز شدن یک اتصال شبکه با microservice پایین‌دست است، و <strong>request</strong> در امتداد این اتصال ارسال می‌شود. اتصال در حالی باز نگه داشته می‌شود که microservice بالادستی منتظر پاسخ microservice پایین‌دست است. در این مورد، microservice که پاسخ را ارسال می‌کند، واقعاً نیازی به دانستن چیزی در مورد microservice که <strong>request</strong> را ارسال کرده است، ندارد—این فقط مواردی را از طریق یک اتصال ورودی ارسال می‌کند. اگر آن اتصال از بین برود، شاید به این دلیل که نمونه microservice بالادستی یا پایین‌دستی از بین می‌رود، در این صورت ممکن است با مشکلی مواجه شویم.
  </p>
<p>
   با یک <strong>asynchronous request-response</strong>، اوضاع کمتر سرراست است. بیایید فرآیند مرتبط با رزرو سهام را دوباره بررسی کنیم. در شکل 4-10، درخواست رزرو سهام به عنوان یک پیام از طریق نوعی <strong>message broker</strong> ارسال می‌شود (ما در ادامه این فصل <strong>message brokers</strong> را بررسی خواهیم کرد). به جای اینکه پیام مستقیماً از <strong>Order Processor</strong> به microservice <strong>Inventory</strong> برود، در عوض در یک صف قرار می‌گیرد. <strong>Inventory</strong> هنگامی که قادر است، پیام‌ها را از این صف مصرف می‌کند. این درخواست را می‌خواند، کار مرتبط با رزرو سهام را انجام می‌دهد، و سپس نیاز دارد که پاسخ را به یک صف که <strong>Order Processor</strong> از آن می‌خواند، برگرداند. microservice <strong>Inventory</strong> باید بداند که پاسخ را از کجا مسیریابی کند. در مثال ما، این پاسخ را از طریق صف دیگری ارسال می‌کند که به نوبه خود توسط <strong>Order Processor</strong> مصرف می‌شود.
  </p>
<p>106 | Chapter 4: Microservice Communication Styles</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0132</div>
            </div>
        </div>
        <!-- Page 0133 -->
        <div class="chapter" id="page-0133">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 4-10. استفاده از صف‌ها برای ارسال درخواست‌های رزرو سهام
  </p>
<p>
   بنابراین با یک تعامل ناهمزمان <strong>nonblocking</strong>، microservice که درخواست را دریافت می‌کند یا باید بداند که به طور ضمنی کجا پاسخ را مسیریابی کند یا اینکه به او گفته شود که پاسخ باید به کجا برود. هنگام استفاده از یک صف، ما این مزیت را داریم که چندین درخواست می‌توانند در صف منتظر بمانند تا رسیدگی شوند. این می‌تواند در موقعیت‌هایی کمک کند که درخواست‌ها به اندازه کافی سریع قابل رسیدگی نباشند. microservice می‌تواند درخواست بعدی را زمانی مصرف کند که آماده است، به جای اینکه با تماس‌های زیاد تحت تأثیر قرار گیرد. البته، سپس خیلی چیزها به جذب این درخواست‌ها توسط صف بستگی دارد.
  </p>
<p>
   وقتی یک microservice به این ترتیب پاسخی دریافت می‌کند، ممکن است نیاز داشته باشد که پاسخ را به درخواست اصلی مرتبط کند. این می‌تواند چالش‌برانگیز باشد، زیرا زمان زیادی ممکن است سپری شده باشد، و بسته به ماهیت <strong>protocol</strong> مورد استفاده، پاسخ ممکن است به همان نمونه microservice که درخواست را ارسال کرده است، بازنگردد. در مثال ما از رزرو سهام به عنوان بخشی از ثبت سفارش، ما باید بدانیم چگونه پاسخ "سهام رزرو شده" را با یک سفارش مشخص مرتبط کنیم تا بتوانیم به پردازش آن سفارش خاص ادامه دهیم. یک راه آسان برای رسیدگی به این موضوع، ذخیره هر <strong>state</strong> مرتبط با درخواست اصلی در یک پایگاه داده است، به طوری که هنگامی که پاسخ می‌رسد، نمونه دریافت‌کننده می‌تواند هر <strong>state</strong> مرتبط را دوباره بارگیری کند و بر این اساس عمل کند.
  </p>
<p>
   یک نکته آخر: همه اشکال تعامل <strong>request-response</strong> احتمالاً به نوعی رسیدگی به <strong>time-out</strong> نیاز دارند تا از مشکلاتی که در آن سیستم برای چیزی که ممکن است هرگز اتفاق نیفتد، مسدود می‌شود، جلوگیری شود. نحوه پیاده‌سازی این <strong>time-out functionality</strong> می‌تواند بر اساس فناوری پیاده‌سازی متفاوت باشد، اما مورد نیاز خواهد بود.
  </p>
<p>ما در فصل 12 با جزئیات بیشتری به <strong>time-outs</strong> نگاه خواهیم کرد.</p>
<p>Pattern: Request-Response Communication | 107</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 133" src="page_0133/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0133</div>
            </div>
        </div>
        <!-- Page 0134 -->
        <div class="chapter" id="page-0134">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>فراخوانی‌های موازی در مقابل متوالی</h4>
<p>
   هنگام کار با تعاملات <strong>request-response</strong>، شما اغلب با موقعیتی مواجه می‌شوید که در آن قبل از اینکه بتوانید به پردازش ادامه دهید، باید چندین <strong>call</strong> انجام دهید.
  </p>
<p>
   وضعیتی را در نظر بگیرید که در آن <strong>MusicCorp</strong> نیاز دارد که قیمت یک کالای خاص را از سه انباردار مختلف بررسی کند، که ما این کار را با صدور فراخوانی‌های <strong>API</strong> انجام می‌دهیم. ما می‌خواهیم قیمت‌ها را از هر سه انباردار دریافت کنیم قبل از اینکه تصمیم بگیریم از کدام یک باید سهام جدید سفارش دهیم. ما می‌توانیم تصمیم بگیریم که سه <strong>call</strong> را به صورت متوالی انجام دهیم—منتظر بمانیم تا هر کدام تمام شود قبل از ادامه دادن به بعدی. در چنین موقعیتی، ما منتظر مجموع <strong>latencies</strong> هر یک از <strong>calls</strong> خواهیم بود. اگر فراخوانی <strong>API</strong> به هر ارائه دهنده یک ثانیه طول بکشد تا بازگردد، ما سه ثانیه منتظر خواهیم بود قبل از اینکه بتوانیم تصمیم بگیریم که از چه کسی باید سفارش دهیم.
  </p>
<p>
   یک گزینه بهتر این است که این سه درخواست را به موازات هم اجرا کنیم. سپس <strong>latency</strong> کلی عملیات بر اساس کندترین فراخوانی <strong>API</strong> خواهد بود، نه بر اساس مجموع <strong>latencies</strong> هر فراخوانی <strong>API</strong>.
  </p>
<p>
<strong>Reactive extensions</strong> و مکانیسم‌هایی مانند <strong>async/await</strong> می‌توانند در کمک به اجرای <strong>calls</strong> به صورت موازی بسیار مفید باشند، و این می‌تواند منجر به بهبودهای قابل توجهی در <strong>latency</strong> برخی از عملیات شود.
  </p>
<h4>کجا از آن استفاده کنیم</h4>
<p>
   فراخوانی‌های <strong>request-response</strong> برای هر موقعیتی که در آن نتیجه یک درخواست قبل از اینکه پردازش بیشتر انجام شود، مورد نیاز است، کاملاً منطقی است. آنها همچنین در موقعیت‌هایی که یک microservice می‌خواهد بداند که آیا یک <strong>call</strong> کار نکرد تا بتواند نوعی اقدام جبرانی را انجام دهد، مانند یک <strong>retry</strong>، واقعاً مناسب هستند. اگر هر کدام با شرایط شما مطابقت داشته باشند، در این صورت <strong>request-response</strong> یک رویکرد منطقی است. تنها سوال باقی‌مانده این است که در مورد یک پیاده‌سازی <strong>synchronous</strong> در مقابل <strong>asynchronous</strong>، با همان مبادله‌هایی که قبلاً مورد بحث قرار دادیم، تصمیم بگیریم.
  </p>
<h4>الگو: ارتباط Event-Driven</h4>
<p>
   ارتباط <strong>event-driven</strong> در مقایسه با فراخوانی‌های <strong>request-response</strong> کاملاً عجیب به نظر می‌رسد.
   به جای اینکه یک microservice از microservice دیگری بخواهد کاری را انجام دهد، یک microservice <strong>events</strong> را منتشر می‌کند که ممکن است توسط microservicesهای دیگر دریافت شود یا نشود. این یک تعامل ذاتاً ناهمزمان است، زیرا <strong>event listeners</strong> در <strong>thread</strong> اجرایی خودشان اجرا خواهند شد.
  </p>
<p>
   یک <strong>event</strong>، بیانیه‌ای در مورد چیزی است که اتفاق افتاده است، که تقریباً همیشه چیزی است که در دنیای microservice که در حال انتشار <strong>event</strong> است، اتفاق افتاده است.
  </p>
<p>
   microservice که <strong>event</strong> را منتشر می‌کند، هیچ اطلاعی از قصد microservicesهای دیگر ندارد.
  </p>
<p>108 | Chapter 4: Microservice Communication Styles</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0134</div>
            </div>
        </div>
        <!-- Page 0135 -->
        <div class="chapter" id="page-0135">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   microservicesها از این رویداد استفاده کنند، و در واقع ممکن است حتی از وجود microservicesهای دیگر بی‌خبر باشد. هنگامی که لازم باشد، رویداد را منتشر می‌کند، و این پایان مسئولیت‌های آن است.
  </p>
<p>
   در شکل 4-11، ما می‌بینیم که <strong>Warehouse</strong> <strong>events</strong> مربوط به فرآیند بسته‌بندی یک سفارش را منتشر می‌کند. این <strong>events</strong> توسط دو microservice، <strong>Notifications</strong> و <strong>Inventory</strong>، دریافت می‌شوند، و آنها بر این اساس واکنش نشان می‌دهند. microservice <strong>Notifications</strong>، یک ایمیل برای به‌روزرسانی مشتری ما در مورد تغییرات وضعیت سفارش ارسال می‌کند، در حالی که microservice <strong>Inventory</strong> می‌تواند سطح موجودی را با بسته‌بندی اقلام در سفارش مشتری به‌روزرسانی کند.
  </p>
<p>
   شکل 4-11. <strong>Warehouse</strong> رویدادهایی را منتشر می‌کند که برخی از microservicesهای پایین‌دست در آنها مشترک می‌شوند
  </p>
<p>
<strong>Warehouse</strong> فقط در حال پخش <strong>events</strong> است، با این فرض که طرف‌های ذینفع بر این اساس واکنش نشان خواهند داد. این از اینکه چه کسانی گیرنده <strong>events</strong> هستند، بی‌اطلاع است، که تعاملات <strong>event-driven</strong> را به طور کلی بسیار <em>loosely coupled</em> می‌کند. وقتی این را با یک <strong>request-response call</strong> مقایسه می‌کنید، ممکن است مدتی طول بکشد تا درک خود را در مورد معکوس‌سازی مسئولیت به دست آورید. با <strong>request-response</strong>، ما ممکن است در عوض انتظار داشته باشیم که <strong>Warehouse</strong> به microservice <strong>Notifications</strong> بگوید که در صورت مناسب بودن، ایمیل‌ها را ارسال کند. در چنین مدلی، <strong>Warehouse</strong> باید بداند که چه <strong>events</strong> نیاز به اطلاع‌رسانی به مشتری دارند. با یک تعامل <strong>event-driven</strong>، ما در عوض آن مسئولیت را به microservice <strong>Notifications</strong> منتقل می‌کنیم.
  </p>
<p>
   قصد پشت یک <strong>event</strong> می‌تواند در مقابل یک <strong>request</strong> در نظر گرفته شود. <strong>event emitter</strong> این موضوع را به دریافت‌کنندگان واگذار می‌کند که تصمیم بگیرند چه کاری انجام دهند. با <strong>request-response</strong>، microservice که <strong>request</strong> را ارسال می‌کند، می‌داند که چه کاری باید انجام شود و به microservice دیگر می‌گوید که به نظرش چه چیزی باید در مرحله بعد اتفاق بیفتد. این البته به این معنی است که در <strong>request-response</strong>، درخواست‌کننده باید از آنچه که گیرنده پایین‌دست می‌تواند انجام دهد، آگاهی داشته باشد، که حاکی از درجه بالاتری از <strong>domain coupling</strong> است. با <strong>event-driven</strong>
</p>
<p>Pattern: Event-Driven Communication | 109</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 135" src="page_0135/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0135</div>
            </div>
        </div>
        <!-- Page 0136 -->
        <div class="chapter" id="page-0136">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   در این حالت، <strong>event emitter</strong> نیازی به دانستن اینکه کدام microservicesهای پایین‌دست قادر به انجام چه کاری هستند، ندارد، و در واقع ممکن است حتی نداند که آنها وجود دارند—در نتیجه، <em>coupling</em> تا حد زیادی کاهش می‌یابد.
  </p>
<p>
   توزیع مسئولیتی که ما با تعاملات <strong>event-driven</strong> خود می‌بینیم می‌تواند توزیع مسئولیتی را که با سازمان‌هایی که در تلاش برای ایجاد تیم‌های خودمختارتر هستند، منعکس کند. به جای نگه‌داشتن تمام مسئولیت‌ها به صورت مرکزی، ما می‌خواهیم آن را به خود تیم‌ها منتقل کنیم تا به آنها اجازه دهیم به روشی خودمختارتر عمل کنند—مفهومی که ما در فصل 15 به آن باز خواهیم گشت. در اینجا، ما مسئولیت را از <strong>Warehouse</strong> به <strong>Notifications</strong> و <strong>Payment</strong> منتقل می‌کنیم—این می‌تواند به ما در کاهش پیچیدگی microservicesها مانند <strong>Warehouse</strong> کمک کند و منجر به توزیع یکنواخت‌تری از "هوش" در سیستم ما شود. ما این ایده را با جزئیات بیشتری هنگام مقایسه <strong>choreography</strong> و <strong>orchestration</strong> در فصل 6 بررسی خواهیم کرد.
  </p>
<h4>Events و Messages</h4>
<p>
   من گاهی اوقات دیده‌ام که اصطلاحات <strong>messages</strong> و <strong>events</strong> با هم اشتباه گرفته می‌شوند. یک <strong>event</strong> یک واقعیت است—بیانیه‌ای مبنی بر اینکه چیزی اتفاق افتاده است، به همراه مقداری اطلاعات در مورد اینکه دقیقاً چه اتفاقی افتاده است. یک <strong>message</strong> چیزی است که ما از طریق یک مکانیسم ارتباط ناهمزمان، مانند یک <strong>message broker</strong>، ارسال می‌کنیم.
  </p>
<p>
   با همکاری <strong>event-driven</strong>، ما می‌خواهیم آن <strong>event</strong> را پخش کنیم، و یک راه معمول برای پیاده‌سازی آن مکانیسم پخش، قرار دادن <strong>event</strong> در یک <strong>message</strong> است.
  </p>
<p>
<strong>Message</strong>، واسطه است. <strong>Event</strong>، <strong>payload</strong> است.
  </p>
<p>
   به همین ترتیب، ما ممکن است بخواهیم یک <strong>request</strong> را به عنوان <strong>payload</strong> یک <strong>message</strong> ارسال کنیم—که در این صورت ما یک نوع از <strong>asynchronous request-response</strong> را پیاده‌سازی می‌کنیم.
  </p>
<h4>پیاده‌سازی</h4>
<p>
   دو جنبه اصلی وجود دارد که ما باید در اینجا در نظر بگیریم: راهی برای microservicesهای ما برای انتشار <strong>events</strong>، و راهی برای مصرف‌کنندگان ما برای فهمیدن اینکه این <strong>events</strong> اتفاق افتاده است.
  </p>
<p>
   به طور سنتی، <strong>message brokers</strong>ها مانند <strong>RabbitMQ</strong> سعی می‌کنند هر دو مشکل را مدیریت کنند. <strong>Producers</strong> از یک <strong>API</strong> برای انتشار یک <strong>event</strong> به <strong>broker</strong> استفاده می‌کنند. <strong>Broker</strong> اشتراک‌ها را مدیریت می‌کند و به مصرف‌کنندگان اجازه می‌دهد تا هنگام رسیدن یک <strong>event</strong> مطلع شوند. این <strong>brokers</strong>ها حتی می‌توانند <strong>state</strong> مصرف‌کنندگان را مدیریت کنند—به عنوان مثال، با کمک به پیگیری اینکه چه پیام‌هایی را قبلاً دیده‌اند. این سیستم‌ها معمولاً به گونه‌ای طراحی شده‌اند که مقیاس‌پذیر و انعطاف‌پذیر باشند، اما این ویژگی رایگان نیست. این می‌تواند پیچیدگی را به فرآیند توسعه اضافه کند، زیرا این یک سیستم دیگر است که شما ممکن است برای توسعه و آزمایش <strong>services</strong> خود نیاز به اجرای آن داشته باشید. ممکن است به دستگاه‌ها و تخصص‌های اضافی نیز برای راه‌اندازی و اجرای این زیرساخت نیاز باشد. اما هنگامی که این کار انجام شد، می‌تواند یک راه فوق‌العاده مؤثر برای پیاده‌سازی معماری‌های <strong>loosely coupled</strong> و <strong>event-driven</strong> باشد. به طور کلی، من طرفدار آن هستم.
  </p>
<p>109 | Chapter 4: Microservice Communication Styles</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0136</div>
            </div>
        </div>
        <!-- Page 0137 -->
        <div class="chapter" id="page-0137">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   با این حال، در مورد دنیای <strong>middleware</strong>، که <strong>message broker</strong> تنها بخش کوچکی از آن است، محتاط باشید. صف‌ها به خودی خود، چیزهای کاملاً معقول و مفیدی هستند. با این حال، فروشندگان تمایل دارند که نرم‌افزارهای زیادی را با آنها بسته‌بندی کنند، که می‌تواند منجر به این شود که هوش بیشتری به <strong>middleware</strong> وارد شود، همانطور که توسط مواردی مانند <strong>enterprise service bus</strong> مشهود است. مطمئن شوید که می‌دانید چه چیزی به دست می‌آورید: <strong>middleware</strong> خود را <strong>dumb</strong> نگه دارید، و هوش را در <strong>endpoints</strong> نگه دارید.
  </p>
<p>
   رویکرد دیگر این است که سعی کنید از <strong>HTTP</strong> به عنوان راهی برای انتشار <strong>events</strong> استفاده کنید. <strong>Atom</strong> یک مشخصات سازگار با <strong>REST</strong> است که معناشناسی (از جمله موارد دیگر) را برای انتشار فیدهای <strong>resources</strong> تعریف می‌کند. بسیاری از کتابخانه‌های کلاینت وجود دارند که به ما امکان ایجاد و مصرف این فیدها را می‌دهند. بنابراین <strong>customer service</strong> ما می‌تواند هر زمان که <strong>customer service</strong> ما تغییر می‌کند، یک <strong>event</strong> را به چنین فید منتشر کند. مصرف‌کنندگان ما به سادگی فید را <strong>poll</strong> می‌کنند و به دنبال تغییرات هستند. از یک طرف، این واقعیت که ما می‌توانیم از مشخصات <strong>Atom</strong> موجود و هر کتابخانه مرتبط استفاده مجدد کنیم، مفید است، و ما می‌دانیم که <strong>HTTP</strong> مقیاس را خیلی خوب مدیریت می‌کند. با این حال، این استفاده از <strong>HTTP</strong> در <strong>low latency</strong> خوب نیست (جایی که برخی از <strong>message brokers</strong>ها عالی هستند)، و ما همچنان باید با این واقعیت مقابله کنیم که مصرف‌کنندگان باید پیگیری کنند که چه پیام‌هایی را دیده‌اند و برنامه <strong>polling</strong> خود را مدیریت کنند.
  </p>
<p>
   من دیده‌ام که افراد زمان زیادی را صرف پیاده‌سازی رفتارهای بیشتری می‌کنند که شما از جعبه با یک <strong>message broker</strong> مناسب دریافت می‌کنید تا <strong>Atom</strong> برای برخی موارد استفاده کار کند. به عنوان مثال، الگوی <strong>competing consumer</strong> روشی را توصیف می‌کند که به موجب آن شما چندین نمونه کارگر را برای رقابت بر سر پیام‌ها بالا می‌آورید، که برای مقیاس‌بندی تعداد کارگران برای رسیدگی به فهرستی از مشاغل مستقل (ما در فصل بعد به آن باز خواهیم گشت) به خوبی کار می‌کند. با این حال، ما می‌خواهیم از این مورد اجتناب کنیم که در آن دو یا چند کارگر، یک پیام یکسان را ببینند، زیرا در نهایت کار یکسانی را بیشتر از آنچه نیاز داریم، انجام خواهیم داد. با یک <strong>message broker</strong>، یک صف استاندارد این کار را مدیریت خواهد کرد. با <strong>Atom</strong>، ما اکنون نیاز داریم که <strong>state</strong> مشترک خود را در میان همه کارگران مدیریت کنیم تا سعی کنیم شانس تکرار تلاش را کاهش دهیم.
  </p>
<p>
   اگر از قبل یک <strong>message broker</strong> خوب و انعطاف‌پذیر در دسترس دارید، استفاده از آن را برای مدیریت انتشار و اشتراک در <strong>events</strong> در نظر بگیرید. اگر هنوز یکی ندارید، نگاهی به <strong>Atom</strong> بیندازید، اما از مغلطه هزینه مدفون آگاه باشید. اگر متوجه شدید که به پشتیبانی بیشتری که یک <strong>message broker</strong> به شما می‌دهد نیاز دارید، در یک نقطه مشخص ممکن است بخواهید رویکرد خود را تغییر دهید.
  </p>
<p>
   از نظر آنچه که ما در واقع از طریق این <strong>protocols asynchronous</strong> ارسال می‌کنیم، همان ملاحظات با ارتباط <strong>synchronous</strong> اعمال می‌شود. اگر در حال حاضر از رمزگذاری درخواست‌ها و پاسخ‌ها با استفاده از <strong>JSON</strong> خوشحال هستید، به آن پایبند باشید.
  </p>
<h4>یک <strong>Event</strong> در چه چیزی است؟</h4>
<p>
   در شکل 4-12، ما یک <strong>event</strong> را می‌بینیم که از microservice <strong>Customer</strong> پخش می‌شود، و به طرف‌های ذینفع اطلاع می‌دهد که یک مشتری جدید با سیستم ثبت‌نام کرده است. دو مورد از microservicesهای پایین‌دست، <strong>Loyalty</strong> و <strong>Notifications</strong>، به این <strong>event</strong> اهمیت می‌دهند.
  </p>
<p>
   microservice <strong>Loyalty</strong> با دریافت <strong>event</strong> با راه‌اندازی یک حساب برای
  </p>
<p>Pattern: Event-Driven Communication | 111</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0137</div>
            </div>
        </div>
        <!-- Page 0138 -->
        <div class="chapter" id="page-0138">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   در این مثال، microservice <strong>Notifications</strong> و <strong>Loyalty</strong>، به <strong>event</strong> واکنش نشان می‌دهند. microservice <strong>Loyalty</strong> با راه‌اندازی یک حساب برای مشتری جدید به <strong>event</strong> واکنش نشان می‌دهد تا آنها بتوانند شروع به کسب امتیاز کنند، در حالی که microservice <strong>Notifications</strong>، ایمیلی را به مشتری تازه ثبت‌نام شده ارسال می‌کند و از آنها به خاطر لذت‌های شگفت‌انگیز <strong>MusicCorp</strong> استقبال می‌کند.
  </p>
<p>
   شکل 4-12. microservicesهای <strong>Notifications</strong> و <strong>Loyalty</strong> یک <strong>event</strong> را هنگام ثبت‌نام یک مشتری جدید دریافت می‌کنند
  </p>
<p>
   با یک <strong>request</strong>، ما از یک microservice می‌خواهیم کاری را انجام دهد و اطلاعات مورد نیاز را برای انجام عملیات درخواستی ارائه می‌کنیم. با یک <strong>event</strong>، ما یک واقعیت را منتشر می‌کنیم که سایر طرف‌ها ممکن است به آن علاقه‌مند باشند، اما از آنجایی که microservice که یک <strong>event</strong> را منتشر می‌کند، نمی‌تواند و نباید بداند چه کسی <strong>event</strong> را دریافت می‌کند، ما چگونه می‌دانیم که سایر طرف‌ها ممکن است به چه اطلاعاتی از <strong>event</strong> نیاز داشته باشند؟ دقیقاً چه چیزی باید در داخل <strong>event</strong> باشد؟
  </p>
<h4>فقط یک <strong>ID</strong></h4>
<p>
   یک گزینه این است که <strong>event</strong> فقط شامل یک شناسگر برای مشتری تازه ثبت‌نام شده باشد، همانطور که در شکل 4-13 نشان داده شده است. microservice <strong>Loyalty</strong> فقط به این شناسگر برای ایجاد حساب وفاداری منطبق نیاز دارد، بنابراین همه اطلاعاتی که نیاز دارد را دارد. با این حال، در حالی که microservice <strong>Notifications</strong> می‌داند که برای انجام کار خود نیاز به ارسال یک ایمیل خوشامدگویی دارد، برای انجام کارش به اطلاعات اضافی نیاز دارد—حداقل یک آدرس ایمیل، و احتمالاً نام مشتری نیز به منظور دادن آن لمس شخصی به ایمیل. از آنجایی که این اطلاعات در <strong>event</strong> که microservice <strong>Notifications</strong> دریافت می‌کند وجود ندارد، چاره‌ای جز دریافت این اطلاعات از microservice <strong>Customer</strong> ندارد، چیزی که ما در شکل 4-13 می‌بینیم.
  </p>
<p>112 | Chapter 4: Microservice Communication Styles</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 138" src="page_0138/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0138</div>
            </div>
        </div>
        <!-- Page 0139 -->
        <div class="chapter" id="page-0139">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 4-13. microservice <strong>Notifications</strong> نیاز به درخواست جزئیات بیشتر از microservice <strong>Customer</strong> دارد که در رویداد گنجانده نشده است
  </p>
<p>
   برخی از معایب این رویکرد وجود دارد. اولاً، microservice <strong>Notifications</strong> اکنون باید در مورد microservice <strong>Customer</strong> اطلاعات داشته باشد، و <strong>domain coupling</strong> اضافی اضافه می‌کند. در حالی که <strong>domain coupling</strong>، همانطور که در فصل 2 مورد بحث قرار دادیم، در انتهای <em>coupling</em> آزادتر است، ما همچنان می‌خواهیم در صورت امکان از آن اجتناب کنیم. اگر <strong>event</strong> که microservice <strong>Notifications</strong> دریافت کرد، تمام اطلاعات مورد نیاز خود را شامل می‌شد، در این صورت نیازی به این <strong>callback</strong> وجود نداشت. <strong>Callback</strong> از microservice دریافت‌کننده همچنین می‌تواند منجر به دیگر معایب اصلی شود—یعنی، که در موقعیتی با تعداد زیادی microservices دریافت‌کننده، microservice که <strong>event</strong> را منتشر می‌کند، ممکن است در نتیجه با یک رگبار درخواست‌ها مواجه شود. تصور کنید اگر پنج microservices مختلف، همان <strong>customer creation event</strong> را دریافت کنند، و همه نیاز به درخواست اطلاعات اضافی داشته باشند—آنها همه باید فوراً درخواستی را به microservice <strong>Customer</strong> ارسال کنند تا آنچه را که نیاز دارند، دریافت کنند. با افزایش تعداد microservicesهای علاقه‌مند به یک <strong>event</strong> خاص، تأثیر این <strong>calls</strong> می‌تواند قابل توجه شود.
  </p>
<h4>رویدادهای کاملاً دقیق</h4>
<p>
   جایگزین، که من ترجیح می‌دهم، این است که همه چیز را در یک <strong>event</strong> قرار دهید که در غیر این صورت از طریق یک <strong>API</strong> به اشتراک می‌گذارید. اگر به microservice <strong>Notifications</strong> اجازه می‌دهید که آدرس ایمیل و نام یک مشتری مشخص را درخواست کند، چرا آن اطلاعات را در وهله اول در <strong>event</strong> قرار ندهیم؟ در شکل 4-14، ما این رویکرد را می‌بینیم—<strong>Notifica</strong>
   tions اکنون خودکفا است و می‌تواند کار خود را بدون نیاز به برقراری ارتباط با microservice <strong>Customer</strong> انجام دهد. در واقع، ممکن است هرگز نیازی به دانستن وجود microservice <strong>Customer</strong> نداشته باشد.
  </p>
<p>Pattern: Event-Driven Communication | 113</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 139" src="page_0139/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0139</div>
            </div>
        </div>
        <!-- Page 0140 -->
        <div class="chapter" id="page-0140">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شکل 4-14. یک <strong>event</strong> با اطلاعات بیشتر در آن می‌تواند به microservicesهای دریافت‌کننده اجازه دهد که بدون نیاز به فراخوانی‌های بیشتر به منبع <strong>event</strong>، عمل کنند
  </p>
<p>
   علاوه بر این واقعیت که <strong>events</strong> با اطلاعات بیشتر می‌توانند به <em>coupling</em> آزادتر اجازه دهند، <strong>events</strong> با اطلاعات بیشتر می‌توانند به عنوان یک سابقه تاریخی از آنچه برای یک موجودیت خاص اتفاق افتاده است، دو برابر شوند. این می‌تواند به شما در پیاده‌سازی یک سیستم حسابرسی کمک کند، یا شاید حتی توانایی بازسازی یک موجودیت را در نقاط مشخصی از زمان فراهم کند—به این معنی که این <strong>events</strong> می‌توانند به عنوان بخشی از یک <strong>event sourcing</strong>، مفهومی که ما در یک لحظه به طور خلاصه آن را بررسی خواهیم کرد، استفاده شوند.
  </p>
<p>
   در حالی که این رویکرد قطعاً ترجیح من است، اما خالی از اشکال نیست. اولاً، اگر داده‌های مرتبط با یک <strong>event</strong> بزرگ باشد، ممکن است در مورد اندازه <strong>event</strong> نگران باشیم. <strong>Message brokers</strong>های مدرن (با فرض اینکه شما از یکی برای پیاده‌سازی مکانیسم انتشار <strong>event</strong> خود استفاده می‌کنید) محدودیت‌های کاملاً سخاوتمندانه‌ای برای اندازه پیام دارند. اندازه حداکثر پیش‌فرض برای یک پیام در <strong>Kafka</strong>، 1 مگابایت است، و آخرین نسخه <strong>RabbitMQ</strong> دارای یک حد بالای نظری 512 مگابایت برای یک پیام واحد است (کاهش از حد قبلی 2 گیگابایت!)، حتی اگر کسی انتظار داشته باشد که برخی از مسائل عملکردی جالب با پیام‌های بزرگی مانند این وجود داشته باشد. اما حتی 1 مگابایت که به ما به عنوان حداکثر اندازه یک پیام در <strong>Kafka</strong> اعطا می‌شود، به ما فضای زیادی برای ارسال مقدار زیادی از داده‌ها می‌دهد. در نهایت، اگر شما در حال ورود به فضایی هستید که در آن شروع به نگرانی در مورد اندازه <strong>events</strong> خود دارید، در این صورت رویکردی ترکیبی را توصیه می‌کنم که در آن مقداری از اطلاعات در <strong>event</strong> باشد، اما سایر داده‌های (بزرگتر) را می‌توان در صورت نیاز جستجو کرد.
  </p>
<p>
   در شکل 4-14، <strong>Loyalty</strong> نیازی به دانستن آدرس ایمیل یا نام مشتری ندارد، و با این حال آن را از طریق <strong>event</strong> دریافت می‌کند. این می‌تواند منجر به نگرانی‌هایی شود اگر ما در تلاش برای محدود کردن دامنه microservicesهایی باشیم که می‌توانند چه نوع داده‌هایی را ببینند—به عنوان مثال، من ممکن است بخواهم محدود کنم که کدام microservicesها می‌توانند اطلاعات قابل شناسایی شخصی <strong>(PII)</strong>، جزئیات کارت پرداخت، یا داده‌های حساس مشابه را ببینند. یک راه برای حل این مشکل می‌تواند ارسال دو نوع مختلف <strong>events</strong> باشد—یکی که حاوی <strong>PII</strong> است و می‌تواند توسط برخی از microservicesها مشاهده شود، و دیگری که <strong>PII</strong> را حذف می‌کند و می‌تواند منتشر شود
  </p>
<p>Pattern: Event-Driven Communication | 113</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 140" src="page_0140/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0140</div>
            </div>
        </div>
        <!-- Page 0141 -->
        <div class="chapter" id="page-0141">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   به طور گسترده‌تر. این امر پیچیدگی را از نظر مدیریت دید <strong>events</strong>های مختلف و اطمینان از اینکه هر دو <strong>events</strong> واقعاً منتشر می‌شوند، اضافه می‌کند. چه اتفاقی می‌افتد وقتی که یک microservice نوع اول <strong>event</strong> را ارسال می‌کند اما قبل از اینکه <strong>event</strong> دوم بتواند ارسال شود، از بین می‌رود؟
  </p>
<p>
   یکی دیگر از ملاحظات این است که هنگامی که ما داده‌ها را در یک <strong>event</strong> قرار می‌دهیم، به بخشی از قرارداد ما با دنیای بیرون تبدیل می‌شود. ما باید آگاه باشیم که اگر فیلدی را از یک <strong>event</strong> حذف کنیم، ممکن است طرف‌های خارجی را خراب کنیم. <strong>Information hiding</strong> هنوز یک مفهوم مهم در همکاری <strong>event-driven</strong> است—هر چه داده‌های بیشتری در یک <strong>event</strong> قرار دهیم، مفروضات بیشتری را که طرف‌های خارجی در مورد <strong>event</strong> خواهند داشت. قانون کلی من این است که اگر خوشحال باشم که داده‌های یکسان را از طریق یک <strong>request-response API</strong> به اشتراک بگذارم، در قرار دادن اطلاعات در یک <strong>event</strong> مشکلی ندارم.
  </p>
<h4>کجا از آن استفاده کنیم</h4>
<p>
   همکاری <strong>event-driven</strong> در موقعیت‌هایی که اطلاعات می‌خواهد پخش شود، و در موقعیت‌هایی که شما از معکوس کردن قصد خوشحال هستید، رونق دارد. حرکت از یک مدل گفتن به چیزهای دیگر که چه کاری انجام دهند و در عوض به microservicesهای پایین‌دست اجازه دهید که این موضوع را برای خودشان حل کنند، جاذبه زیادی دارد.
  </p>
<p>
   در موقعیتی که شما بر <em>coupling</em> آزادتر بیش از عوامل دیگر تمرکز می‌کنید، همکاری <strong>event-driven</strong> جذابیت آشکاری خواهد داشت.
  </p>
<p>
   نکته احتیاطی این است که اغلب منابع جدیدی از پیچیدگی وجود دارد که با این سبک از همکاری به وجود می‌آید، به خصوص اگر شما در معرض آن قرار گرفته باشید.
  </p>
<p>
   اگر در مورد این شکل از ارتباط مطمئن نیستید، به یاد داشته باشید که معماری microservice ما می‌تواند (و احتمالاً خواهد بود) شامل ترکیبی از سبک‌های مختلف تعامل باشد. شما مجبور نیستید با همکاری <strong>event-driven</strong> به طور کامل پیش بروید. شاید فقط با یک <strong>event</strong> شروع کنید و از آنجا پیش بروید.
  </p>
<p>
   من شخصاً خود را به سمت همکاری <strong>event-driven</strong> تقریباً به عنوان یک پیش‌فرض سوق می‌دهم. به نظر می‌رسد مغز من به گونه‌ای دوباره سیم‌کشی شده است که این نوع ارتباطات برای من بدیهی به نظر می‌رسند. این کاملاً مفید نیست، زیرا تلاش برای توضیح اینکه چرا این مورد صادق است، دشوار است، به جز اینکه بگویم درست به نظر می‌رسد. اما این فقط سوگیری درونی من است—من به طور طبیعی به سمت آنچه می‌دانم، بر اساس تجربیات خودم، گرایش پیدا می‌کنم. این احتمال زیادی وجود دارد که جذابیت من برای این شکل از تعامل تقریباً به‌طور کامل ناشی از تجربیات بد قبلی‌ام با سیستم‌های بیش از حد <em>coupled</em> باشد. من ممکن است فقط در حال جنگیدن با آخرین نبرد بارها و بارها باشم بدون در نظر گرفتن اینکه شاید این بار واقعاً متفاوت است.
  </p>
<p>
   آنچه که من خواهم گفت، کنار گذاشتن سوگیری‌های خودم است، این است که من تیم‌های بسیار بیشتری را می‌بینم که تعاملات <strong>request-response</strong> را با تعاملات <strong>event-driven</strong> جایگزین می‌کنند تا بالعکس.
  </p>
<p>Pattern: Event-Driven Communication | 115</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0141</div>
            </div>
        </div>
        <!-- Page 0142 -->
        <div class="chapter" id="page-0142">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>احتیاط کنید</h4>
<p>
   برخی از این مطالب ناهمزمان، سرگرم‌کننده به نظر می‌رسند، درست است؟ به نظر می‌رسد که معماری‌های <strong>event-driven</strong> منجر به سیستم‌های بسیار <em>decoupled</em> و مقیاس‌پذیرتر می‌شوند. و می‌توانند این کار را انجام دهند. اما این سبک‌های ارتباطی منجر به افزایش پیچیدگی می‌شوند. این فقط پیچیدگی لازم برای مدیریت انتشار و اشتراک در پیام‌ها نیست، همانطور که ما فقط بحث کردیم، بلکه پیچیدگی در مشکلات دیگری نیز وجود دارد که ممکن است با آنها روبرو شویم. به عنوان مثال، هنگام در نظر گرفتن <strong>request-response</strong> <strong>async</strong> طولانی‌مدت، ما باید به این فکر کنیم که وقتی پاسخ برگشت، چه کاری انجام دهیم. آیا به همان <strong>node</strong> که درخواست را آغاز کرده است برمی‌گردد؟ اگر اینطور است، اگر آن <strong>node</strong> از کار افتاده باشد، چه اتفاقی می‌افتد؟ اگر نه، آیا من نیاز دارم که اطلاعات را در جایی ذخیره کنم تا بتوانم بر این اساس واکنش نشان دهم؟ <strong>Async</strong>های کوتاه‌مدت می‌تواند مدیریت آسان‌تری داشته باشند اگر <strong>APIs</strong> مناسبی دارید، اما با این وجود، این یک روش تفکر متفاوت برای برنامه‌نویسانی است که به فراخوانی‌های پیام <strong>synchronous</strong> درون فرآیندی عادت دارند.
  </p>
<p>
   زمان یک داستان هشداردهنده فرا رسیده است. در سال 2006، من در حال کار بر روی ساخت یک سیستم قیمت‌گذاری برای یک بانک بودم. ما به رویدادهای بازار نگاه می‌کردیم و مشخص می‌کردیم که کدام کالاها در یک پرتفوی نیاز به قیمت‌گذاری مجدد دارند. هنگامی که فهرست مواردی را که باید بررسی می‌کردیم، مشخص کردیم، همه آنها را در یک صف پیام قرار دادیم. ما از یک شبکه برای ایجاد مجموعه‌ای از <strong>pricing workers</strong> استفاده می‌کردیم، که به ما امکان می‌داد مزرعه قیمت‌گذاری را در صورت درخواست مقیاس‌بندی کنیم.
  </p>
<p>
   این <strong>workers</strong>ها از الگوی <strong>competing consumers</strong> استفاده می‌کردند، که هر کدام پیام‌ها را تا جایی که چیزی برای پردازش باقی نماند، با سرعت هر چه تمام‌تر می‌بلعیدند.
  </p>
<p>
   با این حال، سیستم راه‌اندازی و در حال اجرا بود، و ما احساس غرور می‌کردیم. اما یک روز، درست پس از اینکه یک <strong>release</strong> را منتشر کردیم، به یک مشکل ناخوشایند برخورد کردیم: <strong>workers</strong>های ما مدام در حال از کار افتادن بودند.
  </p>
<p>
   و از کار افتادن. و از کار افتادن.
  </p>
<p>
   سرانجام، ما مشکل را ردیابی کردیم. یک باگ به وجود آمده بود که باعث می‌شد یک نوع خاص از درخواست قیمت‌گذاری باعث از کار افتادن یک <strong>worker</strong> شود. ما از یک صف <strong>transacted</strong> استفاده می‌کردیم: با از کار افتادن <strong>worker</strong>، قفل آن روی درخواست تمام شد، و درخواست قیمت‌گذاری دوباره در صف قرار گرفت—فقط برای اینکه <strong>worker</strong> دیگری آن را انتخاب کند و از کار بیفتد. این یک نمونه کلاسیک از چیزی بود که <strong>Martin Fowler</strong> آن را <strong>catastrophic failover</strong> می‌نامد.
  </p>
<p>
   جدا از خود باگ، ما نتوانستیم یک محدودیت <strong>retry</strong> حداکثری را برای کار در صف مشخص کنیم. بنابراین ما باگ را برطرف کردیم، و یک <strong>retry</strong> حداکثری را پیکربندی کردیم. اما همچنین متوجه شدیم که به راهی برای مشاهده و احتمالاً پخش مجدد این پیام‌های بد نیاز داریم. ما در نهایت مجبور شدیم یک بیمارستان پیام (یا <strong>dead letter queue</strong>) را پیاده‌سازی کنیم، که در آن پیام‌ها در صورت شکست ارسال می‌شدند. ما همچنین یک <strong>UI</strong> برای مشاهده آن پیام‌ها و تکرار آنها در صورت نیاز ایجاد کردیم. این نوع مشکلات بلافاصله آشکار نمی‌شوند اگر شما فقط با ارتباط <strong>synchronous point-to-point</strong> آشنا هستید.
  </p>
<p>
   پیچیدگی مرتبط با معماری‌های <strong>event-driven</strong> و برنامه‌نویسی ناهمزمان به طور کلی، من را بر این باور می‌کند که شما باید در مورد اینکه چقدر مشتاقانه این ایده‌ها را اتخاذ می‌کنید، محتاط باشید. اطمینان حاصل کنید که نظارت خوبی دارید، و استفاده از <strong>correlation IDs</strong> را به شدت در نظر بگیرید، که به شما امکان می‌دهد درخواست‌ها را در مرزهای فرآیند ردیابی کنید، همانطور که در فصل 10 به تفصیل بررسی خواهیم کرد.
  </p>
<p>Pattern: Event-Driven Communication | 115</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0142</div>
            </div>
        </div>
        <!-- Page 0143 -->
        <div class="chapter" id="page-0143">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   4 Gregor Hohpe and Bobby Woolf, Enterprise Integration Patterns (Boston: Addison-Wesley, 2003).
  </p>
<p>
   من همچنین به شدت توصیه می‌کنم که <em>Enterprise Integration Patterns</em> نوشته <strong>Gregor Hohpe</strong> و <strong>Bobby Woolf</strong> را بررسی کنید،4 که جزئیات بیشتری در مورد الگوهای مختلف <strong>messaging</strong> که ممکن است بخواهید در این فضا در نظر بگیرید، دارد.
  </p>
<p>
   با این حال، ما همچنین باید در مورد سبک‌های ادغام که ممکن است "ساده‌تر" در نظر بگیریم، صادق باشیم—مشکلات مرتبط با دانستن اینکه آیا کارها انجام شده‌اند یا خیر به اشکال ناهمزمان ادغام محدود نمی‌شود. با یک فراخوانی <strong>synchronous</strong>، <strong>blocking</strong>، اگر یک <strong>time-out</strong> دریافت کنید، آیا این به این دلیل اتفاق افتاده است که درخواست گم شده است و طرف پایین‌دست آن را دریافت نکرده است؟ یا آیا درخواست انجام شد، اما پاسخ گم شد؟ در آن موقعیت چه می‌کنید؟ اگر دوباره تلاش کنید، اما درخواست اصلی انجام شد، چه اتفاقی می‌افتد؟ (خوب، اینجاست که <strong>idempotency</strong> وارد می‌شود، موضوعی که ما در فصل 12 پوشش می‌دهیم.)
  </p>
<p>
   به‌طور مسلم، با توجه به رسیدگی به شکست، فراخوانی‌های <strong>synchronous blocking</strong> می‌تواند باعث ایجاد سردردهای زیادی در ما شود، زمانی که صحبت از مشخص کردن این است که آیا اتفاقاتی افتاده است (یا نه). فقط این است که آن سردردها ممکن است برای ما آشنا‌تر باشند!
  </p>
<h4>خلاصه</h4>
<p>
   در این فصل، من برخی از سبک‌های اصلی ارتباط microservice را شکسته‌ام و در مورد مبادله‌های مختلف بحث کردم. همیشه یک گزینه درست وجود ندارد، اما امیدوارم اطلاعات کافی در مورد فراخوانی‌های <strong>synchronous</strong> و <strong>asynchronous</strong> و سبک‌های ارتباطی <strong>event-driven</strong> و <strong>request-response</strong> ارائه کرده باشم تا به شما در انجام فراخوانی صحیح برای <strong>context</strong> داده شده‌تان کمک کنم. سوگیری‌های من نسبت به همکاری ناهمزمان و <strong>event-driven</strong>، نه تنها تابعی از تجربیات من، بلکه همچنین از بیزاری من از <em>coupling</em> به طور کلی است. اما این سبک از ارتباط با پیچیدگی قابل توجهی همراه است که نمی‌توان آن را نادیده گرفت، و هر موقعیتی منحصربه‌فرد است.
  </p>
<p>
   در این فصل، من به طور خلاصه به چند فناوری خاص اشاره کردم که می‌توانند برای پیاده‌سازی این سبک‌های تعامل استفاده شوند. ما اکنون برای شروع بخش دوم این کتاب—پیاده‌سازی—آماده‌ایم. در فصل بعد، ما به بررسی پیاده‌سازی ارتباط microservice با جزئیات بیشتر خواهیم پرداخت.
  </p>
<p>Summary | 117</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0143</div>
            </div>
        </div>
        <!-- Page 0145 -->
        <div class="chapter" id="page-0145">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>PART II</h3>
<h4>پیاده‌سازی</h4>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0145</div>
            </div>
        </div>
        <!-- Page 0147 -->
        <div class="chapter" id="page-0147">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>CHAPTER 5</h3>
<h4>پیاده‌سازی ارتباط Microservice</h4>
<p>
   همانطور که در فصل قبل بحث کردیم، انتخاب فناوری شما باید تا حد زیادی توسط سبک ارتباطی مورد نظر شما هدایت شود. تصمیم‌گیری بین <strong>blocking synchronous</strong> یا <strong>nonblocking asynchronous calls</strong>، <strong>request-response</strong> یا همکاری <strong>event-driven</strong>، به شما کمک می‌کند تا آنچه که در غیر این صورت ممکن است یک فهرست بسیار طولانی از فناوری باشد را کاهش دهید. در این فصل، ما قصد داریم به برخی از فناوری‌هایی که معمولاً برای ارتباط microservice استفاده می‌شوند، نگاهی بیندازیم.
  </p>
<h4>به دنبال فناوری ایده‌آل</h4>
<p>
   گزینه‌های گیج‌کننده‌ای برای اینکه یک microservice چگونه می‌تواند با دیگری صحبت کند، وجود دارد. اما کدام یک درست است—<strong>SOAP</strong>؟ <strong>XML-RPC</strong>؟ <strong>REST</strong>؟ <strong>gRPC</strong>؟ و همیشه گزینه‌های جدیدی در حال ظهور هستند. بنابراین قبل از اینکه در مورد فناوری خاصی بحث کنیم، بیایید در مورد آنچه که از فناوری انتخاب می‌کنیم، فکر کنیم.
  </p>
<h4>سازگاری با عقب را آسان کنید</h4>
<p>
   هنگام ایجاد تغییرات در microservicesهایمان، ما باید مطمئن شویم که سازگاری را با هر microservices مصرف‌کننده از بین نمی‌بریم. به این ترتیب، ما می‌خواهیم اطمینان حاصل کنیم که هر فناوری که انتخاب می‌کنیم، ایجاد تغییرات سازگار با عقب را آسان می‌کند.
  </p>
<p>
   عملیات ساده مانند افزودن <strong>fields</strong> جدید نباید مشتریان را خراب کند. ما همچنین در حالت ایده‌آل می‌خواهیم توانایی تأیید اینکه تغییراتی که ایجاد کرده‌ایم با عقب سازگار هستند—و راهی برای دریافت آن بازخورد قبل از استقرار microservice خود در <strong>production</strong> داشته باشیم.
  </p>
<p>121</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0147</div>
            </div>
        </div>
        <!-- Page 0148 -->
        <div class="chapter" id="page-0148">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   رابط خود را صریح کنید
  </p>
<p>
   مهم است که <strong>interface</strong>ای که یک microservice به دنیای بیرون نشان می‌دهد، صریح باشد. این بدان معناست که برای یک <strong>consumer</strong> یک microservice مشخص است که چه <strong>functionality</strong> را آن microservice نشان می‌دهد. اما همچنین به این معنی است که برای یک توسعه‌دهنده که روی microservice کار می‌کند، مشخص است که چه <strong>functionality</strong> باید برای طرف‌های خارجی دست‌نخورده باقی بماند—ما می‌خواهیم از موقعیتی اجتناب کنیم که در آن تغییری در یک microservice باعث ایجاد شکست تصادفی در سازگاری شود.
  </p>
<p>
<strong>Schemas</strong> صریح می‌توانند در کمک به اطمینان از صریح بودن <strong>interface</strong>ی که یک microservice ارائه می‌دهد، راه طولانی را طی کنند. برخی از فناوری‌هایی که می‌توانیم به آنها نگاه کنیم، نیازمند استفاده از یک <strong>schema</strong> هستند. برای سایر فناوری‌ها، استفاده از یک <strong>schema</strong> اختیاری است. به هر حال، من به شدت استفاده از یک <strong>schema</strong> صریح، و همچنین وجود مستندات پشتیبانی کافی برای روشن بودن در مورد آنچه که یک <strong>consumer</strong> می‌تواند انتظار داشته باشد که یک microservice ارائه دهد، را تشویق می‌کنم.
  </p>
<h4><strong>APIs</strong>های خود را <strong>Technology Agnostic</strong> نگه دارید</h4>
<p>
   اگر بیش از 15 دقیقه در صنعت <strong>IT</strong> بوده‌اید، نیازی نیست که به شما بگویم که ما در فضایی کار می‌کنیم که به سرعت در حال تغییر است. تنها اطمینان، تغییر است. ابزارها، فریم‌ورک‌ها و زبان‌های جدید در تمام مدت در حال ظهور هستند، و ایده‌های جدیدی را پیاده‌سازی می‌کنند که می‌تواند به ما در کار سریع‌تر و مؤثرتر کمک کند. در حال حاضر، شما ممکن است یک فروشگاه <strong>.NET</strong> باشید. اما یک سال از این به بعد، یا پنج سال از این به بعد چطور؟ اگر بخواهید با یک <strong>technology stack</strong> جایگزین آزمایش کنید که ممکن است شما را مولدتر کند، چه؟
  </p>
<p>
   من طرفدار بزرگی برای باز نگه داشتن گزینه‌های خود هستم، به همین دلیل است که من طرفدار microservicesها هستم. همچنین به همین دلیل است که فکر می‌کنم بسیار مهم است که اطمینان حاصل کنید که <strong>APIs</strong> مورد استفاده برای ارتباط بین microservicesها، <strong>technology agnostic</strong> باقی می‌مانند. این به معنای اجتناب از فناوری‌های ادغام است که دیکته می‌کند ما از چه <strong>technology stacks</strong> برای پیاده‌سازی microservicesهایمان می‌توانیم استفاده کنیم.
  </p>
<h4><strong>Service</strong> خود را برای <strong>Consumers</strong> آسان کنید</h4>
<p>
   ما می‌خواهیم استفاده از microservice خود را برای <strong>consumers</strong> آسان کنیم. داشتن یک microservice به زیبایی فاکتور شده، اگر هزینه استفاده از آن به عنوان یک <strong>consumer</strong> بسیار بالا باشد، ارزش چندانی ندارد! بنابراین بیایید در مورد اینکه چه چیزی استفاده از <strong>service</strong> جدید شگفت‌انگیز ما را برای <strong>consumers</strong> آسان می‌کند، فکر کنیم. در حالت ایده‌آل، ما می‌خواهیم به مشتریانمان آزادی کامل در انتخاب فناوری خود بدهیم. از سوی دیگر، ارائه یک کتابخانه کلاینت می‌تواند پذیرش را آسان کند. با این حال، اغلب، چنین کتابخانه‌هایی با چیزهای دیگری که می‌خواهیم به آنها برسیم ناسازگار هستند. به عنوان مثال، ما ممکن است از کتابخانه‌های کلاینت استفاده کنیم تا استفاده از آنها را برای <strong>consumers</strong> آسان کنیم، اما این می‌تواند به قیمت افزایش <em>coupling</em> تمام شود.
  </p>
<p>122 | Chapter 5: Implementing Microservice Communication</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0148</div>
            </div>
        </div>
        <!-- Page 0149 -->
        <div class="chapter" id="page-0149">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>پنهان کردن جزئیات پیاده‌سازی داخلی</h3>
<p>ما نمی‌خواهیم مصرف‌کنندگانمان به پیاده‌سازی داخلی ما وابسته باشند، زیرا این امر منجر به افزایش <em>coupling</em> می‌شود؛ این به نوبه خود به این معنی است که اگر بخواهیم چیزی را در داخل <em>microservice</em> خود تغییر دهیم، می‌توانیم با مجبور کردن آن‌ها به تغییر، مصرف‌کنندگان خود را خراب کنیم.</p>
<p>این امر هزینه تغییر را افزایش می‌دهد—دقیقا همان چیزی که ما در تلاشیم از آن اجتناب کنیم. همچنین به این معنی است که ما کمتر تمایل داریم تغییراتی ایجاد کنیم، زیرا می‌ترسیم مجبور شویم مصرف‌کنندگان خود را ارتقا دهیم، که می‌تواند منجر به افزایش <strong>technical debt</strong> در داخل <em>service</em> شود. بنابراین باید از هر فناوری که ما را به افشای جزئیات <strong>internal representation</strong> سوق می‌دهد، اجتناب کرد.</p>
<h3>انتخاب‌های فناوری</h3>
<p>تعداد زیادی فناوری وجود دارد که می‌توانیم به آن‌ها نگاه کنیم، اما به جای نگاه گسترده به لیست بلندبالایی از گزینه‌ها، برخی از محبوب‌ترین و جالب‌ترین انتخاب‌ها را برجسته خواهم کرد. در اینجا گزینه‌هایی که به آن‌ها نگاه خواهیم کرد، آمده است:</p>
<ul>
<li><strong>Remote procedure calls</strong></li>
<p>فریم‌ورک‌هایی که به شما امکان می‌دهند <em>local method calls</em> را روی یک <em>remote process</em> فراخوانی کنید. گزینه‌های رایج شامل <em>SOAP</em> و <em>gRPC</em> می‌شوند.</p>
<li><strong>REST</strong></li>
<p>یک سبک معماری که در آن شما <em>resources</em> (مانند <em>Customer</em>, <em>Order</em> و غیره) را در معرض نمایش قرار می‌دهید که می‌توان با استفاده از مجموعه‌ای از <em>verbs</em> (مانند <em>GET</em>, <em>POST</em>) به آن‌ها دسترسی پیدا کرد. کمی بیشتر از این وجود دارد، اما به زودی به آن خواهیم رسید.</p>
<li><strong>GraphQL</strong></li>
<p>یک <em>protocol</em> نسبتاً جدید که به مصرف‌کنندگان اجازه می‌دهد <em>custom queries</em> را تعریف کنند که می‌تواند اطلاعات را از چندین <em>downstream microservices</em> واکشی کند و نتایج را فیلتر کند تا فقط آنچه مورد نیاز است را برگرداند.</p>
<li><strong>Message brokers</strong></li>
<p><em>Middleware</em> که امکان برقراری ارتباط <em>asynchronous</em> را از طریق <em>queues</em> یا <em>topics</em> فراهم می‌کند.</p>
</ul>
<h4>Remote Procedure Calls</h4>
<p><em>Remote procedure call (RPC)</em> به تکنیک برقراری یک تماس <em>local</em> و اجرای آن در یک <em>remote service</em> در جایی اشاره دارد. تعدادی پیاده‌سازی مختلف <em>RPC</em> در حال استفاده است. اکثر فناوری‌های موجود در این فضا به یک <em>explicit schema</em> مانند <em>SOAP</em> یا <em>gRPC</em> نیاز دارند. در زمینه <em>RPC</em>، <em>schema</em> اغلب به عنوان یک <em>interface definition language (IDL)</em> شناخته می‌شود، با این حال <em>SOAP</em> به <em>schema</em> خود برای <em>format</em> به عنوان یک <em>web service definition language (WSDL)</em> اشاره می‌کند. استفاده از یک <em>separate schema</em>، تولید <em>client</em> و <em>server stubs</em> را برای <em>different technology stacks</em> آسان‌تر می‌کند—بنابراین، به عنوان مثال، من می‌توانم یک <em>Java server</em> داشته باشم که یک رابط <em>SOAP</em> را در معرض نمایش قرار می‌دهد، و یک <em>.NET client</em> که از همان تعریف <em>WSDL</em> از <em>interface</em> تولید شده است. فناوری‌های دیگر، مانند <em>Java RMI</em>، خواستار یک <em>coupling</em> محکم‌تر بین <em>client</em> و <em>server</em> است، که نیازمند آن است:</p>
<h4>Technology Choices</h4>
<p>این عنوان تکراری است.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0149</div>
            </div>
        </div>
        <!-- Page 0150 -->
        <div class="chapter" id="page-0150">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>هر دو از <strong>same underlying technology</strong> استفاده می‌کنند اما از نیاز به یک <em>explicit service definition</em> اجتناب می‌کنند، زیرا <em>service definition</em> به طور ضمنی توسط <em>Java type definitions</em> ارائه می‌شود.</p>
<p>با این حال، تمام این فناوری‌ها دارای همان <strong>core characteristic</strong> هستند: آن‌ها یک <em>remote call</em> را شبیه یک <em>local call</em> جلوه می‌دهند.</p>
<p>معمولاً، استفاده از یک فناوری <em>RPC</em> به این معنی است که شما در حال خرید یک <em>serialization protocol</em> هستید. <em>RPC framework</em> نحوه <em>serialize</em> و <em>deserialize</em> کردن داده‌ها را تعریف می‌کند. به عنوان مثال، <em>gRPC</em> از <em>protocol buffer serialization format</em> برای این منظور استفاده می‌کند. برخی از پیاده‌سازی‌ها به یک <em>specific networking protocol</em> (مانند <em>SOAP</em>، که استفاده کمی از <em>HTTP</em> می‌کند) متصل هستند، در حالی که برخی دیگر ممکن است به شما اجازه دهند از انواع مختلف <em>networking protocols</em> استفاده کنید، که می‌تواند ویژگی‌های اضافی را ارائه دهد. به عنوان مثال، <em>TCP</em> تضمین‌هایی در مورد تحویل ارائه می‌دهد، در حالی که <em>UDP</em> این کار را نمی‌کند اما دارای <em>overhead</em> بسیار کمتری است. این می‌تواند به شما اجازه دهد از <em>networking technology</em> متفاوتی برای موارد استفاده مختلف استفاده کنید.</p>
<p><em>RPC frameworks</em> که دارای یک <em>explicit schema</em> هستند، ایجاد <em>client code</em> را بسیار آسان می‌کنند. این می‌تواند از نیاز به <em>client libraries</em> جلوگیری کند، زیرا هر <em>client</em> می‌تواند کد خود را در برابر این <em>service specification</em> تولید کند. با این حال، برای اینکه <em>client-side code generation</em> کار کند، <em>client</em> به روشی برای دریافت <em>schema out of band</em> نیاز دارد—به عبارت دیگر، <em>consumer</em> باید قبل از اینکه قصد داشته باشد <em>calls</em> برقرار کند، به <em>schema</em> دسترسی داشته باشد. <em>Avro RPC</em> یک <em>outlier</em> جالب در اینجا است، زیرا این گزینه را دارد که <em>full schema</em> را همراه با <em>payload</em> ارسال کند و به <em>clients</em> اجازه می‌دهد تا <em>schema</em> را به صورت پویا تفسیر کنند.</p>
<p>سهولت تولید <em>client-side code</em> یکی از نقاط فروش اصلی <em>RPC</em> است. این واقعیت که من فقط می‌توانم یک <em>normal method call</em> برقرار کنم و از بقیه صرف نظر کنم، یک مزیت بزرگ است.</p>
<h4>چالش‌ها</h4>
<p>همانطور که دیدیم، <em>RPC</em> مزایای زیادی را ارائه می‌دهد، اما خالی از اشکالات نیست—و برخی از پیاده‌سازی‌های <em>RPC</em> می‌توانند مشکل‌سازتر از بقیه باشند. بسیاری از این مسائل را می‌توان حل کرد، اما سزاوار بررسی بیشتر هستند.</p>
<ul>
<li><strong>Technology coupling</strong>.</li>
<p>برخی از <em>RPC mechanisms</em>، مانند <em>Java RMI</em>، به شدت به یک <em>specific platform</em> متصل هستند، که می‌تواند محدود کند که چه فناوری می‌تواند در <em>client</em> و <em>server</em> استفاده شود. <em>Thrift</em> و <em>gRPC</em> دارای مقدار چشمگیری از پشتیبانی برای زبان‌های جایگزین هستند، که می‌تواند این نقطه ضعف را تا حدودی کاهش دهد، اما آگاه باشید که فناوری <em>RPC</em> گاهی اوقات با محدودیت‌هایی در <em>interoperability</em> همراه است.</p>
<p>به نوعی، این <em>technology coupling</em> می‌تواند نوعی از افشای جزئیات پیاده‌سازی فنی داخلی باشد. به عنوان مثال، استفاده از <em>RMI</em> نه تنها <em>client</em> را به <em>JVM</em> متصل می‌کند، بلکه <em>server</em> را نیز متصل می‌کند.</p>
</ul>
<p>صادقانه بگویم، تعدادی از پیاده‌سازی‌های <em>RPC</em> وجود دارد که این محدودیت را ندارند—<em>gRPC</em>, <em>SOAP</em> و <em>Thrift</em> همه نمونه‌هایی هستند که <em>interoperability</em> بین <em>different technology stacks</em> را امکان‌پذیر می‌کنند.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0150</div>
            </div>
        </div>
        <!-- Page 0151 -->
        <div class="chapter" id="page-0151">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>Local calls</em> مانند <em>remote calls</em> نیستند. ایده اصلی <em>RPC</em> این است که پیچیدگی یک <em>remote call</em> را پنهان کند. با این حال، این می‌تواند منجر به پنهان کردن بیش از حد شود. تلاش در برخی از اشکال <em>RPC</em> برای اینکه <em>remote method calls</em> شبیه <em>local method calls</em> به نظر برسند، این واقعیت را پنهان می‌کند که این دو چیز بسیار متفاوت هستند. من می‌توانم تعداد زیادی <em>local, in-process calls</em> برقرار کنم بدون اینکه خیلی نگران عملکرد باشم. با این حال، با <em>RPC</em>، هزینه <em>marshaling</em> و <em>unmarshaling payloads</em> می‌تواند قابل توجه باشد، چه رسد به زمانی که برای ارسال چیزها از طریق شبکه صرف می‌شود. این بدان معناست که شما باید در مورد طراحی <em>API</em> برای <em>remote interfaces</em> در مقابل <em>local interfaces</em> متفاوت فکر کنید. فقط گرفتن یک <em>local API</em> و تلاش برای تبدیل آن به یک <em>service boundary</em> بدون هیچ فکر دیگری احتمالاً شما را به دردسر می‌اندازد. در برخی از بدترین نمونه‌ها، توسعه‌دهندگان ممکن است بدون اینکه بدانند از <em>remote calls</em> استفاده می‌کنند، اگر <em>abstraction</em> بیش از حد <em>opaque</em> باشد.</p>
<p>شما باید در مورد خود <strong>network</strong> فکر کنید. معروف است که اولین مورد از <em>fallacies</em> محاسبات توزیع شده این است که "شبکه قابل اعتماد است". شبکه‌ها قابل اعتماد نیستند. آن‌ها می‌توانند و خراب خواهند شد، حتی اگر <em>client</em> شما و <em>server</em> که با آن صحبت می‌کنید خوب باشند. آن‌ها می‌توانند سریع شکست بخورند، می‌توانند کند شکست بخورند، و حتی می‌توانند <em>packets</em> شما را بد شکل کنند. شما باید فرض کنید که شبکه‌های شما مملو از موجودات بدخواه هستند که آماده‌اند خشم خود را در یک لحظه از بین ببرند. بنابراین، می‌توانید انتظار داشته باشید که با انواع <em>failure modes</em> مواجه شوید که ممکن است هرگز مجبور نشده باشید در نرم‌افزار ساده‌تر و <em>monolithic</em> با آن مقابله کنید. یک <em>failure</em> می‌تواند ناشی از بازگشت یک <em>error</em> توسط <em>remote server</em> یا برقراری یک تماس بد توسط شما باشد. آیا می‌توانید تفاوت را تشخیص دهید و اگر چنین است، آیا می‌توانید در مورد آن کاری انجام دهید؟ و وقتی <em>remote server</em> به آرامی شروع به پاسخ دادن می‌کند چه می‌کنید؟ ما این موضوع را زمانی که در فصل 12 در مورد <em>resiliency</em> صحبت می‌کنیم، پوشش خواهیم داد.</p>
<p><strong>Brittleness</strong>. برخی از محبوب‌ترین پیاده‌سازی‌های <em>RPC</em> می‌توانند منجر به برخی از اشکال‌های ناخوشایند <em>brittleness</em> شوند، که <em>Java RMI</em> یک مثال بسیار خوب است. بیایید یک <em>Java interface</em> بسیار ساده را در نظر بگیریم که تصمیم گرفته‌ایم یک <em>remote API</em> برای <em>Customer service</em> خود ایجاد کنیم. <em>Example 5-1</em> متدهایی را که قصد داریم از راه دور در معرض نمایش قرار دهیم، اعلام می‌کند. سپس <em>Java RMI</em> <em>client</em> و <em>server stubs</em> را برای متد ما تولید می‌کند.</p>
<p><strong>Example 5-1. Defining a service endpoint using Java RMI</strong></p>
<pre><code class="language-java">
import java.rmi.Remote;
import java.rmi.RemoteException;

public interface CustomerRemote extends Remote {
  public Customer findCustomer(String id) throws RemoteException;
  public Customer createCustomer(
    String firstname, String surname, String emailAddress)
    throws RemoteException;
}
  </code></pre>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0151</div>
            </div>
        </div>
        <!-- Page 0152 -->
        <div class="chapter" id="page-0152">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>در این <em>interface</em>، <code>createCustomer</code> <code>firstName</code>, <code>surname</code> و <code>email address</code> را می‌گیرد.</p>
<p>اگر تصمیم بگیریم به <em>Customer</em> <em>object</em> اجازه دهیم فقط با یک <code>email address</code> ایجاد شود، چه اتفاقی می‌افتد؟ در این مرحله می‌توانیم یک <em>method</em> جدید را به راحتی اضافه کنیم، مانند این:</p>
<pre><code class="language-java">
...
public Customer createCustomer(String emailAddress) throws RemoteException;
...
  </code></pre>
<p>مشکل این است که اکنون باید <em>client stubs</em> را نیز بازسازی کنیم. <em>Clients</em> که می‌خواهند از <em>method</em> جدید استفاده کنند، به <em>stubs</em> جدید نیاز دارند، و بسته به ماهیت تغییرات در <em>specification</em>، <em>consumers</em> که به <em>method</em> جدید نیازی ندارند نیز ممکن است نیاز داشته باشند که <em>stubs</em> آن‌ها ارتقا یابد. البته این قابل مدیریت است، اما فقط تا یک نقطه.</p>
<p>واقعیت این است که تغییراتی از این قبیل نسبتاً رایج هستند. <em>RPC endpoints</em> اغلب در نهایت تعداد زیادی <em>method</em> برای راه‌های مختلف ایجاد یا تعامل با <em>objects</em> دارند. این تا حدی به این دلیل است که ما هنوز به این <em>remote calls</em> به عنوان <em>local ones</em> فکر می‌کنیم.</p>
<p>با این حال، نوع دیگری از <em>brittleness</em> وجود دارد. بیایید نگاهی به شکل <em>Customer</em> <em>object</em> خود بیندازیم:</p>
<pre><code class="language-java">
public class Customer implements Serializable {
  private String firstName;
  private String surname;
  private String emailAddress;
  private String age;
}
  </code></pre>
<p>اگر مشخص شود که، اگرچه ما <em>age field</em> را در <em>Customer objects</em> خود قرار می‌دهیم، اما هیچ یک از <em>consumers</em> ما هرگز از آن استفاده نمی‌کنند؟ ما تصمیم می‌گیریم که می‌خواهیم این <em>field</em> را حذف کنیم. اما اگر پیاده‌سازی <em>server</em> <code>age</code> را از تعریف خود از این <em>type</em> حذف کند، و ما همین کار را با همه <em>consumers</em> انجام ندهیم، در این صورت، حتی اگر آن‌ها هرگز از <em>field</em> استفاده نکرده باشند، کد مرتبط با <em>deserializing</em> <em>Customer object</em> در سمت <em>consumer</em> خراب می‌شود. برای پیاده‌سازی این تغییر، باید تغییراتی در <em>client code</em> ایجاد کنیم تا از تعریف جدید پشتیبانی کنیم و این <em>updated clients</em> را همزمان با راه‌اندازی نسخه جدید <em>server</em> مستقر کنیم. این یک چالش کلیدی با هر مکانیزم <em>RPC</em> است که استفاده از <em>binary stub generation</em> را ترویج می‌دهد: شما نمی‌توانید <em>client</em> و <em>server deployments</em> را از هم جدا کنید. اگر از این فناوری استفاده می‌کنید، <em>lockstep releases</em> ممکن است در آینده شما باشد.</p>
<p>مشکلات مشابهی در صورت تمایل به <em>restructure</em> کردن <em>Customer object</em> رخ می‌دهد، حتی اگر <em>fields</em> را حذف نکنیم—به عنوان مثال، اگر بخواهیم <code>firstName</code> و <code>surname</code> را در یک <em>naming type</em> جدید کپسوله کنیم تا مدیریت آن آسان‌تر شود. البته می‌توانیم این مشکل را با انتقال <em>dictionary types</em> به عنوان پارامترهای <em>calls</em> خود برطرف کنیم، اما در آن مرحله، بسیاری از مزایای <em>generated stubs</em> را از دست می‌دهیم زیرا همچنان باید به صورت دستی <em>match</em> و <em>extract</em> کنیم <em>fields</em> را که می‌خواهیم.</p>
<p>در عمل، <em>objects</em> که به عنوان بخشی از <em>binary serialization across the wire</em> استفاده می‌شوند، می‌توانند به عنوان <em>"expand-only" types</em> در نظر گرفته شوند. این <em>brittleness</em> منجر به این می‌شود که <em>types</em> از طریق</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0152</div>
            </div>
        </div>
        <!-- Page 0153 -->
        <div class="chapter" id="page-0153">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>و تبدیل شدن به یک توده از <code>fields</code>، که برخی از آن‌ها دیگر استفاده نمی‌شوند اما نمی‌توانند با خیال راحت حذف شوند.</p>
<h4>کجا از آن استفاده کنیم</h4>
<p>با وجود کاستی‌هایش، من در واقع <em>RPC</em> را خیلی دوست دارم، و پیاده‌سازی‌های مدرن‌تر، مانند <em>gRPC</em>، عالی هستند، در حالی که پیاده‌سازی‌های دیگر مشکلاتی دارند که باعث می‌شود من از آن‌ها فاصله بگیرم. برای مثال، <em>Java RMI</em> تعدادی مشکل در رابطه با <em>brittleness</em> و <em>limited technology choices</em> دارد، و <em>SOAP</em> از دیدگاه توسعه‌دهنده بسیار سنگین است، به‌ویژه در مقایسه با انتخاب‌های مدرن‌تر.</p>
<p>فقط از برخی از <em>potential pitfalls</em> مرتبط با <em>RPC</em> آگاه باشید، اگر می‌خواهید این مدل را انتخاب کنید. <em>remote calls</em> خود را به گونه‌ای <em>abstract</em> نکنید که <strong>network</strong> کاملاً پنهان شود، و اطمینان حاصل کنید که می‌توانید <em>server interface</em> را بدون اصرار بر <em>lockstep upgrades</em> برای <em>clients</em> تکامل دهید. یافتن تعادل مناسب برای <em>client code</em> شما مهم است، به عنوان مثال. اطمینان حاصل کنید که <em>clients</em> شما از این واقعیت غافل نیستند که یک <em>network call</em> قرار است انجام شود. <em>Client libraries</em> اغلب در زمینه <em>RPC</em> استفاده می‌شوند، و اگر به درستی ساختار نیافته باشند، می‌توانند مشکل‌ساز باشند. ما به زودی بیشتر در مورد آن‌ها صحبت خواهیم کرد.</p>
<p>اگر من در حال بررسی گزینه‌ها در این فضا بودم، <em>gRPC</em> در صدر لیست من قرار می‌گرفت. این برنامه که برای استفاده از <em>HTTP/2</em> ساخته شده است، دارای ویژگی‌های عملکردی چشمگیر و سهولت استفاده عمومی خوبی است. من همچنین از اکوسیستم اطراف <em>gRPC</em> قدردانی می‌کنم، از جمله ابزارهایی مانند <em>Protolock</em>، که چیزی است که ما بعداً در این فصل در مورد آن بحث خواهیم کرد، زمانی که در مورد <em>schemas</em> بحث می‌کنیم.</p>
<p><em>gRPC</em> به خوبی با یک مدل <em>synchronous request-response</em> مطابقت دارد اما می‌تواند در ارتباط با <em>reactive extensions</em> نیز کار کند. هر زمان که در موقعیت‌هایی هستم که کنترل زیادی بر هر دو انتهای <em>client</em> و <em>server</em> دارم، در لیست من رتبه بالایی دارد. اگر شما مجبور هستید از طیف گسترده‌ای از برنامه‌های دیگر پشتیبانی کنید که ممکن است نیاز به صحبت با <em>microservices</em> شما داشته باشند، نیاز به کامپایل <em>client-side code</em> در برابر یک <em>server-side schema</em> می‌تواند مشکل‌ساز باشد. در این صورت، برخی از اشکال <em>REST over HTTP API</em> احتمالاً مناسب‌تر خواهد بود.</p>
<h4>REST</h4>
<p><em>Representational State Transfer (REST)</em> یک سبک معماری است که از وب الهام گرفته شده است. اصول و محدودیت‌های زیادی در پشت سبک <em>REST</em> وجود دارد، اما ما روی مواردی تمرکز خواهیم کرد که واقعاً به ما در هنگام مواجهه با چالش‌های <em>integration</em> در یک دنیای <em>microservices</em> کمک می‌کنند، و زمانی که به دنبال جایگزینی برای <em>RPC</em> برای <em>service interfaces</em> خود هستیم.</p>
<p>مهم‌ترین نکته هنگام فکر کردن در مورد <em>REST</em>، مفهوم <em>resources</em> است. شما می‌توانید به یک <em>resource</em> به عنوان چیزی فکر کنید که <em>service</em> خود در مورد آن می‌داند، مانند یک <em>Customer</em>.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0153</div>
            </div>
        </div>
        <!-- Page 0154 -->
        <div class="chapter" id="page-0154">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>server</em> <em>different representations</em> از این <em>Customer</em> را در <em>request</em> ایجاد می‌کند. نحوه نمایش یک <em>resource</em> در خارج، کاملاً از نحوه ذخیره آن در داخل، جدا شده است. برای مثال، یک <em>client</em> ممکن است یک <em>JSON representation</em> از یک <em>Customer</em> را درخواست کند، حتی اگر در یک <em>format</em> کاملاً متفاوت ذخیره شده باشد. هنگامی که یک <em>client</em> یک <em>representation</em> از این <em>Customer</em> را دارد، می‌تواند درخواست‌هایی را برای تغییر آن ایجاد کند، و <em>server</em> ممکن است با آن‌ها موافقت کند یا نکند.</p>
<p>سبک‌های مختلفی از <em>REST</em> وجود دارد، و من فقط به طور خلاصه به آن‌ها اشاره می‌کنم. من به شدت توصیه می‌کنم نگاهی به <em>Richardson Maturity Model</em> بیندازید، که در آن سبک‌های مختلف <em>REST</em> مقایسه شده‌اند.</p>
<p><em>REST</em> در واقع در مورد <em>underlying protocols</em> صحبت نمی‌کند، اگرچه معمولاً بیش از <em>HTTP</em> استفاده می‌شود. من قبلاً پیاده‌سازی‌هایی از <em>REST</em> را دیده‌ام که از <em>protocols</em> بسیار متفاوتی استفاده می‌کنند، اگرچه این می‌تواند به تلاش زیادی نیاز داشته باشد. برخی از ویژگی‌هایی که <em>HTTP</em> به عنوان بخشی از <em>specification</em> به ما می‌دهد، مانند <em>verbs</em>، پیاده‌سازی <em>REST</em> را بر روی <em>HTTP</em> آسان‌تر می‌کند، در حالی که با <em>protocols</em> دیگر، شما باید این ویژگی‌ها را خودتان مدیریت کنید.</p>
<h4>REST و HTTP</h4>
<p><em>HTTP</em> خود، برخی از قابلیت‌های مفیدی را تعریف می‌کند که با سبک <em>REST</em> بسیار خوب عمل می‌کنند. به عنوان مثال، <em>HTTP verbs</em> (مانند <em>GET</em>، <em>POST</em> و <em>PUT</em>) در حال حاضر در <em>HTTP specification</em> معانی مشخصی دارند در مورد نحوه عملکرد آن‌ها با <em>resources</em>. سبک معماری <em>REST</em> در واقع به ما می‌گوید که این <em>verbs</em> باید به یک روش در تمام <em>resources</em> رفتار کنند، و <em>HTTP specification</em> اتفاقاً مجموعه‌ای از <em>verbs</em> را تعریف می‌کند که می‌توانیم از آن‌ها استفاده کنیم. برای مثال، <em>GET</em> یک <em>resource</em> را به روشی <em>idempotent</em> بازیابی می‌کند، و <em>POST</em> یک <em>resource</em> جدید ایجاد می‌کند. این بدان معناست که می‌توانیم از بسیاری از <em>different</em> <code>createCustomer</code> یا <code>editCustomer</code> متدها اجتناب کنیم. در عوض، می‌توانیم به سادگی یک <em>customer representation</em> را <em>POST</em> کنیم تا از <em>server</em> درخواست کنیم که یک <em>resource</em> جدید ایجاد کند، و سپس می‌توانیم یک <em>GET request</em> را برای بازیابی یک <em>representation</em> از یک <em>resource</em> آغاز کنیم. از نظر مفهومی، در این موارد یک <em>endpoint</em> به شکل یک <em>Customer resource</em> وجود دارد، و عملیاتی که می‌توانیم روی آن انجام دهیم، در <em>HTTP protocol</em> تعبیه شده است.</p>
<p><em>HTTP</em> همچنین یک اکوسیستم بزرگ از ابزارها و فناوری‌های پشتیبانی‌کننده را به ارمغان می‌آورد. ما می‌توانیم از <em>HTTP caching proxies</em> مانند <em>Varnish</em> و <em>load balancers</em> مانند <em>mod_proxy</em> استفاده کنیم، و بسیاری از ابزارهای <em>monitoring</em> در حال حاضر پشتیبانی زیادی از <em>HTTP out of the box</em> دارند. این <em>building blocks</em> به ما امکان می‌دهند تا حجم زیادی از ترافیک <em>HTTP</em> را مدیریت و آن‌ها را هوشمندانه و به روشی نسبتاً شفاف مسیریابی کنیم. ما همچنین می‌توانیم از تمام <em>security controls</em> موجود با <em>HTTP</em> برای ایمن‌سازی ارتباطات خود استفاده کنیم. از <em>basic auth</em> تا <em>client certs</em>، اکوسیستم <em>HTTP</em> ابزارهای زیادی را در اختیار ما قرار می‌دهد تا فرآیند امنیت را آسان‌تر کنیم، و ما این موضوع را در فصل 11 بیشتر بررسی خواهیم کرد. با این حال، برای به دست آوردن این مزایا، باید از <em>HTTP</em> به خوبی استفاده کنید. بد استفاده کنید، و می‌تواند به اندازه هر فناوری دیگری ناامن و مقیاس‌پذیری دشوار باشد. اگر درست استفاده کنید، کمک زیادی دریافت می‌کنید.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0154</div>
            </div>
        </div>
        <!-- Page 0155 -->
        <div class="chapter" id="page-0155">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>توجه داشته باشید که <em>HTTP</em> می‌تواند برای پیاده‌سازی <em>RPC</em> نیز استفاده شود. برای مثال، <em>SOAP</em>، از طریق <em>HTTP</em> مسیریابی می‌شود، اما متأسفانه از <em>specification</em> بسیار کمی استفاده می‌کند. <em>Verbs</em> نادیده گرفته می‌شوند، همانطور که کدهای خطای <em>HTTP</em> ساده نادیده گرفته می‌شوند. از طرف دیگر، <em>gRPC</em> برای استفاده از قابلیت‌های <em>HTTP/2</em>، مانند توانایی ارسال چندین <em>request-response streams</em> از طریق یک اتصال واحد، طراحی شده است. اما البته، هنگامی که از <em>gRPC</em> استفاده می‌کنید، فقط به این دلیل که از <em>HTTP</em> استفاده می‌کنید، <em>REST</em> انجام نمی‌دهید!</p>
<h4>Hypermedia as the engine of application state</h4>
<p>اصل دیگری که در <em>REST</em> معرفی شده و می‌تواند به ما در اجتناب از <em>coupling</em> بین <em>client</em> و <em>server</em> کمک کند، مفهوم <em>hypermedia as the engine of application state</em> است (که اغلب به صورت <em>HATEOAS</em> خلاصه می‌شود، و این واقعا به یک خلاصه نیاز داشت). این عبارت نسبتاً متراکم و یک مفهوم کاملاً جالب است، بنابراین بیایید کمی آن را تجزیه کنیم.</p>
<p><em>Hypermedia</em> مفهومی است که در آن یک قطعه محتوا حاوی پیوندهایی به قطعات مختلف محتوای دیگر در قالب‌های مختلف است (به عنوان مثال، متن، تصاویر، صداها). این باید برای شما کاملاً آشنا باشد، زیرا این همان چیزی است که در صفحه وب معمولی اتفاق می‌افتد: شما پیوندها را دنبال می‌کنید، که نوعی از کنترل‌های <em>hypermedia</em> هستند، تا محتوای مرتبط را ببینید. ایده پشت <em>HATEOAS</em> این است که <em>clients</em> باید تعاملاتی را با <em>server</em> (که به طور بالقوه منجر به <em>state transitions</em> می‌شود) از طریق این پیوندها به سایر <em>resources</em> انجام دهند. یک <em>client</em> نیازی ندارد که بداند مشتریان دقیقاً در کجا در <em>server</em> قرار دارند با دانستن کدام <em>URI</em> را باید <em>hit</em> کند؛ در عوض، <em>client</em> به دنبال پیوندها می‌گردد و برای یافتن آنچه نیاز دارد، در آن‌ها حرکت می‌کند.</p>
<p>این کمی یک مفهوم عجیب است، بنابراین بیایید ابتدا یک قدم به عقب برگردیم و بررسی کنیم که مردم چگونه با یک صفحه وب تعامل دارند، که ما قبلاً نشان داده‌ایم که سرشار از کنترل‌های <em>hypermedia</em> است.</p>
<p>به سایت خرید <em>Amazon.com</em> فکر کنید. موقعیت سبد خرید در طول زمان تغییر کرده است. گرافیک تغییر کرده است. پیوند تغییر کرده است. اما ما به عنوان انسان به اندازه کافی باهوش هستیم که همچنان یک سبد خرید را ببینیم، بدانیم که چیست و با آن تعامل داشته باشیم. ما درک درستی از معنای سبد خرید داریم، حتی اگر شکل دقیق و کنترل اساسی مورد استفاده برای نشان دادن آن تغییر کرده باشد. ما می‌دانیم که اگر می‌خواهیم سبد را مشاهده کنیم، این کنترلی است که می‌خواهیم با آن تعامل داشته باشیم. این نحوه تغییر تدریجی صفحات وب در طول زمان است. تا زمانی که این قراردادهای ضمنی بین مشتری و وب‌سایت همچنان رعایت شوند، تغییرات نیازی به ایجاد تغییرات اساسی ندارند.</p>
<p>با کنترل‌های <em>hypermedia</em>، ما در تلاشیم تا به همان سطح "هوش" برای مصرف‌کنندگان الکترونیکی خود برسیم. بیایید نگاهی به یک کنترل <em>hypermedia</em> بیندازیم که ممکن است برای <em>MusicCorp</em> داشته باشیم. ما به یک <em>resource</em> که نمایانگر یک ورودی کاتالوگ برای یک آلبوم داده شده در <em>Example 5-2</em> است، دسترسی پیدا کرده‌ایم. در کنار اطلاعات مربوط به آلبوم، تعدادی کنترل <em>hypermedia</em> را می‌بینیم.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0155</div>
            </div>
        </div>
        <!-- Page 0156 -->
        <div class="chapter" id="page-0156">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><strong>Example 5-2. Hypermedia controls used on an album listing</strong></p>
<pre><code class="language-xml">
<album>
  <name>Give Blood</name>
  <link href="/artist/theBrakes" rel="/artist"/> 
  <description>
    Awesome, short, brutish, funny and loud. Must buy!
  </description>
  <link href="/instantPurchase/1234" rel="/instantpurchase"/> 
</album>
  </code></pre>
<p>این <em>hypermedia control</em> به ما نشان می‌دهد که کجا می‌توانیم اطلاعاتی در مورد هنرمند پیدا کنیم.</p>
<p>و اگر بخواهیم آلبوم را خریداری کنیم، اکنون می‌دانیم به کجا برویم.</p>
<p>در این سند، ما دو <em>hypermedia controls</em> داریم. <em>client</em> که چنین سندی را می‌خواند، باید بداند که یک <em>control</em> با رابطه <em>artist</em> جایی است که باید برای دریافت اطلاعات در مورد هنرمند به آن <em>navigate</em> کند، و <code>instantpurchase</code> بخشی از <em>protocol</em> است که برای خرید آلبوم استفاده می‌شود. <em>client</em> باید معناشناسی <em>API</em> را تقریباً به همان روشی درک کند که یک انسان باید درک کند که در یک وب‌سایت خرید، سبد خرید جایی است که اقلام مورد نظر برای خرید در آن قرار دارند.</p>
<p>به عنوان یک <em>client</em>، من نیازی ندارم که بدانم از کدام <em>URI scheme</em> برای دسترسی به خرید آلبوم استفاده کنم؛ فقط باید به <em>resource</em> دسترسی پیدا کنم، <em>buy control</em> را پیدا کنم و به آن <em>navigate</em> کنم. <em>buy control</em> می‌تواند مکان را تغییر دهد، <em>URI</em> می‌تواند تغییر کند، یا حتی سایت می‌تواند من را به <em>service</em> دیگری بفرستد، و به عنوان یک <em>client</em> من اهمیتی نمی‌دهم. این به ما مقدار زیادی از <em>decoupling</em> بین <em>client</em> و <em>server</em> می‌دهد.</p>
<p>ما در اینجا از <em>underlying detail</em> بسیار <em>abstracted</em> هستیم. ما می‌توانیم پیاده‌سازی نحوه ارائه <em>control</em> را کاملاً تغییر دهیم تا زمانی که <em>client</em> همچنان بتواند یک <em>control</em> را پیدا کند که با درک آن از <em>protocol</em> مطابقت داشته باشد، به همان روشی که یک <em>shopping cart control</em> ممکن است از یک پیوند ساده به یک <em>JavaScript control</em> پیچیده‌تر تبدیل شود. ما همچنین آزاد هستیم که <em>new controls</em> را به سند اضافه کنیم، شاید نشان‌دهنده <em>new state transitions</em> باشند که می‌توانیم روی <em>resource</em> مورد نظر انجام دهیم.</p>
<p>ما فقط در صورتی به <em>consumers</em> خود آسیب می‌رسانیم که اساساً معناشناسی یکی از <em>controls</em> را تغییر دهیم تا بسیار متفاوت رفتار کند، یا اگر یک <em>control</em> را به طور کامل حذف کنیم.</p>
<p>نظریه این است که، با استفاده از این <em>controls</em> برای <em>decouple</em> کردن <em>client</em> و <em>server</em>، ما با گذشت زمان مزایای قابل توجهی را به دست می‌آوریم که امیدواریم افزایش زمان را برای راه‌اندازی و اجرای این <em>protocols</em> جبران کند. متأسفانه، اگرچه به نظر می‌رسد همه این ایده‌ها در تئوری منطقی هستند، اما من متوجه شده‌ام که این شکل از <em>REST</em> به ندرت اجرا می‌شود، به دلایلی که من هنوز کاملاً به آن‌ها پی نبرده‌ام. این باعث می‌شود که <em>HATEOAS</em>، به ویژه، یک مفهوم بسیار دشوارتر برای من باشد که برای کسانی که قبلاً به استفاده از <em>REST</em> متعهد شده‌اند، ترویج کنم. اساساً، بسیاری از ایده‌های موجود در <em>REST</em> بر اساس ایجاد سیستم‌های <em>distributed hypermedia</em> استوار است، و این چیزی نیست که اکثر مردم در نهایت می‌سازند.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0156</div>
            </div>
        </div>
        <!-- Page 0157 -->
        <div class="chapter" id="page-0157">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>چالش‌ها</h4>
<p>از نظر سهولت استفاده، از نظر تاریخی شما نمی‌توانستید کد سمت <em>client-side</em> را برای <em>REST over HTTP</em> <em>application protocol</em> خود مانند پیاده‌سازی‌های <em>RPC</em> تولید کنید. این اغلب باعث شده است که افراد <em>REST APIs</em> را ایجاد کنند که <em>client libraries</em> را برای استفاده مصرف‌کنندگان ارائه می‌دهند. این <em>client libraries</em> یک <em>binding</em> به <em>API</em> به شما می‌دهند تا <em>client integration</em> را آسان‌تر کنید. مشکل این است که <em>client libraries</em> می‌توانند باعث ایجاد برخی چالش‌ها در رابطه با <em>coupling</em> بین <em>client</em> و <em>server</em> شوند، چیزی که ما در "<em>DRY and the Perils of Code Reuse in a Microservice World</em>" در صفحه 154 در مورد آن بحث خواهیم کرد.</p>
<p>در سال‌های اخیر این مشکل تا حدودی برطرف شده است. <em>OpenAPI specification</em> که از پروژه <em>Swagger</em> رشد کرد، اکنون این امکان را به شما می‌دهد که اطلاعات کافی را در یک <em>REST endpoint</em> تعریف کنید تا امکان تولید کد سمت <em>client-side</em> را در انواع زبان‌ها فراهم کنید. در تجربه من، من تیم‌های زیادی را ندیده‌ام که واقعاً از این قابلیت استفاده می‌کنند، حتی اگر قبلاً از <em>Swagger</em> برای <em>documentation</em> استفاده می‌کردند. من این گمان را دارم که این ممکن است به دلیل دشواری‌های اصلاح استفاده از آن در <em>APIs</em> فعلی باشد. من همچنین نگرانی‌هایی در مورد <em>specification</em> دارم که قبلاً فقط برای <em>documentation</em> استفاده می‌شد و اکنون برای تعریف یک قرارداد صریح‌تر استفاده می‌شود. این می‌تواند منجر به یک <em>specification</em> بسیار پیچیده‌تر شود—مقایسه یک <em>OpenAPI schema</em> با یک <em>protocol buffer schema</em>، به عنوان مثال، یک تضاد آشکار است. با وجود تحفظات من، خوب است که این گزینه اکنون وجود دارد.</p>
<p>عملکرد نیز ممکن است یک مسئله باشد. <em>REST over HTTP payloads</em> در واقع می‌تواند فشرده‌تر از <em>SOAP</em> باشد زیرا <em>REST</em> از <em>formats</em> جایگزین مانند <em>JSON</em> یا حتی <em>binary</em> پشتیبانی می‌کند، اما هنوز هم به اندازه یک <em>binary protocol</em> سبک مانند <em>Thrift</em> نخواهد بود. <em>Overhead</em> <em>HTTP</em> برای هر <em>request</em> نیز ممکن است برای الزامات <em>low-latency</em> نگران‌کننده باشد. همه <em>HTTP protocols</em> اصلی در حال حاضر از استفاده از <em>Transmission Control Protocol (TCP)</em> در زیر استفاده می‌کنند، که در مقایسه با سایر <em>networking protocols</em> ناکارآمدی دارد، و برخی از پیاده‌سازی‌های <em>RPC</em> به شما اجازه می‌دهند از <em>networking protocols</em> جایگزین به جای <em>TCP</em> مانند <em>User Datagram Protocol (UDP)</em> استفاده کنید.</p>
<p>محدودیت‌های اعمال شده بر <em>HTTP</em> به دلیل الزام به استفاده از <em>TCP</em> در حال رسیدگی است. <em>HTTP/3</em>، که در حال حاضر در حال نهایی شدن است، به دنبال تغییر به استفاده از <em>QUIC protocol</em> جدیدتر است. <em>QUIC</em> همان نوع قابلیت‌ها را به عنوان <em>TCP</em> (مانند بهبود تضمین‌ها نسبت به <em>UDP</em>) اما با برخی از پیشرفت‌های قابل توجه ارائه می‌دهد که نشان داده شده است بهبودهایی در <em>latency</em> و کاهش <em>bandwidth</em> را ارائه می‌دهند. احتمالاً چندین سال طول می‌کشد تا <em>HTTP/3</em> تأثیر گسترده‌ای بر اینترنت عمومی داشته باشد، اما به نظر می‌رسد منطقی است که فرض کنیم سازمان‌ها می‌توانند زودتر از این در شبکه‌های خودشان بهره‌مند شوند.</p>
<p>با توجه به <em>HATEOAS</em> به طور خاص، می‌توانید با مسائل عملکردی بیشتری مواجه شوید. از آنجایی که <em>clients</em> نیاز به <em>navigate</em> کردن چندین <em>control</em> برای یافتن <em>endpoints</em> مناسب برای یک عملیات داده شده دارند، این می‌تواند منجر به <em>protocols</em> بسیار <em>chatty</em> شود—ممکن است چندین <em>round trips</em> وجود داشته باشد</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0157</div>
            </div>
        </div>
        <!-- Page 0158 -->
        <div class="chapter" id="page-0158">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>required</em> برای هر عملیات. در نهایت، این یک <em>trade-off</em> است. اگر تصمیم به اتخاذ یک سبک <em>HATEOAS</em> از <em>REST</em> گرفتید، پیشنهاد می‌کنم ابتدا <em>clients</em> خود را به این <em>controls</em> هدایت کنید و سپس در صورت لزوم بعداً بهینه‌سازی کنید. به یاد داشته باشید که استفاده از <em>HTTP</em> مقدار زیادی کمک <em>out of the box</em> را در اختیار ما قرار می‌دهد، که قبلاً در مورد آن بحث کردیم.</p>
<p>بدی‌های <em>premature optimization</em> قبلاً به خوبی مستند شده‌اند، بنابراین نیازی نیست که در اینجا به آن‌ها بپردازم. همچنین توجه داشته باشید که بسیاری از این رویکردها برای ایجاد <em>distributed hypertext systems</em> توسعه یافته‌اند و همه آن‌ها مناسب نیستند! گاهی اوقات شما فقط <em>good old-fashioned RPC</em> را می‌خواهید.</p>
<p>با وجود این معایب، <em>REST over HTTP</em> یک انتخاب پیش‌فرض منطقی برای تعاملات <em>service-to-service</em> است. اگر می‌خواهید بیشتر بدانید، من کتاب <em>REST in Practice: Hypermedia and Systems Architecture (O’Reilly)</em> نوشته <em>Jim Webber, Savas Parastatidis</em> و <em>Ian Robinson</em> را توصیه می‌کنم، که موضوع <em>REST over HTTP</em> را به طور عمیق پوشش می‌دهد.</p>
<h4>کجا از آن استفاده کنیم</h4>
<p>با توجه به استفاده گسترده آن در صنعت، یک <em>REST-over-HTTP-based API</em> یک انتخاب آشکار برای یک <em>synchronous request-response interface</em> است، اگر به دنبال دسترسی از طیف وسیعی از <em>clients</em> ممکن هستید. این یک اشتباه خواهد بود که به یک <em>REST API</em> به عنوان یک انتخاب "به اندازه کافی خوب برای اکثر موارد" فکر کنیم، اما چیزی در این مورد وجود دارد. این یک سبک <em>interface</em> است که به طور گسترده درک می‌شود که اکثر مردم با آن آشنا هستند، و <em>interoperability</em> را از طیف وسیعی از فناوری‌ها تضمین می‌کند.</p>
<p>عمدتاً به دلیل قابلیت‌های <em>HTTP</em> و میزان <em>REST</em> که بر اساس این قابلیت‌ها ساخته شده است (به جای پنهان کردن آن‌ها)، <em>REST-based APIs</em> در موقعیت‌هایی که می‌خواهید <em>caching</em> بزرگ و مؤثر از <em>requests</em> داشته باشید، عالی هستند. به همین دلیل است که آن‌ها انتخاب‌های آشکاری برای قرار دادن <em>APIs</em> در معرض <em>external parties</em> یا <em>client interfaces</em> هستند. با این حال، آن‌ها ممکن است در مقایسه با <em>communication protocols</em> کارآمدتر رنج ببرند، و اگرچه می‌توانید <em>asynchronous interaction protocols</em> را بر روی <em>REST-based APIs</em> بسازید، اما این واقعاً با توجه به جایگزین‌ها برای ارتباط عمومی <em>microservice-to-microservice</em> مناسب نیست.</p>
<p>با وجود قدردانی فکری از اهداف پشت <em>HATEOAS</em>، من شواهد زیادی مبنی بر اینکه کار اضافی برای پیاده‌سازی این سبک از <em>REST</em>، مزایای ارزشمندی را در درازمدت ارائه می‌دهد، ندیده‌ام، و همچنین نمی‌توانم در چند سال گذشته به یاد بیاورم که با هیچ تیمی در حال پیاده‌سازی یک معماری <em>microservice</em> صحبت کرده باشم که بتواند در مورد ارزش استفاده از <em>HATEOAS</em> صحبت کند. تجربیات من بدیهی است که فقط یک مجموعه از داده‌ها هستند، و من شک ندارم که برای برخی از افراد <em>HATEOAS</em> ممکن است خوب عمل کرده باشد. اما به نظر نمی‌رسد که این مفهوم به اندازه آنچه فکر می‌کردم فراگیر شده باشد. این می‌تواند به این دلیل باشد که مفاهیم پشت <em>HATEOAS</em> برای درک ما بیش از حد بیگانه هستند، یا ممکن است کمبود ابزارها یا استانداردهای موجود در این فضا باشد، یا شاید این مدل فقط برای انواع سیستم‌هایی که ما در نهایت ساخته‌ایم، کارآمد نباشد. البته این نیز ممکن است که مفاهیم پشت <em>HATEOAS</em> واقعاً با نحوه ساخت <em>microservices</em> ما سازگار نباشد.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0158</div>
            </div>
        </div>
        <!-- Page 0159 -->
        <div class="chapter" id="page-0159">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>بنابراین برای استفاده در <em>perimeter</em>، به طرز خارق‌العاده‌ای خوب عمل می‌کند، و برای ارتباط مبتنی بر <em>synchronous request-response</em> بین <em>microservices</em>، عالی است.</p>
<h4>GraphQL</h4>
<p>در سال‌های اخیر، <em>GraphQL</em> محبوبیت بیشتری پیدا کرده است، که عمدتاً به این دلیل است که در یک زمینه خاص برتری دارد. یعنی، این امر امکان را برای یک دستگاه سمت <em>client-side</em> فراهم می‌کند تا <em>queries</em> را تعریف کند که می‌تواند از نیاز به برقراری چندین <em>request</em> برای بازیابی همان اطلاعات جلوگیری کند. این می‌تواند بهبودهای قابل توجهی از نظر عملکرد دستگاه‌های محدود سمت <em>client-side</em> ارائه دهد و همچنین می‌تواند از نیاز به پیاده‌سازی <em>bespoke server-side aggregation</em> جلوگیری کند.</p>
<p>برای مثال ساده، دستگاهی را تصور کنید که می‌خواهد صفحه‌ای را نمایش دهد که مروری بر آخرین سفارشات مشتری را نشان می‌دهد. این صفحه باید حاوی اطلاعاتی در مورد مشتری، همراه با اطلاعاتی در مورد پنج سفارش اخیر مشتری باشد. صفحه فقط به چند <em>field</em> از <em>customer record</em> نیاز دارد، و فقط تاریخ، ارزش، و <em>shipped status</em> هر سفارش. دستگاه تلفن همراه می‌تواند <em>calls</em> را به دو <em>downstream microservices</em> صادر کند تا اطلاعات مورد نیاز را بازیابی کند، اما این شامل برقراری چندین <em>calls</em>، از جمله بازگرداندن اطلاعاتی است که در واقع مورد نیاز نیست. به خصوص با دستگاه‌های تلفن همراه، این می‌تواند اسراف‌آمیز باشد—از <em>data plan</em> یک دستگاه تلفن همراه بیشتر از حد نیاز استفاده می‌کند، و می‌تواند بیشتر طول بکشد.</p>
<p><em>GraphQL</em> به دستگاه تلفن همراه اجازه می‌دهد تا یک <em>query</em> واحد را صادر کند که می‌تواند تمام اطلاعات مورد نیاز را بازیابی کند. برای اینکه این کار انجام شود، شما به یک <em>microservice</em> نیاز دارید که یک <em>GraphQL endpoint</em> را در معرض دستگاه <em>client</em> قرار دهد. این <em>GraphQL endpoint</em> ورودی برای همه <em>client queries</em> است و یک <em>schema</em> را برای استفاده دستگاه‌های <em>client</em> در معرض نمایش قرار می‌دهد. این <em>schema</em> انواع موجود را برای <em>client</em> در معرض نمایش قرار می‌دهد، و یک <em>graphical query builder</em> خوب نیز در دسترس است تا ایجاد این <em>queries</em> را آسان‌تر کند. با کاهش تعداد <em>calls</em> و مقدار داده بازیابی شده توسط دستگاه <em>client</em>، می‌توانید به خوبی با برخی از چالش‌هایی که هنگام ساخت <em>user interfaces</em> با معماری‌های <em>microservice</em> رخ می‌دهد، مقابله کنید.</p>
<h4>چالش‌ها</h4>
<p>در ابتدا، یک چالش کمبود پشتیبانی زبان برای <em>GraphQL specification</em> بود، که در ابتدا <em>JavaScript</em> تنها انتخاب شما بود. این بسیار بهبود یافته است، به طوری که همه فناوری‌های اصلی اکنون از این <em>specification</em> پشتیبانی می‌کنند. در واقع، پیشرفت‌های قابل توجهی در <em>GraphQL</em> و پیاده‌سازی‌های مختلف در سراسر جهان وجود داشته است، که <em>GraphQL</em> را به یک چشم‌انداز بسیار کم خطرتر از چند سال پیش تبدیل کرده است. با این حال، ممکن است بخواهید از چند چالش باقیمانده با این فناوری آگاه باشید.</p>
<p>برای یک مورد، دستگاه <em>client</em> می‌تواند <em>queries</em> را به صورت پویا تغییر دهد، و من از تیم‌هایی شنیده‌ام که در نتیجه این قابلیت با <em>GraphQL queries</em> مشکلاتی داشته‌اند که باعث ایجاد بار قابل توجهی بر روی <em>server side</em> شده است. وقتی <em>GraphQL</em> را با چیزی مانند <em>SQL</em> مقایسه می‌کنیم، با یک مسئله مشابه روبرو می‌شویم. یک عبارت <em>SQL</em> گران قیمت می‌تواند باعث</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0159</div>
            </div>
        </div>
        <!-- Page 0160 -->
        <div class="chapter" id="page-0160">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>مشکلاتی برای یک <em>database</em> ایجاد می‌کند و به طور بالقوه تأثیر زیادی بر سیستم گسترده‌تر دارد. همان مشکل در مورد <em>GraphQL</em> نیز صدق می‌کند. تفاوت این است که با <em>SQL</em> ما حداقل ابزارهایی مانند <em>query planners</em> برای <em>databases</em> خود داریم، که می‌تواند به ما در تشخیص <em>queries</em> مشکل‌ساز کمک کند، در حالی که یک مشکل مشابه با <em>GraphQL</em> ممکن است ردیابی آن دشوارتر باشد.</p>
<p><em>Server-side throttling</em> <em>requests</em> یک راه‌حل بالقوه است، اما از آنجایی که اجرای <em>call</em> ممکن است در چندین <em>microservices</em> پخش شود، این کار بسیار ساده نیست. در مقایسه با <em>REST-based HTTP APIs</em> معمولی، <em>caching</em> نیز پیچیده‌تر است.</p>
<p>با <em>REST-based APIs</em>، من می‌توانم یکی از بسیاری از <em>response headers</em> را تنظیم کنم تا به دستگاه‌های سمت <em>client-side</em>، یا <em>intermediate caches</em> مانند <em>content delivery networks (CDNs)</em>، کمک کنم تا <em>responses</em> را <em>cache</em> کنند تا دیگر نیازی به درخواست آن‌ها نباشد. این به همان روش با <em>GraphQL</em> امکان‌پذیر نیست. توصیه‌هایی که در مورد این موضوع دیده‌ام، به نظر می‌رسد که حول مرتبط کردن یک <em>ID</em> با هر <em>resource</em> بازگشتی (و به یاد داشته باشید، یک <em>GraphQL query</em> می‌تواند شامل چندین <em>resource</em> باشد) می‌چرخد و سپس دستگاه <em>client</em> را ملزم به <em>cache</em> کردن <em>request</em> در برابر آن <em>ID</em> می‌کند. تا جایی که من می‌دانم، این امر استفاده از <em>CDNs</em> یا <em>caching reverse proxies</em> را بدون کار اضافی، فوق‌العاده دشوار می‌کند.</p>
<p>اگرچه من برخی از راه‌حل‌های خاص پیاده‌سازی را برای این مشکل دیده‌ام (مانند آن‌هایی که در پیاده‌سازی <em>JavaScript Apollo</em> یافت می‌شوند)، <em>caching</em> به نظر می‌رسد که یا آگاهانه یا ناخودآگاهانه به عنوان بخشی از توسعه اولیه <em>GraphQL</em> نادیده گرفته شده است.</p>
<p>البته، اگر <em>queries</em> که شما صادر می‌کنید، در طبیعت به یک <em>user</em> خاص بسیار خاص هستند، این کمبود <em>request-level caching</em> ممکن است یک عامل تعیین‌کننده نباشد، زیرا <em>cache-hit ratio</em> شما احتمالاً کم خواهد بود. با این حال، من تعجب می‌کنم که آیا این محدودیت به این معنی است که شما همچنان با یک راه‌حل ترکیبی برای دستگاه‌های <em>client</em>، با برخی از <em>requests</em> (بیشتر عمومی) که از طریق <em>normal REST-based HTTP APIs</em> و سایر <em>requests</em> که از طریق <em>GraphQL</em> می‌روند، به پایان خواهید رسید.</p>
<p>مسئله دیگری این است که در حالی که <em>GraphQL</em> از نظر تئوری می‌تواند <em>writes</em> را مدیریت کند، به نظر نمی‌رسد که به خوبی برای <em>reads</em> مناسب باشد. این منجر به موقعیت‌هایی می‌شود که در آن تیم‌ها از <em>GraphQL</em> برای <em>read</em> استفاده می‌کنند اما از <em>REST</em> برای <em>writes</em> استفاده می‌کنند.</p>
<p>آخرین مسئله چیزی است که ممکن است کاملاً ذهنی باشد، اما من هنوز فکر می‌کنم ارزش مطرح کردن را دارد. <em>GraphQL</em> باعث می‌شود احساس کنید که شما فقط با داده‌ها کار می‌کنید، که می‌تواند این ایده را تقویت کند که <em>microservices</em> که شما با آن‌ها صحبت می‌کنید، فقط <em>wrappers</em> بر روی <em>databases</em> هستند. در واقع، من چندین نفر را دیده‌ام که <em>GraphQL</em> را با <em>OData</em> مقایسه می‌کنند، فناوری‌ای که به عنوان یک <em>API</em> عمومی برای دسترسی به داده‌ها از <em>databases</em> طراحی شده است. همانطور که قبلاً به تفصیل در مورد آن بحث کردیم، ایده برخورد با <em>microservices</em> فقط به عنوان <em>wrappers</em> بر روی <em>databases</em> می‌تواند بسیار مشکل‌ساز باشد. <em>Microservices</em> عملکرد را از طریق <em>networked interfaces</em> در معرض نمایش قرار می‌دهند. بخشی از این عملکرد ممکن است نیاز داشته باشد یا منجر به قرار گرفتن داده‌ها شود، اما آن‌ها همچنان باید منطق و رفتار داخلی خود را داشته باشند. فقط به این دلیل که شما از <em>GraphQL</em> استفاده می‌کنید، به این فکر نکنید که <em>microservices</em> شما چیزی بیش از یک <em>API</em> بر روی یک <em>database</em> هستند—ضروری است که <em>GraphQL API</em> شما به <em>underlying datastores</em> <em>microservices</em> شما متصل نباشد.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0160</div>
            </div>
        </div>
        <!-- Page 0161 -->
        <div class="chapter" id="page-0161">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Where to use it</h4>
<p>جایگاه <em>sweet</em> <em>GraphQL</em> برای استفاده در <em>perimeter</em> سیستم است و عملکرد را برای <em>external clients</em> در معرض نمایش قرار می‌دهد. این <em>clients</em> معمولاً <em>GUIs</em> هستند، و با توجه به محدودیت‌های آن‌ها از نظر توانایی محدود آن‌ها در ارائه داده‌ها به <em>end user</em> و ماهیت شبکه‌های تلفن همراه، یک انتخاب واضح برای دستگاه‌های تلفن همراه است. اما <em>GraphQL</em> همچنین برای <em>external APIs</em> استفاده شده است، که <em>GitHub</em> یکی از اولین پذیرندگان <em>GraphQL</em> است. اگر یک <em>API external</em> دارید که اغلب از <em>external clients</em> می‌خواهد چندین <em>calls</em> را برای دریافت اطلاعات مورد نیاز خود انجام دهند، <em>GraphQL</em> می‌تواند به کارآمدتر و دوستانه‌تر شدن <em>API</em> کمک کند.</p>
<p>اساساً، <em>GraphQL</em> یک مکانیسم <em>call aggregation</em> و <em>filtering</em> است، بنابراین در زمینه معماری <em>microservice</em> از آن برای تجمیع <em>calls</em> بر روی چندین <em>downstream microservices</em> استفاده می‌شود. به این ترتیب، چیزی نیست که جایگزین ارتباط عمومی <em>microservice-to-microservice</em> شود.</p>
<p>جایگزینی برای استفاده از <em>GraphQL</em> این است که یک الگوی جایگزین مانند الگوی <em>backend for frontend (BFF)</em> را در نظر بگیرید—ما به آن نگاه خواهیم کرد و آن را با <em>GraphQL</em> و سایر تکنیک‌های تجمیع در فصل 14 مقایسه خواهیم کرد.</p>
<h4>Message Brokers</h4>
<p><em>Message brokers</em> واسطه‌هایی هستند که اغلب به آن‌ها <em>middleware</em> گفته می‌شود، که بین <em>processes</em> قرار می‌گیرند تا ارتباط بین آن‌ها را مدیریت کنند. آن‌ها یک انتخاب محبوب برای کمک به پیاده‌سازی ارتباط <em>asynchronous</em> بین <em>microservices</em> هستند، زیرا انواع قابلیت‌های قدرتمند را ارائه می‌دهند.</p>
<p>همانطور که قبلاً بحث کردیم، یک <em>message</em> یک مفهوم عمومی است که چیزی را که یک <em>message broker</em> ارسال می‌کند تعریف می‌کند. یک <em>message</em> می‌تواند حاوی یک <em>request</em>، یک <em>response</em> یا یک <em>event</em> باشد. به جای اینکه یک <em>microservice</em> مستقیماً با یک <em>microservice</em> دیگر ارتباط برقرار کند، <em>microservice</em> در عوض یک <em>message</em> را به یک <em>message broker</em> می‌دهد، با اطلاعاتی در مورد نحوه ارسال <em>message</em>.</p>
<h4>Topics و queues</h4>
<p><em>Brokers</em> تمایل دارند که <em>queues</em> یا <em>topics</em> را ارائه دهند، یا هر دو را. <em>Queues</em> معمولاً <em>point to point</em> هستند. یک <em>sender</em> یک <em>message</em> را در یک <em>queue</em> قرار می‌دهد، و یک <em>consumer</em> از آن <em>queue</em> می‌خواند.</p>
<p>با یک سیستم مبتنی بر <em>topic</em>، چندین <em>consumer</em> می‌توانند در یک <em>topic</em> مشترک شوند، و هر <em>consumer</em> مشترک یک کپی از آن <em>message</em> را دریافت خواهد کرد.
  <p>یک <em>consumer</em> می‌تواند نشان دهنده یک یا چند <em>microservices</em> باشد—معمولاً به عنوان یک <em>consumer group</em> مدل‌سازی می‌شود. این زمانی مفید خواهد بود که شما چندین نمونه از یک <em>microservice</em> داشته باشید، و بخواهید هر یک از آن‌ها بتوانند یک <em>message</em> را دریافت کنند. در شکل 5-1، ما یک مثال را می‌بینیم که در آن <em>Order Processor</em> دارای سه نمونه مستقر است، که همگی به عنوان بخشی از یک <em>consumer group</em> هستند. هنگامی که یک <em>message</em> در <em>queue</em> قرار می‌گیرد، فقط یک عضو از <em>consumer group</em> آن <em>message</em> را دریافت خواهد کرد؛ این بدان معناست که <em>queue</em></p>
</p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0161</div>
            </div>
        </div>
        <!-- Page 0162 -->
        <div class="chapter" id="page-0162">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>به عنوان یک مکانیسم توزیع بار عمل می‌کند. این یک نمونه از الگوی <em>competing consumers</em> است که ما در فصل 4 به طور مختصر به آن اشاره کردیم.</p>
<p>شکل 5-1. یک <em>queue</em> امکان وجود یک <em>consumer group</em> را فراهم می‌کند</p>
<p>با <em>topics</em>، می‌توانید چندین <em>consumer groups</em> داشته باشید. در شکل 5-2، یک <em>event</em> که نشان‌دهنده پرداخت یک سفارش است، بر روی <em>Order Status topic</em> قرار می‌گیرد. یک کپی از آن <em>event</em> توسط <em>Warehouse microservice</em> و <em>Notifications microservice</em> دریافت می‌شود، که در <em>consumer groups</em> جداگانه قرار دارند. فقط یک نمونه از هر <em>consumer group</em> آن <em>event</em> را خواهد دید.</p>
<p>در نگاه اول، یک <em>queue</em> فقط شبیه یک <em>topic</em> با یک <em>consumer group</em> واحد به نظر می‌رسد. بخش بزرگی از تمایز بین این دو این است که وقتی یک <em>message</em> از طریق یک <em>queue</em> ارسال می‌شود، دانش وجود دارد که <em>message</em> به چه کسی ارسال می‌شود. با یک <em>topic</em>، این اطلاعات از فرستنده <em>message</em> پنهان است—فرستنده از اینکه چه کسی (اگر کسی) در نهایت <em>message</em> را دریافت می‌کند، بی‌خبر است.</p>
<p><em>Topics</em> برای همکاری مبتنی بر <em>event</em> مناسب هستند، در حالی که <em>queues</em> برای ارتباط <em>request/response</em> مناسب‌تر خواهند بود. با این حال، این باید به عنوان راهنمایی کلی در نظر گرفته شود، نه یک قانون سخت‌گیرانه.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 162" src="page_0162/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0162</div>
            </div>
        </div>
        <!-- Page 0163 -->
        <div class="chapter" id="page-0163">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>شکل 5-2. <em>Topics</em> به چندین مشترک اجازه می‌دهند تا <em>messages</em> یکسانی را دریافت کنند، که برای پخش <em>event</em> مفید است</p>
<h4>Guaranteed delivery</h4>
<p>پس چرا از یک <em>broker</em> استفاده کنیم؟ اساساً، آن‌ها برخی از قابلیت‌ها را ارائه می‌دهند که می‌تواند برای ارتباط <em>asynchronous</em> بسیار مفید باشد. ویژگی‌هایی که آن‌ها ارائه می‌دهند متفاوت است، اما جالب‌ترین ویژگی، <em>guaranteed delivery</em> است، چیزی که همه <em>brokers</em> پرکاربرد به نوعی از آن پشتیبانی می‌کنند. <em>Guaranteed delivery</em> تعهدی از سوی <em>broker</em> را توصیف می‌کند تا اطمینان حاصل شود که <em>message</em> تحویل داده شده است.</p>
<p>از دیدگاه <em>microservice</em> که <em>message</em> را ارسال می‌کند، این می‌تواند بسیار مفید باشد. اگر <em>destination</em> مورد نظر در دسترس نباشد، مشکلی نیست—<em>broker</em> <em>message</em> را نگه می‌دارد تا زمانی که بتواند تحویل داده شود. این می‌تواند تعداد چیزهایی را که یک <em>upstream microservice</em> باید در مورد آن‌ها نگران باشد، کاهش دهد. آن را با یک <em>synchronous direct call</em>—به عنوان مثال، یک <em>HTTP request</em> مقایسه کنید: اگر <em>destination</em> مورد نظر قابل دسترسی نباشد، <em>upstream microservice</em> باید بداند که با <em>request</em> چه کند؛ آیا باید <em>call</em> را دوباره امتحان کند یا تسلیم شود؟</p>
<p>برای اینکه <em>guaranteed delivery</em> کار کند، یک <em>broker</em> باید اطمینان حاصل کند که هر <em>messages</em> که هنوز تحویل داده نشده‌اند، به روشی پایدار نگه داشته می‌شوند تا زمانی که بتوانند تحویل داده شوند. برای عمل به این وعده، یک <em>broker</em> معمولاً به عنوان نوعی سیستم مبتنی بر <em>cluster</em> اجرا می‌شود، و اطمینان حاصل می‌کند که از دست رفتن یک ماشین واحد باعث از دست رفتن یک <em>message</em> نمی‌شود.
  <p>به طور معمول، موارد زیادی در اجرای صحیح یک <em>broker</em> وجود دارد، که تا حدی به دلیل چالش‌ها در مدیریت نرم‌افزار مبتنی بر <em>cluster</em> است. اغلب، وعده <em>guaranteed delivery</em></p>
</p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 163" src="page_0163/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0163</div>
            </div>
        </div>
        <!-- Page 0164 -->
        <div class="chapter" id="page-0164">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>می‌تواند تضعیف شود اگر <em>broker</em> به درستی راه‌اندازی نشود. به عنوان مثال، <em>RabbitMQ</em> به نمونه‌هایی در یک <em>cluster</em> نیاز دارد تا از طریق شبکه‌های با <em>low-latency</em> نسبتاً کم ارتباط برقرار کنند؛ در غیر این صورت، نمونه‌ها می‌توانند در مورد وضعیت فعلی <em>messages</em> در حال رسیدگی، گیج شوند، که منجر به از دست رفتن داده‌ها می‌شود. من این محدودیت خاص را به عنوان راهی برای گفتن این که <em>RabbitMQ</em> به هیچ وجه بد است برجسته نمی‌کنم—همه <em>brokers</em> محدودیت‌هایی در مورد نحوه اجرای آن‌ها برای ارائه وعده <em>guaranteed delivery</em> دارند. اگر قصد دارید <em>broker</em> خود را اجرا کنید، اطمینان حاصل کنید که مستندات را با دقت می‌خوانید.</p>
<p>همچنین شایان ذکر است که منظور هر <em>broker</em> از <em>guaranteed delivery</em> می‌تواند متفاوت باشد. باز هم، خواندن مستندات یک شروع عالی است.</p>
<h4>Trust</h4>
<p>یکی از جاذبه‌های بزرگ یک <em>broker</em>، ویژگی <em>guaranteed delivery</em> است. اما برای اینکه این کار انجام شود، شما باید نه تنها به افرادی که <em>broker</em> را ایجاد کرده‌اند، بلکه به روشی که <em>broker</em> عمل کرده است نیز اعتماد کنید. اگر شما سیستمی را ساخته‌اید که بر اساس این فرض است که <em>delivery</em> تضمین شده است، و این در اثر مشکلی در <em>underlying broker</em> صادق نباشد، می‌تواند مشکلات قابل توجهی ایجاد کند. البته این امید وجود دارد که شما این کار را به نرم‌افزاری محول می‌کنید که توسط افرادی ایجاد شده است که می‌توانند این کار را بهتر از شما انجام دهند. در نهایت، شما باید تصمیم بگیرید که چقدر می‌خواهید به <em>broker</em> که از آن استفاده می‌کنید اعتماد کنید.</p>
<h4>Other characteristics</h4>
<p>علاوه بر <em>guaranteed delivery</em>، <em>brokers</em> می‌توانند ویژگی‌های دیگری را ارائه دهند که ممکن است برای شما مفید باشد.</p>
<p>اکثر <em>brokers</em> می‌توانند ترتیب تحویل <em>messages</em> را تضمین کنند، اما این جهانی نیست، و حتی در این صورت دامنه این تضمین می‌تواند محدود باشد. برای مثال، با <em>Kafka</em>، <em>ordering</em> فقط در یک <em>single partition</em> تضمین شده است. اگر نمی‌توانید مطمئن باشید که <em>messages</em> به ترتیب دریافت می‌شوند، <em>consumer</em> شما ممکن است نیاز به جبران داشته باشد، شاید با به تعویق انداختن پردازش <em>messages</em> که خارج از ترتیب دریافت شده‌اند، تا زمانی که هر <em>missing messages</em> دریافت شود.</p>
<p>برخی از <em>brokers</em> <em>transactions</em> را در <em>write</em> ارائه می‌دهند—به عنوان مثال، <em>Kafka</em> به شما امکان می‌دهد در یک <em>single transaction</em> به چندین <em>topic</em> بنویسید. برخی از <em>brokers</em> همچنین می‌توانند <em>read transactionalit</em> را ارائه دهند، چیزی که من هنگام استفاده از تعدادی <em>broker</em> از طریق <em>Java Message Service (JMS) APIs</em> از آن بهره برده‌ام. این می‌تواند مفید باشد اگر می‌خواهید اطمینان حاصل کنید که <em>message</em> می‌تواند قبل از حذف آن از <em>broker</em> توسط <em>consumer</em> پردازش شود.</p>
<p>ویژگی دیگری که تا حدودی بحث‌برانگیز است و توسط برخی از <em>brokers</em> وعده داده شده است، <em>exactly once delivery</em> است. یکی از راه‌های آسان‌تر برای ارائه <em>guaranteed delivery</em>، اجازه دادن به ارسال مجدد <em>message</em> است. این می‌تواند منجر به این شود که یک <em>consumer</em> یک <em>message</em> را بیش از یک بار ببیند (حتی اگر این یک موقعیت نادر باشد). اکثر <em>brokers</em> آنچه را که می‌توانند برای کاهش این احتمال انجام می‌دهند، یا این واقعیت را از <em>consumer</em> پنهان می‌کنند، اما برخی از <em>brokers</em> با تضمین <em>exactly once delivery</em> فراتر می‌روند. این یک موضوع پیچیده است، همانطور که من صحبت کرده‌ام</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0164</div>
            </div>
        </div>
        <!-- Page 0165 -->
        <div class="chapter" id="page-0165">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>به گفته برخی از کارشناسان که بیان می‌کنند تضمین تحویل دقیقاً یک بار در همه موارد غیرممکن است، در حالی که کارشناسان دیگر می‌گویند شما اساساً می‌توانید این کار را با چند <em>workarounds</em> ساده انجام دهید. به هر حال، اگر <em>broker</em> انتخابی شما ادعا می‌کند که این را پیاده‌سازی می‌کند، پس واقعاً به نحوه پیاده‌سازی آن توجه کنید. حتی بهتر از آن، <em>consumers</em> خود را به گونه‌ای بسازید که برای این واقعیت آماده باشند که ممکن است <em>message</em> را بیش از یک بار دریافت کنند و بتوانند این وضعیت را مدیریت کنند. یک مثال بسیار ساده این است که هر <em>message</em> دارای یک <em>ID</em> باشد، که یک <em>consumer</em> می‌تواند هر بار که یک <em>message</em> دریافت می‌شود، آن را بررسی کند. اگر یک <em>message</em> با آن <em>ID</em> قبلاً پردازش شده باشد، <em>message</em> جدیدتر را می‌توان نادیده گرفت.</p>
<h4>انتخاب‌ها</h4>
<p>انواع مختلفی از <em>message brokers</em> وجود دارد. نمونه‌های محبوب شامل <em>RabbitMQ</em>، <em>ActiveMQ</em> و <em>Kafka</em> (که به زودی بیشتر بررسی خواهیم کرد) می‌شوند. فروشندگان اصلی <em>public cloud</em> نیز انواع محصولاتی را ارائه می‌دهند که این نقش را ایفا می‌کنند، از نسخه‌های مدیریت شده آن <em>brokers</em> که می‌توانید روی زیرساخت خود نصب کنید تا پیاده‌سازی‌های <em>bespoke</em> که مختص یک پلتفرم خاص هستند. به عنوان مثال، <em>AWS</em> دارای <em>Simple Queue Service (SQS)</em>، <em>Simple Notification Service (SNS)</em> و <em>Kinesis</em> است، که همگی انواع مختلفی از <em>brokers</em> کاملاً مدیریت شده را ارائه می‌دهند. در واقع، <em>SQS</em> دومین محصولی بود که توسط <em>AWS</em> منتشر شد، که در سال 2006 راه‌اندازی شد.</p>
<h4>Kafka</h4>
<p><em>Kafka</em> به دلیل محبوبیت اخیر آن، ارزش برجسته کردن را دارد. بخشی از این محبوبیت به دلیل استفاده از <em>Kafka</em> در کمک به جابجایی حجم زیادی از داده‌ها به عنوان بخشی از پیاده‌سازی <em>stream processing pipelines</em> است. این می‌تواند به انتقال از پردازش <em>batch-oriented</em> به پردازش <em>real-time</em> کمک کند.</p>
<p>چند ویژگی از <em>Kafka</em> وجود دارد که ارزش برجسته کردن را دارند. اولاً، برای مقیاس بسیار بزرگ طراحی شده است—در <em>LinkedIn</em> ساخته شد تا چندین <em>message clusters</em> موجود را با یک پلتفرم واحد جایگزین کند. <em>Kafka</em> ساخته شده است تا امکان وجود چندین <em>consumers</em> و <em>producers</em> را فراهم کند—من با یک متخصص در یک شرکت فناوری بزرگ صحبت کردم که بیش از پنجاه هزار <em>producers</em> و <em>consumers</em> داشت که روی یک <em>cluster</em> کار می‌کردند. منصفانه است که بگوییم، تعداد بسیار کمی از سازمان‌ها در آن سطح از مقیاس با مشکل مواجه هستند، اما برای برخی از سازمان‌ها، توانایی مقیاس‌بندی آسان <em>Kafka</em> (نسبتاً) می‌تواند بسیار مفید باشد.</p>
<p>یکی دیگر از ویژگی‌های نسبتاً منحصربه‌فرد <em>Kafka</em>، پایداری <em>message</em> است. با یک <em>message broker</em> معمولی، هنگامی که آخرین <em>consumer</em> یک <em>message</em> را دریافت کرد، <em>broker</em> دیگر نیازی به نگه داشتن آن <em>message</em> ندارد. با <em>Kafka</em>، <em>messages</em> را می‌توان برای یک دوره قابل تنظیم ذخیره کرد. این بدان معناست که <em>messages</em> را می‌توان برای همیشه ذخیره کرد. این می‌تواند به <em>consumers</em> اجازه دهد تا <em>messages</em> را که قبلاً پردازش کرده‌اند دوباره وارد کنند، یا به <em>consumers</em> تازه مستقر شده اجازه می‌دهد تا <em>messages</em> را که قبلاً ارسال شده‌اند، پردازش کنند.</p>
<p>در نهایت، <em>Kafka</em> پشتیبانی داخلی برای <em>stream processing</em> را ارائه کرده است. به جای استفاده از <em>Kafka</em> برای ارسال <em>messages</em> به یک ابزار پردازش <em>stream</em> اختصاصی مانند <em>Apache</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0165</div>
            </div>
        </div>
        <!-- Page 0166 -->
        <div class="chapter" id="page-0166">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>Flink</em>، برخی از وظایف را می‌توان به جای آن در داخل <em>Kafka</em> انجام داد. با استفاده از <em>KSQL</em>، می‌توانید عبارات <em>SQL-like</em> را تعریف کنید که می‌تواند یک یا چند <em>topic</em> را در پرواز پردازش کند. این می‌تواند چیزی شبیه به یک نمای <em>database</em> به‌روزرسانی شده پویا به شما بدهد، که منبع داده‌ها <em>Kafka topics</em> به جای یک <em>database</em> است. این قابلیت‌ها برخی از امکانات بسیار جالب را برای نحوه مدیریت داده‌ها در سیستم‌های توزیع شده باز می‌کند. اگر می‌خواهید این ایده‌ها را با جزئیات بیشتری بررسی کنید، می‌توانم کتاب <em>Designing Event-Driven Systems (O’Reilly)</em> نوشته <em>Ben Stopford</em> را توصیه کنم. (من باید کتاب <em>Ben</em> را توصیه کنم، زیرا من پیشگفتار آن را نوشتم!) برای یک <em>deep dive</em> در <em>Kafka</em> به طور کلی، <em>Kafka: The Definitive Guide (O’Reilly)</em> نوشته <em>Neha Narkhede, Gwen Shapira</em> و <em>Todd Palino</em> را پیشنهاد می‌کنم.</p>
<h4>Serialization Formats</h4>
<p>برخی از انتخاب‌های فناوری که ما به آن‌ها نگاه کردیم—به طور خاص، برخی از پیاده‌سازی‌های <em>RPC</em>—در مورد نحوه <em>serialize</em> و <em>deserialize</em> کردن داده‌ها، برای شما انتخاب‌هایی را انجام می‌دهند. برای مثال، با <em>gRPC</em>، هر داده‌ای که ارسال می‌شود به <em>protocol buffer format</em> تبدیل می‌شود. با این حال، بسیاری از گزینه‌های فناوری، آزادی زیادی را از نظر نحوه تبدیل داده‌ها برای <em>network calls</em> به ما می‌دهند. <em>Kafka</em> را به عنوان <em>broker</em> مورد نظر خود انتخاب کنید، و می‌توانید <em>messages</em> را در قالب‌های مختلف ارسال کنید. بنابراین کدام <em>format</em> را باید انتخاب کنید؟</p>
<h4>Textual Formats</h4>
<p>استفاده از <em>textual formats</em> استاندارد، به <em>clients</em> انعطاف‌پذیری زیادی در نحوه استفاده از <em>resources</em> می‌دهد. <em>REST APIs</em> اغلب از یک <em>textual format</em> برای <em>request</em> و <em>response bodies</em> استفاده می‌کنند، حتی اگر از نظر تئوری می‌توانید داده‌های <em>binary</em> را از طریق <em>HTTP</em> ارسال کنید. در واقع، این نحوه عملکرد <em>gRPC</em> است—با استفاده از <em>HTTP</em> در زیر، اما ارسال <em>binary protocol buffers</em>.</p>
<p><em>JSON</em> <em>XML</em> را به عنوان <em>text serialization format</em> مورد نظر تصاحب کرده است. شما می‌توانید به تعدادی از دلایلی اشاره کنید که چرا این اتفاق افتاده است، اما دلیل اصلی این است که یکی از مصرف‌کنندگان اصلی <em>APIs</em> اغلب یک مرورگر است، جایی که <em>JSON</em> بسیار مناسب است. <em>JSON</em> تا حدی در نتیجه واکنش‌های شدید در برابر <em>XML</em> محبوب شد، و طرفداران، فشردگی و سادگی نسبی آن را در مقایسه با <em>XML</em> به عنوان یک عامل پیروزی دیگر ذکر می‌کنند.
  <p>واقعیت این است که به ندرت یک تفاوت عظیم بین اندازه یک <em>JSON payload</em> و آن یک <em>XML payload</em> وجود دارد، به خصوص که این <em>payloads</em> معمولاً فشرده می‌شوند. همچنین شایان ذکر است که بخشی از سادگی <em>JSON</em> هزینه‌ای دارد—در عجله ما برای اتخاذ <em>protocols</em> ساده‌تر، <em>schemas</em> از پنجره بیرون رفتند (در این مورد بعداً توضیح داده می‌شود).</p>
<p><em>Avro</em> یک <em>serialization format</em> جالب است. <em>JSON</em> را به عنوان یک ساختار اساسی در نظر می‌گیرد و از آن برای تعریف یک <em>schema-based format</em> استفاده می‌کند. <em>Avro</em> به عنوان یک <em>format</em> برای <em>message payloads</em> محبوبیت زیادی پیدا کرده است، تا حدی به دلیل توانایی آن در ارسال <em>schema</em> به عنوان بخشی از <em>payload</em>، که می‌تواند پشتیبانی از <em>multiple different messaging formats</em> را بسیار آسان‌تر کند.</p>
</p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0166</div>
            </div>
        </div>
        <!-- Page 0167 -->
        <div class="chapter" id="page-0167">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>با این حال، من هنوز هم طرفدار <em>XML</em> هستم. برخی از پشتیبانی‌های ابزار بهتر است. به عنوان مثال، اگر بخواهم فقط بخش‌های خاصی از <em>payload</em> را استخراج کنم (تکنیکی که در "<em>Handling Change Between Microservices</em>" در صفحه 144 بیشتر در مورد آن بحث خواهیم کرد)، می‌توانم از <em>XPATH</em> استفاده کنم، که یک استاندارد شناخته شده با پشتیبانی ابزار زیاد است، یا حتی <em>CSS selectors</em>، که بسیاری آن را آسان‌تر می‌دانند. با <em>JSON</em>، من <em>JSONPath</em> را دارم، اما این به طور گسترده پشتیبانی نمی‌شود. من این را عجیب می‌دانم که مردم <em>JSON</em> را انتخاب می‌کنند زیرا خوب و سبک وزن است اما سپس سعی می‌کنند مفاهیمی مانند کنترل‌های <em>hypermedia</em> را که از قبل در <em>XML</em> وجود دارد، به آن وارد کنند. با این حال، من می‌پذیرم که احتمالاً در اینجا در اقلیت هستم و <em>JSON</em> <em>format</em> مورد انتخاب بسیاری از مردم است!</p>
<h4>Binary Formats</h4>
<p>در حالی که <em>textual formats</em> مزایایی مانند آسان کردن خواندن آن‌ها برای انسان‌ها و ارائه <em>interoperability</em> زیاد با ابزارها و فناوری‌های مختلف دارند، دنیای <em>binary serialization protocols</em> جایی است که اگر شروع به نگرانی در مورد اندازه <em>payload</em> یا در مورد راندمان نوشتن و خواندن <em>payloads</em> کردید، باید در آن قرار بگیرید. <em>Protocol buffers</em> مدتی است که وجود دارند و اغلب خارج از محدوده <em>gRPC</em> استفاده می‌شوند—آن‌ها احتمالاً محبوب‌ترین <em>binary serialization format</em> را برای ارتباط مبتنی بر <em>microservice</em> نشان می‌دهند.</p>
<p>با این حال، این فضا بزرگ است، و تعدادی از <em>formats</em> دیگر با در نظر گرفتن طیف وسیعی از الزامات توسعه یافته‌اند. <em>Simple Binary Encoding</em>، <em>Cap’n Proto</em>، و <em>FlatBuffers</em> همه به ذهن می‌آیند. اگرچه <em>benchmarks</em> برای هر یک از این <em>formats</em> وجود دارد، که مزایای مربوطه آن‌ها را در مقایسه با <em>protocol buffers</em>، <em>JSON</em>، یا <em>other formats</em> برجسته می‌کند، <em>benchmarks</em> از یک مشکل اساسی رنج می‌برند به این صورت که ممکن است لزوماً نشان‌دهنده نحوه استفاده شما از آن‌ها نباشند. اگر می‌خواهید آخرین چند بایت را از <em>serialization format</em> خود استخراج کنید، یا میکروثانیه‌ها را از زمانی که برای خواندن یا نوشتن این <em>payloads</em> صرف می‌شود، اصلاح کنید، من به شدت پیشنهاد می‌کنم مقایسه خود را از این <em>formats</em> مختلف انجام دهید. در تجربه من، اکثریت قریب به اتفاق سیستم‌ها به ندرت مجبورند نگران چنین بهینه‌سازی‌هایی باشند، زیرا آن‌ها اغلب می‌توانند بهبودهایی را که به دنبال آن هستند با ارسال داده‌های کمتر یا با عدم برقراری <em>call</em> به دست آورند. با این حال، اگر در حال ساخت یک سیستم توزیع شده با <em>ultra-low-latency</em> هستید، مطمئن شوید که برای شیرجه زدن به دنیای <em>binary serialization formats</em> آماده‌اید.</p>
<h4>Schemas</h4>
<p>بحثی که بارها و بارها مطرح می‌شود این است که آیا باید از <em>schemas</em> برای تعریف آنچه <em>endpoints</em> ما در معرض نمایش قرار می‌دهند و آنچه می‌پذیرند، استفاده کنیم یا خیر. <em>Schemas</em> می‌توانند در انواع مختلفی ارائه شوند، و انتخاب یک <em>serialization format</em> معمولاً فناوری <em>schema</em> را که می‌توانید از آن استفاده کنید، تعریف می‌کند. اگر با <em>raw XML</em> کار می‌کنید، از <em>XML Schema Definition (XSD)</em> استفاده می‌کنید؛ اگر با <em>raw JSON</em> کار می‌کنید، از <em>JSON Schema</em> استفاده می‌کنید. برخی از انتخاب‌های فناوری که ما به آن‌ها اشاره کردیم (به طور خاص، یک زیرمجموعه قابل توجه از گزینه‌های <em>RPC</em>) نیازمند استفاده از <em>explicit schemas</em> هستند، بنابراین اگر آن فناوری‌ها را انتخاب کردید، شما</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0167</div>
            </div>
        </div>
        <!-- Page 0168 -->
        <div class="chapter" id="page-0168">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>باید از <em>schemas</em> استفاده کنند. <em>SOAP</em> از طریق استفاده از <em>WSDL</em> کار می‌کند، در حالی که <em>gRPC</em> نیازمند استفاده از یک <em>protocol buffer specification</em> است. سایر انتخاب‌های فناوری که ما بررسی کرده‌ایم، استفاده از <em>schemas</em> را اختیاری می‌کنند، و این جایی است که اوضاع جالب‌تر می‌شود.</p>
<p>همانطور که قبلاً بحث کردم، من طرفدار داشتن <em>explicit schemas</em> برای <em>microservice endpoints</em> هستم، به دو دلیل اصلی. اولاً، آن‌ها راهی طولانی را در جهت ارائه یک <em>explicit representation</em> از آنچه یک <em>microservice endpoint</em> در معرض نمایش قرار می‌دهد و آنچه می‌تواند بپذیرد، طی می‌کنند. این کار هم برای توسعه‌دهندگانی که روی <em>microservice</em> کار می‌کنند و هم برای مصرف‌کنندگانشان زندگی را آسان‌تر می‌کند. <em>Schemas</em> ممکن است جایگزین نیاز به <em>good documentation</em> نشوند، اما مطمئناً می‌توانند به کاهش مقدار <em>documentation</em> مورد نیاز کمک کنند.</p>
<p>دلیل دیگری که من <em>explicit schemas</em> را دوست دارم، این است که آن‌ها از نظر گرفتن <em>accidental breakages</em> از <em>microservice endpoints</em> چگونه کمک می‌کنند. ما در یک لحظه بررسی خواهیم کرد که چگونه تغییرات بین <em>microservices</em> را مدیریت کنیم، اما ابتدا ارزش دارد که انواع مختلف <em>breakages</em> و نقشی که <em>schemas</em> می‌توانند ایفا کنند را بررسی کنیم.</p>
<h4>Structural Versus Semantic Contract Breakages</h4>
<p>به طور کلی، می‌توانیم <em>contract breakages</em> را به دو دسته تقسیم کنیم—<em>structural breakages</em> و <em>semantic breakages</em>. یک <em>structural breakage</em> موقعیتی است که در آن ساختار <em>endpoint</em> به گونه‌ای تغییر می‌کند که یک <em>consumer</em> اکنون ناسازگار است—این می‌تواند نشان‌دهنده حذف <em>fields</em> یا <em>methods</em>، یا افزودن <em>new required fields</em> باشد. یک <em>semantic breakage</em> به موقعیتی اشاره دارد که در آن ساختار <em>microservices endpoint</em> یکسان باقی می‌ماند، اما رفتار به گونه‌ای تغییر می‌کند که انتظارات مصرف‌کنندگان را از بین می‌برد.</p>
<p>بیایید یک مثال ساده بزنیم. شما یک <em>microservice</em> به نام <em>Hard Calculations</em> بسیار پیچیده دارید که یک متد <code>calculate</code> را در <em>endpoint</em> خود در معرض نمایش قرار می‌دهد. این متد <code>calculate</code> دو عدد صحیح را می‌گیرد، که هر دو <em>fields</em> مورد نیاز هستند. اگر شما <em>Hard Calculations</em> را به گونه‌ای تغییر دهید که متد <code>calculate</code> اکنون فقط یک عدد صحیح می‌گیرد، در این صورت <em>consumers</em> خراب می‌شوند—آن‌ها درخواست‌هایی را با دو عدد صحیح ارسال می‌کنند که <em>Hard Calculations microservice</em> رد خواهد کرد. این یک نمونه از یک <em>structural change</em> است، و به طور کلی چنین تغییراتی را می‌توان آسان‌تر تشخیص داد.</p>
<p>یک <em>semantic changes</em> مشکل‌سازتر است. این جایی است که ساختار <em>endpoint</em> تغییر نمی‌کند اما رفتار <em>endpoint</em> تغییر می‌کند. با بازگشت به متد <code>calculate</code> خود، تصور کنید که در نسخه اول، دو عدد صحیح ارائه شده با هم جمع می‌شوند و نتایج برگردانده می‌شوند. تا اینجای کار، همه چیز خوب است. حالا ما <em>Hard Calculations</em> را تغییر می‌دهیم تا متد <code>calculate</code> اعداد صحیح را در هم ضرب کند و نتیجه را برگرداند. <em>Semantics</em> متد <code>calculate</code> به گونه‌ای تغییر کرده است که می‌تواند انتظارات <em>consumers</em> را از بین ببرد.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0168</div>
            </div>
        </div>
        <!-- Page 0169 -->
        <div class="chapter" id="page-0169">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>1 <em>Martin Fowler</em> این موضوع را در مورد <em>schemaless data storage</em> با جزئیات بیشتری بررسی می‌کند.</p>
<h4>Should You Use Schemas?</h4>
<p>با استفاده از <em>schemas</em> و مقایسه نسخه‌های مختلف <em>schemas</em>، می‌توانیم <em>structural breakages</em> را تشخیص دهیم. تشخیص <em>semantic breakages</em> نیازمند استفاده از <em>testing</em> است. اگر شما <em>schemas</em> ندارید، یا اگر <em>schemas</em> دارید اما تصمیم می‌گیرید که تغییرات <em>schema</em> را برای سازگاری مقایسه نکنید، در این صورت بار تشخیص <em>structural breakages</em> قبل از رسیدن به <em>production</em> نیز بر عهده <em>testing</em> خواهد بود. مسلماً، وضعیت تا حدودی با <em>static versus dynamic typing</em> در زبان‌های برنامه‌نویسی مشابه است. با یک زبان <em>statically typed</em>، انواع در زمان <em>compile time</em> ثابت هستند—اگر کد شما کاری را با یک نمونه از یک <em>type</em> انجام دهد که مجاز نیست (مانند فراخوانی یک متد که وجود ندارد)، در این صورت <em>compiler</em> می‌تواند آن اشتباه را تشخیص دهد. این می‌تواند شما را وا دارد که تلاش‌های <em>testing</em> را بر روی انواع دیگر مشکلات متمرکز کنید. با این حال، با یک زبان <em>dynamically typed</em>، برخی از <em>testing</em> شما باید اشتباهاتی را تشخیص دهد که یک <em>compiler</em> برای زبان‌های <em>statically typed</em> تشخیص می‌دهد.</p>
<p>اکنون، من در مورد زبان‌های <em>static versus dynamically typed</em> نسبتاً راحت هستم، و من متوجه شده‌ام که در هر دو بسیار مولد هستم (نسبتاً). مطمئناً، زبان‌های <em>dynamically typed</em> برخی از مزایای قابل توجه را به شما می‌دهند که برای بسیاری از افراد توجیهی برای رها کردن ایمنی <em>compile-time</em> دارد. با این حال، شخصاً، اگر بحث را به تعاملات <em>microservice</em> برگردانیم، من متوجه نشده‌ام که یک <em>trade-off</em> متعادل مشابه در مورد <em>schema versus “schemaless” communication</em> وجود دارد. به زبان ساده، من فکر می‌کنم داشتن یک <em>explicit schema</em> بیش از هر سود قابل درکی برای داشتن <em>schemaless communication</em> است.</p>
<p>واقعاً، سؤال این نیست که آیا شما <em>schema</em> دارید یا خیر—این است که آیا آن <em>schema</em> صریح است یا خیر. اگر شما در حال مصرف داده‌ها از یک <em>schemaless API</em> هستید، همچنان انتظاراتی دارید که چه داده‌هایی باید در آنجا وجود داشته باشند و چگونه آن داده‌ها باید ساختاردهی شوند. کد شما که داده‌ها را مدیریت می‌کند، با مجموعه‌ای از فرض‌ها در مورد چگونگی ساختاردهی آن داده‌ها نوشته می‌شود. در چنین حالتی، من استدلال می‌کنم که شما <em>schema</em> دارید، اما فقط کاملاً ضمنی است، نه صریح.1 بسیاری از میل من برای یک <em>explicit schema</em> ناشی از این واقعیت است که من فکر می‌کنم مهم است که تا حد امکان در مورد آنچه یک <em>microservice</em> انجام می‌دهد (یا نمی‌دهد) صریح باشیم.</p>
<p>به نظر می‌رسد استدلال اصلی برای <em>schemaless endpoints</em> این است که <em>schemas</em> به کار بیشتری نیاز دارند و ارزش کافی نمی‌دهند. این، به نظر من، تا حدی شکست تخیل و تا حدی شکست ابزار خوب است تا به <em>schemas</em> کمک کند ارزش بیشتری داشته باشند، وقتی صحبت از استفاده از آن‌ها برای تشخیص <em>structural breakages</em> می‌شود.</p>
<p>در نهایت، بسیاری از آنچه <em>schemas</em> ارائه می‌دهند، یک <em>explicit representation</em> از بخشی از <em>structure contract</em> بین یک <em>client</em> و یک <em>server</em> است. آن‌ها به صریح کردن مسائل کمک می‌کنند و می‌توانند تا حد زیادی به ارتباط بین تیم‌ها کمک کنند و همچنین به عنوان یک <em>safety net</em> عمل کنند. در موقعیت‌هایی که هزینه تغییر کاهش می‌یابد—به عنوان مثال، زمانی که هم <em>client</em> و هم <em>server</em> متعلق به یک تیم هستند—من در مورد نداشتن <em>schemas</em> راحت‌تر هستم.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0169</div>
            </div>
        </div>
        <!-- Page 0170 -->
        <div class="chapter" id="page-0170">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Handling Change Between Microservices</h4>
<p>احتمالاً رایج‌ترین سؤالی که در مورد <em>microservices</em> دریافت می‌کنم، پس از "آن‌ها چقدر باید بزرگ باشند؟" این است که "چگونه <em>versioning</em> را مدیریت می‌کنید؟" وقتی این سؤال پرسیده می‌شود، به ندرت سؤالی در مورد اینکه چه نوع طرح شماره‌گذاری باید استفاده کنید، است و بیشتر در مورد نحوه مدیریت تغییرات در قراردادهای بین <em>microservices</em> است.</p>
<p>نحوه مدیریت تغییرات واقعاً به دو موضوع تقسیم می‌شود. در یک لحظه، ما به این نگاه خواهیم کرد که اگر شما نیاز به ایجاد یک تغییر اساسی داشته باشید، چه اتفاقی می‌افتد. اما قبل از آن، بیایید نگاهی بیندازیم به آنچه که می‌توانید برای اجتناب از ایجاد یک تغییر اساسی در وهله اول انجام دهید.</p>
<h4>Avoiding Breaking Changes</h4>
<p>اگر می‌خواهید از ایجاد <em>breaking changes</em> اجتناب کنید، چند ایده اصلی وجود دارد که ارزش بررسی دارند، که بسیاری از آن‌ها را قبلاً در ابتدای فصل لمس کردیم. اگر می‌توانید این ایده‌ها را عملی کنید، متوجه خواهید شد که اجازه دادن به <em>microservices</em> برای تغییر مستقل از یکدیگر بسیار آسان‌تر است.</p>
<ul>
<li><strong>Expansion changes</strong></li>
<p>چیزهای جدید را به یک <em>microservice interface</em> اضافه کنید؛ چیزهای قدیمی را حذف نکنید.</p>
<li><strong>Tolerant reader</strong></li>
<p>هنگام استفاده از یک <em>microservice interface</em>، در آنچه انتظار دارید، انعطاف‌پذیر باشید.</p>
<li><strong>Right technology</strong></li>
<p>فناوری را انتخاب کنید که ایجاد تغییرات <em>backward-compatible</em> را در <em>interface</em> آسان‌تر می‌کند.</p>
<li><strong>Explicit interface</strong></li>
<p>در مورد آنچه که یک <em>microservice</em> در معرض نمایش قرار می‌دهد، صریح باشید. این کار هم برای توسعه‌دهندگان که روی <em>microservice</em> کار می‌کنند و هم برای نگه‌دارندگان <em>microservice</em>، درک آنچه که می‌توان آزادانه تغییر داد را آسان‌تر می‌کند.</p>
<li><strong>Catch accidental breaking changes early</strong></li>
<p>مکانیسم‌هایی را برای تشخیص تغییرات <em>interface</em> که در <em>production</em> مصرف‌کنندگان را خراب می‌کنند، قبل از استقرار آن تغییرات، در نظر بگیرید.</p>
</ul>
<p>این ایده‌ها یکدیگر را تقویت می‌کنند، و بسیاری از آن‌ها بر این مفهوم کلیدی از پنهان کردن اطلاعات بنا شده‌اند که ما مکرراً در مورد آن بحث کرده‌ایم. بیایید به نوبه خود به هر ایده نگاهی بیندازیم.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0170</div>
            </div>
        </div>
        <!-- Page 0171 -->
        <div class="chapter" id="page-0171">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Expansion Changes</h4>
<p>احتمالاً آسان‌ترین نقطه برای شروع، این است که فقط چیزهای جدید را به یک <em>microservice contract</em> اضافه کنید و هیچ چیز دیگری را حذف نکنید. مثال افزودن یک <em>field</em> جدید به یک <em>payload</em> را در نظر بگیرید—با فرض اینکه <em>client</em> به نوعی نسبت به این تغییرات تحمل دارد، این نباید تأثیر مادی داشته باشد. به عنوان مثال، افزودن یک <em>dateOfBirth field</em> جدید به یک <em>customer record</em> باید خوب باشد.</p>
<h4>Tolerant Reader</h4>
<p>نحوه پیاده‌سازی <em>consumer</em> یک <em>microservice</em> می‌تواند تأثیر زیادی در آسان‌تر کردن تغییرات <em>backward-compatible</em> داشته باشد. به طور خاص، ما می‌خواهیم از <em>client code</em> که بیش از حد به <em>interface</em> یک <em>microservice</em> متصل می‌شود، اجتناب کنیم. بیایید یک <em>Email microservice</em> را در نظر بگیریم که کار آن ارسال ایمیل به مشتریان ما از زمان به زمان است. از آن خواسته می‌شود که یک ایمیل "سفارش ارسال شده" را به یک مشتری با <em>ID</em> 1234 ارسال کند؛ به سراغ آن می‌رود و مشتری را با آن <em>ID</em> بازیابی می‌کند و چیزی شبیه پاسخ نشان داده شده در <em>Example 5-3</em> را دریافت می‌کند.</p>
<p><strong>Example 5-3. Sample response from the Customer service</strong></p>
<pre><code class="language-xml">
<customer>
  <firstname>Sam</firstname>
  <lastname>Newman</lastname>
  <email>sam@magpiebrain.com</email>
  <telephonenumber>555-1234-5678</telephonenumber>
</customer>
  </code></pre>
<p>اکنون، برای ارسال ایمیل، <em>Email microservice</em> فقط به <code>firstname</code>، <code>lastname</code>، و <code>email fields</code> نیاز دارد. ما نیازی به دانستن <code>telephoneNumber</code> نداریم. ما می‌خواهیم به سادگی <em>fields</em> را که به آن‌ها اهمیت می‌دهیم بیرون بکشیم و بقیه را نادیده بگیریم. برخی از <em>binding technology</em>ها، به‌ویژه آن‌هایی که توسط زبان‌های <em>strongly typed</em> استفاده می‌شوند، می‌توانند سعی کنند همه <em>fields</em> را پیوند دهند، خواه <em>consumer</em> آن‌ها را بخواهد یا نه. اگر متوجه شدیم که هیچ‌کس از <code>telephoneNumber</code> استفاده نمی‌کند و تصمیم گرفتیم آن را حذف کنیم، چه اتفاقی می‌افتد؟ این می‌تواند باعث شود که <em>consumers</em> بی‌جهت خراب شوند.</p>
<p>به همین ترتیب، اگر بخواهیم <em>Customer object</em> خود را برای پشتیبانی از جزئیات بیشتر <em>restructure</em> کنیم، شاید برخی از ساختارهای بیشتر را اضافه کنیم، مانند <em>Example 5-4</em>؟ داده‌هایی که <em>Email service</em> ما می‌خواهد هنوز وجود دارد، با همان نام، اما اگر کد ما فرضیات بسیار صریحی را در مورد جایی که <code>firstname</code> و <code>lastname fields</code> ذخیره می‌شوند، داشته باشد، در این صورت می‌تواند دوباره خراب شود. در این مورد، ما می‌توانیم به جای آن از <em>XPath</em> برای بیرون کشیدن <em>fields</em> استفاده کنیم که به آن‌ها اهمیت می‌دهیم، و به ما اجازه می‌دهد در مورد جایی که <em>fields</em> قرار دارند، تا زمانی که بتوانیم آن‌ها را پیدا کنیم، <em>ambivalent</em> باشیم. این الگو—از پیاده‌سازی یک <em>reader</em> که قادر به نادیده گرفتن تغییراتی است که به آن‌ها اهمیت نمی‌دهیم—چیزی است که <em>Martin Fowler</em> آن را <em>tolerant reader</em> می‌نامد.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0171</div>
            </div>
        </div>
        <!-- Page 0172 -->
        <div class="chapter" id="page-0172">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><strong>Example 5-4. A restructured Customer resource: the data is all still there, but can our consumers find it?</strong></p>
<pre><code class="language-xml">
<customer>
  <naming>
    <firstname>Sam</firstname>
    <lastname>Newman</lastname>
    <nickname>Magpiebrain</nickname>
    <fullname>Sam "Magpiebrain" Newman</fullname>
  </naming>
  <email>sam@magpiebrain.com</email>
</customer>
  </code></pre>
<p>نمونه‌ای از <em>client</em> که سعی می‌کند تا حد امکان در استفاده از یک <em>service</em> انعطاف‌پذیر باشد، قانون <em>Postel’s law</em> (که به عنوان اصل <em>robustness</em> نیز شناخته می‌شود) را نشان می‌دهد، که بیان می‌کند:</p>
<p>“در آنچه انجام می‌دهید محافظه‌کار باشید، در آنچه از دیگران می‌پذیرید، لیبرال باشید.” زمینه اصلی این قطعه از خرد، تعامل دستگاه‌ها از طریق شبکه‌ها بود، جایی که شما باید انتظار داشته باشید انواع چیزهای عجیب و غریب اتفاق بیفتد. در زمینه تعاملات مبتنی بر <em>microservice</em>، این ما را به این سوق می‌دهد که سعی کنیم کد <em>client</em> خود را به گونه‌ای ساختار دهیم که نسبت به تغییرات در <em>payloads</em> تحمل داشته باشد.</p>
<h4>Right Technology</h4>
<p>همانطور که قبلاً بررسی کردیم، برخی از فناوری‌ها می‌توانند در مورد اجازه دادن به ما برای تغییر <em>interfaces</em> شکننده‌تر باشند—من قبلاً ناامیدی‌های شخصی خود را با <em>Java RMI</em> برجسته کرده‌ام. از طرف دیگر، برخی از پیاده‌سازی‌های <em>integration</em> تمام تلاش خود را می‌کنند تا تغییرات را بدون <em>breaking clients</em> تا حد امکان آسان کنند. در انتهای ساده طیف، <em>protocol buffers</em>، <em>serialization format</em> که به عنوان بخشی از <em>gRPC</em> استفاده می‌شود، مفهوم شماره <em>field</em> را دارد. هر ورودی در یک <em>protocol buffer</em> باید یک شماره <em>field</em> را تعریف کند، که <em>client code</em> انتظار دارد آن را پیدا کند. اگر <em>fields</em> جدید اضافه شوند، <em>client</em> اهمیتی نمی‌دهد. <em>Avro</em> به <em>schema</em> اجازه می‌دهد تا همراه با <em>payload</em> ارسال شود، که به <em>clients</em> اجازه می‌دهد تا به طور بالقوه یک <em>payload</em> را بسیار شبیه به یک <em>dynamic type</em> تفسیر کنند.</p>
<p>در انتهای افراطی‌تر طیف، مفهوم <em>REST</em> از <em>HATEOAS</em> تا حد زیادی در مورد این است که به <em>clients</em> امکان می‌دهد حتی زمانی که با استفاده از لینک‌های <em>hypermedia</em> که قبلاً مورد بحث قرار گرفت، تغییر می‌کنند، از <em>REST endpoints</em> استفاده کنند. البته این مستلزم این است که شما وارد کل طرز فکر <em>HATEOAS</em> شوید.</p>
<h4>Explicit Interface</h4>
<p>من طرفدار بزرگ یک <em>microservice</em> هستم که یک <em>explicit schema</em> را در معرض نمایش قرار می‌دهد که نشان‌دهنده عملکرد <em>endpoints</em> آن است. داشتن یک <em>explicit schema</em>، این موضوع را برای مصرف‌کنندگان روشن می‌کند که چه انتظاراتی می‌توانند داشته باشند، اما همچنین برای یک توسعه‌دهنده که روی یک <em>microservice</em> کار می‌کند، مشخص می‌کند که چه چیزهایی باید دست‌نخورده باقی بمانند تا اطمینان حاصل شود که شما مصرف‌کنندگان را خراب نمی‌کنید. به عبارت دیگر، یک <em>explicit schema</em> راهی طولانی را در جهت ایجاد مرزهای</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0172</div>
            </div>
        </div>
        <!-- Page 0173 -->
        <div class="chapter" id="page-0173">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>information hiding</em> را صریح‌تر می‌کند—آنچه در <em>schema</em> در معرض نمایش قرار می‌گیرد، طبق تعریف پنهان نیست.</p>
<p>داشتن یک <em>explicit schema</em> برای <em>RPC</em> مدتی است که تثبیت شده است و در واقع یک <em>requirement</em> برای بسیاری از پیاده‌سازی‌های <em>RPC</em> است. از طرف دیگر، <em>REST</em> معمولاً مفهوم یک <em>schema</em> را به عنوان اختیاری در نظر می‌گیرد، تا جایی که من <em>explicit schemas</em> را برای <em>REST endpoints</em> بسیار نادر می‌دانم. این در حال تغییر است، با مواردی مانند <em>OpenAPI specification</em> که قبلاً ذکر شد و <em>JSON Schema specification</em> نیز در حال کسب بلوغ است.</p>
<p>پروتکل‌های پیام‌رسانی <em>Asynchronous</em> در این فضا بیشتر تلاش کرده‌اند. شما می‌توانید به اندازه کافی یک <em>schema</em> برای <em>payload</em> یک <em>message</em> داشته باشید، و در واقع این حوزه‌ای است که در آن <em>Avro</em> اغلب استفاده می‌شود. با این حال، داشتن یک <em>explicit interface</em> باید فراتر از این برود. اگر یک <em>microservice</em> را در نظر بگیریم که <em>events</em> را <em>fire</em> می‌کند، چه <em>events</em> را در معرض نمایش قرار می‌دهد؟ در حال حاضر چند تلاش برای ایجاد <em>explicit schemas</em> برای <em>event-based endpoints</em> در حال انجام است. یکی <em>AsyncAPI</em> است، که تعدادی از کاربران بزرگ را به خود جذب کرده است، اما به نظر می‌رسد موردی که بیشترین <em>traction</em> را به دست می‌آورد، <em>CloudEvents</em> است، <em>specification</em> که توسط <em>Cloud Native Computing Foundation (CNCF)</em> پشتیبانی می‌شود. محصول <em>Azure’s event grid</em> از <em>CloudEvents format</em> پشتیبانی می‌کند، نشانه‌ای از فروشندگان مختلف که از این <em>format</em> پشتیبانی می‌کنند، که باید به <em>interoperability</em> کمک کند. این هنوز یک فضای نسبتاً جدید است، بنابراین جالب خواهد بود که ببینیم اوضاع در چند سال آینده چگونه پیش خواهد رفت.</p>
<h4>Semantic Versioning</h4>
<p>آیا عالی نمی‌شد اگر به عنوان یک <em>client</em> می‌توانستید فقط به شماره نسخه یک <em>service</em> نگاه کنید و بدانید که آیا می‌توانید با آن ادغام شوید؟ <em>Semantic versioning</em> یک <em>specification</em> است که دقیقاً همین را ممکن می‌سازد. با <em>semantic versioning</em>، هر شماره نسخه به صورت <em>MAJOR.MINOR.PATCH</em> است. وقتی عدد <em>MAJOR</em> افزایش می‌یابد، به این معنی است که تغییرات <em>backward-incompatible</em> ایجاد شده است. وقتی <em>MINOR</em> افزایش می‌یابد، عملکرد جدیدی اضافه شده است که باید <em>backward compatible</em> باشد. در نهایت، یک تغییر در <em>PATCH</em> بیان می‌کند که <em>bug fixes</em> برای عملکرد موجود انجام شده است.</p>
<p>برای دیدن اینکه <em>semantic versioning</em> چقدر می‌تواند مفید باشد، بیایید به یک مورد استفاده ساده نگاه کنیم. برنامه <em>helpdesk</em> ما برای کار در برابر نسخه 1.2.0 از <em>Customer service</em> ساخته شده است. اگر یک ویژگی جدید اضافه شود، که باعث شود <em>Customer service</em> به 1.3.0 تغییر کند، برنامه <em>helpdesk</em> ما نباید تغییری در رفتار خود ببیند و نباید انتظار داشته باشد که هیچ تغییری ایجاد کند. با این حال، ما نمی‌توانستیم تضمین کنیم که می‌توانیم در برابر نسخه 1.1.0 از <em>Customer service</em> کار کنیم، زیرا ممکن است به عملکرد اضافه شده در نسخه 1.2.0 متکی باشیم. همچنین می‌توانیم انتظار داشته باشیم که اگر یک نسخه 2.0.0 جدید از <em>Customer service</em> منتشر شود، باید تغییراتی در برنامه خود ایجاد کنیم.</p>
<p>ممکن است تصمیم بگیرید که یک <em>semantic version</em> برای <em>service</em>، یا حتی برای یک <em>individual endpoint</em> در یک <em>service</em> داشته باشید، اگر آن‌ها را در کنار هم دارید، همانطور که در بخش بعد توضیح داده شده است.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0173</div>
            </div>
        </div>
        <!-- Page 0174 -->
        <div class="chapter" id="page-0174">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>2 توجه داشته باشید که در واقع سه ابزار مختلف در این فضا با یک نام وجود دارد! ابزار <em>openapi-diff</em> در <em>https://github.com/Azure/openapi-diff</em> به نظر می‌رسد به ابزاری نزدیک‌تر می‌شود که در واقع سازگاری را پاس می‌کند یا رد می‌شود.</p>
<p>این طرح <em>versioning</em> به ما امکان می‌دهد اطلاعات و انتظارات زیادی را فقط در سه <em>fields</em> بسته‌بندی کنیم. <em>full specification</em> به زبان بسیار ساده، انتظاراتی را که <em>clients</em> می‌توانند از تغییرات در این اعداد داشته باشند، مشخص می‌کند، و می‌تواند فرآیند برقراری ارتباط در مورد اینکه آیا تغییرات باید بر مصرف‌کنندگان تأثیر بگذارند یا خیر را ساده کند. متأسفانه، من این رویکرد را به اندازه کافی در سیستم‌های توزیع شده برای درک اثربخشی آن در آن زمینه ندیده‌ام—چیزی که از زمان اولین ویرایش این کتاب واقعاً تغییر نکرده است.</p>
<h4>Catch Accidental Breaking Changes Early</h4>
<p>بسیار مهم است که تغییراتی را که مصرف‌کنندگان را خراب می‌کنند در اسرع وقت شناسایی کنیم، زیرا حتی اگر بهترین فناوری ممکن را انتخاب کنیم، یک تغییر بی‌ضرر از یک <em>microservice</em> می‌تواند باعث شود که مصرف‌کنندگان خراب شوند. همانطور که قبلاً به آن اشاره کردیم، استفاده از <em>schemas</em> می‌تواند به ما در تشخیص <em>structural changes</em> کمک کند، با فرض اینکه ما از نوعی <em>tooling</em> برای کمک به مقایسه نسخه‌های <em>schema</em> استفاده کنیم. طیف گسترده‌ای از <em>tooling</em> در آنجا برای انجام این کار برای انواع <em>schema</em> مختلف وجود دارد. ما <em>Protolock</em> را برای <em>protocol buffers</em>، <em>json-schema-diff-validator</em> را برای <em>JSON Schema</em>، و <em>openapi-diff</em> را برای <em>OpenAPI specification</em> داریم.2 به نظر می‌رسد ابزارهای بیشتری همیشه در این فضا ظاهر می‌شوند. با این حال، آنچه شما به دنبال آن هستید، چیزی است که فقط تفاوت‌های بین دو <em>schemas</em> را گزارش نمی‌کند، بلکه بر اساس سازگاری پاس یا رد می‌شود؛ این به شما امکان می‌دهد اگر <em>incompatible schemas</em> یافت شد، یک ساخت <em>CI</em> را شکست دهید و اطمینان حاصل کنید که <em>microservice</em> شما مستقر نخواهد شد.</p>
<p><em>Confluent Schema Registry</em> منبع باز از <em>JSON Schema</em>، <em>Avro</em> و <em>protocol buffers</em> پشتیبانی می‌کند و قادر به مقایسه نسخه‌های جدید آپلود شده برای <em>backward compatibility</em> است. اگرچه این برنامه برای کمک به عنوان بخشی از یک اکوسیستم که در آن از <em>Kafka</em> استفاده می‌شود، ساخته شده است و برای اجرا به <em>Kafka</em> نیاز دارد، هیچ چیز شما را از استفاده از آن برای ذخیره و اعتبارسنجی <em>schemas</em> که برای ارتباط مبتنی بر غیر <em>Kafka</em> استفاده می‌شوند، باز نمی‌دارد.</p>
<p>ابزارهای مقایسه <em>Schema</em> می‌توانند به ما در تشخیص <em>structural breakages</em> کمک کنند، اما در مورد <em>semantic breakages</em> چطور؟ یا اگر شما در وهله اول از <em>schemas</em> استفاده نمی‌کنید چه؟ در این صورت، ما در حال نگاه کردن به <em>testing</em> هستیم. این موضوعی است که ما در "<em>Contract Tests and Consumer-Driven Contracts (CDCs)</em>" در صفحه 292 با جزئیات بیشتری بررسی خواهیم کرد، اما می‌خواستم <em>consumer-driven contract testing</em> را برجسته کنم، که صریحاً در این زمینه کمک می‌کند—<em>Pact</em> یک مثال عالی از یک ابزار است که به طور خاص برای این مشکل هدف‌گذاری شده است. فقط به یاد داشته باشید، اگر <em>schemas</em> ندارید، انتظار داشته باشید که <em>testing</em> شما برای تشخیص <em>breaking changes</em> باید کار بیشتری انجام دهد.</p>
<p>اگر شما از چندین <em>client libraries</em> مختلف پشتیبانی می‌کنید، اجرای <em>tests</em> با استفاده از هر <em>library</em> که از آن پشتیبانی می‌کنید در برابر آخرین <em>service</em> یک تکنیک دیگر است که می‌تواند کمک کند. هنگامی که متوجه شدید که می‌خواهید یک <em>consumer</em> را خراب کنید، شما این انتخاب را دارید که یا سعی کنید</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0174</div>
            </div>
        </div>
        <!-- Page 0175 -->
        <div class="chapter" id="page-0175">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>از <em>break</em> به طور کامل اجتناب کنید یا آن را بپذیرید و مکالمات درستی را با افرادی که <em>services</em> مصرف‌کننده را مدیریت می‌کنند، آغاز کنید.</p>
<h4>Managing Breaking Changes</h4>
<p>بنابراین شما تا آنجا که می‌توانید پیش رفته‌اید تا اطمینان حاصل کنید که تغییراتی که در <em>interface</em> یک <em>microservice</em> ایجاد می‌کنید، <em>backward compatible</em> هستند، اما متوجه شده‌اید که فقط باید تغییری ایجاد کنید که یک <em>breaking change</em> را تشکیل می‌دهد. در چنین شرایطی چه کاری می‌توانید انجام دهید؟ شما سه گزینه اصلی دارید:</p>
<ul>
<li><strong>Lockstep deployment</strong></li>
<p>لازم است که <em>microservice</em> که <em>interface</em> را در معرض نمایش قرار می‌دهد و تمام مصرف‌کنندگان آن <em>interface</em> همزمان تغییر کنند.</p>
<li><strong>Coexist incompatible microservice versions</strong></li>
<p>نسخه‌های قدیمی و جدید <em>microservice</em> را در کنار هم اجرا کنید.</p>
<li><strong>Emulate the old interface</strong></li>
<p><em>Microservice</em> خود را داشته باشید تا <em>interface</em> جدید را در معرض نمایش قرار دهید و همچنین <em>interface</em> قدیمی را شبیه‌سازی کنید.</p>
</ul>
<h4>Lockstep Deployment</h4>
<p>البته، <em>lockstep deployment</em> با استقلال استقرار در تضاد است. اگر بخواهیم یک نسخه جدید از <em>microservice</em> خود را با یک <em>breaking change</em> برای <em>interface</em> آن مستقر کنیم، اما همچنان این کار را به روشی مستقل انجام دهیم، باید به مصرف‌کنندگان خود زمان بدهیم تا به <em>interface</em> جدید ارتقا یابند. این ما را به سمت دو گزینه بعدی سوق می‌دهد که من در نظر می‌گیرم.</p>
<h4>Coexist Incompatible Microservice Versions</h4>
<p>یکی دیگر از راه‌حل‌های <em>versioning</em> که اغلب ذکر می‌شود، این است که نسخه‌های مختلف <em>service</em> را یکباره داشته باشید و به مصرف‌کنندگان قدیمی‌تر اجازه دهید ترافیک خود را به نسخه قدیمی‌تر هدایت کنند، در حالی که مصرف‌کنندگان جدیدتر نسخه جدید را مشاهده می‌کنند، همانطور که در شکل 5-3 نشان داده شده است. این رویکردی است که <em>Netflix</em> با احتیاط در موقعیت‌هایی استفاده می‌کند که هزینه تغییر مصرف‌کنندگان قدیمی‌تر بیش از حد زیاد است، به خصوص در موارد نادر که دستگاه‌های قدیمی هنوز به نسخه‌های قدیمی‌تر <em>API</em> متصل هستند. من شخصاً طرفدار این ایده نیستم، و می‌فهمم که چرا <em>Netflix</em> به ندرت از آن استفاده می‌کند. اولاً، اگر نیاز به رفع یک <em>internal bug</em> در <em>service</em> خود داشته باشم، اکنون باید دو مجموعه مختلف از <em>services</em> را اصلاح و مستقر کنم. این احتمالاً به این معنی است که من باید <em>codebase</em> را برای <em>service</em> خود <em>branch</em> کنم، و این همیشه مشکل‌ساز است. ثانیاً، به این معنی است که من نیاز به <em>smarts</em> دارم تا مصرف‌کنندگان را به <em>microservice</em> مناسب هدایت کنم. این رفتار ناگزیر در جایی در <em>middleware</em> قرار می‌گیرد، یا در تعدادی از <em>nginx scripts</em>، که باعث می‌شود درک رفتار سیستم دشوارتر شود. در نهایت، هر <em>persistent state</em> را که <em>service</em> ما ممکن است مدیریت کند، در نظر بگیرید. مشتریانی که توسط هر دو نسخه</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0175</div>
            </div>
        </div>
        <!-- Page 0176 -->
        <div class="chapter" id="page-0176">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>service</em> باید ذخیره شوند و برای همه <em>services</em> قابل مشاهده باشند، صرف نظر از اینکه کدام نسخه برای ایجاد داده‌ها در وهله اول استفاده شده است. این می‌تواند منبع پیچیدگی اضافی باشد.</p>
<p>شکل 5-3. اجرای چندین نسخه از یک <em>service</em> برای پشتیبانی از <em>old endpoints</em></p>
<p>همزیستی همزمان نسخه‌های <em>service</em> برای یک دوره کوتاه مدت می‌تواند کاملاً منطقی باشد، به خصوص زمانی که شما کاری مانند انتشار <em>canary</em> انجام می‌دهید (ما در مورد این الگو در "<em>On to Progressive Delivery</em>" در صفحه 270 بیشتر بحث خواهیم کرد). در این شرایط، ما ممکن است فقط برای چند دقیقه یا شاید چند ساعت نسخه‌ها را در کنار هم داشته باشیم، و معمولاً فقط دو نسخه مختلف از <em>service</em> به طور همزمان وجود خواهد داشت.</p>
<p>هر چه بیشتر طول بکشد تا مصرف‌کنندگان را به نسخه جدیدتر ارتقا دهید و منتشر کنید، بیشتر باید به همزیستی <em>different endpoints</em> در همان <em>microservice</em> نگاه کنید تا اینکه نسخه‌های کاملاً متفاوتی را در کنار هم داشته باشید. من همچنان قانع نشده‌ام که این کار برای پروژه متوسط ​​ارزش دارد.</p>
<h4>Emulate the Old Interface</h4>
<p>اگر ما تمام تلاش خود را برای جلوگیری از معرفی یک <em>breaking interface change</em> انجام داده‌ایم، کار بعدی ما محدود کردن تأثیر است. چیزی که ما می‌خواهیم از آن اجتناب کنیم این است که مصرف‌کنندگان را مجبور کنیم تا با ما <em>lockstep</em> ارتقا دهند، زیرا ما همیشه می‌خواهیم توانایی انتشار <em>microservices</em> را مستقل از یکدیگر حفظ کنیم. یک رویکردی که من با موفقیت برای رسیدگی به این موضوع استفاده کرده‌ام، این است که هم <em>old</em> و هم <em>new interfaces</em> را در همان <em>running service</em> در کنار هم داشته باشیم.
  <p>بنابراین اگر می‌خواهیم یک <em>breaking change</em> را منتشر کنیم، یک نسخه جدید از <em>service</em> را مستقر می‌کنیم که هم نسخه‌های قدیمی و هم جدید <em>endpoint</em> را در معرض نمایش قرار می‌دهد.</p>
</p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 176" src="page_0176/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0176</div>
            </div>
        </div>
        <!-- Page 0177 -->
        <div class="chapter" id="page-0177">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>این به ما امکان می‌دهد تا <em>microservice</em> جدید را در اسرع وقت، همراه با <em>interface</em> جدید، منتشر کنیم، در حالی که به مصرف‌کنندگان زمان می‌دهیم تا منتقل شوند. هنگامی که همه مصرف‌کنندگان دیگر از <em>old endpoint</em> استفاده نمی‌کنند، می‌توانید آن را همراه با هر کد مرتبط حذف کنید، همانطور که در شکل 5-4 نشان داده شده است.</p>
<p>شکل 5-4. یک <em>microservice</em> که <em>old endpoint</em> را شبیه‌سازی می‌کند و <em>new backward-incompatible endpoint</em> را در معرض نمایش قرار می‌دهد</p>
<p>وقتی آخرین بار از این رویکرد استفاده کردم، ما خودمان را در کمی آشفتگی با تعداد مصرف‌کنندگانی که داشتیم و تعداد <em>breaking changes</em> که ایجاد کرده بودیم، قرار دادیم. این بدان معنا بود که ما در واقع سه نسخه مختلف از <em>endpoint</em> را در کنار هم داشتیم. این چیزی نیست که من توصیه کنم! حفظ تمام کدها و <em>testing</em> مرتبط که برای اطمینان از عملکرد صحیح همه آن‌ها لازم بود، کاملاً یک بار اضافی بود.</p>
<p>برای مدیریت این موضوع، ما به صورت داخلی تمام درخواست‌ها را به <em>V1 endpoint</em> به یک درخواست <em>V2</em>، و سپس درخواست‌های <em>V2</em> به <em>V3 endpoint</em> تبدیل کردیم. این بدان معنا بود که ما می‌توانستیم به وضوح مشخص کنیم که چه کدی قرار است زمانی که <em>old endpoint(s)</em> از بین رفت، بازنشسته شود. این در واقع نمونه‌ای از الگوی <em>expand and contract</em> است، که به ما امکان می‌دهد <em>breaking changes</em> را مرحله به مرحله وارد کنیم. ما قابلیت‌هایی را که ارائه می‌دهیم، گسترش می‌دهیم، و هم راه‌های قدیمی و هم راه‌های جدید انجام کاری را پشتیبانی می‌کنیم. هنگامی که مصرف‌کنندگان قدیمی کارها را به روش جدید انجام می‌دهند، ما <em>API</em> خود را منقبض می‌کنیم، و عملکرد قدیمی را حذف می‌کنیم.</p>
<p>اگر قرار است <em>endpoints</em> را در کنار هم داشته باشید، شما به روشی نیاز دارید تا تماس‌گیرندگان درخواست‌های خود را بر این اساس مسیریابی کنند. برای سیستم‌هایی که از <em>HTTP</em> استفاده می‌کنند، من این کار را هم با شماره‌های نسخه در <em>request headers</em> و هم در خود <em>URI</em> دیده‌ام—به عنوان مثال، /v1/customer/ یا /v2/customer/. من در مورد اینکه کدام رویکرد منطقی‌تر است، دو دل هستم. از یک طرف، من دوست دارم <em>URIs</em> <em>opaque</em> باشند تا <em>clients</em> را از <em>hardcoding URI</em> دلسرد کنند</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 177" src="page_0177/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0177</div>
            </div>
        </div>
        <!-- Page 0178 -->
        <div class="chapter" id="page-0178">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>templates</em>، اما از طرف دیگر، این رویکرد باعث می‌شود که همه چیز بسیار واضح شود و می‌تواند مسیریابی <em>request</em> را ساده کند.
  <p>برای <em>RPC</em>، اوضاع می‌تواند کمی پیچیده‌تر باشد. من این موضوع را با <em>protocol buffers</em> با قرار دادن متدهای خود در <em>namespaces</em> مختلف—به عنوان مثال، <code>v1.createCustomer</code> و <code>v2.createCustomer</code>—مدیریت کرده‌ام، اما وقتی سعی می‌کنید از نسخه‌های مختلف از همان <em>types</em> که از طریق شبکه ارسال می‌شوند پشتیبانی کنید، این رویکرد می‌تواند واقعاً دردناک شود.</p>
<h4>Which Approach Do I Prefer?</h4>
<p>برای موقعیت‌هایی که در آن‌ها همان تیم هم <em>microservice</em> و هم همه <em>consumers</em> را مدیریت می‌کند، من در مورد یک <em>lockstep release</em> در موقعیت‌های محدود تا حدودی راحت هستم. با فرض اینکه واقعاً یک موقعیت یک‌باره است، انجام این کار زمانی که تأثیر به یک تیم واحد محدود می‌شود، می‌تواند قابل توجیه باشد. با این حال، من در این مورد بسیار محتاط هستم، زیرا خطر این وجود دارد که یک فعالیت یک‌باره به روال عادی تبدیل شود، و استقلال استقرار از بین می‌رود. از <em>lockstep deployments</em> بیش از حد استفاده کنید، و خیلی زود به یک <em>distributed monolith</em> خواهید رسید.</p>
<p>همانطور که بحث کردیم، همزیستی نسخه‌های مختلف از همان <em>microservice</em> می‌تواند مشکل‌ساز باشد. من فقط در موقعیت‌هایی که ما قصد داشتیم نسخه‌های <em>microservice</em> را فقط برای یک دوره زمانی کوتاه در کنار هم اجرا کنیم، این کار را در نظر می‌گیرم. واقعیت این است که وقتی شما نیاز دارید به مصرف‌کنندگان زمان بدهید تا ارتقا یابند، ممکن است هفته‌ها یا بیشتر به آن نگاه کنید. در موقعیت‌های دیگری که ممکن است نسخه‌های <em>microservice</em> را در کنار هم داشته باشید، شاید به عنوان بخشی از یک <em>blue-green deployment</em> یا <em>canary release</em>، مدت زمان‌های درگیر بسیار کوتاه‌تر است، که معایب این رویکرد را جبران می‌کند.</p>
<p>ترجیح کلی من استفاده از شبیه‌سازی <em>old endpoints</em> در هر کجا که ممکن باشد است. چالش‌های پیاده‌سازی شبیه‌سازی، به نظر من، بسیار آسان‌تر از چالش‌های همزیستی نسخه‌های <em>microservice</em> هستند.</p>
<h4>The Social Contract</h4>
<p>اینکه کدام رویکرد را انتخاب می‌کنید، تا حد زیادی به انتظاراتی که <em>consumers</em> از نحوه ایجاد این تغییرات دارند، بستگی دارد. حفظ <em>old interface</em> می‌تواند هزینه‌ای داشته باشد، و در حالت ایده‌آل، شما می‌خواهید آن را خاموش کنید و کد و زیرساخت مرتبط را در اسرع وقت حذف کنید. از طرف دیگر، شما می‌خواهید تا حد امکان به مصرف‌کنندگان زمان بدهید تا تغییری ایجاد کنند. و به یاد داشته باشید، در بسیاری از موارد، <em>backward-incompatible changes</em> که شما ایجاد می‌کنید، اغلب چیزهایی هستند که توسط مصرف‌کنندگان درخواست شده‌اند و/یا در واقع در نهایت به نفع آن‌ها خواهد بود. البته، یک عمل متعادل‌کننده‌ای بین نیازهای نگه‌دارندگان <em>microservice</em> و نیازهای مصرف‌کنندگان وجود دارد، و این باید مورد بحث قرار گیرد.</p>
<p>من متوجه شده‌ام که در بسیاری از موقعیت‌ها، نحوه رسیدگی به این تغییرات هرگز مورد بحث قرار نگرفته است، که منجر به انواع مختلف چالش‌ها می‌شود. همانطور که در مورد <em>schemas</em>، داشتن درجه‌ای از</p>
</p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0178</div>
            </div>
        </div>
        <!-- Page 0179 -->
        <div class="chapter" id="page-0179">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>explicitness</em> در مورد چگونگی ایجاد تغییرات <em>backward-incompatible</em> می‌تواند چیزها را بسیار ساده کند.
  <p>شما لزوماً به ورق‌های کاغذ و جلسات بزرگ برای رسیدن به توافق در مورد نحوه رسیدگی به تغییرات نیاز ندارید. اما با فرض اینکه شما در مسیر <em>lockstep releases</em> قرار ندارید، من پیشنهاد می‌کنم که هم مالک و هم مصرف‌کننده یک <em>microservice</em> باید در مورد چند چیز روشن باشند:</p>
<ul>
<li>چگونه موضوعی را که <em>interface</em> نیاز به تغییر دارد، مطرح خواهید کرد؟</li>
<li>چگونه تیم‌های مصرف‌کننده و <em>microservice</em> برای توافق بر سر اینکه تغییر چه شکلی خواهد داشت، همکاری خواهند کرد؟</li>
<li>از چه کسی انتظار می‌رود که برای به‌روزرسانی مصرف‌کنندگان کار کند؟</li>
<li>هنگامی که در مورد تغییر توافق شد، مصرف‌کنندگان چقدر زمان خواهند داشت تا قبل از حذف، به <em>interface</em> جدید منتقل شوند؟</li>
</ul>
<p>به یاد داشته باشید، یکی از اسرار یک معماری <em>microservice</em> مؤثر، پذیرش یک رویکرد <em>consumer-first</em> است. <em>Microservices</em> شما وجود دارند تا توسط سایر مصرف‌کنندگان فراخوانی شوند. نیازهای مصرف‌کنندگان بسیار مهم است، و اگر شما در حال ایجاد تغییراتی در یک <em>microservice</em> هستید که قرار است برای مصرف‌کنندگان بالادستی مشکل ایجاد کند، این باید در نظر گرفته شود.</p>
<p>البته، در برخی از موقعیت‌ها، ممکن است تغییر مصرف‌کنندگان امکان‌پذیر نباشد. من از <em>Netflix</em> شنیده‌ام که آن‌ها (حداقل از نظر تاریخی) با <em>set-top boxes</em> قدیمی که از نسخه‌های قدیمی‌تر <em>Netflix APIs</em> استفاده می‌کردند، مشکلاتی داشتند. این <em>set-top boxes</em> را نمی‌توان به راحتی ارتقا داد، بنابراین <em>old endpoints</em> باید در دسترس باقی بمانند، مگر اینکه تعداد <em>set-top boxes</em> قدیمی‌تر به سطحی برسد که بتوان پشتیبانی آن‌ها را غیرفعال کرد.
  <p>تصمیم برای جلوگیری از دسترسی مصرف‌کنندگان قدیمی به <em>endpoints</em> شما، گاهی اوقات می‌تواند منجر به تصمیمات مالی شود—پشتیبانی از <em>old interface</em> چه مقدار برای شما هزینه دارد، در مقابل اینکه از آن مصرف‌کنندگان چقدر درآمد دارید.</p>
<h4>Tracking Usage</h4>
<p>حتی اگر شما در مورد زمانی که مصرف‌کنندگان باید استفاده از <em>old interface</em> را متوقف کنند، توافق کنید، آیا می‌دانید که آیا آن‌ها واقعاً استفاده از آن را متوقف کرده‌اند؟ اطمینان از اینکه <em>logging</em> را برای هر <em>endpoint</em> که <em>microservice</em> شما در معرض نمایش قرار می‌دهد، در جای خود دارید می‌تواند کمک کند، همانطور که اطمینان از اینکه شما نوعی <em>client identifier</em> دارید، می‌تواند کمک کند تا در صورت نیاز به کار با آن‌ها برای انتقال آن‌ها از <em>old interface</em> شما، با تیم مورد نظر صحبت کنید. این می‌تواند چیزی به سادگی درخواست از مصرف‌کنندگان باشد که شناسه خود را در <em>user-agent header</em> هنگام برقراری <em>HTTP requests</em> قرار دهند، یا می‌توانید این را بخواهید که همه <em>calls</em> از طریق نوعی <em>API gateway</em> انجام شوند که <em>clients</em> به کلیدهایی برای شناسایی خود نیاز دارند.</p>
</p></p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0179</div>
            </div>
        </div>
        <!-- Page 0180 -->
        <div class="chapter" id="page-0180">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Extreme Measures</h4>
<p>بنابراین با فرض اینکه شما می‌دانید که یک <em>consumer</em> هنوز از یک <em>interface</em> قدیمی استفاده می‌کند که می‌خواهید حذف کنید، و آن‌ها در مورد انتقال به نسخه جدید تعلل می‌کنند، چه کاری می‌توانید در مورد آن انجام دهید؟ خوب، اولین کاری که باید انجام دهید این است که با آن‌ها صحبت کنید. شاید بتوانید به آن‌ها کمک کنید تا تغییرات انجام شود. اگر همه چیز شکست خورد، و آن‌ها حتی پس از موافقت با این کار، همچنان ارتقا نمی‌دهند، برخی از تکنیک‌های افراطی وجود دارد که من استفاده آن‌ها را دیده‌ام.</p>
<p>در یک شرکت بزرگ فناوری، ما در مورد چگونگی رسیدگی به این موضوع بحث کردیم. به صورت داخلی، شرکت یک دوره بسیار سخاوتمندانه یک ساله قبل از بازنشستگی <em>old interfaces</em> داشت. من پرسیدم که چگونه می‌دانست که آیا مصرف‌کنندگان هنوز از <em>old interfaces</em> استفاده می‌کنند، و شرکت پاسخ داد که واقعاً زحمت ردیابی آن اطلاعات را نکشید؛ پس از یک سال، آن فقط <em>old interface</em> را خاموش کرد. در داخل تشخیص داده شد که اگر این باعث شود که یک <em>consumer</em> خراب شود، این تقصیر تیم <em>consuming microservice</em> بود—آن‌ها یک سال برای ایجاد تغییر داشتند و این کار را انجام نداده بودند. البته، این رویکرد برای بسیاری از افراد کارساز نخواهد بود (من گفتم که افراطی بود!). همچنین منجر به درجه بالایی از ناکارآمدی می‌شود.
  <p>با ندانستن اینکه آیا <em>old interface</em> استفاده می‌شد، شرکت فرصت حذف آن را قبل از گذشت سال از دست داد. شخصاً، حتی اگر قرار بود فقط <em>endpoint</em> را پس از یک دوره زمانی مشخص خاموش کنم، باز هم قطعاً می‌خواستم ردیابی کنم که چه کسانی تحت تأثیر قرار خواهند گرفت.</p>
<p>یکی دیگر از اقدامات افراطی که دیدم در واقع در زمینه منسوخ کردن <em>libraries</em> بود، اما از نظر تئوری می‌توانست برای <em>microservice endpoints</em> نیز استفاده شود. مثال ارائه شده، یک <em>library</em> قدیمی بود که مردم سعی می‌کردند آن را به نفع یک <em>library</em> جدیدتر و بهتر از داخل سازمان بازنشسته کنند. با وجود تلاش‌های فراوان برای انتقال کد برای استفاده از <em>new library</em>، برخی از تیم‌ها همچنان در حال تعلل بودند. راه‌حل این بود که یک <em>sleep</em> را در <em>old library</em> وارد کنید تا به <em>calls</em> کندتر پاسخ دهد (با <em>logging</em> برای نشان دادن آنچه در حال رخ دادن است). با گذشت زمان، تیمی که <em>deprecation</em> را هدایت می‌کرد، به سادگی مدت زمان <em>sleep</em> را افزایش داد، تا اینکه در نهایت تیم‌های دیگر پیام را دریافت کردند. بدیهی است که شما باید کاملاً مطمئن باشید که سایر تلاش‌های معقول برای وادار کردن مصرف‌کنندگان به ارتقا را قبل از در نظر گرفتن چیزی مانند این، خسته کرده‌اید!</p>
<h4>DRY and the Perils of Code Reuse in a Microservice World</h4>
<p>یکی از مخفف‌هایی که ما توسعه‌دهندگان زیاد می‌شنویم، <em>DRY</em> است: خودت را تکرار نکن. اگرچه تعریف آن گاهی اوقات به عنوان تلاش برای اجتناب از تکرار کد ساده می‌شود، <em>DRY</em> به طور دقیق‌تر به این معنی است که ما می‌خواهیم از تکرار رفتار و دانش سیستم خود اجتناب کنیم. این به طور کلی یک توصیه بسیار منطقی است. داشتن تعداد زیادی خط کد که کار یکسانی را انجام می‌دهند، <em>codebase</em> شما را بزرگتر از حد نیاز می‌کند و بنابراین استدلال در مورد آن دشوارتر است. وقتی می‌خواهید رفتار را تغییر دهید، و آن رفتار در بسیاری از قسمت‌های سیستم شما تکراری است، فراموش کردن همه جا که باید تغییری ایجاد کنید، آسان است، که می‌تواند منجر به <em>bugs</em> شود. بنابراین استفاده از <em>DRY</em> به عنوان یک مانترا به طور کلی منطقی است.</p>
</p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0180</div>
            </div>
        </div>
        <!-- Page 0181 -->
        <div class="chapter" id="page-0181">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>DRY</em> چیزی است که ما را به ایجاد کدی سوق می‌دهد که می‌تواند دوباره استفاده شود. ما کد تکراری را به <em>abstractions</em> می‌کشیم که سپس می‌توانیم از چندین مکان آن‌ها را فراخوانی کنیم. شاید ما تا حد ایجاد یک <em>shared library</em> که می‌توانیم در همه جا از آن استفاده کنیم، پیش برویم! با این حال، مشخص می‌شود که اشتراک کد در یک محیط <em>microservice</em> کمی پیچیده‌تر از این است. مانند همیشه، ما بیش از یک گزینه برای بررسی داریم.</p>
<h4>Sharing Code via Libraries</h4>
<p>یک نکته که ما می‌خواهیم به هر قیمتی از آن اجتناب کنیم، اتصال بیش از حد یک <em>microservice</em> و مصرف‌کنندگان است، به طوری که هر تغییر کوچکی در خود <em>microservice</em> می‌تواند باعث تغییرات غیرضروری در مصرف‌کننده شود. با این حال، گاهی اوقات، استفاده از کد مشترک می‌تواند خود این اتصال را ایجاد کند. به عنوان مثال، در یک <em>client</em> ما یک <em>library</em> از <em>common domain objects</em> داشتیم که نمایانگر نهادهای اصلی مورد استفاده در سیستم ما بود. از این <em>library</em> توسط تمام <em>services</em> که داشتیم استفاده می‌شد. اما وقتی تغییری در یکی از آن‌ها ایجاد شد، همه <em>services</em> باید به‌روز می‌شدند. سیستم ما از طریق <em>message queues</em> ارتباط برقرار می‌کرد، که همچنین باید از محتوای نامعتبر فعلی خود تخلیه می‌شدند، و وای به حال شما اگر فراموش می‌کردید.</p>
<p>اگر استفاده شما از کد مشترک، بیرون از <em>service boundary</em> شما نفوذ کند، شما یک شکل بالقوه از <em>coupling</em> را معرفی کرده‌اید. استفاده از کد مشترک مانند <em>logging libraries</em> خوب است، زیرا آن‌ها مفاهیم داخلی هستند که برای دنیای بیرون نامرئی هستند. وب‌سایت <em>realestate.com.au</em> از یک <em>tailored service template</em> برای کمک به راه‌اندازی ایجاد <em>service</em> جدید استفاده می‌کند. به جای اینکه این کد را مشترک کند، شرکت آن را برای هر <em>new service</em> کپی می‌کند تا اطمینان حاصل شود که <em>coupling</em> نفوذ نمی‌کند.</p>
<p>نکته واقعاً مهم در مورد اشتراک کد از طریق <em>libraries</em> این است که شما نمی‌توانید تمام موارد استفاده از <em>library</em> را به طور همزمان به‌روزرسانی کنید. اگرچه چندین <em>microservices</em> ممکن است همگی از یک <em>library</em> یکسان استفاده کنند، اما معمولاً این کار را با بسته‌بندی آن <em>library</em> در <em>microservice deployment</em> انجام می‌دهند. بنابراین برای ارتقاء نسخه <em>library</em> مورد استفاده، شما باید <em>microservice</em> را <em>redeploy</em> کنید. اگر می‌خواهید همان <em>library</em> را در همه جا دقیقاً همزمان به‌روزرسانی کنید، می‌تواند منجر به استقرار گسترده چندین <em>microservices</em> مختلف در یک زمان شود، با تمام سردردهای مرتبط.</p>
<p>بنابراین اگر از <em>libraries</em> برای استفاده مجدد از کد در سراسر <em>microservice boundaries</em> استفاده می‌کنید، باید بپذیرید که نسخه‌های مختلفی از همان <em>library</em> ممکن است همزمان در آنجا وجود داشته باشند. البته، شما می‌توانید به دنبال به‌روزرسانی همه آن‌ها به آخرین نسخه در طول زمان باشید، اما تا زمانی که با این واقعیت مشکلی ندارید، حتماً از کد از طریق <em>libraries</em> مجدداً استفاده کنید. اگر واقعاً نیاز دارید که آن کد را برای همه کاربران دقیقاً در همان زمان به‌روزرسانی کنید، در این صورت، در واقع می‌خواهید به جای آن به استفاده مجدد از کد از طریق یک <em>microservice</em> اختصاصی نگاه کنید.</p>
<p>با این حال، یک مورد استفاده خاص مرتبط با استفاده مجدد از طریق <em>libraries</em> وجود دارد که ارزش بررسی بیشتری دارد.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0181</div>
            </div>
        </div>
        <!-- Page 0182 -->
        <div class="chapter" id="page-0182">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Client libraries</h4>
<p>من با بیش از یک تیم صحبت کرده‌ام که اصرار داشتند که ایجاد <em>client libraries</em> برای <em>services</em> شما، یک بخش ضروری از ایجاد <em>services</em> در وهله اول است. استدلال این است که این امر استفاده از <em>service</em> شما را آسان می‌کند و از تکرار کد مورد نیاز برای استفاده از خود <em>service</em> جلوگیری می‌کند.</p>
<p>البته، مشکل این است که اگر همان افراد هم <em>server API</em> و هم <em>client API</em> را ایجاد کنند، این خطر وجود دارد که منطقی که باید در <em>server</em> وجود داشته باشد، شروع به نشت به <em>client</em> کند. من باید بدانم: من خودم این کار را انجام داده‌ام. هرچه منطق بیشتری وارد <em>client library</em> شود، هم‌افزایی شروع به فروپاشی می‌کند، و شما خود را مجبور می‌کنید که چندین <em>clients</em> را تغییر دهید تا <em>fixes</em> را در <em>server</em> خود اعمال کنید. شما همچنین انتخاب‌های فناوری را محدود می‌کنید، به خصوص اگر شما این را الزامی کنید که <em>client library</em> باید استفاده شود.</p>
<p>یک مدل که من برای <em>client libraries</em> دوست دارم، مدل <em>Amazon Web Services (AWS)</em> است. تماس‌های <em>underlying SOAP</em> یا <em>REST web service</em> را می‌توان مستقیماً برقرار کرد، اما همه فقط از یکی از <em>software development kits (SDKs)</em> موجود استفاده می‌کنند، که <em>abstractions</em> را بر روی <em>underlying API</em> ارائه می‌دهند. با این حال، این <em>SDKs</em> توسط جامعه گسترده‌تر، یا توسط افرادی در داخل <em>AWS</em> غیر از کسانی که روی خود <em>API</em> کار می‌کنند، نوشته شده‌اند. این درجه از جداسازی به نظر می‌رسد که کارآمد است و از برخی از مشکلات <em>client libraries</em> جلوگیری می‌کند. بخشی از دلیل اینکه این کار اینقدر خوب جواب می‌دهد این است که <em>client</em> مسئول زمان وقوع ارتقا است. اگر خودتان در مسیر <em>client libraries</em> قدم می‌گذارید، مطمئن شوید که این مورد وجود دارد.</p>
<p><em>Netflix</em> به ویژه تأکید ویژه‌ای بر <em>client library</em> دارد، اما من نگرانم که مردم این را صرفاً از طریق لنز اجتناب از تکرار کد مشاهده کنند. در واقع، <em>client libraries</em> مورد استفاده توسط <em>Netflix</em>، اگر بیشتر نباشد، بیشتر در مورد اطمینان از قابلیت اطمینان و مقیاس‌پذیری سیستم‌های آن‌ها است. <em>Netflix client libraries</em>، <em>service discovery</em>، <em>failure modes</em>، <em>logging</em>، و سایر جنبه‌هایی را مدیریت می‌کنند که در واقع در مورد ماهیت خود <em>service</em> نیستند. بدون این <em>shared clients</em>، اطمینان از اینکه هر بخش از ارتباطات <em>client/server</em> در مقیاس وسیعی که <em>Netflix</em> کار می‌کند، به خوبی رفتار می‌کند، دشوار خواهد بود. استفاده آن‌ها در <em>Netflix</em> قطعاً راه‌اندازی و افزایش بهره‌وری را آسان کرده است و در عین حال اطمینان حاصل کرده است که سیستم به خوبی رفتار می‌کند. با این حال، طبق گفته حداقل یک نفر در <em>Netflix</em>، با گذشت زمان این امر منجر به درجه‌ای از <em>coupling</em> بین <em>client</em> و <em>server</em> شده است که مشکل‌ساز بوده است.</p>
<p>اگر رویکرد <em>client library</em> چیزی است که شما به آن فکر می‌کنید، مهم است که کد <em>client</em> را جدا کنید تا <em>transport protocol</em> اساسی را مدیریت کند، که می‌تواند با مواردی مانند <em>service discovery</em> و <em>failure</em> سروکار داشته باشد، از مواردی که مربوط به خود <em>destination service</em> هستند. تصمیم بگیرید که آیا می‌خواهید اصرار داشته باشید که از <em>client library</em> استفاده شود، یا اگر به افراد اجازه دهید از <em>technology stacks</em> مختلف برای برقراری <em>calls</em> به <em>underlying API</em> استفاده کنند. و در نهایت، اطمینان حاصل کنید که <em>clients</em> مسئول زمان ارتقاء <em>client libraries</em> خود هستند: ما باید اطمینان حاصل کنیم که توانایی انتشار <em>services</em> خود را مستقل از یکدیگر حفظ می‌کنیم!</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0182</div>
            </div>
        </div>
        <!-- Page 0183 -->
        <div class="chapter" id="page-0183">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Service Discovery</h4>
<p>هنگامی که شما بیش از چند <em>microservices</em> دارید، توجه شما ناگزیر به این سمت معطوف می‌شود که بدانید همه چیز دقیقاً کجاست. شاید شما می‌خواهید بدانید چه چیزی در یک محیط مشخص در حال اجرا است، بنابراین می‌دانید که چه چیزی را باید نظارت کنید. شاید به سادگی دانستن اینکه <em>Accounts microservice</em> شما کجاست، کافی باشد تا مصرف‌کنندگان آن بدانند که کجا آن را پیدا کنند. یا شاید شما فقط می‌خواهید این کار را برای توسعه‌دهندگان در سازمان خود آسان کنید تا بدانند کدام <em>APIs</em> در دسترس هستند تا چرخ را دوباره اختراع نکنند.</p>
<p>به طور کلی، همه این موارد استفاده تحت عنوان <em>service discovery</em> قرار می‌گیرند. و مثل همیشه با <em>microservices</em>، ما گزینه‌های مختلفی در اختیار داریم تا با آن مقابله کنیم.</p>
<p>همه راه‌حل‌هایی که به آن‌ها نگاه خواهیم کرد، کارها را در دو بخش انجام می‌دهند. اول، آن‌ها مکانیسمی را برای یک نمونه فراهم می‌کنند تا خود را ثبت کند و بگوید: "من اینجا هستم!" ثانیاً، آن‌ها راهی برای یافتن <em>service</em> پس از ثبت نام، ارائه می‌دهند. با این حال، <em>service discovery</em> زمانی پیچیده‌تر می‌شود که ما محیطی را در نظر می‌گیریم که در آن ما به طور مداوم در حال از بین بردن و استقرار نمونه‌های جدید از <em>services</em> هستیم. در حالت ایده‌آل، ما می‌خواهیم هر راه‌حلی که انتخاب می‌کنیم، با این موضوع مقابله کند.</p>
<p>بیایید به برخی از رایج‌ترین راه‌حل‌ها برای <em>service delivery</em> نگاهی بیندازیم و گزینه‌های خود را بررسی کنیم.</p>
<h4>Domain Name System (DNS)</h4>
<p>خوب است ساده شروع کنید. <em>DNS</em> به ما امکان می‌دهد نامی را با آدرس <em>IP</em> یک یا چند دستگاه مرتبط کنیم. به عنوان مثال، ما می‌توانیم تصمیم بگیریم که <em>Accounts microservice</em> ما همیشه در <em>accounts.musiccorp.net</em> یافت می‌شود. سپس ما آن نقطه ورود را به آدرس <em>IP</em> میزبان در حال اجرای آن <em>microservice</em> خواهیم داشت، یا شاید آن را به یک <em>load balancer</em> که بار را در تعدادی از نمونه‌ها توزیع می‌کند، تبدیل کنیم. این بدان معناست که ما باید به عنوان بخشی از استقرار <em>service</em> خود، به به‌روزرسانی این ورودی‌ها بپردازیم.
  <p>هنگام برخورد با نمونه‌های یک <em>service</em> در محیط‌های مختلف، من دیده‌ام که یک <em>convention-based domain template</em> به خوبی کار می‌کند. به عنوان مثال، ممکن است یک <em>template</em> به عنوان <em><servicename>-<environment>.musiccorp.net</environment></servicename></em> تعریف کرده باشیم، که ورودی‌هایی مانند <em>accounts-uat.musiccorp.net</em> یا <em>accounts-dev.musiccorp.net</em> را به ما می‌دهد.</p>
<p>یک راه پیشرفته‌تر برای مدیریت محیط‌های مختلف، داشتن <em>domain name servers</em> مختلف برای این محیط‌ها است. بنابراین من می‌توانم فرض کنم که <em>accounts.musiccorp.net</em> جایی است که من همیشه <em>Accounts microservice</em> را پیدا می‌کنم، اما این می‌تواند بسته به جایی که <em>lookup</em> را انجام می‌دهم، به میزبان‌های مختلفی تبدیل شود. اگر قبلاً محیط‌های خود را در بخش‌های شبکه مختلف قرار داده‌اید و در مدیریت <em>DNS servers</em> و ورودی‌های خود راحت هستید، این می‌تواند یک راه‌حل بسیار خوب باشد، اما اگر مزایای دیگری از این تنظیمات دریافت نمی‌کنید، کار زیادی می‌طلبد.</p>
</p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0183</div>
            </div>
        </div>
        <!-- Page 0184 -->
        <div class="chapter" id="page-0184">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>DNS</em> مزایای زیادی دارد، که اصلی‌ترین آن این است که یک استاندارد بسیار شناخته شده و پرکاربرد است که تقریباً هر <em>technology stack</em> از آن پشتیبانی می‌کند. متأسفانه، در حالی که تعدادی <em>services</em> برای مدیریت <em>DNS</em> در داخل یک سازمان وجود دارد، به نظر می‌رسد که تعداد کمی از آن‌ها برای محیطی طراحی شده‌اند که ما با میزبان‌های بسیار <em>disposable</em> سروکار داریم، که به‌روزرسانی ورودی‌های <em>DNS</em> را تا حدودی دشوار می‌کند. <em>Amazon’s Route 53 service</em> کار بسیار خوبی در این زمینه انجام می‌دهد، اما من هنوز یک گزینه خود میزبانی را ندیده‌ام که به همان خوبی باشد، اگرچه (همانطور که به زودی بحث خواهیم کرد) برخی از ابزارهای اختصاصی <em>service discovery</em> مانند <em>Consul</em> ممکن است در اینجا به ما کمک کنند. جدا از مشکلات در به‌روزرسانی ورودی‌های <em>DNS</em>، خود <em>DNS specification</em> می‌تواند برای ما مشکلاتی ایجاد کند.</p>
<p>ورودی‌های <em>DNS</em> برای نام‌های دامنه دارای یک <em>time to live (TTL)</em> هستند. این مدت زمانی است که یک <em>client</em> می‌تواند ورودی را تازه در نظر بگیرد. وقتی می‌خواهیم میزبان را تغییر دهیم که نام دامنه به آن اشاره دارد، آن ورودی را به‌روزرسانی می‌کنیم، اما باید فرض کنیم که <em>clients</em>، <em>IP</em> قدیمی را حداقل تا زمانی که <em>TTL</em> مشخص می‌کند، نگه می‌دارند. ورودی‌های <em>DNS</em> می‌توانند در چندین مکان <em>cached</em> شوند (حتی <em>JVM</em> ورودی‌های <em>DNS</em> را <em>cache</em> می‌کند مگر اینکه به آن بگویید که این کار را انجام ندهد)، و هرچه مکان‌های بیشتری <em>cached</em> شوند، ورودی می‌تواند <em>stale</em> تر شود.</p>
<p>یک راه برای دور زدن این مشکل این است که ورودی نام دامنه <em>service</em> شما را به یک <em>load balancer</em>، که به نوبه خود به نمونه‌های <em>service</em> شما اشاره می‌کند، اختصاص دهید، همانطور که در شکل 5-5 نشان داده شده است. هنگامی که یک نمونه جدید را مستقر می‌کنید، می‌توانید نمونه قدیمی را از ورودی <em>load-balancer</em> خارج کرده و نمونه جدید را اضافه کنید. برخی از افراد از <em>DNS round-robining</em> استفاده می‌کنند، که در آن خود ورودی‌های <em>DNS</em> به گروهی از دستگاه‌ها اشاره می‌کنند. این تکنیک بسیار مشکل‌ساز است، زیرا <em>client</em> از میزبان <em>underlying</em> پنهان است و بنابراین نمی‌تواند به راحتی ترافیک را به یکی از میزبان‌ها در صورت بیمار شدن متوقف کند.</p>
<p>شکل 5-5. استفاده از <em>DNS</em> برای حل <em>load balancer</em> برای جلوگیری از ورودی‌های <em>stale DNS</em></p>
<p>همانطور که گفته شد، <em>DNS</em> به خوبی درک شده و به طور گسترده پشتیبانی می‌شود. اما یک یا دو نقطه ضعف دارد. من پیشنهاد می‌کنم قبل از</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 184" src="page_0184/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0184</div>
            </div>
        </div>
        <!-- Page 0185 -->
        <div class="chapter" id="page-0185">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>انتخاب چیزی پیچیده‌تر. برای موقعیتی که فقط یک <em>node</em> دارید، ارجاع <em>DNS</em> مستقیماً به میزبان‌ها احتمالاً خوب است. اما برای آن موقعیت‌هایی که شما به بیش از یک نمونه از یک میزبان نیاز دارید، ورودی‌های <em>DNS</em> را به <em>load balancers</em> منتقل کنید که می‌توانند میزبان‌های جداگانه را به داخل و خارج از <em>service</em> به درستی مدیریت کنند.</p>
<h4>Dynamic Service Registries</h4>
<p>نقاط ضعف <em>DNS</em> به عنوان راهی برای یافتن <em>nodes</em> در یک محیط بسیار پویا، منجر به ایجاد تعدادی سیستم جایگزین شده است، که اکثر آن‌ها شامل ثبت نام <em>service</em> با یک <em>central registry</em> است، که به نوبه خود توانایی جستجوی این <em>services</em> را در اواخر ارائه می‌دهد. اغلب، این سیستم‌ها چیزی بیش از ارائه ثبت و کشف <em>service</em> انجام می‌دهند، که ممکن است چیز خوبی باشد یا نباشد. این یک زمینه شلوغ است، بنابراین ما فقط به چند گزینه نگاه خواهیم کرد تا شما را با آنچه در دسترس است، آشنا کنیم.</p>
<h4>ZooKeeper</h4>
<p><em>ZooKeeper</em> در اصل به عنوان بخشی از پروژه <em>Hadoop</em> توسعه یافت. از آن برای آرایه تقریباً گیج‌کننده‌ای از موارد استفاده، از جمله مدیریت پیکربندی، همگام‌سازی داده‌ها بین <em>services</em>، انتخاب <em>leader</em>، <em>message queues</em>، و (با توجه به نیاز ما) به عنوان یک <em>naming service</em> استفاده می‌شود.</p>
<p>مانند بسیاری از انواع سیستم‌های مشابه، <em>ZooKeeper</em> به اجرای تعدادی <em>nodes</em> در یک <em>cluster</em> برای ارائه تضمین‌های مختلف متکی است. این بدان معناست که شما باید انتظار داشته باشید که حداقل سه <em>Zookeeper nodes</em> را اجرا کنید. بیشتر <em>smarts</em> در <em>ZooKeeper</em> در مورد اطمینان از تکثیر ایمن داده‌ها بین این <em>nodes</em> است، و اینکه وقتی <em>nodes</em> شکست می‌خورند، همه چیز سازگار باقی می‌ماند.</p>
<p>در اصل، <em>ZooKeeper</em> یک <em>hierarchical namespace</em> برای ذخیره اطلاعات فراهم می‌کند. <em>Clients</em> می‌توانند <em>nodes</em> جدید را در این سلسله مراتب درج، آن‌ها را تغییر، یا از آن‌ها <em>query</em> کنند. علاوه بر این، آن‌ها می‌توانند <em>watches</em> را به <em>nodes</em> اضافه کنند تا وقتی تغییر می‌کنند، به آن‌ها گفته شود. این بدان معناست که ما می‌توانیم اطلاعات مربوط به محل قرارگیری <em>services</em> خود را در این ساختار ذخیره کنیم و به عنوان یک <em>client</em> به ما گفته می‌شود که چه زمانی تغییر می‌کنند. <em>ZooKeeper</em> اغلب به عنوان یک <em>general configuration store</em> استفاده می‌شود، بنابراین شما همچنین می‌توانید پیکربندی <em>service-specific</em> را در آن ذخیره کنید، و به شما امکان می‌دهد کارهایی مانند تغییر پویا سطوح <em>log</em> یا غیرفعال کردن ویژگی‌های یک سیستم در حال اجرا را انجام دهید.</p>
<p>در واقعیت، راه‌حل‌های بهتری برای <em>dynamic service registration</em> وجود دارد، تا جایی که من امروزه فعالانه از <em>ZooKeeper</em> برای این مورد استفاده اجتناب می‌کنم.</p>
<h4>Consul</h4>
<p>مانند <em>ZooKeeper</em>، <em>Consul</em> از هر دو مدیریت پیکربندی و کشف <em>service</em> پشتیبانی می‌کند. اما در ارائه پشتیبانی بیشتر برای این موارد استفاده کلیدی، فراتر از <em>ZooKeeper</em> می‌رود. به عنوان مثال، یک <em>HTTP interface</em> را برای <em>service discovery</em> به نمایش می‌گذارد، و یکی از ویژگی‌های برجسته <em>Consul</em> این است که در واقع یک <em>DNS server</em> را از جعبه ارائه می‌دهد؛</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0185</div>
            </div>
        </div>
        <!-- Page 0186 -->
        <div class="chapter" id="page-0186">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>به طور خاص، می‌تواند رکوردهای <em>SRV</em> را ارائه دهد، که به شما هم <em>IP</em> و هم یک <em>port</em> را برای یک نام مشخص می‌دهد. این بدان معناست که اگر بخشی از سیستم شما از قبل از <em>DNS</em> استفاده می‌کند و می‌تواند از رکوردهای <em>SRV</em> پشتیبانی کند، می‌توانید فقط <em>Consul</em> را اضافه کنید و بدون هیچ تغییری در سیستم موجود خود شروع به استفاده از آن کنید.</p>
<p><em>Consul</em> همچنین قابلیت‌های دیگری را در خود ایجاد می‌کند که ممکن است مفید بدانید، مانند توانایی انجام <em>health checks</em> بر روی <em>nodes</em>. بنابراین <em>Consul</em> می‌تواند به خوبی با قابلیت‌های ارائه شده توسط سایر ابزارهای مانیتورینگ اختصاصی همپوشانی داشته باشد، اگرچه احتمالاً از <em>Consul</em> به عنوان منبع این اطلاعات استفاده می‌کنید و سپس آن را در یک راه‌اندازی نظارت جامع‌تر وارد می‌کنید.
  <p><em>Consul</em> از یک <em>RESTful HTTP interface</em> برای همه چیز، از ثبت یک <em>service</em> گرفته تا <em>querying the key/value store</em> یا درج <em>health checks</em> استفاده می‌کند. این امر ادغام با <em>different technology stacks</em> را بسیار ساده می‌کند. <em>Consul</em> همچنین دارای مجموعه‌ای از ابزارها است که به خوبی با آن کار می‌کنند، و این باعث بهبود بیشتر مفید بودن آن می‌شود. یک نمونه <em>consul-template</em> است، که راهی برای به‌روزرسانی فایل‌های متنی بر اساس ورودی‌ها در <em>Consul</em> فراهم می‌کند. در نگاه اول، این خیلی جالب به نظر نمی‌رسد، تا زمانی که واقعیت را در نظر بگیرید که با <em>consul-template</em> اکنون می‌توانید یک مقدار را در <em>Consul</em> تغییر دهید—شاید مکان یک <em>microservice</em>، یا یک مقدار پیکربندی—و فایل‌های پیکربندی را در سراسر سیستم خود به صورت پویا به‌روزرسانی کنید. ناگهان، هر برنامه‌ای که پیکربندی خود را از یک فایل متنی می‌خواند، می‌تواند فایل‌های متنی خود را به صورت پویا به‌روزرسانی کند بدون اینکه نیازی به دانستن چیزی در مورد خود <em>Consul</em> داشته باشد. یک مورد استفاده عالی برای این کار، افزودن یا حذف پویا <em>nodes</em> به یک <em>load balancer pool</em> با استفاده از یک <em>software load balancer</em> مانند <em>HAProxy</em> خواهد بود.</p>
<p>ابزار دیگری که به خوبی با <em>Consul</em> ادغام می‌شود، <em>Vault</em> است، یک ابزار مدیریت <em>secrets</em> که در "<em>Secrets</em>" در صفحه 356 دوباره به آن می‌پردازیم. مدیریت <em>secrets</em> می‌تواند دشوار باشد، اما ترکیب <em>Consul</em> و <em>Vault</em> قطعاً می‌تواند زندگی را آسان‌تر کند.</p>
<h4>etcd and Kubernetes</h4>
<p>اگر شما بر روی پلتفرمی در حال اجرا هستید که بارهای کاری <em>container</em> را برای شما مدیریت می‌کند، احتمالاً در حال حاضر یک مکانیسم <em>service discovery</em> برای شما فراهم شده است. <em>Kubernetes</em> تفاوتی ندارد، و تا حدی از <em>etcd</em>، یک <em>configuration management store</em> بسته‌بندی شده با <em>Kubernetes</em>، می‌آید. <em>etcd</em> دارای قابلیت‌هایی مشابه با <em>Consul</em> است، و <em>Kubernetes</em> از آن برای مدیریت طیف گسترده‌ای از اطلاعات پیکربندی استفاده می‌کند.</p>
<p>ما <em>Kubernetes</em> را با جزئیات بیشتری در "<em>Kubernetes and Container Orchestration</em>" در صفحه 259 بررسی خواهیم کرد، اما به طور خلاصه، نحوه عملکرد <em>service discovery</em> در <em>Kubernetes</em> این است که شما یک <em>container</em> را در یک <em>pod</em> مستقر می‌کنید، و سپس یک <em>service</em> به صورت پویا مشخص می‌کند که کدام <em>pods</em> باید بخشی از یک <em>service</em> باشند با تطبیق الگو در <em>metadata</em> مرتبط با <em>pod</em>. این یک مکانیسم کاملاً زیبا است و می‌تواند بسیار قدرتمند باشد. سپس درخواست‌ها به یک <em>service</em> به یکی از <em>pods</em> که آن <em>service</em> را تشکیل می‌دهند، هدایت می‌شوند.
  <p>قابلیت‌هایی که شما از جعبه با <em>Kubernetes</em> دریافت می‌کنید، ممکن است منجر به این شود که شما فقط بخواهید با آنچه با پلتفرم اصلی ارائه می‌شود کار کنید، و از استفاده از ابزارهای اختصاصی مانند <em>Consul</em> اجتناب کنید، و برای بسیاری از افراد این منطقی است، به خصوص اگر</p>
</p></p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0186</div>
            </div>
        </div>
        <!-- Page 0187 -->
        <div class="chapter" id="page-0187">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>اگر اکوسیستم وسیع‌تری از <em>tooling</em> در اطراف <em>Consul</em> برای شما جالب نیست. با این حال، اگر شما در یک محیط ترکیبی در حال اجرا هستید، جایی که بارهای کاری را در <em>Kubernetes</em> و جاهای دیگر اجرا می‌کنید، داشتن یک ابزار اختصاصی <em>service discovery</em> که بتواند در هر دو پلتفرم استفاده شود، ممکن است راهی باشد که باید بروید.</p>
<h4>Rolling your own</h4>
<p>یک رویکرد که من خودم استفاده کرده‌ام و در جای دیگری نیز استفاده شده است، این است که سیستم خود را راه‌اندازی کنید. در یک پروژه، ما از <em>AWS</em> به شدت استفاده می‌کردیم، که امکان افزودن <em>tags</em> را به نمونه‌ها ارائه می‌دهد. هنگام راه‌اندازی نمونه‌های <em>service</em>، من <em>tags</em> را برای کمک به تعریف اینکه نمونه چه بود و برای چه چیزی استفاده می‌شد، اعمال می‌کردم. این‌ها اجازه می‌دادند که برخی از <em>rich metadata</em> با یک میزبان داده شده مرتبط شود—به عنوان مثال:</p>
<ul>
<li><em>service = accounts</em></li>
<li><em>environment = production</em></li>
<li><em>version = 154</em></li>
</ul>
<p>سپس من از <em>AWS APIs</em> استفاده کردم تا تمام نمونه‌های مرتبط با یک حساب <em>AWS</em> داده شده را <em>query</em> کنم تا بتوانم ماشین‌هایی را که به آن‌ها اهمیت می‌دادم، پیدا کنم. در اینجا، خود <em>AWS</em> در حال مدیریت ذخیره <em>metadata</em> مرتبط با هر نمونه است و به ما این امکان را می‌دهد که آن را <em>query</em> کنیم. سپس من ابزارهای <em>command-line</em> را برای تعامل با این نمونه‌ها ایجاد کردم و <em>graphical interfaces</em> را برای مشاهده وضعیت نمونه در یک نگاه ارائه دادم. اگر بتوانید اطلاعاتی را در مورد <em>service interfaces</em> به‌طور برنامه‌ریزی جمع‌آوری کنید، همه این‌ها به یک کار نسبتاً ساده تبدیل می‌شود.</p>
<p>آخرین باری که این کار را انجام دادم، ما تا آنجا پیش نرفتیم که <em>services</em> از <em>AWS APIs</em> برای یافتن وابستگی‌های <em>service</em> خود استفاده کنند، اما هیچ دلیلی وجود ندارد که شما نتوانید این کار را انجام دهید. بدیهی است، اگر می‌خواهید <em>upstream services</em> هنگامی که مکان یک <em>downstream service</em> تغییر می‌کند، هشدار داده شوند، شما در این زمینه تنها هستید.</p>
<p>امروزه، این مسیری نیست که من می‌روم. محصول <em>tooling</em> در این فضا آنقدر بالغ است که این مورد نه تنها اختراع دوباره چرخ، بلکه بازآفرینی یک چرخ بسیار بدتر خواهد بود.</p>
<h4>Don’t Forget the Humans!</h4>
<p>سیستم‌هایی که تاکنون به آن‌ها نگاه کرده‌ایم، این امکان را برای یک نمونه <em>service</em> فراهم می‌کنند که خود را ثبت کند و <em>services</em> دیگری را که نیاز دارد با آن‌ها صحبت کند، جستجو کند. اما ما به عنوان انسان، گاهی اوقات این اطلاعات را نیز می‌خواهیم. در دسترس قرار دادن اطلاعات به روش‌هایی که به انسان‌ها اجازه می‌دهد از آن استفاده کنند، شاید با استفاده از <em>APIs</em> برای کشیدن این جزئیات به ثبت‌های انسانی (موضوعی که در یک لحظه به آن نگاه خواهیم کرد)، می‌تواند حیاتی باشد.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0187</div>
            </div>
        </div>
        <!-- Page 0188 -->
        <div class="chapter" id="page-0188">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Service Meshes and API Gateways</h4>
<p>تعداد کمی از حوزه‌های فناوری مرتبط با <em>microservices</em> به اندازه <em>service meshes</em> و <em>API gateways</em> مورد توجه، <em>hype</em>، و سردرگمی قرار گرفته‌اند. هر دو جایگاه خود را دارند، اما به طور گیج‌کننده‌ای، آن‌ها همچنین می‌توانند در مسئولیت‌ها همپوشانی داشته باشند. <em>API gateway</em> به ویژه مستعد سوء استفاده (و سوء فروش) است، بنابراین مهم است که ما درک کنیم که چگونه این نوع فناوری می‌تواند در معماری <em>microservice</em> ما جای گیرد.
  <p>به جای تلاش برای ارائه یک دیدگاه دقیق در مورد آنچه می‌توانید با این محصولات انجام دهید، من می‌خواهم یک نمای کلی از جایی که آن‌ها در آن قرار می‌گیرند، نحوه کمک آن‌ها، و برخی از مشکلات اجتناب‌پذیر ارائه دهم.</p>
<p>در اصطلاحات مرکز داده معمولی، ما در مورد ترافیک "شرق-غرب" به عنوان ترافیک داخل یک مرکز داده صحبت می‌کنیم، در حالی که ترافیک "شمال-جنوب" مربوط به تعاملاتی است که از دنیای بیرون وارد یا از مرکز داده خارج می‌شوند. از دیدگاه شبکه‌سازی، آنچه یک مرکز داده است، تا حدودی به یک مفهوم مبهم تبدیل شده است، بنابراین برای اهداف ما، ما به طور کلی‌تر در مورد یک <em>networked perimeter</em> صحبت خواهیم کرد. این می‌تواند مربوط به یک مرکز داده کامل، یک <em>Kubernetes cluster</em>، یا شاید فقط یک مفهوم <em>virtual networking</em> مانند گروهی از دستگاه‌های در حال اجرا در یک <em>virtual LAN</em> یکسان باشد.
  <p>به طور کلی، یک <em>API gateway</em> در <em>perimeter</em> سیستم شما قرار دارد و با ترافیک شمال-جنوب سروکار دارد. نگرانی‌های اصلی آن مدیریت دسترسی از دنیای بیرون به <em>microservices</em> داخلی شما است. از طرف دیگر، یک <em>service mesh</em> بسیار محدود به ارتباط بین <em>microservices</em> در داخل <em>perimeter</em> شما می‌پردازد—ترافیک شرق-غرب—همانطور که شکل 5-6 نشان می‌دهد.</p>
<p>شکل 5-6. مروری بر جایی که <em>API gateways</em> و <em>service meshes</em> استفاده می‌شوند</p>
</p></p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 188" src="page_0188/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0188</div>
            </div>
        </div>
        <!-- Page 0189 -->
        <div class="chapter" id="page-0189">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>Service meshes</em> و <em>API gateways</em> به طور بالقوه می‌توانند به <em>microservices</em> اجازه دهند که کد را به اشتراک بگذارند بدون اینکه نیازی به ایجاد <em>client libraries</em> جدید یا <em>microservices</em> جدید داشته باشند. به زبان ساده (بسیار)، <em>service meshes</em> و <em>API gateways</em> می‌توانند به عنوان <em>proxies</em> بین <em>microservices</em> عمل کنند. این می‌تواند به این معنی باشد که آن‌ها ممکن است برای پیاده‌سازی برخی از رفتار‌های <em>microservice-agnostic</em> که در غیر این صورت باید در کد انجام می‌شد، مانند <em>service discovery</em> یا <em>logging</em>، استفاده شوند.
  <p>اگر شما از یک <em>API gateway</em> یا یک <em>service mesh</em> برای پیاده‌سازی رفتار مشترک و رایج برای <em>microservices</em> خود استفاده می‌کنید، ضروری است که این رفتار کاملاً عمومی باشد—به عبارت دیگر، اینکه رفتار در <em>proxy</em> هیچ ارتباطی با هیچ رفتار خاصی از یک <em>microservice</em> جداگانه نداشته باشد.
  <p>اکنون، پس از توضیح این، من همچنین باید توضیح دهم که جهان همیشه به این روشنی نیست. تعدادی از <em>API gateways</em> سعی می‌کنند قابلیت‌هایی را برای ترافیک شرق-غرب نیز ارائه دهند، اما این چیزی است که ما به زودی در مورد آن بحث خواهیم کرد. اول، بیایید به <em>API gateways</em> و انواع چیزهایی که می‌توانند انجام دهند، نگاهی بیندازیم.</p>
<h4>API Gateways</h4>
<p>با تمرکز بیشتر بر روی ترافیک شمال-جنوب، نگرانی اصلی <em>API gateway</em> در یک محیط <em>microservices</em>، نگاشت درخواست‌ها از طرف‌های خارجی به <em>microservices</em> داخلی است. این مسئولیت شبیه به چیزی است که شما می‌توانید با یک <em>HTTP proxy</em> ساده به آن برسید، و در واقع <em>API gateways</em> معمولاً ویژگی‌های بیشتری را بر روی محصولات <em>HTTP proxy</em> موجود ایجاد می‌کنند، و آن‌ها تا حد زیادی به عنوان <em>reverse proxies</em> عمل می‌کنند. علاوه بر این، <em>API gateways</em> می‌توانند برای پیاده‌سازی مکانیسم‌هایی مانند <em>API keys</em> برای طرف‌های خارجی، <em>logging</em>، <em>rate limiting</em> و موارد مشابه استفاده شوند. برخی از محصولات <em>API gateway</em>، پورتال‌های توسعه‌دهنده را نیز ارائه می‌دهند، که اغلب مخاطب مصرف‌کنندگان خارجی هستند.
  <p>بخشی از سردرگمی در مورد <em>API gateway</em> مربوط به تاریخچه است. مدتی پیش، مقدار زیادی علاقه به چیزی وجود داشت که به آن "اقتصاد <em>API</em>" می‌گفتند. صنعت شروع به درک قدرت ارائه <em>APIs</em> به راه‌حل‌های مدیریت شده کرده بود، از محصولات <em>SaaS</em> مانند <em>Salesforce</em> تا پلتفرم‌هایی مانند <em>AWS</em>، زیرا مشخص بود که یک <em>API</em> به مشتریان انعطاف‌پذیری بیشتری در نحوه استفاده از نرم‌افزارشان می‌دهد. این امر باعث شد که تعدادی از افراد شروع به بررسی نرم‌افزارهایی کنند که قبلاً داشتند و مزایای قرار دادن آن عملکرد در معرض دید مشتریان خود، نه فقط از طریق یک <em>GUI</em>، بلکه از طریق یک <em>API</em> را در نظر بگیرند. امید این بود که این امر فرصت‌های بزرگ‌تر بازار را باز کند، و خوب، پول بیشتری به دست آورد. در میان این علاقه، تعدادی از محصولات <em>API gateway</em> پدیدار شدند تا به تحقق این اهداف کمک کنند. مجموعه ویژگی‌های آن‌ها به شدت به مدیریت <em>API keys</em> برای اشخاص ثالث، اعمال محدودیت‌های نرخ، و ردیابی استفاده برای مقاصد <em>charge-back</em> متمایل بود. واقعیت این است که در حالی که <em>APIs</em> قطعاً به عنوان یک راه عالی برای ارائه <em>services</em> به برخی از مشتریان نشان داده شده‌اند، اندازه اقتصاد <em>API</em> به اندازه آنچه برخی امیدوار بودند بزرگ نبود، و بسیاری از شرکت‌ها دریافتند که محصولات <em>API gateway</em> را خریداری کرده‌اند که مملو از ویژگی‌هایی است که هرگز واقعاً به آن‌ها نیاز نداشتند.</p>
</p></p></p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0189</div>
            </div>
        </div>
        <!-- Page 0190 -->
        <div class="chapter" id="page-0190">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>بسیاری از اوقات، تنها چیزی که یک <em>API gateway</em> در واقع برای آن استفاده می‌شود، مدیریت دسترسی به <em>microservices</em> یک سازمان از <em>GUI clients</em> خود (صفحات وب، برنامه‌های <em>native mobile</em>) از طریق اینترنت عمومی است. در اینجا هیچ "<em>third party</em>"ای در این ترکیب وجود ندارد. نیاز به نوعی <em>API gateway</em> برای <em>Kubernetes</em> ضروری است، زیرا <em>Kubernetes</em> بومی فقط شبکه را در داخل <em>cluster</em> مدیریت می‌کند و هیچ کاری در مورد مدیریت ارتباط با و از خود <em>cluster</em> انجام نمی‌دهد. اما در چنین موردی استفاده، یک <em>API gateway</em> که برای دسترسی خارجی <em>third-party</em> طراحی شده است، بسیار زیاد است.</p>
<p>بنابراین اگر شما یک <em>API gateway</em> می‌خواهید، در مورد آنچه از آن انتظار دارید، واقعاً واضح باشید. در واقع، من کمی فراتر خواهم رفت و می‌گویم که شما احتمالاً باید از داشتن یک <em>API gateway</em> که بیش از حد انجام می‌دهد، اجتناب کنید. اما به این موضوع در ادامه خواهیم پرداخت.</p>
<h4>Where to use them</h4>
<p>هنگامی که شما شروع به درک این می‌کنید که چه نوع موارد استفاده‌ای دارید، دیدن اینکه به چه نوع <em>gateway</em> نیاز دارید، کمی آسان‌تر می‌شود. اگر فقط یک مورد از قرار دادن <em>microservices</em> در <em>Kubernetes</em> است، می‌توانید <em>reverse proxies</em> خود را اجرا کنید—یا بهتر از آن، می‌توانید به یک محصول متمرکز مانند <em>Ambassador</em> نگاه کنید، که از ابتدا با آن مورد استفاده در نظر گرفته شده است. اگر واقعاً متوجه شدید که نیاز به مدیریت تعداد زیادی از کاربران <em>third-party</em> دارید که به <em>API</em> شما دسترسی دارند، احتمالاً محصولات دیگری نیز وجود دارد که باید به آن‌ها نگاه کنید. در واقع، این امکان وجود دارد که شما ممکن است در نهایت بیش از یک <em>gateway</em> در این ترکیب داشته باشید تا جداسازی بهتر <em>concerns</em> را مدیریت کنید، و من می‌توانم ببینم که این در بسیاری از موقعیت‌ها منطقی است، اگرچه هشدار‌های معمول در مورد افزایش پیچیدگی کلی سیستم و افزایش <em>network hops</em> همچنان اعمال می‌شود.</p>
<p>من گاهی درگیر کار مستقیم با فروشندگان برای کمک به انتخاب ابزار بوده‌ام. من می‌توانم بدون هیچ تردیدی بگویم که در فضای <em>API gateway</em>، سوء فروش و رفتار ضعیف یا بی‌رحمانه‌ای را بیشتر از هر جای دیگری تجربه کرده‌ام—و در نتیجه شما ارجاعاتی به برخی از محصولات فروشنده در این فصل پیدا نخواهید کرد. من بیشتر این را به شرکت‌های تحت حمایت <em>VC</em> نسبت داده‌ام که محصولی را برای دوران رونق اقتصاد <em>API</em> ساخته‌اند، فقط برای اینکه متوجه شوند که آن بازار وجود ندارد، و بنابراین آن‌ها در دو جبهه می‌جنگند: آن‌ها بر سر تعداد کمی از کاربرانی که واقعاً به آنچه <em>gateways</em> پیچیده‌تر ارائه می‌دهند، نیاز دارند، می‌جنگند، در حالی که همچنین تجارت خود را به محصولات <em>API gateway</em> متمرکزتر که برای اکثریت قریب به اتفاق نیازهای ساده‌تر ساخته شده‌اند، از دست می‌دهند.</p>
<h4>What to avoid</h4>
<p>تا حدی به دلیل ناامیدی آشکار برخی از فروشندگان <em>API gateway</em>، انواع ادعاها برای آنچه این محصولات می‌توانند انجام دهند، مطرح شده است. این امر منجر به سوء استفاده‌های زیادی از این محصولات شده است، و به نوبه خود به بی‌اعتمادی تأسف‌بار از آنچه که اساساً یک مفهوم کاملاً ساده است، منجر شده است. دو نمونه کلیدی که من از سوء استفاده از <em>API gateways</em> دیده‌ام، برای تجمیع <em>call</em> و بازنویسی <em>protocol</em> است، اما من همچنین فشار بیشتری برای استفاده از <em>API gateways</em> برای تماس‌های درون <em>perimeter</em> (شرق-غرب) نیز دیده‌ام.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0190</div>
            </div>
        </div>
        <!-- Page 0191 -->
        <div class="chapter" id="page-0191">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>در این فصل ما قبلاً به طور خلاصه به مفید بودن یک <em>protocol</em> مانند <em>GraphQL</em> در کمک به ما در موقعیتی که نیاز به برقراری تعدادی <em>calls</em> داریم و سپس نتایج را تجمیع و فیلتر می‌کنیم، نگاه کرده‌ایم، اما مردم اغلب وسوسه می‌شوند که این مشکل را در لایه‌های <em>API gateway</em> نیز حل کنند. این به اندازه کافی بی‌ضرر شروع می‌شود: شما چند <em>calls</em> را ترکیب می‌کنید و یک <em>payload</em> واحد را برمی‌گردانید. سپس شما شروع به برقراری یک <em>downstream call</em> دیگر به عنوان بخشی از همان جریان تجمیع شده می‌کنید. سپس شما می‌خواهید منطق شرطی را اضافه کنید، و قبل از آنکه متوجه شوید، فرآیندهای کسب‌وکار اصلی را به یک ابزار <em>third-party</em> که برای این کار مناسب نیست، منتقل کرده‌اید.</p>
<p>اگر شما متوجه شدید که نیاز به انجام <em>call aggregation</em> و <em>filtering</em> دارید، پس به پتانسیل <em>GraphQL</em> یا الگوی <em>BFF</em> نگاه کنید، که ما در فصل 14 به آن خواهیم پرداخت. اگر <em>call aggregation</em> که شما انجام می‌دهید، اساساً یک فرآیند تجاری است، پس این بهتر است از طریق یک <em>saga</em> صریحاً مدل‌سازی شده انجام شود، که ما در فصل 6 به آن خواهیم پرداخت.</p>
<p>جدا از زاویه تجمیع، بازنویسی <em>protocol</em> نیز اغلب به عنوان چیزی که <em>API gateways</em> باید برای آن استفاده شوند، مطرح می‌شود. من به یاد دارم که یک فروشنده بی‌نام، بسیار تهاجمی ایده این را ترویج می‌داد که محصول آن می‌تواند "هر <em>SOAP API</em> را به یک <em>REST API</em> تبدیل کند." اولاً، <em>REST</em> یک <em>mindset</em> معماری کامل است که نمی‌تواند به سادگی در یک لایه <em>proxy</em> پیاده‌سازی شود. ثانیاً، بازنویسی <em>protocol</em>، که اساساً همان چیزی است که این در تلاش برای انجام آن است، نباید در لایه‌های میانی انجام شود، زیرا این کار رفتار بیش از حد را به مکان اشتباهی منتقل می‌کند.</p>
<p>مشکل اصلی هر دو قابلیت بازنویسی <em>protocol</em> و پیاده‌سازی <em>call aggregation</em> در داخل <em>API gateways</em> این است که ما در حال نقض قانون <em>keeping the pipes dumb, and the endpoints smart</em> هستیم. "<em>smarts</em>" در سیستم ما می‌خواهد در کد ما زندگی کند، جایی که می‌توانیم کنترل کاملی بر آن‌ها داشته باشیم. <em>API gateway</em> در این مثال یک <em>pipe</em> است—ما می‌خواهیم آن را تا حد امکان ساده نگه داریم. با <em>microservices</em>، ما به دنبال مدلی هستیم که در آن تغییرات می‌توانند ایجاد شوند و به راحتی از طریق <em>independent deployability</em> منتشر شوند. نگه داشتن <em>smarts</em> در <em>microservices</em> ما به این امر کمک می‌کند. اگر ما اکنون همچنین مجبور به ایجاد تغییرات در لایه‌های میانی هستیم، اوضاع مشکل‌سازتر می‌شود.
  <p>با توجه به اهمیت <em>API gateways</em>، تغییرات در آن‌ها اغلب به شدت کنترل می‌شوند. به نظر می‌رسد که به تیم‌های جداگانه، اختیار خود-سرویس برای تغییر این <em>services</em> که اغلب به‌طور مرکزی مدیریت می‌شوند، داده نمی‌شود. این به چه معناست؟ <em>Tickets</em>. برای راه‌اندازی یک تغییر در نرم‌افزار خود، شما در نهایت تیم <em>API gateway</em> را وادار می‌کنید که تغییراتی را برای شما ایجاد کند. هرچه رفتار بیشتری را به <em>API gateways</em> (یا به <em>enterprise service buses</em>) نفوذ دهید، بیشتر در معرض خطر <em>handoffs</em>، افزایش هماهنگی، و کاهش سرعت تحویل قرار می‌گیرید.</p>
<p>آخرین مسئله، استفاده از یک <em>API gateway</em> به عنوان یک واسطه برای همه <em>inter-microservice calls</em> است. این می‌تواند بسیار مشکل‌ساز باشد. اگر ما یک <em>API gateway</em> یا یک <em>network proxy</em> معمولی را بین دو <em>microservices</em> قرار دهیم، در این صورت ما به‌طور معمول حداقل یک <em>network hop</em> اضافه کرده‌ایم. یک <em>call</em> از <em>microservice A</em> به <em>microservice B</em> ابتدا از <em>A</em> به <em>API gateway</em> و سپس از <em>API gateway</em> به <em>B</em> می‌رود. ما باید تأثیر تأخیر <em>network call</em> اضافی و <em>overhead</em> هر چه</p>
</p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0191</div>
            </div>
        </div>
        <!-- Page 0192 -->
        <div class="chapter" id="page-0192">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>proxy</em> در حال انجام است. <em>Service meshes</em>، که در ادامه به بررسی آن‌ها می‌پردازیم، در حل این مشکل بسیار بهتر هستند.</p>
<h4>Service Meshes</h4>
<p>با یک <em>service mesh</em>، عملکرد مشترک مرتبط با ارتباطات بین <em>microservice</em>، وارد <em>mesh</em> می‌شود. این امر باعث کاهش عملکردی می‌شود که یک <em>microservice</em> باید به صورت داخلی پیاده‌سازی کند، در حالی که همچنین ثبات را در نحوه انجام کارهای خاص ارائه می‌دهد.</p>
<p>ویژگی‌های رایج پیاده‌سازی شده توسط <em>service meshes</em> شامل <em>mutual TLS</em>، <em>correlation IDs</em>، <em>service discovery</em> و <em>load balancing</em> و موارد دیگر است. اغلب این نوع عملکرد از یک <em>microservice</em> به <em>microservice</em> بعدی نسبتاً عمومی است، بنابراین ما در نهایت از یک <em>shared library</em> برای مدیریت آن استفاده می‌کنیم. اما سپس شما باید با این موضوع مقابله کنید که اگر <em>microservices</em> مختلف نسخه‌های متفاوتی از <em>libraries</em> را اجرا کنند، یا اگر <em>microservices</em> شما در <em>runtimes</em> مختلف نوشته شده‌اند، چه اتفاقی می‌افتد.</p>
<p>حداقل از نظر تاریخی، <em>Netflix</em> دستور می‌داد که همه ارتباطات شبکه غیرمحلی باید <em>JVM to JVM</em> انجام شود. این برای اطمینان از این بود که <em>common libraries</em> که امتحان شده و آزمایش شده‌اند و بخش حیاتی از مدیریت ارتباطات مؤثر بین <em>microservices</em> هستند، می‌توانند دوباره مورد استفاده قرار گیرند. با این حال، با استفاده از یک <em>service mesh</em>، ما این امکان را داریم که از عملکرد مشترک بین <em>microservice</em> در <em>microservices</em> نوشته شده در زبان‌های برنامه‌نویسی مختلف، استفاده مجدد کنیم. <em>Service meshes</em> همچنین می‌توانند در پیاده‌سازی رفتار استاندارد در سراسر <em>microservices</em> ایجاد شده توسط تیم‌های مختلف، بسیار مفید باشند—و استفاده از یک <em>service mesh</em>، به‌ویژه در <em>Kubernetes</em>، به طور فزاینده‌ای به بخشی فرض شده از هر پلتفرمی که ممکن است برای استقرار و مدیریت خودکار <em>microservices</em> ایجاد کنید، تبدیل شده است.</p>
<p>آسان کردن پیاده‌سازی رفتار مشترک در سراسر <em>microservices</em> یکی از مزایای بزرگ یک <em>service mesh</em> است. اگر این عملکرد مشترک فقط از طریق <em>shared libraries</em> پیاده‌سازی می‌شد، تغییر این رفتار مستلزم این بود که هر <em>microservice</em> یک نسخه جدید از <em>libraries</em> گفته شده را دریافت کند و قبل از اینکه آن تغییر فعال شود، مستقر شود. با یک <em>service mesh</em>، شما در مورد راه‌اندازی تغییرات در ارتباط بین <em>microservice</em>، انعطاف‌پذیری بیشتری دارید، بدون اینکه نیازی به بازسازی و <em>redeploy</em> داشته باشید.</p>
<h4>How they work</h4>
<p>به طور کلی، ما انتظار داریم که ترافیک شمال-جنوب کمتری نسبت به ترافیک شرق-غرب با معماری <em>microservice</em> داشته باشیم. یک <em>north-south call</em> واحد—به عنوان مثال، ثبت سفارش—می‌تواند منجر به چندین <em>east-west calls</em> شود. این بدان معناست که هنگام در نظر گرفتن هر نوع <em>proxy</em> برای <em>in-perimeter calls</em>، ما باید از سربار این <em>additional calls</em> آگاه باشیم، و این یک ملاحظه اصلی از نظر نحوه ساخت <em>service meshes</em> است.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0192</div>
            </div>
        </div>
        <!-- Page 0193 -->
        <div class="chapter" id="page-0193">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>Service meshes</em> در اشکال و اندازه‌های مختلفی وجود دارند، اما آنچه آن‌ها را متحد می‌کند این است که معماری آن‌ها بر اساس تلاش برای محدود کردن تأثیر ناشی از <em>calls</em> به و از <em>proxy</em> است. این امر در درجه اول با توزیع فرآیندهای <em>proxy</em> برای اجرا بر روی همان دستگاه‌های فیزیکی به‌عنوان نمونه‌های <em>microservice</em>، برای اطمینان از محدود بودن تعداد <em>remote network calls</em>، به دست می‌آید. در شکل 5-7 ما این را در عمل می‌بینیم—<em>Order Processor</em> یک <em>request</em> را به <em>Payment microservice</em> ارسال می‌کند. این <em>call</em> ابتدا به صورت محلی به یک نمونه <em>proxy</em> که روی همان دستگاه <em>Order Processor</em> اجرا می‌شود، هدایت می‌شود، قبل از اینکه از طریق نمونه <em>proxy</em> محلی خود به <em>Payment microservice</em> ادامه یابد. <em>Order Processor</em> فکر می‌کند که در حال برقراری یک <em>network call</em> معمولی است، بدون اینکه بداند که این <em>call</em> به صورت محلی روی دستگاه هدایت می‌شود، که به طور قابل توجهی سریع‌تر است (و همچنین مستعد <em>partitions</em> کمتری است).
  <p>شکل 5-7. یک <em>service mesh</em> برای رسیدگی به تمام ارتباطات مستقیم بین <em>microservice</em> مستقر شده است</p>
<p>یک <em>control plane</em> در بالای <em>local mesh proxies</em> قرار می‌گیرد، و هم به عنوان مکانی که در آن رفتار این <em>proxies</em> می‌تواند تغییر کند و هم مکانی که در آن می‌توانید اطلاعاتی در مورد آنچه که <em>proxies</em> در حال انجام هستند جمع‌آوری کنید، عمل می‌کند.
  <p>هنگام استقرار در <em>Kubernetes</em>، شما هر نمونه <em>microservice</em> را در یک <em>pod</em> با <em>proxy</em> محلی خود مستقر می‌کنید. یک <em>pod</em> واحد همیشه به عنوان یک واحد واحد مستقر می‌شود، بنابراین شما همیشه می‌دانید که یک <em>proxy</em> در دسترس دارید. علاوه بر این، از بین رفتن یک <em>proxy</em> واحد فقط بر روی آن یک <em>pod</em> تأثیر می‌گذارد. این تنظیم همچنین به شما امکان می‌دهد هر <em>proxy</em> را برای اهداف مختلف متفاوت پیکربندی کنید. ما این مفاهیم را با جزئیات بیشتری در "<em>Kubernetes and Container Orchestration</em>" در صفحه 259 بررسی خواهیم کرد.</p>
<p>بسیاری از پیاده‌سازی‌های <em>service mesh</em> از <em>Envoy proxy</em> برای اساس این فرآیندهای در حال اجرا محلی استفاده می‌کنند. <em>Envoy</em> یک <em>proxy</em> سبک وزن <em>C++</em> است که اغلب به عنوان</p>
</p></p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 193" src="page_0193/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0193</div>
            </div>
        </div>
        <!-- Page 0194 -->
        <div class="chapter" id="page-0194">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>building block</em> برای <em>service meshes</em> و سایر انواع نرم‌افزارهای مبتنی بر <em>proxy</em> است—به عنوان مثال، این یک <em>building block</em> مهم برای <em>Istio</em> و <em>Ambassador</em> است.</p>
<p>این <em>proxies</em> به نوبه خود توسط یک <em>control plane</em> مدیریت می‌شوند. این مجموعه‌ای از نرم‌افزار خواهد بود که به شما کمک می‌کند ببینید چه اتفاقی می‌افتد و آنچه را که در حال انجام است، کنترل کنید. به عنوان مثال، هنگام استفاده از یک <em>service mesh</em> برای پیاده‌سازی <em>mutual TLS</em>، از <em>control plane</em> برای توزیع گواهی‌های <em>client</em> و <em>server</em> استفاده می‌شود.</p>
<h4>Aren’t service meshes smart pipes?</h4>
<p>بنابراین همه این صحبت‌ها در مورد قرار دادن رفتار مشترک در یک <em>service mesh</em> ممکن است زنگ‌های هشدار را برای برخی از شما به صدا درآورد. آیا این رویکرد در معرض همان نوع مشکلات <em>enterprise service buses</em> یا <em>overly bloated API gateways</em> نیست؟ آیا ما در معرض خطر قرار دادن بیش از حد "<em>smarts</em>" در <em>service mesh</em> خود نیستیم؟</p>
<p>نکته اصلی که در اینجا باید به خاطر داشت این است که رفتار مشترکی که ما در حال قرار دادن آن در <em>mesh</em> هستیم، مختص هیچ <em>microservice</em> واحدی نیست. هیچ عملکرد تجاری به بیرون نشت نکرده است. ما در حال پیکربندی چیزهای عمومی مانند نحوه رسیدگی به <em>request time-outs</em> هستیم.
  <p>از نظر رفتار مشترکی که ممکن است بخواهید به ازای هر <em>microservice</em> تنظیم کنید، این معمولاً چیزی است که به خوبی برآورده می‌شود، بدون نیاز به انجام کار روی یک پلتفرم مرکزی. به عنوان مثال، با <em>Istio</em>، من می‌توانم الزامات <em>time-out</em> خود را به صورت خودکار فقط با تغییر تعریف <em>service</em> خود تعریف کنم.</p>
<h4>Do you need one?</h4>
<p>هنگامی که استفاده از <em>service meshes</em> برای اولین بار شروع به محبوب شدن کرد، درست پس از انتشار نسخه اول این کتاب، من مزایای زیادی را در این ایده دیدم اما همچنین آشفتگی زیادی را در این فضا دیدم. مدل‌های استقرار مختلف پیشنهاد، ساخته و سپس کنار گذاشته شدند، و تعداد شرکت‌هایی که راه‌حل‌هایی را در این فضا ارائه می‌کردند به طور چشمگیری افزایش یافت؛ اما حتی برای آن ابزارهایی که مدت‌ها بود وجود داشتند، کمبود ظاهری ثبات وجود داشت. <em>Linkerd</em>، که مسلماً به اندازه هر کس دیگری در پیشگامی این فضا تلاش کرد، محصول خود را از ابتدا در انتقال از نسخه 1 به نسخه 2 کاملاً بازسازی کرد. <em>Istio</em>، که <em>service mesh</em> مورد تأیید <em>Google</em> بود، سال‌ها طول کشید تا به نسخه اولیه 1.0 برسد، و حتی با این وجود تغییرات قابل توجهی در معماری خود داشت (تا حدودی طعنه‌آمیز، اگرچه منطقی، به یک مدل استقرار <em>monolithic</em> بیشتر برای <em>control plane</em> خود حرکت کرد).</p>
<p>در بیشتر پنج سال گذشته، وقتی از من پرسیده می‌شد "آیا باید یک <em>service mesh</em> تهیه کنیم؟" توصیه من این بود: "اگر می‌توانید شش ماه صبر کنید قبل از اینکه تصمیمی بگیرید، پس شش ماه صبر کنید." من به این ایده فروخته شدم اما نگران ثبات بودم. و چیزی مانند یک <em>service mesh</em> جایی نیست که من شخصاً بخواهم ریسک زیادی کنم—برای اینکه همه چیز به خوبی کار کند، بسیار کلیدی و ضروری است. شما آن را در مسیر بحرانی خود قرار می‌دهید. از نظر اینکه چقدر آن را جدی می‌گیرم، با انتخاب یک <em>message broker</em> یا <em>cloud provider</em> برابری می‌کند.</p>
</p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0194</div>
            </div>
        </div>
        <!-- Page 0195 -->
        <div class="chapter" id="page-0195">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>از آن زمان، خوشحالم که بگویم، این فضا بالغ شده است. آشفتگی تا حدودی کاهش یافته است، اما ما همچنان دارای یک جمع (سالم) از فروشندگان هستیم. با این حال، <em>service meshes</em> برای همه مناسب نیستند. اولاً، اگر شما در <em>Kubernetes</em> نیستید، گزینه‌های شما محدود است. ثانیاً، آن‌ها پیچیدگی را اضافه می‌کنند. اگر شما پنج <em>microservices</em> دارید، من فکر نمی‌کنم شما بتوانید به راحتی یک <em>service mesh</em> را توجیه کنید (این قابل بحث است که آیا شما می‌توانید <em>Kubernetes</em> را توجیه کنید اگر فقط پنج <em>microservices</em> داشته باشید!). برای سازمان‌هایی که <em>microservices</em> بیشتری دارند، به خصوص اگر آن‌ها می‌خواهند این گزینه را داشته باشند که آن <em>microservices</em> در زبان‌های برنامه‌نویسی مختلف نوشته شوند، <em>service meshes</em> ارزش دیدن را دارند. با این حال، تحقیقات خود را انجام دهید—جابجایی بین <em>service meshes</em> دردناک است!</p>
<p><em>Monzo</em> سازمانی است که به صراحت در مورد اینکه چگونه استفاده از یک <em>service mesh</em> برای آن‌ها ضروری بود تا اجازه دهند معماری خود را در مقیاسی که انجام می‌دهد، اجرا کنند، صحبت کرده است. استفاده از نسخه 1 <em>Linkerd</em> برای کمک به مدیریت <em>inter-microservice RPC calls</em>، بسیار مفید بود. جالب اینجاست که <em>Monzo</em> مجبور شد درد یک <em>service mesh migration</em> را تحمل کند تا به آن‌ها در دستیابی به مقیاسی که نیاز داشتند، کمک کند، زمانی که معماری قدیمی‌تر <em>Linkerd v1</em> دیگر الزامات آن‌ها را برآورده نمی‌کرد. در پایان، آن‌ها به‌طور مؤثر به یک <em>service mesh in-house</em> که از <em>Envoy proxy</em> استفاده می‌کرد، منتقل شدند.</p>
<h4>What About Other Protocols?</h4>
<p><em>API gateways</em> و <em>service meshes</em> عمدتاً برای رسیدگی به <em>HTTP-related calls</em> استفاده می‌شوند. بنابراین <em>REST</em>، <em>SOAP</em>، <em>gRPC</em>، و موارد مشابه را می‌توان از طریق این محصولات مدیریت کرد. با این حال، وقتی شروع به نگاه کردن به ارتباط از طریق <em>protocols</em> دیگر می‌کنید، مانند استفاده از <em>message brokers</em> مانند <em>Kafka</em>، اوضاع کمی مبهم‌تر می‌شود. به طور معمول، در این مرحله <em>service mesh</em> دور زده می‌شود—ارتباط مستقیماً با خود <em>broker</em> انجام می‌شود. این بدان معناست که شما نمی‌توانید فرض کنید که <em>service mesh</em> شما قادر به کار به عنوان یک واسطه برای همه <em>calls</em> بین <em>microservices</em> است.</p>
<h4>Documenting Services</h4>
<p>با تجزیه سیستم‌های خود به <em>microservices</em> ریزدانه، ما امیدواریم که درزهای زیادی را به شکل <em>APIs</em> در معرض نمایش قرار دهیم که مردم می‌توانند از آن‌ها برای انجام کارهای بسیار خوب استفاده کنند. اگر کشف ما درست باشد، ما می‌دانیم که چیزها کجا هستند. اما چگونه می‌دانیم که آن چیزها چه می‌کنند یا چگونه از آن‌ها استفاده کنیم؟ یک گزینه، بدیهی است، داشتن <em>documentation</em> در مورد <em>APIs</em> است. البته، <em>documentation</em> اغلب می‌تواند منسوخ شود. در حالت ایده‌آل، ما اطمینان حاصل می‌کنیم که <em>documentation</em> ما همیشه با <em>microservice API</em> به‌روز است و دیدن این <em>documentation</em> را زمانی که می‌دانیم یک <em>service endpoint</em> کجاست، آسان می‌کنیم.</p>
<h4>Explicit Schemas</h4>
<p>داشتن <em>explicit schemas</em> راه زیادی را به سمت آسان‌تر کردن درک آنچه هر <em>endpoint</em> داده شده در معرض نمایش قرار می‌دهد، طی می‌کند، اما به خودی خود اغلب کافی نیستند. همانطور که قبلاً بحث کردیم، <em>schemas</em> به نشان دادن ساختار کمک می‌کنند، اما آن‌ها خیلی دور نمی‌روند</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0195</div>
            </div>
        </div>
        <!-- Page 0196 -->
        <div class="chapter" id="page-0196">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>در کمک به برقراری ارتباط رفتار یک <em>endpoint</em>، بنابراین <em>good documentation</em> همچنان می‌تواند برای کمک به مصرف‌کنندگان در درک نحوه استفاده از یک <em>endpoint</em> مورد نیاز باشد. البته، شایان ذکر است که اگر شما تصمیم بگیرید از یک <em>explicit schema</em> استفاده نکنید، <em>documentation</em> شما در نهایت کار بیشتری انجام خواهد داد. شما باید توضیح دهید که <em>endpoint</em> چه کاری انجام می‌دهد و همچنین ساختار و جزئیات <em>interface</em> را مستند کنید. علاوه بر این، بدون یک <em>explicit schema</em>، تشخیص اینکه آیا <em>documentation</em> شما با <em>real endpoints</em> به‌روز است یا خیر، دشوارتر است. <em>Stale documentation</em> یک مشکل مداوم است، اما حداقل یک <em>explicit schema</em> به شما شانس بیشتری برای به‌روز بودن می‌دهد.</p>
<p>من قبلاً <em>OpenAPI</em> را به عنوان یک <em>schema format</em> معرفی کرده‌ام، اما همچنین در ارائه <em>documentation</em> بسیار مؤثر است، و بسیاری از ابزارهای منبع باز و تجاری اکنون وجود دارند که می‌توانند از توصیف‌گرهای <em>OpenAPI</em> پشتیبانی کنند تا به ایجاد پورتال‌های مفیدی کمک کنند که به توسعه‌دهندگان اجازه می‌دهد <em>documentation</em> را بخوانند. شایان ذکر است که پورتال‌های منبع باز برای مشاهده <em>OpenAPI</em> تا حدودی اساسی به نظر می‌رسند—به عنوان مثال، من در یافتن موردی که از قابلیت جستجو پشتیبانی می‌کرد، مشکل داشتم. برای کسانی که در <em>Kubernetes</em> هستند، پورتال توسعه‌دهنده <em>Ambassador</em> به ویژه جالب است. <em>Ambassador</em> در حال حاضر یک انتخاب محبوب به عنوان یک <em>API gateway</em> برای <em>Kubernetes</em> است، و پورتال توسعه‌دهنده آن توانایی <em>autodiscover</em> <em>OpenAPI endpoints</em> موجود را دارد. ایده استقرار یک <em>microservice</em> جدید و در دسترس قرار دادن خودکار <em>documentation</em> آن، بسیار برای من جذاب است.</p>
<p>در گذشته ما از پشتیبانی خوب برای مستندسازی <em>event-based interfaces</em> برخوردار نبودیم. اکنون حداقل ما گزینه‌هایی داریم. <em>AsyncAPI format</em> به عنوان اقتباسی از <em>OpenAPI</em> شروع به کار کرد، و ما اکنون <em>CloudEvents</em> را نیز داریم، که یک پروژه <em>CNCF</em> است. من از هیچ‌کدام از آن‌ها به درستی استفاده نکرده‌ام (یعنی در یک محیط واقعی)، اما من بیشتر به <em>CloudEvents</em> جذب شده‌ام، صرفاً به این دلیل که به نظر می‌رسد به‌دلیل ارتباط آن با <em>CNCF</em>، دارای یک ثروت از یکپارچه‌سازی و پشتیبانی است. حداقل از نظر تاریخی، به نظر می‌رسید که <em>CloudEvents</em> از نظر <em>event format</em> در مقایسه با <em>AsyncAPI</em> محدودتر است، و فقط <em>JSON</em> به درستی پشتیبانی می‌شد، تا اینکه اخیراً پشتیبانی از <em>protocol buffer</em> پس از حذف قبلی دوباره معرفی شد؛ بنابراین این ممکن است یک نکته باشد.</p>
<h4>The Self-Describing System</h4>
<p>در طول تکامل اولیه <em>SOA</em>، استانداردهایی مانند <em>Universal Description, Discovery, and Integration (UDDI)</em> پدیدار شدند تا به ما در درک اینکه چه <em>services</em> در حال اجرا هستند، کمک کنند. این رویکردها نسبتاً سنگین بودند، که منجر به تکنیک‌های جایگزینی شد تا سعی شود سیستم‌های ما را درک کنند. <em>Martin Fowler</em> در مورد مفهوم <em>humane registry</em> بحث کرده است، یک رویکرد بسیار سبک‌تر که در آن انسان‌ها می‌توانند اطلاعاتی را در مورد <em>services</em> در سازمان در چیزی به سادگی یک <em>wiki</em> ثبت کنند.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0196</div>
            </div>
        </div>
        <!-- Page 0197 -->
        <div class="chapter" id="page-0197">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>به دست آوردن تصویری از سیستم ما و نحوه رفتار آن مهم است، به خصوص زمانی که ما در مقیاس هستیم. ما تعدادی از تکنیک‌های مختلف را پوشش داده‌ایم که به ما کمک می‌کنند تا درک مستقیمی از سیستم خود به دست آوریم. با ردیابی سلامت <em>services</em> بالادستی خود، همراه با <em>correlation IDs</em> برای کمک به ما در دیدن زنجیره‌های <em>call</em>، می‌توانیم داده‌های واقعی را از نظر نحوه ارتباط <em>services</em> خود به دست آوریم. با استفاده از سیستم‌های <em>service discovery</em> مانند <em>Consul</em>، ما می‌توانیم ببینیم که <em>microservices</em> ما کجا در حال اجرا هستند. مکانیسم‌هایی مانند <em>OpenAPI</em> و <em>CloudEvents</em> می‌توانند به ما کمک کنند تا ببینیم چه قابلیت‌هایی در هر <em>endpoint</em> داده شده میزبانی می‌شود، در حالی که صفحات <em>health check</em> و سیستم‌های مانیتورینگ ما به ما در مورد سلامت سیستم کلی و <em>services</em> جداگانه اطلاع می‌دهند.</p>
<p>تمام این اطلاعات به صورت برنامه‌نویسی در دسترس است. همه این داده‌ها به ما اجازه می‌دهد که <em>humane registry</em> خود را قدرتمندتر از یک صفحه <em>wiki</em> ساده کنیم که بدون شک منسوخ خواهد شد. در عوض، ما باید از آن برای مهار و نمایش تمام اطلاعاتی که سیستم ما منتشر می‌کند، استفاده کنیم. با ایجاد داشبوردهای سفارشی، ما می‌توانیم مجموعه عظیمی از اطلاعات موجود را جمع‌آوری کنیم تا به ما در درک اکوسیستم خود کمک کند.
  <p>به هر وسیله‌ای، با چیزی به سادگی یک صفحه وب ایستا یا <em>wiki</em> شروع کنید که احتمالاً کمی از داده‌ها را از سیستم زنده استخراج می‌کند. اما به مرور زمان به دنبال جمع‌آوری اطلاعات بیشتر و بیشتر باشید. در دسترس قرار دادن این اطلاعات، یک ابزار کلیدی برای مدیریت پیچیدگی نوظهوری است که از اجرای این سیستم‌ها در مقیاس حاصل می‌شود.</p>
<p>من با تعدادی از شرکت‌ها صحبت کرده‌ام که با این مسائل مواجه بوده‌اند و در نهایت رجیستری‌های داخلی ساده‌ای را ایجاد کردند تا به جمع‌آوری <em>metadata</em> در اطراف <em>services</em> کمک کنند. برخی از این رجیستری‌ها به سادگی در مخازن کد منبع <em>crawl</em> می‌کنند و به دنبال فایل‌های <em>metadata</em> برای ایجاد لیستی از <em>services</em> موجود هستند. این اطلاعات می‌تواند با داده‌های واقعی حاصل از سیستم‌های <em>service discovery</em> مانند <em>Consul</em> یا <em>etcd</em> ادغام شود تا تصویری غنی‌تر از آنچه در حال اجرا است و کسی که می‌توانید در مورد آن با او صحبت کنید، ایجاد شود.</p>
<p><em>Financial Times</em>، <em>Biz Ops</em> را برای کمک به حل این مشکل ایجاد کرد. این شرکت دارای چندین صد <em>services</em> است که توسط تیم‌هایی در سراسر جهان توسعه یافته‌اند. ابزار <em>Biz Ops</em> (شکل 5-8) به این شرکت یک مکان واحد می‌دهد که در آن می‌توانید اطلاعات مفیدی در مورد <em>microservices</em> آن، علاوه بر اطلاعات مربوط به سایر <em>IT infrastructure services</em> مانند شبکه‌ها و <em>file servers</em> پیدا کنید. <em>Biz Ops</em> که بر اساس یک <em>graph database</em> ساخته شده است، در مورد داده‌هایی که جمع‌آوری می‌کند و نحوه مدل‌سازی اطلاعات، انعطاف‌پذیری زیادی دارد.</p>
</p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0197</div>
            </div>
        </div>
        <!-- Page 0198 -->
        <div class="chapter" id="page-0198">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>شکل 5-8. ابزار <em>Financial Times Biz Ops</em>، که اطلاعاتی را در مورد <em>microservices</em> آن جمع‌آوری می‌کند</p>
<p>با این حال، ابزار <em>Biz Ops</em> فراتر از اکثر ابزارهای مشابهی که من دیده‌ام، می‌رود. این ابزار چیزی را محاسبه می‌کند که آن را <em>System Operability Score</em> می‌نامند، همانطور که در شکل 5-9 نشان داده شده است. ایده این است که کارهای خاصی وجود دارد که <em>services</em> و تیم‌های آن‌ها باید انجام دهند تا اطمینان حاصل شود که <em>services</em> را می‌توان به راحتی اداره کرد. این می‌تواند از اطمینان از اینکه تیم‌ها اطلاعات صحیح را در <em>registry</em> ارائه کرده‌اند تا اطمینان از اینکه <em>services</em> دارای <em>health checks</em> مناسب هستند، متفاوت باشد. <em>System Operability Score</em>، پس از محاسبه، به تیم‌ها اجازه می‌دهد تا در یک نگاه ببینند که آیا مواردی وجود دارد که باید رفع شوند.</p>
<p>این یک فضای در حال رشد است. در دنیای منبع باز، ابزار <em>Spotify’s Backstage</em> یک مکانیسم برای ساخت یک <em>service catalog</em> مانند <em>Biz Ops</em> ارائه می‌دهد، با یک مدل <em>plug-in</em> برای اجازه دادن به اضافات پیچیده، مانند توانایی راه‌اندازی ایجاد یک <em>microservice</em> جدید یا کشیدن اطلاعات زنده از یک <em>Kubernetes cluster</em>. <em>Service Catalog</em> خود <em>Ambassador</em> بیشتر بر روی دید <em>services</em> در <em>Kubernetes</em> متمرکز شده است، که به این معنی است که ممکن است به اندازه چیزی مانند <em>FT’s</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 198" src="page_0198/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0198</div>
            </div>
        </div>
        <!-- Page 0199 -->
        <div class="chapter" id="page-0199">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>Biz Ops</em>، اما دیدن برخی از رویکردهای جدید در این ایده که به طور کلی‌تری در دسترس هستند، همچنان خوب است.
  <p>شکل 5-9. نمونه‌ای از <em>Service Operability Score</em> برای یک <em>microservice</em> در <em>Financial Times</em></p>
<h4>Summary</h4>
<p>بنابراین ما در این فصل مطالب زیادی را پوشش دادیم—بیایید برخی از آن‌ها را تجزیه کنیم:</p>
<ul>
<li>برای شروع، اطمینان حاصل کنید که مشکلی که در تلاش برای حل آن هستید، انتخاب فناوری شما را هدایت می‌کند. بر اساس <em>context</em> و سبک ارتباطی مورد نظر خود، فناوری مناسب‌ترین را برای خود انتخاب کنید—در دام انتخاب فناوری در وهله اول نیفتید. خلاصه سبک‌های ارتباط <em>inter-microservice</em>، که برای اولین بار در فصل 4 معرفی شد و دوباره در شکل 5-10 نشان داده شده است، می‌تواند به هدایت تصمیم‌گیری شما کمک کند، اما فقط پیروی از این مدل جایگزینی برای نشستن و فکر کردن در مورد وضعیت خود شما نیست.</li>
</ul>
</p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 199" src="page_0199/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0199</div>
            </div>
        </div>
        <!-- Page 0200 -->
        <div class="chapter" id="page-0200">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>شکل 5-10. سبک‌های مختلف ارتباطات <em>inter-microservice</em>، همراه با نمونه‌ای از فناوری‌های پیاده‌سازی</p>
<ul>
<li>هر انتخابی که انجام می‌دهید، استفاده از <em>schemas</em> را در نظر بگیرید، تا حدی به صریح‌تر کردن قراردادهای خود کمک کنید، اما همچنین به تشخیص <em>accidental breaking changes</em> کمک کنید.</li>
<li>در صورت امکان، تلاش کنید تغییراتی ایجاد کنید که <em>backward compatible</em> باشند تا اطمینان حاصل شود که قابلیت استقرار مستقل همچنان یک امکان است.</li>
<li>اگر شما مجبور به ایجاد تغییرات <em>backward-incompatible</em> هستید، راهی برای دادن زمان به مصرف‌کنندگان برای ارتقاء پیدا کنید تا از استقرار <em>lockstep</em> جلوگیری کنید.</li>
<li>به این فکر کنید که چه کاری می‌توانید انجام دهید تا اطلاعاتی در مورد <em>endpoints</em> خود به انسان‌ها ارائه دهید—استفاده از <em>humane registries</em> و موارد مشابه را برای کمک به درک هرج و مرج در نظر بگیرید.</li>
</ul>
<p>ما به این نگاه کردیم که چگونه می‌توانیم یک تماس را بین دو <em>microservices</em> پیاده‌سازی کنیم، اما وقتی نیاز به هماهنگی عملیات بین چندین <em>microservices</em> داریم، چه اتفاقی می‌افتد؟ این موضوع تمرکز فصل بعدی ما خواهد بود.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 200" src="page_0200/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0200</div>
            </div>
        </div>
        <!-- Page 0201 -->
        <div class="chapter" id="page-0201">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>CHAPTER 6</h3>
<h3>Workflow</h3>
<p>در دو فصل قبل، ما به جنبه‌هایی از <em>microservices</em> که مربوط به نحوه صحبت یک <em>microservice</em> با دیگری است، نگاه کردیم. اما وقتی می‌خواهیم چندین <em>microservices</em> با هم همکاری کنند، شاید برای پیاده‌سازی یک فرآیند تجاری، چه اتفاقی می‌افتد؟ نحوه مدل‌سازی و پیاده‌سازی این نوع <em>workflows</em> در سیستم‌های توزیع شده می‌تواند یک کار دشوار برای درست انجام دادن باشد.</p>
<p>در این فصل، ما به مشکلات مرتبط با استفاده از <em>distributed transactions</em> برای حل این مشکل نگاه خواهیم کرد، و همچنین به <em>sagas</em> نگاه خواهیم کرد—مفهومی که می‌تواند به ما در مدل‌سازی <em>microservice workflows</em> خود به روشی بسیار رضایت‌بخش‌تر کمک کند.</p>
<h4>Database Transactions</h4>
<p>به طور کلی، هنگامی که ما در مورد یک <em>transaction</em> در زمینه محاسبات فکر می‌کنیم، به یک یا چند عملیاتی فکر می‌کنیم که قرار است رخ دهند و ما می‌خواهیم آن‌ها را به عنوان یک واحد واحد در نظر بگیریم. هنگام ایجاد تغییرات متعدد به عنوان بخشی از یک عملیات کلی، ما می‌خواهیم تأیید کنیم که آیا همه تغییرات ایجاد شده‌اند یا خیر. ما همچنین یک راه برای پاکسازی بعد از خود می‌خواهیم اگر خطایی در حین وقوع این تغییرات رخ دهد. به طور معمول، این امر منجر به این می‌شود که ما از چیزی مانند یک <em>database transaction</em> استفاده کنیم.</p>
<p>با یک <em>database</em>، ما از یک <em>transaction</em> برای اطمینان از اینکه یک یا چند تغییر حالت با موفقیت انجام شده است، استفاده می‌کنیم. این می‌تواند شامل داده‌های حذف شده، درج شده یا تغییر یافته باشد. در یک <em>relational database</em>، این می‌تواند شامل به‌روزرسانی جداول متعدد در یک <em>single transaction</em> باشد.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0201</div>
            </div>
        </div>
        <!-- Page 0202 -->
        <div class="chapter" id="page-0202">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>1 این موضوع تغییر کرده است، با پشتیبانی از <em>multidocument ACID transactions</em> که به عنوان بخشی از <em>Mongo 4.0</em> منتشر شده است. من خودم از این ویژگی <em>Mongo</em> استفاده نکرده‌ام؛ فقط می‌دانم که وجود دارد!</p>
<p>2 <em>Martin Kleppmann, Designing Data-Intensive Applications (Sebastopol: O’Reilly, 2017)</em>.</p>
<h4>ACID Transactions</h4>
<p>به طور معمول، وقتی در مورد <em>database transactions</em> صحبت می‌کنیم، در مورد <em>ACID transactions</em> صحبت می‌کنیم. <em>ACID</em> مخفف ویژگی‌های اصلی <em>database transactions</em> است که منجر به سیستمی می‌شود که ما می‌توانیم به آن تکیه کنیم تا دوام و سازگاری ذخیره‌سازی داده‌های خود را تضمین کنیم. <em>ACID</em> مخفف <em>atomicity</em>، <em>consistency</em>، <em>isolation</em>، و <em>durability</em> است، و در اینجا آمده است که این ویژگی‌ها چه چیزی را به ما می‌دهند:</p>
<ul>
<li><strong>Atomicity</strong></li>
<p>اطمینان حاصل می‌کند که عملیات انجام شده در داخل <em>transaction</em> یا همه کامل می‌شوند یا همه ناموفق می‌شوند. اگر هر یک از تغییراتی که ما در تلاشیم ایجاد کنیم به دلایلی شکست بخورند، در این صورت کل عملیات لغو می‌شود، و انگار هیچ تغییری هرگز ایجاد نشده است.</p>
<li><strong>Consistency</strong></li>
<p>هنگامی که تغییراتی در <em>database</em> ما ایجاد می‌شود، ما اطمینان حاصل می‌کنیم که در یک حالت معتبر و ثابت باقی می‌ماند.</p>
<li><strong>Isolation</strong></li>
<p>به چندین <em>transactions</em> اجازه می‌دهد تا همزمان و بدون تداخل با یکدیگر عمل کنند. این امر با اطمینان از اینکه هرگونه تغییر حالت موقت ایجاد شده در طول یک <em>transaction</em> برای <em>other transactions</em> نامرئی است، به دست می‌آید.</p>
<li><strong>Durability</strong></li>
<p>اطمینان حاصل می‌کند که پس از اتمام یک <em>transaction</em>، ما اطمینان داریم که داده‌ها در صورت بروز هرگونه <em>system failure</em> از دست نمی‌روند.</p>
</ul>
<p>شایان ذکر است که همه <em>databases</em>، <em>ACID transactions</em> را ارائه نمی‌دهند. تمام سیستم‌های <em>relational database</em> که من تا به حال استفاده کرده‌ام، این کار را انجام می‌دهند، همانطور که بسیاری از <em>NoSQL databases</em> جدیدتر مانند <em>Neo4j</em> این کار را انجام می‌دهند. <em>MongoDB</em> سال‌ها <em>ACID transactions</em> را فقط در مورد تغییرات انجام شده در یک <em>single document</em> پشتیبانی می‌کرد، که می‌تواند در صورت تمایل به ایجاد یک <em>atomic update</em> به بیش از یک <em>document</em>، مشکلاتی ایجاد کند.1</p>
<p>این کتاب برای بررسی دقیق این مفاهیم نیست؛ من مطمئناً برخی از این توضیحات را برای اختصار ساده کرده‌ام. برای کسانی که مایل به بررسی بیشتر این مفاهیم هستند، من <em>Designing Data-Intensive Applications</em> را توصیه می‌کنم.2</p>
<p>ما بیشتر در مورد <em>atomicity</em> در آنچه در ادامه می‌آید، نگران خواهیم بود. این به این معنا نیست که سایر ویژگی‌ها نیز مهم نیستند، اما مقابله با نحوه برخورد با <em>atomicity</em> از عملیات <em>database</em>، تمایل دارد که اولین مسئله‌ای باشد که وقتی شروع به جدا کردن عملکرد به <em>microservices</em> می‌کنیم، با آن برخورد می‌کنیم.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0202</div>
            </div>
        </div>
        <!-- Page 0203 -->
        <div class="chapter" id="page-0203">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Still ACID, but Lacking Atomicity?</h4>
<p>می‌خواهم روشن کنم که ما هنوز هم می‌توانیم از <em>ACID-style transactions</em> هنگام استفاده از <em>microservices</em> استفاده کنیم. به عنوان مثال، یک <em>microservice</em> آزاد است تا از یک <em>ACID transaction</em> برای عملیات به <em>database</em> خود استفاده کند. فقط این است که دامنه این <em>transactions</em> به تغییر حالتی که به صورت محلی در داخل آن <em>single microservice</em> اتفاق می‌افتد، کاهش می‌یابد. شکل 6-1 را در نظر بگیرید.
  <p>در اینجا، ما در حال پیگیری فرآیند مربوط به راه‌اندازی یک مشتری جدید در <em>MusicCorp</em> هستیم. ما به پایان فرآیند رسیده‌ایم، که شامل تغییر <em>Status</em> مشتری 2346 از <em>PENDING</em> به <em>VERIFIED</em> است. از آنجایی که اکنون ثبت‌نام تکمیل شده است، ما همچنین می‌خواهیم ردیف منطبق را از جدول <em>PendingEnrollments</em> حذف کنیم. با یک <em>single database</em>، این کار در محدوده یک <em>single ACID database transaction</em> انجام می‌شود—یا هر دو این تغییرات حالت رخ می‌دهند، یا هیچ‌کدام رخ نمی‌دهند.</p>
<p>شکل 6-1. به‌روزرسانی دو جدول در محدوده یک <em>single ACID transaction</em></p>
<p>این را با شکل 6-2 مقایسه کنید، جایی که ما دقیقاً همان تغییر را ایجاد می‌کنیم، اما هر تغییر در یک <em>database</em> متفاوت ایجاد می‌شود. این بدان معناست که دو <em>transaction</em> وجود دارد که باید در نظر گرفته شود، که هر یک از آن‌ها می‌توانند مستقل از دیگری کار کنند یا شکست بخورند.</p>
</p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 203" src="page_0203/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0203</div>
            </div>
        </div>
        <!-- Page 0204 -->
        <div class="chapter" id="page-0204">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>شکل 6-2. تغییرات ایجاد شده توسط <em>Customer</em> و <em>Enrollments microservices</em> اکنون در محدوده دو <em>transactions</em> مختلف انجام می‌شود</p>
<p>البته، ما می‌توانیم تصمیم بگیریم که این دو <em>transactions</em> را <em>sequence</em> کنیم، و یک ردیف را از جدول <em>PendingEnrollments</em> حذف کنیم، فقط اگر بتوانیم ردیف را در جدول <em>Customer</em> تغییر دهیم. اما ما همچنان باید در مورد کاری که باید انجام دهیم اگر حذف از جدول <em>PendingEnrollments</em> شکست خورد، فکر کنیم—تمام منطقی که ما باید خودمان پیاده‌سازی کنیم. با این حال، توانایی تغییر ترتیب مراحل برای مدیریت بهتر این موارد استفاده می‌تواند یک ایده واقعاً مفید باشد (موردی که ما به آن بازخواهیم گشت وقتی <em>sagas</em> را بررسی می‌کنیم). اما اساساً، ما باید بپذیریم که با تجزیه این عملیات به دو <em>database transactions</em> جداگانه، <em>atomicity</em> تضمین شده عملیات را به طور کلی از دست داده‌ایم.</p>
<p>این کمبود <em>atomicity</em> می‌تواند شروع به ایجاد مشکلات قابل توجهی کند، به خصوص اگر ما در حال انتقال سیستم‌هایی باشیم که قبلاً به این ویژگی متکی بودند. به طور معمول، اولین گزینه‌ای که مردم شروع به در نظر گرفتن آن می‌کنند، همچنان استفاده از یک <em>single transaction</em> است، اما این بار شامل چندین <em>processes</em> می‌شود—یک <em>distributed transaction</em>. متأسفانه، همانطور که خواهیم دید، <em>distributed transactions</em> ممکن است راه درستی نباشند. بیایید به یکی از رایج‌ترین الگوریتم‌ها برای پیاده‌سازی <em>distributed transactions</em>، <em>two-phase commit</em>، به عنوان راهی برای بررسی چالش‌های مرتبط با <em>distributed transactions</em> به طور کلی، نگاهی بیندازیم.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 204" src="page_0204/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0204</div>
            </div>
        </div>
        <!-- Page 0205 -->
        <div class="chapter" id="page-0205">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Distributed Transactions—Two-Phase Commits</h4>
<p>الگوریتم <em>two-phase commit</em> (که گاهی اوقات به <em>2PC</em> خلاصه می‌شود) اغلب در تلاش برای دادن توانایی به ما برای ایجاد تغییرات تراکنشی در یک سیستم توزیع شده استفاده می‌شود، که در آن چندین فرآیند جداگانه ممکن است نیاز به به‌روزرسانی به عنوان بخشی از عملیات کلی داشته باشند. <em>Distributed transactions</em>، و <em>two-phased commits</em> به طور خاص‌تر، اغلب توسط تیم‌هایی که به معماری <em>microservice</em> منتقل می‌شوند، به عنوان راهی برای حل چالش‌هایی که با آن مواجه می‌شوند، در نظر گرفته می‌شوند. اما همانطور که خواهیم دید، آن‌ها ممکن است مشکلات شما را حل نکنند و حتی باعث ایجاد سردرگمی بیشتری در سیستم شما شوند.</p>
<p><em>2PC</em> به دو فاز تقسیم می‌شود (از این رو نام <em>two-phase commit</em>): یک فاز رای‌گیری و یک فاز <em>commit</em>. در طول فاز رای‌گیری، یک <em>central coordinator</em> با تمام <em>workers</em> که قرار است بخشی از <em>transaction</em> باشند تماس می‌گیرد و از آن‌ها برای تأیید اینکه آیا تغییری در وضعیت می‌تواند ایجاد شود یا خیر، درخواست می‌کند. در شکل 6-3، ما دو <em>request</em> را می‌بینیم: یکی برای تغییر وضعیت مشتری به <em>VERIFIED</em>، و دیگری برای حذف یک ردیف از جدول <em>PendingEnrollments</em>. اگر همه <em>workers</em> موافقت کنند که تغییر وضعیت درخواستی می‌تواند رخ دهد، الگوریتم به فاز بعدی می‌رود. اگر هر <em>worker</em> بگوید که تغییر نمی‌تواند رخ دهد، شاید به این دلیل که تغییر وضعیت درخواستی، برخی از شرایط محلی را نقض می‌کند، کل عملیات لغو می‌شود.</p>
<p>شکل 6-3. در فاز اول یک <em>two-phase commit</em>، <em>workers</em> رأی می‌دهند تا تصمیم بگیرند که آیا می‌توانند تغییری در وضعیت محلی ایجاد کنند</p>
<p>مهم است که برجسته کنیم که تغییر بلافاصله پس از اینکه یک <em>worker</em> نشان داد که می‌تواند تغییر را ایجاد کند، اعمال نمی‌شود. در عوض، <em>worker</em> تضمین می‌کند که می‌تواند آن تغییر را در مقطعی در آینده ایجاد کند. <em>How would the worker</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 205" src="page_0205/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0205</div>
            </div>
        </div>
        <!-- Page 0206 -->
        <div class="chapter" id="page-0206">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>چنین تضمینی را بدهد؟ به عنوان مثال، در شکل 6-3، <em>Worker A</em> گفته است که می‌تواند وضعیت ردیف را در جدول <em>Customer</em> تغییر دهد تا وضعیت آن مشتری خاص را به <em>VERIFIED</em> به‌روزرسانی کند. اگر یک عملیات متفاوت در نقطه‌ای بعدی، ردیف را حذف کند، یا تغییرات دیگری را ایجاد کند که با این وجود به این معنی باشد که تغییری به <em>VERIFIED</em> در اواخر نامعتبر است؟ برای تضمین اینکه تغییر به <em>VERIFIED</em> می‌تواند در اواخر انجام شود، <em>Worker A</em> احتمالاً باید رکورد را قفل کند تا اطمینان حاصل شود که تغییرات دیگری نمی‌توانند انجام شوند.</p>
<p>اگر هیچ <em>worker</em> به نفع <em>commit</em> رأی ندهد، یک پیام <em>rollback</em> باید به همه طرف‌ها ارسال شود تا اطمینان حاصل شود که آن‌ها می‌توانند به صورت محلی پاک‌سازی کنند، که به <em>workers</em> اجازه می‌دهد هر قفل احتمالی را که در دست دارند، آزاد کنند. اگر همه <em>workers</em> با ایجاد تغییر موافقت کردند، ما به فاز <em>commit</em> می‌رویم، همانطور که در شکل 6-4 نشان داده شده است. در اینجا، تغییرات در واقع اعمال می‌شوند، و قفل‌های مرتبط آزاد می‌شوند.</p>
<p>شکل 6-4. در فاز <em>commit</em> یک <em>two-phase commit</em>، تغییرات در واقع اعمال می‌شوند</p>
<p>مهم است که توجه داشته باشید که در چنین سیستمی، ما به هیچ وجه نمی‌توانیم تضمین کنیم که این <em>commits</em> دقیقاً در یک زمان انجام می‌شوند. <em>Coordinator</em> باید <em>commit request</em> را به همه شرکت‌کنندگان ارسال کند، و آن <em>message</em> می‌تواند در زمان‌های مختلف وارد شود و پردازش شود. این بدان معناست که اگر بتوانیم مستقیماً وضعیت هر <em>worker</em> را مشاهده کنیم، این احتمال وجود دارد که بتوانیم تغییر ایجاد شده در <em>Worker A</em> را ببینیم، اما هنوز در <em>Worker B</em> نباشد. هرچه تأخیر بین <em>Coordinator</em> و شرکت‌کنندگان در <em>two-phase commit</em> بیشتر باشد، و هرچه <em>workers</em> پاسخ را کندتر پردازش کنند، این <em>window of inconsistency</em> می‌تواند گسترده‌تر باشد. با بازگشت به تعریف ما از</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 206" src="page_0206/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0206</div>
            </div>
        </div>
        <!-- Page 0207 -->
        <div class="chapter" id="page-0207">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>ACID</em>، <em>isolation</em> تضمین می‌کند که ما در طول یک <em>transaction</em>، حالت‌های میانی را نمی‌بینیم. اما با این <em>two-phase commit</em>، ما آن تضمین را از دست داده‌ایم.</p>
<p>وقتی یک <em>two-phase commit</em> کار می‌کند، در اصل، اغلب فقط در حال هماهنگی <em>distributed locks</em> است. <em>Workers</em> باید <em>local resources</em> را قفل کنند تا اطمینان حاصل شود که <em>commit</em> می‌تواند در طول فاز دوم انجام شود. مدیریت قفل‌ها و اجتناب از <em>deadlocks</em> در یک سیستم تک-فرآیندی سرگرم‌کننده نیست. اکنون چالش‌های هماهنگی قفل‌ها را در میان چندین شرکت‌کننده تصور کنید. زیبا نیست.</p>
<p>تعدادی از <em>failure modes</em> مرتبط با <em>two-phase commits</em> وجود دارد که ما وقت بررسی آن‌ها را نداریم. مشکل یک <em>worker</em> را در نظر بگیرید که به نفع <em>commit</em> رأی می‌دهد اما سپس در پاسخ به <em>commit</em>، پاسخ نمی‌دهد. در این صورت باید چه‌کار کنیم؟ برخی از این <em>failure modes</em> را می‌توان به صورت خودکار مدیریت کرد، اما برخی می‌توانند سیستم را در حالتی قرار دهند که نیاز به رفع دستی توسط یک <em>operator</em> داشته باشد.</p>
<p>هرچه تعداد شرکت‌کنندگان بیشتر باشد و هرچه <em>latency</em> در سیستم بیشتر باشد، مشکلات بیشتری برای یک <em>two-phase commit</em> وجود خواهد داشت. <em>2PC</em> می‌تواند یک راه سریع برای تزریق مقادیر زیادی <em>latency</em> به سیستم شما باشد، به خصوص اگر دامنه قفل کردن زیاد باشد، یا اگر مدت زمان <em>transaction</em> زیاد باشد. به همین دلیل است که <em>two-phase commits</em> معمولاً فقط برای عملیات‌های بسیار کوتاه مدت استفاده می‌شوند. هرچه عملیات طولانی‌تر شود، منابع بیشتری را قفل کرده‌اید!</p>
<h4>Distributed Transactions—Just Say No</h4>
<p>به تمام دلایل ذکر شده تا کنون، من به شدت پیشنهاد می‌کنم که از استفاده از <em>distributed transactions</em> مانند <em>two-phase commit</em> برای هماهنگی تغییرات در حالت در <em>microservices</em> خود اجتناب کنید. پس چه کار دیگری می‌توانید انجام دهید؟</p>
<p>خوب، اولین گزینه می‌تواند این باشد که داده‌ها را در وهله اول از هم جدا نکنید. اگر شما قطعاتی از <em>state</em> را دارید که می‌خواهید به روشی واقعاً اتمی و ثابت مدیریت کنید، و شما نمی‌توانید بفهمید که چگونه این ویژگی‌ها را بدون یک <em>ACID-style transaction</em> به دست آورید، در این صورت آن <em>state</em> را در یک <em>single database</em> رها کنید، و عملکردی را که آن <em>state</em> را مدیریت می‌کند، در یک <em>single service</em> (یا در <em>monolith</em> خود) رها کنید. اگر شما در حال کار بر روی این هستید که کجا <em>monolith</em> خود را تقسیم کنید و چه تجزیه‌هایی ممکن است آسان (یا دشوار) باشد، در این صورت شما می‌توانید تصمیم بگیرید که تقسیم داده‌هایی که در حال حاضر در یک <em>transaction</em> مدیریت می‌شوند، در حال حاضر بسیار دشوار است. روی برخی از قسمت‌های دیگر سیستم کار کنید، و بعداً به این موضوع بازگردید.</p>
<p>اما اگر واقعاً نیاز به شکستن این داده‌ها دارید، اما نمی‌خواهید تمام دردسرهای مدیریت <em>distributed transactions</em> را داشته باشید، چه اتفاقی می‌افتد؟ چگونه می‌توانید عملیات را در چندین <em>services</em> انجام دهید اما از قفل کردن اجتناب کنید؟ اگر عملیات قرار است دقایق، روزها، یا شاید حتی ماه‌ها طول بکشد، چه؟ در چنین مواردی، شما ممکن است یک رویکرد جایگزین را در نظر بگیرید: <em>sagas</em>.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0207</div>
            </div>
        </div>
        <!-- Page 0208 -->
        <div class="chapter" id="page-0208">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>3 <em>Robert Kubis, “Google Cloud Spanner: Global Consistency at Scale,” Devoxx, November 7, 2017, YouTube</em>
<p><em>video, 33:22, https://oreil.ly/XHvY5.</em></p>
<p>4 <em>Hector Garcia-Molina and Kenneth Salem, “Sagas,” ACM Sigmod Record 16, no. 3 (1987): 249–59.</em></p>
<h4>Database Distributed Transactions</h4>
<p>من در حال بحث در مورد استفاده کلی از <em>distributed transactions</em> برای هماهنگی تغییرات حالت در سراسر <em>microservices</em> هستم. در چنین شرایطی، هر <em>microservice</em> در حال مدیریت <em>local durable state</em> خود (به عنوان مثال، در <em>database</em> خود) است. <em>Distributed transactional algorithms</em> با موفقیت برای برخی از <em>databases</em> در مقیاس بزرگ، مانند <em>Google’s Spanner</em>، استفاده می‌شوند. در این وضعیت، <em>distributed transaction</em> به طور شفاف از دیدگاه یک <em>application</em> توسط <em>underling database</em> اعمال می‌شود، و <em>distributed transaction</em> فقط برای هماهنگی تغییرات حالت در یک <em>single logical database</em> استفاده می‌شود (اگرچه ممکن است در چندین دستگاه توزیع شده باشد، و به طور بالقوه در سراسر چندین <em>data centers</em> نیز باشد).</p>
<p>آنچه <em>Google</em> موفق به دستیابی به آن با <em>Spanner</em> شده است، چشمگیر است، اما همچنین شایان ذکر است که کاری که آن‌ها برای کارکردن آن انجام دادند، ایده‌ای از چالش‌های موجود به شما می‌دهد. بیایید فقط بگوییم که شامل <em>data centers</em> بسیار گران‌قیمت و ساعت‌های اتمی مبتنی بر ماهواره است (واقعاً). برای یک نمای کلی خوب از نحوه عملکرد <em>Spanner</em>، من ارائه "<em>Google Cloud Spanner: Global Consistency at Scale</em>" را توصیه می‌کنم.3</p>
<h4>Sagas</h4>
<p>برخلاف یک <em>two-phase commit</em>، یک <em>saga</em>، طبق طراحی، الگوریتمی است که می‌تواند چندین تغییر در حالت را هماهنگ کند، اما از نیاز به قفل کردن منابع برای مدت‌های طولانی اجتناب می‌کند. یک <em>saga</em> این کار را با مدل‌سازی مراحل درگیر به عنوان فعالیت‌های مجزایی که می‌توانند به‌طور مستقل اجرا شوند، انجام می‌دهد. استفاده از <em>sagas</em> با مزیت اضافه کردن ما را مجبور می‌کند که فرآیندهای تجاری خود را صریحاً مدل کنیم، که می‌تواند مزایای قابل توجهی داشته باشد.
  <p>ایده اصلی، که برای اولین بار در "<em>Sagas</em>" توسط <em>Hector Garcia-Molina</em> و <em>Kenneth Salem</em>4 مطرح شد، نحوه رسیدگی به عملیاتی را که به عنوان <em>long lived transactions (LLTs)</em> شناخته می‌شوند، نشان می‌دهد. این <em>transactions</em> ممکن است زمان زیادی (چند دقیقه، ساعت‌ها، یا شاید حتی روزها) طول بکشد و به عنوان بخشی از آن فرآیند، نیاز به ایجاد تغییراتی در یک <em>database</em> دارند.
  <p>اگر شما مستقیماً یک <em>LLT</em> را به یک <em>normal database transaction</em> نگاشتید، یک <em>single database transaction</em> کل چرخه عمر <em>LLT</em> را در بر می‌گرفت. این می‌تواند منجر به قفل شدن چندین ردیف یا حتی جداول کامل برای مدت‌های طولانی در حالی که <em>LLT</em> در حال انجام است، شود، که اگر فرآیندهای دیگر در تلاش برای خواندن یا تغییر این منابع قفل شده باشند، باعث ایجاد مشکلات قابل توجهی می‌شود.</p>
</p></p></p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0208</div>
            </div>
        </div>
        <!-- Page 0209 -->
        <div class="chapter" id="page-0209">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>در عوض، نویسندگان مقاله پیشنهاد می‌کنند که ما این <em>LLTs</em> را به یک دنباله‌ای از <em>transactions</em> تقسیم کنیم، که هر یک از آن‌ها می‌تواند به طور مستقل مدیریت شود. ایده این است که مدت زمان هر یک از این <em>sub transactions</em> کوتاه‌تر خواهد بود، و فقط بخشی از داده‌های تحت تأثیر کل <em>LLT</em> را تغییر می‌دهد. در نتیجه، در <em>database</em> اساسی، به دلیل کاهش زیاد دامنه و مدت زمان قفل‌ها، بحث کمتری وجود خواهد داشت.</p>
<p>در حالی که <em>sagas</em> در ابتدا به عنوان یک مکانیسم برای کمک به <em>LLTs</em> که در برابر یک <em>single database</em> عمل می‌کنند، تصور می‌شد، این مدل برای هماهنگی تغییرات در چندین <em>services</em> نیز به خوبی کار می‌کند. ما می‌توانیم یک فرآیند تجاری واحد را به مجموعه‌ای از <em>calls</em> تقسیم کنیم که به <em>collaborating services</em> انجام می‌شود—این چیزی است که یک <em>saga</em> را تشکیل می‌دهد.</p>
<p>قبل از اینکه جلوتر برویم، شما باید درک کنید که یک <em>saga</em> به ما <em>atomicity</em> را از نظر <em>ACID</em> که ما به آن عادت کرده‌ایم، مانند یک <em>normal database transaction</em>، نمی‌دهد. همانطور که <em>LLT</em> را به <em>individual transactions</em> تقسیم می‌کنیم، ما <em>atomicity</em> را در سطح خود <em>saga</em> نداریم.
  <p>ما برای هر <em>individual transaction</em> در داخل <em>overall saga</em>، <em>atomicity</em> را داریم، زیرا هر یک از آن‌ها در صورت نیاز می‌توانند به یک تغییر <em>ACID transactional</em> مرتبط شوند. آنچه یک <em>saga</em> به ما می‌دهد، اطلاعات کافی برای استدلال در مورد حالتی است که در آن قرار دارد؛ این به ما بستگی دارد که پیامدهای این موضوع را مدیریت کنیم.</p>
<p>بیایید نگاهی به یک جریان ساده تکمیل سفارش برای <em>MusicCorp</em> بیندازیم، که در شکل 6-5 نشان داده شده است، که می‌توانیم از آن برای بررسی بیشتر <em>sagas</em> در زمینه یک معماری <em>microservice</em> استفاده کنیم.</p>
<p>در اینجا، فرآیند تکمیل سفارش به عنوان یک <em>single saga</em> نشان داده شده است، که در آن هر مرحله از این جریان نشان‌دهنده عملیاتی است که می‌تواند توسط یک <em>service</em> متفاوت انجام شود.
  <p>در داخل هر <em>service</em>، هر گونه تغییر حالت می‌تواند در یک <em>local ACID transaction</em> مدیریت شود. به عنوان مثال، هنگامی که ما موجودی را با استفاده از <em>Warehouse service</em> بررسی و ذخیره می‌کنیم، به صورت داخلی، <em>Warehouse service</em> ممکن است یک ردیف را در جدول <em>Reservation</em> محلی خود ایجاد کند و رزرو را ثبت کند؛ این تغییر در یک <em>normal database transaction</em> مدیریت می‌شود.</p>
</p></p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 209" src="page_0209/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0209</div>
            </div>
        </div>
        <!-- Page 0210 -->
        <div class="chapter" id="page-0210">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>شکل 6-5. یک جریان نمونه تکمیل سفارش، همراه با <em>services</em> مسئول اجرای عملیات</p>
<h4>Saga Failure Modes</h4>
<p>با <em>saga</em> که به تراکنش‌های جداگانه تقسیم شده است، ما باید در نظر بگیریم که چگونه شکست را مدیریت کنیم—یا، به طور خاص‌تر، چگونه در صورت وقوع یک شکست، بازیابی کنیم. مقاله اصلی <em>saga</em> دو نوع بازیابی را توصیف می‌کند: <em>backward recovery</em> و <em>forward recovery</em>.</p>
<p><em>Backward recovery</em> شامل بازگرداندن شکست و پاکسازی پس از آن است—یک <em>roll-back</em>. برای اینکه این کار انجام شود، ما نیاز به تعریف اقدامات جبرانی داریم که به ما امکان می‌دهد تراکنش‌های قبلاً انجام شده را خنثی کنیم. <em>Forward recovery</em> به ما اجازه می‌دهد تا از نقطه‌ای که شکست رخ داده است شروع کنیم و به پردازش ادامه دهیم. برای اینکه این کار انجام شود، ما باید بتوانیم تراکنش‌ها را دوباره امتحان کنیم، که به نوبه خود این را می‌رساند که سیستم ما اطلاعات کافی را برای اجازه دادن به انجام این تلاش مجدد، حفظ می‌کند.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 210" src="page_0210/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0210</div>
            </div>
        </div>
        <!-- Page 0211 -->
        <div class="chapter" id="page-0211">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>بسته به ماهیت فرآیند تجاری که مدل‌سازی می‌شود، شما ممکن است انتظار داشته باشید که هر <em>failure mode</em> یک <em>backward recovery</em>، یک <em>forward recovery</em>، یا شاید ترکیبی از این دو را فعال کند.</p>
<p>واقعاً مهم است که توجه داشته باشید که یک <em>saga</em> به ما اجازه می‌دهد از <em>business failures</em> بازیابی کنیم، نه از <em>technical failures</em>. به عنوان مثال، اگر ما سعی کنیم از مشتری پرداخت دریافت کنیم اما مشتری موجودی کافی ندارد، در این صورت این یک <em>business failure</em> است که انتظار می‌رود <em>saga</em> آن را مدیریت کند. از سوی دیگر، اگر <em>Payment Gateway</em> <em>time out</em> شود یا یک خطای 500 <em>Internal Service Error</em> را پرتاب کند، در این صورت این یک <em>technical failure</em> است که ما باید جداگانه آن را مدیریت کنیم. <em>saga</em> فرض می‌کند که مؤلفه‌های اساسی به درستی کار می‌کنند—که سیستم اساسی قابل اعتماد است، و این است که ما در حال هماهنگی کار مؤلفه‌های قابل اعتماد هستیم. ما برخی از راه‌هایی را که می‌توانیم مؤلفه‌های فنی خود را قابل اطمینان‌تر کنیم، در فصل 12 بررسی خواهیم کرد، اما برای اطلاعات بیشتر در مورد این محدودیت <em>sagas</em>، من "<em>The Limits of the Saga Pattern</em>" نوشته <em>Uwe Friedrichsen</em> را توصیه می‌کنم.</p>
<h4>Saga rollbacks</h4>
<p>با یک <em>ACID transaction</em>، اگر به مشکلی برخوردیم، یک <em>rollback</em> را قبل از وقوع یک <em>commit</em> فعال می‌کنیم. پس از <em>rollback</em>، انگار هیچ اتفاقی نیفتاده است: تغییری که ما در تلاش برای ایجاد آن بودیم، رخ نداد. با <em>saga</em> ما، با این حال، چندین <em>transactions</em> درگیر داریم، و برخی از آن‌ها ممکن است قبل از اینکه ما تصمیم به <em>roll back</em> کل عملیات بگیریم، قبلاً <em>committed</em> شده باشند. بنابراین چگونه می‌توانیم <em>transactions</em> را پس از اینکه قبلاً <em>committed</em> شده‌اند، <em>roll back</em> کنیم؟</p>
<p>بیایید به مثال خود در مورد پردازش یک سفارش، همانطور که در شکل 6-5 نشان داده شده است، بازگردیم. یک <em>potential failure mode</em> را در نظر بگیرید. ما تا حد تلاش برای بسته‌بندی کالا پیش رفته‌ایم، فقط برای اینکه متوجه شویم کالا در انبار یافت نمی‌شود، همانطور که در شکل 6-6 نشان داده شده است. سیستم ما فکر می‌کند که این کالا وجود دارد، اما فقط روی قفسه نیست!</p>
<p>اکنون، بیایید فرض کنیم که ما تصمیم می‌گیریم که فقط کل سفارش را <em>roll back</em> کنیم، به جای اینکه به مشتری این گزینه را بدهیم که کالا را در <em>back order</em> قرار دهد. مشکل این است که ما قبلاً پرداخت را دریافت کرده‌ایم و امتیاز وفاداری را برای سفارش اعطا کرده‌ایم.
  <p>اگر این مراحل همگی در یک <em>single database transaction</em> انجام شده بودند، یک <em>simple rollback</em> همه چیز را پاک می‌کرد. با این حال، هر مرحله در فرآیند تکمیل سفارش توسط یک <em>service call</em> متفاوت مدیریت می‌شد، که هر کدام در یک <em>transactional scope</em> متفاوت عمل می‌کردند. هیچ "<em>rollback</em>" ساده‌ای برای کل عملیات وجود ندارد.</p>
</p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0211</div>
            </div>
        </div>
        <!-- Page 0212 -->
        <div class="chapter" id="page-0212">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>شکل 6-6. ما سعی کرده‌ایم کالای خود را بسته‌بندی کنیم، اما نمی‌توانیم آن را در انبار پیدا کنیم</p>
<p>در عوض، اگر می‌خواهید یک <em>rollback</em> را پیاده‌سازی کنید، باید یک <em>compensating transaction</em> را پیاده‌سازی کنید. یک <em>compensating transaction</em>، عملیاتی است که یک <em>transaction</em> قبلاً <em>committed</em> شده را خنثی می‌کند. برای <em>roll back</em> کردن فرآیند تکمیل سفارش خود، ما <em>compensating transaction</em> را برای هر مرحله در <em>saga</em> خود که قبلاً <em>committed</em> شده است، فعال می‌کنیم، همانطور که در شکل 6-7 نشان داده شده است.
  <p>شایان ذکر است که این <em>compensating transactions</em> ممکن است دقیقاً مانند تراکنش‌های یک <em>normal database rollback</em> رفتار نکنند. یک <em>database rollback</em> قبل از <em>commit</em> رخ می‌دهد، و پس از <em>rollback</em>، انگار هیچ اتفاقی نیفتاده است: تغییری که ما در تلاش برای ایجاد آن بودیم، رخ نداد. در این وضعیت، البته، این <em>transactions</em> اتفاق افتادند. ما در حال ایجاد یک <em>transaction</em> جدید هستیم که تغییرات ایجاد شده توسط <em>original transaction</em> را برمی‌گرداند، اما ما نمی‌توانیم زمان را <em>roll back</em> کنیم و کاری کنیم که انگار <em>original transaction</em> رخ نداده است.</p>
</p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 212" src="page_0212/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0212</div>
            </div>
        </div>
        <!-- Page 0213 -->
        <div class="chapter" id="page-0213">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>5 ما واقعاً نمی‌توانیم. من امتحان کردم!</p>
<p>شکل 6-7. فعال‌سازی یک <em>rollback</em> از کل <em>saga</em></p>
<p>از آنجایی که ما همیشه نمی‌توانیم یک <em>transaction</em> را به درستی بازگردانیم، ما می‌گوییم که این <em>compensating transactions</em>، <em>semantic rollbacks</em> هستند. ما همیشه نمی‌توانیم همه چیز را پاک کنیم، اما ما به اندازه کافی برای زمینه <em>saga</em> خود انجام می‌دهیم. به عنوان مثال، یکی از مراحل ما ممکن است شامل ارسال ایمیل به یک مشتری برای اطلاع از اینکه سفارش آن‌ها در راه است، بوده باشد. اگر ما تصمیم به <em>roll back</em> آن گرفتیم، نمی‌توانیم یک ایمیل را پس بگیریم!5 در عوض، <em>compensating transaction</em> ما می‌تواند باعث شود که یک ایمیل دوم به مشتری ارسال شود، و به آن‌ها اطلاع داده شود که مشکلی در سفارش وجود داشته است و لغو شده است.
  <p>کاملاً مناسب است که اطلاعات مربوط به <em>rollback</em> در سیستم باقی بماند. در واقع، این ممکن است اطلاعات بسیار مهمی باشد. شما ممکن است بخواهید یک رکورد را در <em>Order service</em> برای این سفارش لغو شده، همراه با اطلاعاتی در مورد آنچه اتفاق افتاده است، به دلایل زیادی نگه دارید.</p>
</p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 213" src="page_0213/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0213</div>
            </div>
        </div>
        <!-- Page 0214 -->
        <div class="chapter" id="page-0214">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Reordering workflow steps to reduce rollbacks</h4>
<p>در شکل 6-7، ما می‌توانستیم سناریوهای <em>rollback</em> خود را با تغییر ترتیب مراحل در <em>workflow</em> اصلی خود، تا حدودی ساده‌تر کنیم. یک تغییر ساده این است که امتیازات را تنها زمانی اعطا کنیم که سفارش واقعاً ارسال شده باشد، همانطور که در شکل 6-8 مشاهده می‌شود.</p>
<p>شکل 6-8. انتقال مراحل به اواخر <em>saga</em> می‌تواند آنچه را که باید در صورت <em>failure</em> برگردانده شود، کاهش دهد</p>
<p>به این ترتیب، ما از نگرانی در مورد اینکه آن مرحله در صورتی که در تلاش برای بسته‌بندی و ارسال سفارش با مشکلی مواجه شویم، <em>rolled back</em> شود، اجتناب می‌کنیم. گاهی اوقات شما می‌توانید عملیات <em>rollback</em> خود را فقط با تنظیم نحوه انجام <em>workflow</em> خود ساده کنید. با کشیدن آن مراحلی که احتمال شکست خوردن آن‌ها بیشتر است و شکست دادن فرآیند در اوایل، از فعال کردن <em>compensating transactions</em> بعدی اجتناب می‌کنید، زیرا آن مراحل اصلاً در وهله اول فعال نشده بودند.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 214" src="page_0214/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0214</div>
            </div>
        </div>
        <!-- Page 0215 -->
        <div class="chapter" id="page-0215">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>این تغییرات، اگر بتوانند برآورده شوند، می‌توانند زندگی شما را بسیار آسان‌تر کنند، و از نیاز به ایجاد حتی <em>compensating transactions</em> برای برخی مراحل اجتناب کنند. این می‌تواند به ویژه در صورتی مهم باشد که پیاده‌سازی یک <em>compensating transaction</em> دشوار باشد. شما ممکن است بتوانید یک مرحله را در فرآیند به مرحله‌ای منتقل کنید که هرگز نیازی به <em>rolled back</em> شدن ندارد.</p>
<h4>Mixing fail-backward and fail-forward situations</h4>
<p>کاملاً مناسب است که ترکیبی از حالت‌های بازیابی <em>failure</em> داشته باشید. برخی از <em>failures</em> ممکن است نیاز به <em>rollback</em> داشته باشند (<em>fail backward</em>)؛ برخی دیگر ممکن است <em>fail forward</em> باشند. به عنوان مثال، برای <em>order processing</em>، هنگامی که ما از مشتری پول دریافت کردیم، و کالا بسته‌بندی شد، تنها مرحله باقی مانده، ارسال بسته است. اگر به هر دلیلی نتوانیم بسته را ارسال کنیم (شاید شرکت تحویل‌دهنده‌ای که از آن استفاده می‌کنیم، امروز فضای کافی در ون‌های خود برای دریافت سفارش نداشته باشد)، <em>roll back</em> کردن کل سفارش بسیار عجیب به نظر می‌رسد. در عوض، ما احتمالاً فقط دوباره ارسال را امتحان می‌کنیم (شاید آن را برای روز بعد در صف قرار دهیم)، و اگر این کار با شکست مواجه شود، به مداخله انسانی برای حل این وضعیت نیاز خواهیم داشت.</p>
<h4>Implementing Sagas</h4>
<p>تاکنون ما به مدل منطقی نحوه عملکرد <em>sagas</em> نگاه کرده‌ایم، اما ما نیاز داریم که کمی عمیق‌تر شویم تا راه‌های پیاده‌سازی خود <em>saga</em> را بررسی کنیم. ما می‌توانیم به دو سبک از پیاده‌سازی <em>saga</em> نگاه کنیم. <em>Orchestrated sagas</em> از نزدیک از فضای راه‌حل اصلی پیروی می‌کنند و عمدتاً به هماهنگی و ردیابی متمرکز متکی هستند. این‌ها را می‌توان با <em>choreographed sagas</em> مقایسه کرد، که از نیاز به هماهنگی متمرکز به نفع یک مدل <em>loosely coupled</em> تر اجتناب می‌کنند، اما می‌توانند ردیابی پیشرفت یک <em>saga</em> را پیچیده‌تر کنند.</p>
<h4>Orchestrated sagas</h4>
<p><em>Orchestrated sagas</em> از یک <em>central coordinator</em> (که از این به بعد به آن <em>orchestrator</em> خواهیم گفت) برای تعریف ترتیب اجرا و راه‌اندازی هر عمل جبرانی مورد نیاز استفاده می‌کنند. شما می‌توانید به <em>orchestrated sagas</em> به عنوان یک رویکرد <em>command-and-control</em> فکر کنید: <em>orchestrator</em>، آنچه را که اتفاق می‌افتد و زمان آن را کنترل می‌کند، و با آن، درجه خوبی از دید به آنچه که با هر <em>saga</em> داده شده اتفاق می‌افتد، ارائه می‌شود.</p>
<p>با در نظر گرفتن فرآیند تکمیل سفارش در شکل 6-5، بیایید ببینیم که این فرآیند هماهنگی مرکزی چگونه به عنوان مجموعه‌ای از <em>collaborating services</em> عمل می‌کند، همانطور که در شکل 6-9 نشان داده شده است.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0215</div>
            </div>
        </div>
        <!-- Page 0216 -->
        <div class="chapter" id="page-0216">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>شکل 6-9. نمونه‌ای از نحوه استفاده از یک <em>orchestrated saga</em> برای پیاده‌سازی فرآیند تکمیل سفارش ما</p>
<p>در اینجا، <em>Order Processor</em> مرکزی ما، که نقش <em>orchestrator</em> را ایفا می‌کند، فرآیند تکمیل ما را هماهنگ می‌کند. این می‌داند که چه <em>services</em> برای انجام عملیات مورد نیاز است، و تصمیم می‌گیرد که چه زمانی <em>calls</em> را به آن <em>services</em> انجام دهد. اگر <em>calls</em> شکست بخورند، می‌تواند تصمیم بگیرد که در نتیجه چه کاری انجام دهد. به طور کلی، <em>orchestrated sagas</em> تمایل به استفاده سنگین از تعاملات <em>request-response</em> بین <em>services</em> دارند: <em>Order Processor</em> یک <em>request</em> را به <em>services</em> (مانند <em>Payment Gateway</em>) ارسال می‌کند و انتظار دارد که یک <em>response</em> دریافت کند تا به آن اطلاع دهد که آیا <em>request</em> موفقیت‌آمیز بوده است و نتایج <em>request</em> را ارائه دهد.
  <p>داشتن فرآیند کسب‌وکار ما که صریحاً در داخل <em>Order Processor</em> مدل‌سازی شده است، بسیار مفید است. این به ما امکان می‌دهد تا به یک مکان در سیستم خود نگاه کنیم و بفهمیم که این فرآیند چگونه قرار است کار کند. این می‌تواند ورود افراد جدید را آسان‌تر کند و به ایجاد درک بهتری از بخش‌های اصلی سیستم کمک کند.
  <p>با این حال، چند نقطه ضعف نیز وجود دارد که باید در نظر گرفته شوند. اول، این به دلیل ماهیت خود، یک رویکرد تا حدودی <em>coupled</em> است. <em>Order Processor</em> ما باید در مورد همه <em>services</em> مرتبط بداند، که منجر به درجه بالاتری از <em>domain coupling</em> می‌شود. در حالی که <em>domain coupling</em> ذاتاً بد نیست، ما همچنان می‌خواهیم آن را تا حد امکان به حداقل برسانیم. در اینجا، <em>Order Processor</em> ما باید در مورد چیزهای زیادی بداند و آن‌ها را کنترل کند، که این شکل از <em>coupling</em> را دشوار می‌کند.
  <p>مسئله دیگر، که ظریف‌تر است، این است که منطقی که در غیر این صورت باید به <em>services</em> منتقل شود، می‌تواند به جای آن شروع به جذب در <em>orchestrator</em> کند. اگر این اتفاق شروع به رخ دادن کند، ممکن است متوجه شوید که <em>services</em> شما <em>anemic</em> می‌شوند، با رفتار کمی از خودشان، فقط از <em>orchestrators</em> مانند <em>Order Processor</em> دستور می‌گیرند. این است</p>
</p></p></p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 216" src="page_0216/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0216</div>
            </div>
        </div>
        <!-- Page 0217 -->
        <div class="chapter" id="page-0217">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>مهم است که شما همچنان <em>services</em> را که این جریان‌های <em>orchestrated</em> را تشکیل می‌دهند، به عنوان موجودیت‌هایی که <em>local state</em> و رفتار خود را دارند، در نظر بگیرید. آن‌ها مسئول <em>local state machines</em> خود هستند.</p>
<p>اگر منطق جایی دارد که می‌تواند متمرکز شود، متمرکز خواهد شد!</p>
<p>یک راه برای اجتناب از تمرکز بیش از حد با جریان‌های <em>orchestrated</em>، اطمینان از این است که <em>services</em> مختلف نقش <em>orchestrator</em> را برای جریان‌های مختلف ایفا می‌کنند. شما ممکن است یک <em>Order Processor microservice</em> داشته باشید که سفارش را مدیریت می‌کند، یک <em>Returns microservice</em> برای مدیریت فرآیند بازگشت و بازپرداخت، یک <em>Goods Receiving microservice</em> که ورود سهام جدید و قرار دادن آن در قفسه‌ها را مدیریت می‌کند، و غیره. چیزی مانند <em>Warehouse microservice</em> ما ممکن است توسط همه آن <em>orchestrators</em> استفاده شود؛ چنین مدلی به شما این امکان را می‌دهد که عملکرد را در خود <em>Warehouse microservice</em> نگه دارید، و به شما امکان می‌دهد تا عملکرد را در همه آن جریان‌ها دوباره استفاده کنید.</p>
<h4>BPM Tools</h4>
<p>ابزارهای <em>business process modeling (BPM)</em> سال‌هاست که در دسترس هستند. به طور کلی، آن‌ها برای این طراحی شده‌اند که به غیرتوسعه‌دهندگان اجازه دهند جریان‌های فرآیند تجاری را تعریف کنند، که اغلب از ابزارهای بصری <em>drag-and-drop</em> استفاده می‌کنند. ایده این است که توسعه‌دهندگان بلوک‌های ساختمانی این فرآیندها را ایجاد می‌کنند، و سپس غیرتوسعه‌دهندگان این بلوک‌های ساختمانی را به هم متصل می‌کنند تا جریان‌های فرآیند بزرگ‌تری را ایجاد کنند. به نظر می‌رسد استفاده از چنین ابزارهایی، واقعاً به خوبی با راهی برای پیاده‌سازی <em>orchestrated sagas</em> مطابقت دارد، و در واقع، <em>process orchestration</em> تقریباً مورد استفاده اصلی ابزارهای <em>BPM</em> است (یا، برعکس، استفاده از ابزارهای <em>BPM</em> منجر به این می‌شود که شما باید <em>orchestration</em> را اتخاذ کنید).</p>
<p>در تجربه من، من بسیار از ابزارهای <em>BPM</em> متنفر شده‌ام. دلیل اصلی این است که <em>central conceit</em>—که غیرتوسعه‌دهندگان، فرآیند تجاری را تعریف خواهند کرد—در تجربه من تقریباً هرگز درست نبوده است. <em>Tooling</em> با هدف قرار دادن غیرتوسعه‌دهندگان، در نهایت توسط توسعه‌دهندگان استفاده می‌شود، و متأسفانه این ابزارها اغلب به روش‌هایی کار می‌کنند که با نحوه عملکرد توسعه‌دهندگان ناسازگار است. آن‌ها اغلب به استفاده از <em>GUIs</em> برای تغییر جریان‌ها نیاز دارند، جریان‌هایی که ایجاد می‌کنند ممکن است دشوار (یا غیرممکن) باشد که کنترل <em>version</em> شوند، خود جریان‌ها ممکن است با <em>testing</em> طراحی نشده باشند، و موارد دیگر.</p>
<p>اگر توسعه‌دهندگان شما قصد دارند فرآیندهای تجاری شما را پیاده‌سازی کنند، به آن‌ها اجازه دهید از <em>tooling</em> استفاده کنند که آن‌ها می‌دانند و درک می‌کنند و برای <em>workflows</em> آن‌ها مناسب است. به طور کلی، این به معنای این است که فقط به آن‌ها اجازه دهید از کد برای پیاده‌سازی این موارد استفاده کنند! اگر شما نیاز به دید به نحوه پیاده‌سازی یک فرآیند تجاری یا نحوه عملکرد آن دارید، در این صورت، بسیار آسان‌تر است که یک نمایش بصری از یک <em>workflow</em> را از کد ارائه دهید تا اینکه از یک نمایش بصری از <em>workflow</em> خود برای توصیف نحوه عملکرد کد خود استفاده کنید.</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 217" src="page_0217/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0217</div>
            </div>
        </div>
        <!-- Page 0218 -->
        <div class="chapter" id="page-0218">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>تلاش‌هایی برای ایجاد ابزارهای <em>BPM</em> که بیشتر برای توسعه‌دهندگان مناسب هستند، وجود دارد. به نظر می‌رسد که بازخورد توسعه‌دهندگان در مورد این ابزارها متفاوت است، اما این ابزارها برای برخی خوب عمل کرده‌اند، و دیدن تلاش افراد برای بهبود این فریم‌ورک‌ها خوب است. اگر احساس می‌کنید که نیاز به بررسی بیشتر این ابزارها دارید، به <em>Camunda</em> و <em>Zeebe</em> نگاهی بیندازید، که هر دو فریم‌ورک‌های <em>open source orchestration</em> هستند که توسعه‌دهندگان <em>microservice</em> را هدف قرار می‌دهند، و اگر من تصمیم می‌گرفتم که یک ابزار <em>BPM</em> برای من مناسب است، در صدر لیست من قرار می‌گرفتند.</p>
<h4>Choreographed sagas</h4>
<p>یک <em>choreographed saga</em> با هدف توزیع مسئولیت عملیات <em>saga</em> در میان چندین <em>collaborating services</em> است. اگر <em>orchestration</em> یک رویکرد <em>command-and-control</em> است، <em>choreographed sagas</em> یک معماری <em>trust-but-verify</em> را نشان می‌دهد. همانطور که در مثال ما در شکل 6-10 خواهیم دید، <em>choreographed sagas</em> اغلب از <em>events</em> برای همکاری بین <em>services</em> استفاده می‌کنند.
  <p>شکل 6-10. نمونه‌ای از یک <em>choreographed saga</em> برای پیاده‌سازی تکمیل سفارش</p>
<p>در اینجا اتفاقات زیادی در حال رخ دادن است، بنابراین ارزش دارد که با جزئیات بیشتری آن را بررسی کنیم. اولاً، این <em>microservices</em> در حال واکنش به <em>events</em> دریافتی هستند. از نظر مفهومی، <em>events</em> در سیستم <em>broadcast</em> می‌شوند، و طرف‌های ذینفع می‌توانند آن‌ها را دریافت کنند. به یاد داشته باشید، همانطور که در فصل 4 بحث کردیم، شما <em>events</em> را به یک <em>microservice</em> ارسال نمی‌کنید؛ شما فقط آن‌ها را <em>fire</em> می‌کنید، و <em>microservices</em> که به این <em>events</em> علاقه‌مند هستند، می‌توانند آن‌ها را دریافت کرده و بر این اساس عمل کنند. در مثال ما، هنگامی که <em>Warehouse service</em>، اولین</p>
</p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 218" src="page_0218/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0218</div>
            </div>
        </div>
        <!-- Page 0219 -->
        <div class="chapter" id="page-0219">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>Order Placed event</em>، می‌داند که وظیفه آن رزرو سهام مناسب و <em>fire</em> کردن یک <em>event</em> پس از اتمام آن است. اگر سهام قابل دریافت نباشد، <em>Warehouse</em> باید یک <em>event</em> مناسب (شاید یک <em>Insufficient Stock event</em>) را مطرح کند، که ممکن است منجر به لغو سفارش شود.</p>
<p>ما همچنین در این مثال می‌بینیم که چگونه <em>events</em> می‌توانند پردازش موازی را تسهیل کنند. وقتی <em>Payment Taken event</em> توسط <em>Payment Gateway</em> فعال می‌شود، باعث واکنش‌هایی در هر دو <em>Loyalty</em> و <em>Warehouse microservices</em> می‌شود. <em>Warehouse</em> با ارسال بسته واکنش نشان می‌دهد، در حالی که <em>Loyalty microservice</em> با اعطای امتیازات واکنش نشان می‌دهد.
  <p>به طور معمول، شما از نوعی <em>message broker</em> برای مدیریت پخش و تحویل قابل اعتماد <em>events</em> استفاده می‌کنید. این امکان وجود دارد که چندین <em>microservices</em> به یک <em>event</em> یکسان واکنش نشان دهند، و اینجاست که شما از یک <em>topic</em> استفاده می‌کنید. طرف‌های علاقه‌مند به یک نوع خاص از <em>event</em> در یک <em>topic</em> خاص مشترک می‌شوند، بدون اینکه نیازی به نگرانی در مورد منشأ این <em>events</em> داشته باشند، و <em>broker</em>، دوام <em>topic</em> و این که <em>events</em> روی آن با موفقیت به مشترکان تحویل داده می‌شوند، را تضمین می‌کند. به عنوان مثال، ما ممکن است یک <em>Recommendation service</em> داشته باشیم که همچنین به <em>Order Placed events</em> گوش می‌دهد و از آن برای ساخت یک <em>database</em> از انتخاب‌های موسیقی که ممکن است دوست داشته باشید، استفاده می‌کند.</p>
<p>در معماری قبلی، هیچ <em>service</em>، در مورد هیچ <em>microservice</em> دیگری چیزی نمی‌داند. آن‌ها فقط باید بدانند که وقتی یک <em>event</em> خاص دریافت می‌شود، چه کاری انجام دهند—ما مقدار <em>domain coupling</em> را به شدت کاهش داده‌ایم. ذاتاً، این امر یک معماری بسیار کمتر <em>coupled</em> ایجاد می‌کند. از آنجایی که پیاده‌سازی فرآیند در اینجا در میان سه <em>microservices</em> توزیع و تجزیه شده است، ما همچنین از نگرانی در مورد تمرکز <em>logic</em> اجتناب می‌کنیم (اگر شما مکانی برای متمرکز کردن <em>logic</em> ندارید، پس متمرکز نخواهد شد!).</p>
<p>نقطه مقابل این است که می‌تواند کار کردن روی آنچه در حال رخ دادن است، دشوارتر شود. با <em>orchestration</em>، فرآیند ما به صراحت در <em>orchestrator</em> ما مدل‌سازی شد. اکنون، با این معماری همانطور که ارائه شده است، چگونه یک مدل ذهنی از آنچه فرآیند قرار است باشد، ایجاد می‌کنید؟ شما باید به رفتار هر <em>service</em> به صورت جداگانه نگاه کنید و این تصویر را در ذهن خود بازسازی کنید—بسیار دور از ذهن، حتی با یک فرآیند تجاری ساده مانند این.</p>
<p>فقدان یک نمایش صریح از فرآیند تجاری ما به اندازه کافی بد است، اما ما همچنین راهی برای دانستن وضعیت یک <em>saga</em> نداریم، که می‌تواند ما را از فرصت ضمیمه کردن <em>compensating actions</em> در صورت نیاز محروم کند. ما می‌توانیم برخی از مسئولیت‌ها را به <em>individual services</em> برای انجام <em>compensating actions</em> منتقل کنیم، اما اساساً ما به راهی برای دانستن وضعیت یک <em>saga</em> برای برخی از انواع بازیابی نیاز داریم. فقدان مکانی مرکزی برای بازجویی در مورد وضعیت یک <em>saga</em> یک مشکل بزرگ است. ما این را با <em>orchestration</em> دریافت می‌کنیم، پس چگونه در اینجا آن را حل می‌کنیم؟</p>
<p>یکی از ساده‌ترین راه‌ها برای انجام این کار، ارائه یک دیدگاه در مورد وضعیت یک <em>saga</em> با مصرف <em>events</em> است که منتشر می‌شوند. اگر ما یک <em>ID</em> منحصر به فرد برای <em>saga</em> ایجاد کنیم، که به عنوان یک <em>correlation ID</em> شناخته می‌شود، می‌توانیم آن را در تمام <em>events</em> که منتشر می‌شوند قرار دهیم</p>
</p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0219</div>
            </div>
        </div>
        <!-- Page 0220 -->
        <div class="chapter" id="page-0220">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>6 این موضوع خارج از محدوده این کتاب است، اما <em>Hector Garcia-Molina</em> و <em>Kenneth Salem</em> به بررسی این پرداختند که چگونه می‌توان چندین <em>sagas</em> را برای پیاده‌سازی فرآیندهای پیچیده‌تر "<em>nested</em>" کرد. برای خواندن اطلاعات بیشتر در این مورد، به <em>Hector Garcia-Molina</em> و همکاران، "<em>Modeling Long-Running Activities as Nested Sagas</em>"، <em>Data Engineering</em> 14، شماره 1 (مارس 1991: 14–18) مراجعه کنید.</p>
<p>بخشی از این <em>saga</em>. هنگامی که یکی از <em>services</em> ما به یک <em>event</em> واکنش نشان می‌دهد، <em>correlation ID</em> استخراج می‌شود و برای هر فرآیند <em>local logging</em> استفاده می‌شود، و همچنین با هر <em>calls</em> یا <em>events</em> دیگری که <em>fired</em> می‌شوند، به سمت پایین منتقل می‌شود. سپس ما می‌توانیم یک <em>service</em> داشته باشیم که کار آن این است که همه این <em>events</em> را <em>vacuum up</em> کند و دیدگاهی از اینکه هر سفارش در چه وضعیتی است، ارائه دهد، و شاید به‌طور برنامه‌ریزی شده اقداماتی را برای حل مشکلات به عنوان بخشی از فرآیند تکمیل انجام دهد، اگر خود <em>services</em> نتوانند این کار را انجام دهند. من نوعی <em>correlation ID</em> را برای <em>choreographed sagas</em> مانند این ضروری می‌دانم، اما <em>correlation IDs</em> نیز به طور کلی ارزش زیادی دارند، چیزی که ما در فصل 10 با جزئیات بیشتری به آن می‌پردازیم.</p>
<h4>Mixing styles</h4>
<p>در حالی که ممکن است به نظر برسد که <em>orchestrated</em> و <em>choreographed sagas</em> دیدگاه‌های متضادی در مورد چگونگی پیاده‌سازی <em>sagas</em> دارند، شما می‌توانید به راحتی مدل‌ها را با هم ترکیب کنید. شما ممکن است برخی از فرآیندهای تجاری را در سیستم خود داشته باشید که به طور طبیعی با یک مدل یا دیگری مطابقت دارند. شما همچنین ممکن است یک <em>single saga</em> داشته باشید که ترکیبی از سبک‌ها را دارد. به عنوان مثال، در مورد استفاده از تکمیل سفارش، در داخل مرز <em>Warehouse service</em>، هنگام مدیریت بسته‌بندی و ارسال یک سفارش، ما ممکن است از یک جریان <em>orchestrated</em> استفاده کنیم، حتی اگر <em>original request</em> به عنوان بخشی از یک <em>larger choreographed saga</em> انجام شده باشد.6</p>
<p>اگر شما تصمیم به ترکیب سبک‌ها دارید، مهم است که همچنان یک راه روشن برای درک وضعیت یک <em>saga</em> و فعالیت‌هایی که قبلاً به عنوان بخشی از یک <em>saga</em> رخ داده‌اند، داشته باشید. بدون این، درک <em>failure modes</em> پیچیده می‌شود، و بازیابی از <em>failure</em> دشوار است.</p>
<h4>Tracing Calls</h4>
<p>چه <em>choreography</em> را انتخاب کرده باشید یا <em>orchestration</em>، هنگام پیاده‌سازی یک فرآیند تجاری با استفاده از چندین <em>microservices</em>، معمول است که بخواهید تمام <em>calls</em> مرتبط با فرآیند را ردیابی کنید. این می‌تواند گاهی اوقات فقط برای کمک به شما در درک اینکه آیا فرآیند تجاری به درستی کار می‌کند، یا می‌تواند به شما در تشخیص یک مشکل کمک کند.
  <p>در فصل 10 ما مفاهیمی مانند <em>correlation IDs</em> و تجمیع <em>log</em> و اینکه چگونه می‌توانند در این زمینه کمک کنند را بررسی خواهیم کرد.</p>
</p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0220</div>
            </div>
        </div>
        <!-- Page 0221 -->
        <div class="chapter" id="page-0221">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>7 <em>See Pat Helland, “Life Beyond Distributed Transactions: An Apostate’s Opinion,” acmqueue 14, no. 5
  (December 12, 2016).</em></p>
<h4>Should I use choreography or orchestration (or a mix)?</h4>
<p>پیاده‌سازی <em>choreographed sagas</em> می‌تواند ایده‌هایی را به همراه داشته باشد که ممکن است برای شما و تیم شما ناآشنا باشد. آن‌ها به‌طور معمول استفاده سنگین از همکاری <em>event-driven</em> را فرض می‌کنند، که به طور گسترده درک نشده است. با این حال، در تجربه من، پیچیدگی اضافی مرتبط با ردیابی پیشرفت یک <em>saga</em> تقریباً همیشه با مزایای مرتبط با داشتن یک معماری <em>loosely coupled</em> تر، بیش از حد است.
  <p>اما به کنار از سلیقه‌های شخصی من، توصیه‌های کلی که من در مورد <em>orchestration</em> در مقابل <em>choreography</em> ارائه می‌دهم این است که من در استفاده از <em>orchestrated sagas</em> بسیار راحت هستم، زمانی که یک تیم، مالک پیاده‌سازی کل <em>saga</em> است. در چنین موقعیتی، معماری به‌طور ذاتی <em>coupled</em>، مدیریت آن در داخل مرز تیم بسیار آسان‌تر است. اگر شما چندین تیم درگیر دارید، من <em>choreographed saga</em> را که بیشتر <em>decomposed</em> است، ترجیح می‌دهم، زیرا توزیع مسئولیت پیاده‌سازی <em>saga</em> به تیم‌ها آسان‌تر است، با معماری <em>loosely coupled</em> تر به این تیم‌ها اجازه می‌دهد تا بیشتر در انزوا کار کنند.
  <p>شایان ذکر است که به عنوان یک قاعده کلی، شما به احتمال زیاد با <em>orchestration</em> به سمت <em>request-response–based calls</em> خواهید رفت، در حالی که <em>choreography</em> تمایل دارد از <em>events</em> استفاده بیشتری داشته باشد. این یک قانون سخت نیست، فقط یک مشاهده کلی است. گرایش کلی من به سمت <em>choreography</em> احتمالاً تابعی از این واقعیت است که من تمایل دارم به سمت مدل‌های تعامل <em>event-driven</em> بروم—اگر شما استفاده از همکاری <em>event-driven</em> را برای درک آن دشوار می‌دانید، <em>choreography</em> ممکن است برای شما مناسب نباشد.</p>
<h4>Sagas Versus Distributed Transactions</h4>
<p>همانطور که امیدوارم تا به حال توضیح داده باشم، <em>distributed transactions</em> با برخی از چالش‌های قابل توجه همراه هستند، و خارج از برخی موقعیت‌های بسیار خاص، من تمایل دارم از آن‌ها اجتناب کنم. <em>Pat Helland</em>، یک پیشگام در سیستم‌های توزیع شده، چالش‌های اساسی را که با پیاده‌سازی <em>distributed transactions</em> برای انواع برنامه‌هایی که امروزه می‌سازیم، همراه است، خلاصه می‌کند:7</p>
<p>در اکثر سیستم‌های <em>distributed transaction</em>، شکست یک <em>single node</em> باعث می‌شود که <em>transaction commit</em> متوقف شود. این به نوبه خود باعث می‌شود که <em>application</em> دچار مشکل شود. در چنین سیستم‌هایی، هر چه بزرگتر شود، احتمال اینکه سیستم از کار بیفتد، بیشتر می‌شود. هنگام پرواز با هواپیمایی که نیاز دارد همه موتورهایش کار کنند، افزودن یک موتور، در دسترس بودن هواپیما را کاهش می‌دهد.</p>
</p></p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0221</div>
            </div>
        </div>
        <!-- Page 0222 -->
        <div class="chapter" id="page-0222">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>8 <em>Gregor Hohpe and Bobby Woolf, Enterprise Integration Patterns (Boston: Addison-Wesley, 2003)</em>.</p>
<p>9 <em>Bernd Ruecker, Practical Process Automation (Sebastopol: O’Reilly, 2021)</em>.</p>
<p>در تجربه من، مدل‌سازی صریح فرآیندهای تجاری به عنوان یک <em>saga</em>، از بسیاری از چالش‌های <em>distributed transactions</em> جلوگیری می‌کند، در حالی که مزیت اضافه کردن اینکه چه چیزی می‌تواند فرآیندهای مدل‌سازی ضمنی را بسیار صریح و واضح برای توسعه‌دهندگان شما کند، دارد. تبدیل فرآیندهای اصلی کسب‌وکار سیستم شما به یک مفهوم درجه یک، مزایای زیادی خواهد داشت.</p>
<h4>Summary</h4>
<p>بنابراین همانطور که می‌توانیم ببینیم، مسیر اجرای <em>workflows</em> در معماری <em>microservice</em> ما به مدل‌سازی صریح فرآیند تجاری که در تلاش برای پیاده‌سازی آن هستیم، برمی‌گردد. این ما را به ایده مدل‌سازی جنبه‌هایی از <em>business domain</em> ما در معماری <em>microservice</em> ما بازمی‌گرداند—مدل‌سازی صریح فرآیندهای تجاری، اگر مرزهای <em>microservice</em> ما نیز در درجه اول از نظر <em>business domain</em> ما تعریف شده‌اند، منطقی است.</p>
<p>اینکه شما تصمیم بگیرید که بیشتر به سمت <em>orchestration</em> یا به سمت <em>choreography</em> متمایل شوید، امیدوارم که شما در موقعیت بهتری برای دانستن این باشید که کدام مدل با فضای مشکل شما بهتر مطابقت دارد.
  <p>اگر می‌خواهید این فضا را با جزئیات بیشتری بررسی کنید، اگرچه <em>sagas</em> به‌طور صریح پوشش داده نشده‌اند، <em>Enterprise Integration Patterns</em> نوشته <em>Gregor Hohpe</em> و <em>Bobby Woolf</em> دارای تعدادی از الگوها است که می‌تواند در هنگام پیاده‌سازی انواع مختلف <em>workflow</em> فوق‌العاده مفید باشد.8 من همچنین صمیمانه <em>Practical Process Automation</em> نوشته <em>Bernd Ruecker</em> را توصیه می‌کنم.9 کتاب <em>Bernd</em>، تمرکز بیشتری بر روی جنبه <em>orchestration</em> از <em>sagas</em> دارد، اما مملو از اطلاعات مفیدی است که آن را به یک نقطه پیگیری طبیعی برای این موضوع تبدیل می‌کند.</p>
<p>اکنون ما درکی از چگونگی برقراری ارتباط و هماهنگی <em>microservices</em> خود با یکدیگر داریم، اما چگونه آن‌ها را در وهله اول بسازیم؟ در فصل بعدی، ما نگاهی به نحوه اعمال کنترل منبع، ادغام مداوم، و تحویل مداوم در زمینه یک معماری <em>microservice</em> خواهیم داشت.</p>
</p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0222</div>
            </div>
        </div>
        <!-- Page 0223 -->
        <div class="chapter" id="page-0223">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>CHAPTER 7</h3>
<h3>Build</h3>
<p>ما زمان زیادی را صرف پوشش جنبه‌های طراحی <em>microservices</em> کرده‌ایم، اما ما باید شروع به ورود به این موضوع کنیم که چگونه فرآیند توسعه شما ممکن است نیاز به تغییر داشته باشد تا این سبک جدید معماری را در خود جای دهد. در فصل‌های بعدی، ما به این نگاه خواهیم کرد که چگونه <em>microservices</em> خود را استقرار و آزمایش می‌کنیم، اما قبل از آن باید به این نگاه کنیم که چه چیزی اول می‌آید—چه اتفاقی می‌افتد وقتی یک توسعه‌دهنده تغییری را برای <em>check in</em> آماده کرده است؟</p>
<p>ما این بررسی را با بررسی برخی از مفاهیم بنیادی—<em>continuous integration</em> و <em>continuous delivery</em>—آغاز خواهیم کرد. آن‌ها مفاهیم مهمی هستند، مهم نیست که شما از چه نوع معماری سیستمی استفاده می‌کنید، اما <em>microservices</em> تعداد زیادی سؤالات منحصربه‌فرد را باز می‌کند. از آنجا ما به <em>pipelines</em> و راه‌های مختلف مدیریت <em>source code</em> برای <em>services</em> شما نگاه خواهیم کرد.</p>
<h4>A Brief Introduction to Continuous Integration</h4>
<p><em>Continuous integration (CI)</em> سال‌هاست که وجود دارد. با این حال، ارزش دارد که کمی وقت خود را صرف بررسی اصول اولیه کنیم، زیرا گزینه‌های مختلفی برای بررسی وجود دارد، به خصوص وقتی در مورد نقشه‌برداری بین <em>microservices</em>، <em>builds</em> و مخازن کنترل نسخه فکر می‌کنیم.</p>
<p>با <em>CI</em>، هدف اصلی این است که همه را با یکدیگر همگام نگه داریم، که ما با اطمینان از اینکه کد تازه وارد شده به درستی با کد موجود ادغام می‌شود، به آن دست می‌یابیم. برای انجام این کار، یک <em>CI server</em> تشخیص می‌دهد که کد <em>committed</em> شده است، آن را <em>checks out</em> می‌کند، و برخی از تأییدها را انجام می‌دهد، مانند اطمینان از اینکه کد <em>compiles</em> می‌شود و <em>tests pass</em> می‌شوند. حداقل، ما انتظار داریم که این ادغام به صورت روزانه انجام شود، اگرچه در عمل من در چندین تیم کار کرده‌ام که در آن یک توسعه‌دهنده در واقع چندین بار در روز تغییرات خود را ادغام کرده است.</p>
<p>به عنوان بخشی از این فرآیند، ما اغلب مصنوعاتی ایجاد می‌کنیم که برای اعتبارسنجی بیشتر استفاده می‌شوند، مانند استقرار یک <em>running service</em> برای اجرای <em>tests</em> در برابر آن (ما در</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0223</div>
            </div>
        </div>
        <!-- Page 0224 -->
        <div class="chapter" id="page-0224">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>در فصل 9). در حالت ایده‌آل، ما می‌خواهیم این <em>artifacts</em> را فقط یک بار بسازیم و از آن‌ها برای تمام <em>deployments</em> آن نسخه از کد استفاده کنیم. این به این دلیل است که ما می‌توانیم از انجام یک کار یکسان بارها و بارها اجتناب کنیم، و بنابراین می‌توانیم تأیید کنیم که <em>artifacts</em> که ما <em>deploy</em> می‌کنیم، همان <em>artifacts</em> هستند که ما آزمایش کرده‌ایم. برای فعال کردن این <em>artifacts</em> برای استفاده مجدد، ما آن‌ها را در نوعی <em>repository</em> قرار می‌دهیم، که یا توسط خود ابزار <em>CI</em> ارائه شده است یا در یک سیستم جداگانه.
  <p>ما به زودی به نقش <em>artifacts</em> با جزئیات بیشتری نگاه خواهیم کرد، و ما در فصل 9 با جزئیات به <em>testing</em> نگاه خواهیم کرد.</p>
<p><em>CI</em> دارای تعدادی مزیت است. ما بازخورد سریعی در مورد کیفیت کد خود، از طریق استفاده از <em>static analysis</em> و <em>testing</em> دریافت می‌کنیم. <em>CI</em> همچنین به ما امکان می‌دهد تا ایجاد <em>binary artifacts</em> خود را خودکار کنیم. تمام کدهای مورد نیاز برای ساخت <em>artifact</em>، خود کنترل نسخه است، بنابراین در صورت نیاز می‌توانیم <em>artifact</em> را دوباره ایجاد کنیم. ما همچنین می‌توانیم از یک <em>artifact</em> مستقر شده به کد ردیابی کنیم، و، بسته به قابلیت‌های خود ابزار <em>CI</em>، ما می‌توانیم ببینیم چه <em>tests</em> در کد و <em>artifact</em> نیز اجرا شده است. اگر <em>infrastructure as code</em> را اتخاذ می‌کنیم، ما همچنین می‌توانیم تمام کد مورد نیاز برای پیکربندی <em>infrastructure</em> برای <em>microservice</em> خود را در کنار کد خود <em>microservice</em> کنترل نسخه کنیم، و شفافیت را در مورد تغییرات بهبود دهیم و بازتولید <em>builds</em> را آسان‌تر کنیم. به همین دلیل است که <em>CI</em> اینقدر موفق بوده است.</p>
<h4>Are You Really Doing CI?</h4>
<p><em>CI</em> یک <em>practice</em> کلیدی است که به ما امکان می‌دهد تغییراتی را به سرعت و به راحتی ایجاد کنیم، و بدون آن، سفر به <em>microservices</em> دردناک خواهد بود. من گمان می‌کنم که شما احتمالاً از یک ابزار <em>CI</em> در سازمان خود استفاده می‌کنید، اما این ممکن است همان کاری نباشد که در واقع انجام <em>CI</em> می‌دهد. من دیده‌ام که بسیاری از افراد، استفاده از یک ابزار <em>CI</em> را با اتخاذ واقعی <em>CI</em> اشتباه می‌گیرند. یک ابزار <em>CI</em>، که به خوبی مورد استفاده قرار می‌گیرد، به شما در انجام <em>CI</em> کمک می‌کند—اما استفاده از ابزاری مانند <em>Jenkins</em>، <em>CircleCI</em>، <em>Travis</em>، یا یکی از گزینه‌های دیگر موجود در آنجا تضمین نمی‌کند که شما در واقع <em>CI</em> را به درستی انجام می‌دهید.</p>
<p>بنابراین چگونه می‌دانید که آیا شما واقعاً در حال تمرین <em>CI</em> هستید؟ من واقعاً سه سؤال <em>Jez Humble</em> را دوست دارم که از افراد می‌پرسد تا آزمایش کنند که آیا آن‌ها واقعاً درک می‌کنند <em>CI</em> چیست—ممکن است جالب باشد که از خودتان این سؤالات را بپرسید:</p>
<ul>
<li>آیا شما یک بار در روز به <em>mainline</em> <em>check in</em> می‌کنید؟</li>
<p>شما باید اطمینان حاصل کنید که کد شما ادغام می‌شود. اگر شما کد خود را همراه با تغییرات دیگران به دفعات بررسی نکنید، در نهایت ادغام‌های آینده را دشوارتر می‌کنید. حتی اگر شما از <em>short-lived branches</em> برای مدیریت تغییرات استفاده می‌کنید، تا جایی که می‌توانید در یک <em>single mainline branch</em> ادغام شوید—حداقل یک بار در روز.</p>
<li>آیا شما مجموعه‌ای از <em>tests</em> برای اعتبارسنجی تغییرات خود دارید؟</li>
<p>بدون <em>tests</em>، ما فقط می‌دانیم که از نظر نحوی ادغام ما کار کرده است، اما ما نمی‌دانیم که آیا رفتار سیستم را شکسته‌ایم یا خیر. <em>CI</em> بدون برخی از تأییدها که کد ما همانطور که انتظار می‌رود رفتار می‌کند، <em>CI</em> نیست.</p>
</ul>
</p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0224</div>
            </div>
        </div>
        <!-- Page 0225 -->
        <div class="chapter" id="page-0225">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>آیا وقتی <em>build</em> خراب است، این #1 اولویت تیم است که آن را برطرف کند؟</p>
<p>یک <em>passing green build</em> به این معنی است که تغییرات ما با خیال راحت ادغام شده‌اند. یک <em>red build</em> به این معنی است که آخرین تغییر احتمالاً ادغام نشده است. شما باید تمام <em>check-ins</em>های بعدی را که درگیر رفع <em>builds</em> نیستند، متوقف کنید تا دوباره آن را <em>passing</em> کنید. اگر اجازه دهید تغییرات بیشتری جمع شوند، زمانی که برای رفع <em>build</em> صرف می‌شود، به طرز چشمگیری افزایش می‌یابد. من با تیم‌هایی کار کرده‌ام که <em>build</em> روزها خراب بوده است، که منجر به تلاش‌های قابل توجهی برای دریافت در نهایت یک <em>passing build</em> می‌شود.</p>
<h4>Branching Models</h4>
<p>تعدادی از موضوعات پیرامون <em>build</em> و <em>deployment</em> به نظر می‌رسد که باعث ایجاد اختلاف نظر زیادی در مورد استفاده از <em>source code branching</em> برای توسعه <em>feature</em> می‌شود. <em>Branching</em> در <em>source code</em> به شما امکان می‌دهد تا توسعه را به صورت مجزا انجام دهید، بدون اینکه کار دیگران را مختل کنید. در ظاهر، ایجاد یک <em>source code branch</em> برای هر <em>feature</em> که روی آن کار می‌شود—در غیر این صورت به عنوان <em>feature branching</em> شناخته می‌شود—یک مفهوم مفید به نظر می‌رسد.
  <p>مشکل این است که وقتی شما روی یک <em>feature branch</em> کار می‌کنید، شما به‌طور منظم تغییرات خود را با دیگران ادغام نمی‌کنید. اساساً، شما ادغام را به تأخیر می‌اندازید. و وقتی در نهایت تصمیم به ادغام تغییرات خود با دیگران می‌گیرید، یک <em>merge</em> بسیار پیچیده‌تری خواهید داشت.</p>
<p>رویکرد جایگزین این است که همه به همان "<em>trunk</em>" از <em>source code</em> وارد شوند. برای جلوگیری از تأثیر تغییرات بر افراد دیگر، از تکنیک‌هایی مانند <em>feature flags</em> برای "پنهان کردن" کار ناتمام استفاده می‌شود. این تکنیک که همه از یک <em>trunk</em> یکسان کار می‌کنند، توسعه مبتنی بر <em>trunk</em> نامیده می‌شود.
  <p>بحث در مورد این موضوع ظریف است، اما برداشت من این است که مزایای ادغام مکرر—و اعتبارسنجی آن ادغام—به اندازه‌ای قابل توجه است که توسعه مبتنی بر <em>trunk</em>، سبک توسعه ترجیحی من است. علاوه بر این، کار برای پیاده‌سازی <em>feature flags</em>، اغلب از نظر <em>progressive delivery</em> مفید است، مفهومی که ما در فصل 8 به آن خواهیم پرداخت.</p>
<h4>Be Careful About Branches</h4>
<p>زود ادغام کنید، و اغلب ادغام کنید. از استفاده از <em>long-lived branches</em> برای توسعه <em>feature</em> اجتناب کنید، و به جای آن توسعه مبتنی بر <em>trunk</em> را در نظر بگیرید. اگر واقعاً مجبور به استفاده از <em>branches</em> هستید، آن‌ها را کوتاه نگه دارید!</p>
</p></p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 225" src="page_0225/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0225</div>
            </div>
        </div>
        <!-- Page 0226 -->
        <div class="chapter" id="page-0226">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>1 <em>Alanna Brown, Nicole Forsgren, Jez Humble, Nigel Kersten, and Gene Kim, 2016 State of DevOps Report,
  https://oreil.ly/YqEEh.</em></p>
<p>2 <em>Nicole Forsgren, Dustin Smith, Jez Humble, and Jessie Frazelle, Accelerate: State of DevOps 2019, https://
  oreil.ly/mfkIJ.</em></p>
<p>جدا از تجربه حکایتی من، مجموعه رو به رشدی از تحقیقات وجود دارد که کارایی کاهش تعداد <em>branches</em> و اتخاذ توسعه مبتنی بر <em>trunk</em> را نشان می‌دهد. گزارش <em>2016 State of DevOps</em> توسط <em>DORA</em> و <em>Puppet1</em>، تحقیقات دقیقی را در مورد شیوه‌های تحویل سازمان‌ها در سراسر جهان انجام می‌دهد و بررسی می‌کند که کدام شیوه‌ها معمولاً توسط تیم‌های با عملکرد بالا استفاده می‌شوند:</p>
<p>ما دریافتیم که داشتن <em>branches</em> یا <em>forks</em> با طول عمر بسیار کوتاه (کمتر از یک روز) قبل از <em>merged</em> شدن به <em>trunk</em>، و در مجموع کمتر از سه <em>active branches</em>، جنبه‌های مهم <em>continuous delivery</em> هستند، و همه به عملکرد بالاتر کمک می‌کنند. همچنین ادغام کد در <em>trunk</em> یا <em>master</em> به صورت روزانه نیز همینطور است.
  <p>گزارش <em>State of DevOps</em> به کاوش بیشتر این موضوع در سال‌های بعد ادامه داده است، و به جمع‌آوری شواهدی برای کارایی این رویکرد ادامه داده است.
  <p>یک رویکرد سنگین بر اساس <em>branch</em>، هنوز هم در توسعه <em>open source</em> رایج است، که اغلب از طریق اتخاذ مدل توسعه "<em>GitFlow</em>" انجام می‌شود. شایان ذکر است که توسعه <em>open source</em>، با توسعه معمولی روزمره یکسان نیست. توسعه <em>open source</em> با تعداد زیادی مشارکت‌های <em>ad hoc</em> از سوی افراد <em>time-poor</em> "غیرقابل اعتماد" مشخص می‌شود، که تغییرات آن‌ها نیازمند بررسی توسط تعداد کمی از مشارکت‌کنندگان "قابل اعتماد" است. توسعه <em>closed source</em> معمول روزانه توسط یک تیم منسجم انجام می‌شود که همه اعضای آن دارای حقوق <em>commit</em> هستند، حتی اگر تصمیم به اتخاذ نوعی فرآیند <em>code review</em> بگیرند. بنابراین آنچه که ممکن است برای توسعه <em>open source</em> کارساز باشد، ممکن است برای شغل روزانه شما کارساز نباشد. حتی در این صورت، گزارش <em>State of DevOps</em> برای سال 2019،2 با بررسی بیشتر این موضوع، بینش‌های جالبی را در مورد توسعه <em>open source</em> و تأثیر <em>branches</em> "<em>long lived</em>" یافته است:</p>
<ul>
<li>یافته‌های تحقیقاتی ما در برخی از زمینه‌ها به توسعه <em>open source</em> گسترش می‌یابد:</li>
<ul>
<li><em>Committing code sooner</em> بهتر است: در پروژه‌های <em>open source</em>، بسیاری مشاهده کرده‌اند که <em>merging patches</em> سریع‌تر برای جلوگیری از <em>rebases</em> به توسعه‌دهندگان کمک می‌کند تا سریع‌تر حرکت کنند.</li>
<li><em>Working in small batches</em> بهتر است: <em>“Patch bombs”</em> بزرگ، سخت‌تر و کندتر در یک پروژه <em>merge</em> می‌شوند تا <em>patchsets</em> کوچک‌تر و خواناتر، زیرا <em>maintainers</em> به زمان بیشتری برای بررسی تغییرات نیاز دارند.</li>
</ul>
</ul>
<p>چه در حال کار بر روی یک <em>code base</em> با منبع بسته یا یک پروژه <em>open source</em> باشید، <em>short-lived branches</em>؛ <em>small, readable patches</em>؛ و <em>automatic testing of changes</em> همه را مولدتر می‌کند.</p>
</p></p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0226</div>
            </div>
        </div>
        <!-- Page 0227 -->
        <div class="chapter" id="page-0227">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>3 برای اطلاعات بیشتر، به <em>Jez Humble</em> و <em>David Farley, Continuous Delivery: Reliable Software Releases Through
  Build, Test, and Deployment Automation (Upper Saddle River, NJ: Addison-Wesley, 2010).</em> مراجعه کنید.</p>
<h4>Build Pipelines and Continuous Delivery</h4>
<p>در انجام <em>CI</em>، همکاران من در <em>Thoughtworks</em> و من خیلی زود متوجه ارزش داشتن چندین مرحله در داخل یک <em>build</em> شدیم. <em>Tests</em> یک مورد بسیار رایج است که در آن این موضوع وارد عمل می‌شود. من ممکن است تعداد زیادی <em>tests</em> سریع و کوچک داشته باشم، و تعداد کمی <em>tests</em> کند و بزرگ. اگر ما همه <em>tests</em> را با هم اجرا کنیم، و اگر ما منتظر بمانیم تا <em>slow tests</em> با محدوده بزرگ ما تمام شوند، ممکن است نتوانیم بازخورد سریعی را در هنگام شکست <em>fast tests</em> دریافت کنیم. و اگر <em>fast tests</em> شکست بخورند، احتمالاً دلیلی برای اجرای <em>slower tests</em> وجود ندارد! یک راه‌حل برای این مشکل این است که مراحل مختلفی در <em>build</em> خود داشته باشیم، و آنچه را که به عنوان یک <em>build pipeline</em> شناخته می‌شود، ایجاد کنیم. بنابراین ما می‌توانیم یک مرحله اختصاصی برای تمام <em>fast tests</em> داشته باشیم، که ابتدا آن را اجرا می‌کنیم، و اگر همه آن‌ها قبول شوند، سپس یک مرحله جداگانه برای <em>slower tests</em> اجرا می‌کنیم.
  <p>این مفهوم <em>build pipeline</em>، یک راه خوب برای ردیابی پیشرفت نرم‌افزار ما در حالی که هر مرحله را پاک می‌کند، به ما می‌دهد، و به ما در به‌دست آوردن بینشی در مورد کیفیت نرم‌افزارمان کمک می‌کند.
  <p>ما یک <em>deployable artifact</em>، چیزی که در نهایت در <em>production</em> مستقر می‌شود، ایجاد می‌کنیم و از این <em>artifact</em> در سراسر <em>pipeline</em> استفاده می‌کنیم. در زمینه ما، این <em>artifact</em> به یک <em>microservice</em> که می‌خواهیم مستقر کنیم، مربوط می‌شود. در شکل 7-1، ما می‌بینیم که این اتفاق می‌افتد—از همان <em>artifact</em> در هر مرحله از <em>pipeline</em> استفاده می‌شود، و این باعث می‌شود که ما به نرم‌افزار، اطمینان بیشتری داشته باشیم که در <em>production</em> کار خواهد کرد.</p>
<p>شکل 7-1. یک فرآیند انتشار ساده برای <em>Catalog service</em> ما که به عنوان یک <em>build pipeline</em> مدل‌سازی شده است</p>
<p><em>Continuous delivery (CD)</em> بر اساس این مفهوم ساخته شده است، و سپس برخی از موارد دیگر نیز. همانطور که در کتاب <em>Jez Humble</em> و <em>Dave Farley</em> با همین نام شرح داده شده است،3 <em>CD</em> رویکردی است که ما به موجب آن بازخورد مداوم را در مورد آمادگی برای تولید هر <em>check-in</em> دریافت می‌کنیم، و علاوه بر این، هر <em>check-in</em> را به عنوان یک <em>release candidate</em> در نظر می‌گیریم.
  <p>برای اینکه این مفهوم را کاملاً در خود جای دهیم، ما باید تمام فرآیندهای درگیر در دریافت نرم‌افزار خود از <em>check-in</em> تا <em>production</em> را مدل‌سازی کنیم، و ما باید بدانیم که هر نسخه از نرم‌افزار از نظر پاک شدن برای انتشار در چه وضعیتی است. در <em>CD</em>، ما این کار را با</p>
</p></p></p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 227" src="page_0227/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0227</div>
            </div>
        </div>
        <!-- Page 0228 -->
        <div class="chapter" id="page-0228">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>مدل‌سازی هر مرحله‌ای که نرم‌افزار ما باید طی کند، هم دستی و هم خودکار، که نمونه‌ای از آن را برای <em>Catalog service</em> خود در شکل 7-1 به اشتراک گذاشتم. امروزه اکثر ابزارهای <em>CI</em>، مقداری پشتیبانی برای تعریف و تجسم وضعیت <em>build pipelines</em> مانند این ارائه می‌دهند.</p>
<p>اگر <em>new Catalog service</em> از هر بررسی که در یک مرحله از <em>pipeline</em> انجام می‌شود، عبور کند، می‌تواند به مرحله بعدی برود. اگر از یک مرحله عبور نکند، ابزار <em>CI</em> ما می‌تواند به ما اطلاع دهد که <em>build</em> از کدام مراحل عبور کرده است و می‌تواند دیدی در مورد آنچه که شکست خورده است، به دست آورد. اگر ما نیاز به انجام کاری برای رفع آن داشته باشیم، یک تغییر ایجاد می‌کنیم و آن را <em>check in</em> می‌کنیم، و به نسخه جدید <em>microservice</em> خود اجازه می‌دهیم تا سعی کند از تمام مراحل عبور کند قبل از اینکه برای <em>deployment</em> در دسترس باشد. در شکل 7-2، ما نمونه‌ای از این را می‌بینیم: <em>build-120</em> در مرحله <em>fast test</em>، شکست خورد، <em>build-121</em> در <em>performance tests</em> شکست خورد، اما <em>build-122</em> تمام راه را به <em>production</em> طی کرد.</p>
<p>شکل 7-2. <em>microservice</em> کاتالوگ ما فقط در صورتی می‌تواند مستقر شود که از هر مرحله در <em>pipeline</em> ما عبور کند</p>
<h4>Continuous Delivery Versus Continuous Deployment</h4>
<p>من گاهی اوقات سردرگمی‌هایی را در مورد اصطلاحات <em>continuous delivery</em> و <em>continuous deployment</em> دیده‌ام. همانطور که قبلاً بحث کردیم، <em>continuous delivery</em> مفهومی است که به موجب آن هر <em>check-in</em> به عنوان یک <em>release candidate</em> در نظر گرفته می‌شود، و به موجب آن ما می‌توانیم کیفیت هر <em>release candidate</em> را ارزیابی کنیم تا تصمیم بگیریم که آیا برای استقرار آماده است یا خیر. از سوی دیگر، با <em>continuous deployment</em>، همه <em>check-ins</em> باید با استفاده از مکانیسم‌های خودکار (به عنوان مثال، <em>tests</em>) تأیید شوند، و هر نرم‌افزاری که از این بررسی‌های تأیید عبور کند، به طور خودکار، بدون مداخله انسانی، مستقر می‌شود. بنابراین <em>continuous deployment</em> را می‌توان یک <em>extention</em> از <em>continuous delivery</em> در نظر گرفت.</p>
<p>بدون <em>continuous delivery</em>، شما نمی‌توانید <em>continuous deployment</em> انجام دهید. اما شما می‌توانید <em>continuous delivery</em> را بدون انجام <em>continuous deployment</em> انجام دهید.
  <p><em>Continuous deployment</em> برای همه مناسب نیست—بسیاری از مردم می‌خواهند که تعامل انسانی داشته باشند تا تصمیم بگیرند که آیا نرم‌افزار باید مستقر شود یا خیر، چیزی که کاملاً با <em>continuous delivery</em> سازگار است. با این حال، اتخاذ <em>continuous delivery</em>، تمرکز مداوم بر بهینه‌سازی مسیر شما به سمت <em>production</em> را نشان می‌دهد، که دید افزایش‌یافته، ایجاد بهینه‌سازی‌ها را آسان‌تر می‌کند. اغلب، مداخله انسانی در فرآیند <em>post-check-in</em>، یک <em>bottleneck</em> است که نیاز به رسیدگی دارد—به تغییر</p>
</p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 228" src="page_0228/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0228</div>
            </div>
        </div>
        <!-- Page 0229 -->
        <div class="chapter" id="page-0229">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>برای مثال، از <em>manual regression testing</em> تا <em>automated functional testing</em>. در نتیجه، همانطور که شما فرآیند <em>build</em>، <em>deployment</em>، و <em>release</em> خود را خودکار می‌کنید، ممکن است خود را به <em>continuous deployment</em> نزدیک‌تر و نزدیک‌تر ببینید.</p>
<h4>Tooling</h4>
<p>در حالت ایده‌آل، شما به ابزاری نیاز دارید که <em>continuous delivery</em> را به عنوان یک مفهوم درجه اول در خود جای دهد. من دیده‌ام که بسیاری از افراد سعی کرده‌اند ابزارهای <em>CI</em> را هک و گسترش دهند تا آن‌ها را انجام <em>CD</em> کنند، که اغلب منجر به سیستم‌های پیچیده‌ای می‌شود که به هیچ وجه به اندازه ابزارهایی که <em>CD</em> را از ابتدا در خود ایجاد کرده‌اند، آسان نیستند. ابزارهایی که به‌طور کامل از <em>CD</em> پشتیبانی می‌کنند، به شما اجازه می‌دهند این <em>pipelines</em> را تعریف و تجسم کنید، و کل مسیر را تا <em>production</em> برای نرم‌افزار خود مدل‌سازی کنید. همانطور که یک نسخه از کد ما از طریق <em>pipeline</em> حرکت می‌کند، اگر از یکی از این مراحل اعتبارسنجی خودکار عبور کند، به مرحله بعدی می‌رود.
  <p>برخی از مراحل ممکن است دستی باشند. به عنوان مثال، اگر ما یک فرآیند <em>manual user acceptance testing (UAT)</em> داشته باشیم، من باید بتوانم از یک ابزار <em>CD</em> برای مدل‌سازی آن استفاده کنم. من می‌توانم <em>build</em> بعدی را که آماده است در محیط <em>UAT</em> ما مستقر شود، مشاهده کنم و سپس آن را مستقر کنم، و سپس اگر از بررسی‌های دستی ما عبور کند، آن مرحله را به عنوان موفقیت‌آمیز علامت‌گذاری کنم تا بتواند به مرحله بعدی برود. اگر مرحله بعدی خودکار باشد، سپس به طور خودکار فعال می‌شود.</p>
<h4>Trade-Offs and Environments</h4>
<p>همانطور که ما <em>microservice artifact</em> خود را از طریق این <em>pipeline</em> حرکت می‌دهیم، <em>microservice</em> ما در محیط‌های مختلف مستقر می‌شود. محیط‌های مختلف، اهداف متفاوتی را دنبال می‌کنند، و ممکن است ویژگی‌های متفاوتی داشته باشند.
  <p>ساختار یک <em>pipeline</em>، و بنابراین مشخص کردن محیط‌هایی که به آن‌ها نیاز دارید، یک عمل متعادل‌کننده است. در اوایل <em>pipeline</em>، ما به دنبال بازخورد سریع در مورد آمادگی <em>production</em> نرم‌افزارمان هستیم. ما می‌خواهیم در اسرع وقت به توسعه‌دهندگان اطلاع دهیم که آیا مشکلی وجود دارد—هرچه سریع‌تر در مورد بروز مشکل بازخورد دریافت کنیم، رفع آن سریع‌تر خواهد بود. همانطور که نرم‌افزار ما به <em>production</em> نزدیک‌تر می‌شود، ما اطمینان بیشتری می‌خواهیم که نرم‌افزار کار خواهد کرد، و بنابراین ما در حال استقرار در محیط‌هایی هستیم که به طور فزاینده‌ای شبیه به <em>production</em> هستند—ما می‌توانیم این <em>trade-off</em> را در شکل 7-3 ببینیم.</p>
<p>شکل 7-3. تعادل یک <em>build pipeline</em> برای بازخورد سریع و محیط‌های اجرا شبیه به <em>production</em></p>
</p></p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 229" src="page_0229/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0229</div>
            </div>
        </div>
        <!-- Page 0230 -->
        <div class="chapter" id="page-0230">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>شما سریع‌ترین بازخورد را در لپ‌تاپ توسعه خود دریافت می‌کنید—اما این بسیار دور از <em>production-like</em> است. شما می‌توانید هر <em>commit</em> را در محیطی مستقر کنید که یک بازتولید وفادارانه از محیط <em>production</em> واقعی شماست، اما احتمالاً زمان بیشتری می‌برد و هزینه‌بر خواهد بود. بنابراین یافتن تعادل کلیدی است، و ادامه بررسی <em>trade-off</em> بین بازخورد سریع و نیاز به محیط‌های <em>production-like</em> می‌تواند یک فعالیت مداوم فوق‌العاده مهم باشد.</p>
<p>چالش‌های ایجاد یک محیط <em>production-like</em> نیز بخشی از این است که چرا افراد بیشتری در حال انجام انواع <em>testing</em> در <em>production</em> هستند، از جمله تکنیک‌هایی مانند <em>smoke testing</em> و <em>parallel runs</em>. ما در فصل 8 به این موضوع باز خواهیم گشت.</p>
<h4>Artifact Creation</h4>
<p>همانطور که ما <em>microservice</em> خود را به محیط‌های مختلف منتقل می‌کنیم، در واقع باید چیزی برای <em>deploy</em> کردن داشته باشیم. مشخص می‌شود که گزینه‌های مختلفی برای نوع <em>deployment artifact</em> که می‌توانید استفاده کنید، وجود دارد. به طور کلی، این که چه <em>artifact</em> را ایجاد می‌کنید، به شدت به فناوری که برای <em>deployment</em> انتخاب کرده‌اید، بستگی دارد. ما در فصل بعد به این موضوع با جزئیات نگاه خواهیم کرد، اما من می‌خواستم چند نکته بسیار مهم در مورد چگونگی قرار گرفتن ایجاد <em>artifact</em> در فرآیند <em>CI/CD build</em> شما ارائه دهم.
  <p>برای ساده نگه داشتن همه چیز، ما دقیقاً از نوع <em>artifact</em> که ایجاد می‌کنیم صرف نظر خواهیم کرد—فقط آن را در حال حاضر یک <em>deployable blob</em> واحد در نظر بگیرید. اکنون، دو قانون مهم وجود دارد که باید در نظر بگیریم. اولاً، همانطور که قبلاً ذکر کردم، ما باید یک <em>artifact</em> را فقط یک بار بسازیم. ساختن یک چیز یکسان بارها و بارها اتلاف وقت و برای کره زمین بد است، و از نظر تئوری، می‌تواند مشکلاتی را ایجاد کند اگر پیکربندی <em>build</em> دقیقاً در هر بار یکسان نباشد. در برخی از زبان‌های برنامه‌نویسی، یک <em>build flag</em> متفاوت می‌تواند باعث شود که نرم‌افزار کاملاً متفاوت رفتار کند. ثانیاً، <em>artifact</em> که شما تأیید می‌کنید باید همان <em>artifact</em> باشد که شما <em>deploy</em> می‌کنید! اگر شما یک <em>microservice</em> را <em>build</em> می‌کنید، آن را آزمایش می‌کنید، می‌گویید "بله، در حال کار است"، و سپس دوباره آن را برای استقرار در <em>production</em> <em>build</em> می‌کنید، چگونه می‌دانید که نرم‌افزاری که اعتبارسنجی کرده‌اید، همان نرم‌افزاری است که مستقر کرده‌اید؟</p>
<p>با در نظر گرفتن این دو ایده، ما یک رویکرد کاملاً ساده داریم. <em>Build</em> <em>deployable artifact</em> خود را فقط یک بار بسازید، و در حالت ایده‌آل این کار را در اوایل <em>pipeline</em> انجام دهید. من معمولاً این کار را پس از <em>compiling</em> کد (در صورت نیاز) و اجرای <em>fast tests</em> خود انجام می‌دهم. پس از ایجاد، این <em>artifact</em> در یک <em>repository</em> مناسب ذخیره می‌شود—این می‌تواند چیزی مانند <em>Artifactory</em> یا <em>Nexus</em>، یا شاید یک <em>container registry</em> باشد. انتخاب شما از <em>deployment artifact</em> احتمالاً ماهیت <em>artifact store</em> را دیکته می‌کند. این <em>artifact</em> یکسان می‌تواند سپس برای همه مراحل در <em>pipeline</em> که دنبال می‌شود، تا و از جمله استقرار در <em>production</em>، استفاده شود. بنابراین با بازگشت به <em>pipeline</em> قبلی ما، ما می‌توانیم در شکل 7-4 ببینیم که ما یک <em>artifact</em> برای <em>Catalog service</em> خود در طول اولین مرحله از <em>pipeline</em> ایجاد می‌کنیم و سپس همان <em>build-123 artifact</em> را به عنوان بخشی از <em>slow tests</em>، <em>performance tests</em>، و مراحل <em>production</em> مستقر می‌کنیم.</p>
</p></div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0230</div>
            </div>
        </div>
        <!-- Page 0231 -->
        <div class="chapter" id="page-0231">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>شکل 7-4. همان <em>artifact</em> در هر محیط مستقر می‌شود</p>
<p>اگر قرار است از همان <em>artifact</em> در محیط‌های مختلف استفاده شود، هر جنبه‌ای از پیکربندی که از محیطی به محیط دیگر متفاوت است، باید خارج از خود <em>artifact</em> نگهداری شود. به عنوان یک مثال ساده، من ممکن است بخواهم <em>application logs</em> را طوری پیکربندی کنم که همه چیز در سطح <em>DEBUG</em> و بالاتر در هنگام اجرای مرحله <em>Slow Tests</em> ثبت شود، و اطلاعات بیشتری برای تشخیص دلیل شکست یک <em>test</em> به من بدهد. با این حال، ممکن است تصمیم بگیرم که این را به <em>INFO</em> تغییر دهم تا حجم <em>log</em> را برای <em>Performance Tests</em> و استقرار <em>Production</em> کاهش دهم.</p>
<h4>Artifact Creation Tips</h4>
<p>یک <em>deployment artifact</em> را برای <em>microservice</em> خود، فقط یک بار بسازید. از این <em>artifact</em> در هر جایی که می‌خواهید آن نسخه از <em>microservice</em> خود را مستقر کنید، مجدداً استفاده کنید. <em>deployment artifact</em> خود را <em>environment-agnostic</em> نگه دارید—پیکربندی خاص محیط را در جای دیگری ذخیره کنید.</p>
<h4>Mapping Source Code and Builds to Microservices</h4>
<p>ما قبلاً به یک موضوع نگاه کردیم که می‌تواند جناح‌های متخاصم را هیجان‌زده کند—توسعه مبتنی بر <em>feature branching</em> در مقابل <em>trunk-based</em>—اما مشخص می‌شود که این بحث برای این فصل تمام نشده است. موضوع دیگری که احتمالاً نظرات بسیار متنوعی را برمی‌انگیزد، سازماندهی کد برای <em>microservices</em> ما است. من ترجیحات خاص خودم را دارم، اما قبل از اینکه به آن‌ها بپردازیم، بیایید گزینه‌های اصلی را برای نحوه سازماندهی کد برای <em>microservices</em> خود بررسی کنیم.</p>
<h4>One Giant Repo, One Giant Build</h4>
<p>اگر ما با ساده‌ترین گزینه شروع کنیم، می‌توانیم همه چیز را با هم جمع کنیم. ما یک مخزن واحد و عظیم داریم که تمام کد ما را ذخیره می‌کند، و ما یک <em>build</em> واحد داریم، همانطور که در شکل 7-5 می‌بینیم. هر <em>check-in</em> به این مخزن کد منبع باعث می‌شود که <em>build</em> ما فعال شود،</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 231" src="page_0231/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 231" src="page_0231/image_2.png"/></div>
</div>
                <div class="page-number">صفحه 0231</div>
            </div>
        </div>
        <!-- Page 0232 -->
        <div class="chapter" id="page-0232">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>جایی که ما تمام مراحل اعتبارسنجی مرتبط با همه <em>microservices</em> خود را اجرا می‌کنیم و <em>artifacts</em> متعددی تولید می‌کنیم، که همگی به همان <em>build</em> مرتبط هستند.
  <p>شکل 7-5. استفاده از یک <em>source code repository</em> و <em>CI build</em> واحد برای همه <em>microservices</em></p>
<p>در مقایسه با رویکردهای دیگر، این کار در ظاهر بسیار ساده‌تر به نظر می‌رسد: تعداد کمتری <em>repositories</em> برای نگرانی، و یک <em>build</em> از نظر مفهومی ساده‌تر. از دیدگاه توسعه‌دهنده، همه چیز نیز کاملاً سرراست است. من فقط کد را <em>check in</em> می‌کنم. اگر مجبور باشم همزمان روی چندین <em>service</em> کار کنم، فقط باید نگران یک <em>commit</em> باشم.</p>
<p>این مدل می‌تواند کاملاً خوب کار کند اگر شما ایده <em>lockstep releases</em> را اتخاذ کنید، که در آن شما با استقرار چندین <em>services</em> به طور همزمان مشکلی ندارید. به طور کلی، این کاملاً یک الگوی اجتناب‌پذیر است، اما در مراحل اولیه یک پروژه، به خصوص اگر فقط یک تیم روی همه چیز کار می‌کند، این مدل ممکن است برای دوره‌های کوتاه مدت منطقی باشد.
  <p>اکنون اجازه دهید برخی از معایب قابل توجه این رویکرد را توضیح دهم. اگر من یک تغییر یک خطی به یک <em>single service</em> ایجاد کنم—به عنوان مثال، تغییر رفتار در <em>User service</em> در شکل 7-5—تمام <em>services</em> دیگر <em>verified</em> و <em>built</em> می‌شوند. این می‌تواند زمان بیشتری نسبت به نیاز داشته باشد—من منتظر چیزهایی هستم که احتمالاً نیازی به آزمایش ندارند. این امر بر زمان چرخه ما تأثیر می‌گذارد، سرعتی که ما می‌توانیم یک تغییر واحد را از توسعه به <em>live</em> منتقل کنیم. با این حال، مشکل‌سازتر این است که بدانیم چه <em>artifacts</em> باید یا نباید مستقر شوند. آیا اکنون باید تمام <em>build services</em> را برای انتقال تغییر کوچک خود به <em>production</em> مستقر کنم؟ تشخیص آن دشوار است؛ تلاش برای حدس زدن اینکه کدام <em>services</em> واقعاً تغییر کرده‌اند، فقط با خواندن پیام‌های <em>commit</em> دشوار است. سازمان‌هایی که از این رویکرد استفاده می‌کنند، اغلب به سادگی به استقرار همه چیز با هم روی می‌آورند، که ما واقعاً می‌خواهیم از آن اجتناب کنیم.</p>
<p>علاوه بر این، اگر تغییر یک خطی من به <em>User service</em>، <em>build</em> را خراب کند، هیچ تغییر دیگری را نمی‌توان در <em>services</em> دیگر ایجاد کرد تا زمانی که آن شکست برطرف شود. و در مورد</p>
</p></p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 232" src="page_0232/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0232</div>
            </div>
        </div>
        <!-- Page 0233 -->
        <div class="chapter" id="page-0233">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>سناریویی که در آن چندین تیم همگی در حال اشتراک این <em>giant build</em> هستند. چه کسی مسئول است؟</p>
<p>مسلماً، این رویکرد نوعی از <em>monorepo</em> است. با این حال، در عمل، اکثر پیاده‌سازی‌های <em>monorepo</em> که من دیده‌ام، چندین <em>builds</em> را به قسمت‌های مختلف <em>repo</em> نگاشت می‌کنند، که این موضوع را به زودی با جزئیات بیشتری بررسی خواهیم کرد. بنابراین شما می‌توانید این الگوی یک <em>repo</em> که به یک <em>single build</em> نگاشت می‌شود را به عنوان بدترین شکل <em>monorepo</em> برای کسانی که می‌خواهند چندین <em>microservices</em> را به طور مستقل مستقر کنند، ببینید.</p>
<p>در عمل، من تقریباً هرگز این رویکرد را استفاده نمی‌کنم، مگر در مراحل اولیه پروژه‌ها. راستش را بخواهید، هر یک از دو رویکرد زیر به طور قابل‌توجهی ترجیح داده می‌شوند، بنابراین ما به جای آن روی آن‌ها تمرکز خواهیم کرد.</p>
<h4>Pattern: One Repository per Microservice (aka Multirepo)</h4>
<p>با الگوی یک <em>repository</em> در هر <em>microservice</em> (که معمولاً وقتی با الگوی <em>monorepo</em> مقایسه می‌شود، به عنوان الگوی <em>multirepo</em> نامیده می‌شود)، کد هر <em>microservice</em> در <em>source code repository</em> خود ذخیره می‌شود، همانطور که در شکل 7-6 می‌بینیم. این رویکرد منجر به یک نگاشت مستقیم بین تغییرات <em>source code</em> و <em>CI builds</em> می‌شود.</p>
<p>شکل 7-6. <em>source code</em> هر <em>microservice</em> در یک <em>source code repository</em> جداگانه ذخیره می‌شود</p>
<p>هر تغییری در <em>User source code repository</em>، <em>build</em> مربوطه را فعال می‌کند، و اگر آن قبول شود، من یک نسخه جدید از <em>User microservice</em> خود را برای <em>deployment</em> در دسترس خواهم داشت. داشتن یک <em>repository</em> جداگانه برای هر <em>microservice</em> همچنین به شما امکان می‌دهد مالکیت را بر اساس هر <em>repository</em> تغییر دهید، چیزی که اگر می‌خواهید یک مدل مالکیت قوی برای <em>microservices</em> خود در نظر بگیرید (که به زودی بیشتر در مورد آن توضیح خواهیم داد) منطقی است.
  <p>با این حال، ماهیت سرراست این الگو، برخی از چالش‌ها را ایجاد می‌کند. به طور خاص، توسعه‌دهندگان ممکن است خود را در حال کار با چندین <em>repositories</em> به طور همزمان بیابند، که به خصوص اگر آن‌ها در تلاش برای ایجاد تغییراتی در چندین</p>
</p></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 233" src="page_0233/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0233</div>
            </div>
        </div>
        <!-- Page 0234 -->
        <div class="chapter" id="page-0234">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>4 <em>See “Managing Dependency Graphs” in Continuous Delivery, pp. 363–73.</em></p>
<p><em>repositories</em> به طور همزمان. علاوه بر این، تغییرات را نمی‌توان به صورت اتمی در سراسر <em>repositories</em> جداگانه، حداقل با <em>Git</em> ایجاد کرد.</p>
<h4>Reusing code across repositories</h4>
<p>هنگام استفاده از این الگو، هیچ چیز مانع از این نمی‌شود که یک <em>microservice</em> به کد دیگری که در <em>repositories</em> مختلف مدیریت می‌شود، وابسته باشد. یک مکانیسم ساده برای انجام این کار این است که کدی را که می‌خواهید دوباره استفاده کنید، در یک <em>library</em> بسته‌بندی کنید که سپس به یک وابستگی صریح <em>microservices</em> بالادستی تبدیل می‌شود. ما می‌توانیم نمونه‌ای از آن را در شکل 7-7 ببینیم، که در آن <em>Invoice</em> و <em>Payroll services</em> هر دو از <em>Connection library</em> استفاده می‌کنند.</p>
<p>شکل 7-7. استفاده مجدد از کد در <em>repositories</em> مختلف</p>
<p>اگر شما می‌خواستید تغییری را در <em>Connection library</em> اعمال کنید، شما باید تغییراتی را در <em>source code repository</em> مربوطه ایجاد کنید و منتظر بمانید تا <em>build</em> آن کامل شود، و یک <em>artifact</em> با نسخه جدید به شما بدهد. برای استقرار نسخه‌های جدید از <em>Invoice</em> یا <em>Payroll services</em> با استفاده از این نسخه جدید از <em>library</em>، شما باید نسخه <em>Connection library</em> را که استفاده می‌کنند، تغییر دهید. این ممکن است نیاز به یک تغییر دستی داشته باشد (اگر شما به یک نسخه خاص وابسته هستید)، یا می‌تواند برای این اتفاق به صورت پویا پیکربندی شود، که بستگی به ماهیت <em>CI tooling</em> دارد که شما استفاده می‌کنید. مفاهیم پشت این موضوع با جزئیات بیشتری در کتاب <em>Continuous Delivery</em> توسط <em>Jez Humble</em> و <em>Dave Farley</em> آمده است.4</p>
<p>البته، نکته مهم این است که اگر می‌خواهید نسخه جدید <em>Connection library</em> را راه‌اندازی کنید، پس شما همچنین باید <em>Invoice</em> و <em>Payroll services</em> تازه ساخته شده را مستقر کنید. به یاد داشته باشید، تمام هشدارهایی که ما در "<em>DRY and</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 234" src="page_0234/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0234</div>
            </div>
        </div>
        <!-- Page 0235 -->
        <div class="chapter" id="page-0235">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>خطرات استفاده مجدد از کد در دنیای <span style="color:blue">Microservice</span> ها</h3>
<p>
   عبارت "خطرات استفاده مجدد از کد در دنیای <span style="color:blue">Microservice</span> ها" در صفحه 154، در مورد استفاده مجدد و
   <span style="color:blue">Microservice</span> ها همچنان صدق می کند—اگر شما تصمیم دارید از کد از طریق کتابخانه‌ها استفاده مجدد کنید، پس باید با این واقعیت که این تغییرات نمی توانند به صورت اتمی اعمال شوند، موافق باشید، در غیر این صورت
   هدف ما در استقرار مستقل را تضعیف می کنیم. شما همچنین باید آگاه باشید که
   ممکن است دانستن اینکه آیا برخی از <span style="color:blue">Microservice</span> ها از یک نسخه خاص استفاده می کنند، چالش برانگیزتر باشد
   از یک کتابخانه، که ممکن است اگر شما در تلاش برای منسوخ کردن استفاده از یک
   نسخه قدیمی از کتابخانه.
  </p>
<h4>کار کردن در چندین <span style="color:blue">Repository</span></h4>
<p>
   بنابراین، جدا از استفاده مجدد از کد از طریق کتابخانه ها، چگونه می توانیم تغییری را در بیش از
   یک <span style="color:blue">repository</span> ایجاد کنیم؟ بیایید به مثال دیگری نگاهی بیندازیم. در شکل 7-8، من می خواهم
   API ارائه شده توسط سرویس <span style="color:blue">Inventory</span> را تغییر دهم، و همچنین باید سرویس <span style="color:blue">Shipping</span> را به روز کنم
   بنابراین می تواند از تغییر جدید استفاده کند. اگر کد برای هر دو <span style="color:blue">Inventory</span> و
   <span style="color:blue">Shipping</span> در یک <span style="color:blue">repository</span> یکسان بود، می توانستم کد را یک بار کامیت کنم. در عوض، من باید
   تغییرات را به دو <span style="color:blue">commit</span> تقسیم کنم—یکی برای <span style="color:blue">Inventory</span> و دیگری برای
   <span style="color:blue">Shipping</span>.
  </p>
<p>
<strong>شکل 7-8.</strong> تغییرات در سراسر مرزهای <span style="color:blue">repository</span> نیاز به چندین <span style="color:blue">commit</span> دارد
  </p>
<p>
   داشتن این تغییرات تقسیم شده می تواند مشکلاتی ایجاد کند اگر یک <span style="color:blue">commit</span> شکست بخورد اما دیگری
   کار می کند—ممکن است لازم باشد دو تغییر ایجاد کنم تا تغییر را بازگردانم، به عنوان مثال، و
   این می تواند پیچیده باشد اگر افراد دیگری در این بین وارد شده باشند. واقعیت این است که در این موقعیت خاص، من احتمالاً می‌خواهم
   تا حدودی <span style="color:blue">commit</span> ها را آماده کنم. من می‌خواهم مطمئن شوم که <span style="color:blue">commit</span> برای تغییر سرویس <span style="color:blue">Inventory</span> کار کرد
   قبل از اینکه هر کد <span style="color:blue">client</span> را در سرویس <span style="color:blue">Shipping</span> تغییر دهم—اگر عملکرد جدید در
   API وجود ندارد، هیچ فایده ای ندارد که کد <span style="color:blue">client</span> از آن استفاده کند.
  </p>
<p>
   من با افراد متعددی صحبت کرده ام که کمبود استقرار اتمی با این موضوع را
   یک مشکل اساسی می دانند. من مطمئناً می توانم پیچیدگی این موضوع را درک کنم، اما من
   فکر می کنم که در بیشتر موارد به یک موضوع اساسی بزرگتر اشاره دارد. اگر شما به طور مداوم
   نقشه برداری کد منبع و <span style="color:blue">Build</span> ها به <span style="color:blue">Microservice</span> ها
   |
   209
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 235" src="page_0235/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0235</div>
            </div>
        </div>
        <!-- Page 0236 -->
        <div class="chapter" id="page-0236">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>ایجاد تغییرات در چندین <span style="color:blue">Microservice</span></h3>
<p>
   اگر شما در حال ایجاد تغییرات در چندین <span style="color:blue">microservice</span> هستید، پس مرزهای سرویس شما ممکن است
   در جای درستی قرار نداشته باشند و این می تواند به معنای اتصال بیش از حد بین سرویس های شما باشد.
   همانطور که قبلاً بحث کردیم، ما در تلاش برای بهینه سازی معماری خود و
   مرزهای <span style="color:blue">microservice</span> خود هستیم، به طوری که تغییرات به احتمال زیاد در
   مرز یک <span style="color:blue">microservice</span> اعمال می شوند. تغییرات متقاطع باید استثنا باشد، نه
   قاعده.
  </p>
<p>
   در واقع، من استدلال می کنم که درد کار در چندین <span style="color:blue">repo</span> می تواند در کمک به
   اعمال مرزهای <span style="color:blue">microservice</span> مفید باشد، زیرا شما را مجبور می کند که با دقت در مورد جایی که
   این مرزها هستند و در مورد ماهیت تعاملات بین آنها فکر کنید.
  </p>
<p>
   اگر شما به طور مداوم در حال ایجاد تغییرات در چندین <span style="color:blue">microservi</span> -
   ces هستید، احتمالاً مرزهای <span style="color:blue">microservice</span> شما در جای اشتباهی هستند.
   ممکن است ارزش داشته باشد که ادغام <span style="color:blue">microservice</span> ها را در نظر بگیرید
   اگر متوجه این اتفاق شدید، دوباره با هم.
  </p>
<p>
   سپس دردسر این است که باید از چندین <span style="color:blue">repo</span> بکشید و به چندین <span style="color:blue">repo</span> به عنوان بخشی از
   workflow عادی خود فشار بیاورید. در تجربه من، این را می توان ساده کرد
   یا با استفاده از یک <span style="color:blue">IDE</span> که از چندین <span style="color:blue">repository</span> پشتیبانی می کند (این چیزی است که همه
   <span style="color:blue">IDE</span> هایی که در پنج سال گذشته استفاده کرده ام می توانند مدیریت کنند) یا با نوشتن <span style="color:blue">wrapper</span> های ساده
   <span style="color:blue">script</span> ها برای ساده کردن امور هنگام کار در خط فرمان.
  </p>
<h4>از کجا این الگو را استفاده کنیم</h4>
<p>
   استفاده از رویکرد یک <span style="color:blue">repository</span> در هر <span style="color:blue">microservice</span> همانطور که برای تیم های کوچک کار می کند
   همچنین برای تیم های بزرگ نیز خوب است، اما اگر متوجه شدید که تغییرات زیادی ایجاد می کنید
   در مرزهای <span style="color:blue">microservice</span>، پس ممکن است برای شما مناسب نباشد و الگوی <span style="color:blue">monorepo</span> که ما
   در ادامه بحث می کنیم ممکن است مناسب تر باشد—اگرچه ایجاد تغییرات زیادی در سراسر سرویس
   مرزها می تواند یک علامت هشدار دهنده تلقی شود که چیزی درست نیست، همانطور که قبلاً
   بحث کردیم. همچنین می تواند استفاده مجدد از کد را پیچیده تر از استفاده از یک <span style="color:blue">monorepo</span> کند
   رویکرد، زیرا شما باید به بسته بندی کد در <span style="color:blue">artifact</span> های نسخه وابسته باشید.
  </p>
<h4>الگو: <span style="color:blue">Monorepo</span></h4>
<p>
   با رویکرد <span style="color:blue">monorepo</span>، کد برای چندین <span style="color:blue">microservice</span> (یا انواع دیگر
   پروژه ها) در یک <span style="color:blue">repository</span> کد منبع یکسان ذخیره می شود. من موقعیت هایی را دیده ام که در آن
   یک <span style="color:blue">monorepo</span> فقط توسط یک تیم برای مدیریت کنترل منبع برای همه سرویس های آن استفاده می شود،
   اگرچه این مفهوم توسط برخی از شرکت های فناوری بسیار بزرگ که در آن
   چندین تیم و صدها، اگر نگوییم هزاران، توسعه دهنده می توانند همه در یک کار کنند
   <span style="color:blue">repository</span> کد منبع یکسان.
  </p>
<p>
   با داشتن تمام کد منبع در یک <span style="color:blue">repository</span> یکسان، شما اجازه می دهید
   تغییرات کد منبع باید در چندین پروژه به صورت اتمی انجام شود و برای
   استفاده مجدد دقیق تر از کد از یک پروژه به پروژه دیگر. <span style="color:blue">Google</span> احتمالاً
   210
   |
   فصل 7: ساخت
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 236" src="page_0236/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0236</div>
            </div>
        </div>
        <!-- Page 0237 -->
        <div class="chapter" id="page-0237">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   بهترین نمونه شناخته شده از یک شرکت که از رویکرد <span style="color:blue">monorepo</span> استفاده می کند، اگرچه
   بسیار دورتر از تنها مورد است. اگرچه مزایای دیگری برای این رویکرد وجود دارد، مانند
   بهبود دید کد دیگران، توانایی استفاده مجدد از کد به راحتی و ایجاد
   تغییراتی که بر چندین پروژه مختلف تأثیر می گذارد، اغلب به عنوان دلیل اصلی برای
   اتخاذ این الگو ذکر شده است.
  </p>
<p>
   اگر مثالی را که اخیراً مورد بحث قرار دادیم در نظر بگیریم، که در آن می خواهیم تغییری در
   <span style="color:blue">Inventory</span> ایجاد کنیم تا رفتار جدیدی را ارائه دهد و همچنین سرویس <span style="color:blue">Shipping</span> را به روز کنیم
   برای استفاده از این عملکرد جدیدی که ما ارائه کرده ایم، سپس این تغییرات می توانند
   در یک <span style="color:blue">commit</span> واحد ایجاد شود، همانطور که در شکل 7-9 می بینیم.
  </p>
<p>
<strong>شکل 7-9.</strong> استفاده از یک <span style="color:blue">commit</span> واحد برای ایجاد تغییرات در دو <span style="color:blue">microservice</span> با استفاده از یک
   <span style="color:blue">monorepo</span>
</p>
<p>
   البته، مانند الگوی <span style="color:blue">multirepo</span> که قبلاً مورد بحث قرار گرفت، ما هنوز هم باید با
   سمت استقرار این کار کنیم. ما احتمالاً باید به دقت ترتیب
   استقرار را در نظر بگیریم اگر می خواهیم از استقرار <span style="color:blue">lockstep</span> اجتناب کنیم.
  </p>
<h4><span style="color:blue">Atomic Commits</span> در مقابل <span style="color:blue">Atomic Deploy</span></h4>
<p>
   توانایی ایجاد یک <span style="color:blue">commit</span> اتمی در چندین سرویس
   به شما <span style="color:blue">rollout</span> اتمی نمی دهد. اگر متوجه شدید که می خواهید
   کد را در چندین سرویس به طور همزمان تغییر دهید و آن را به
   تولید در یک زمان، این اصل اصلی را نقض می کند
   استقرار مستقل برای اطلاعات بیشتر در این مورد، به "DRY و
   خطرات استفاده مجدد از کد در دنیای <span style="color:blue">Microservice</span>" در صفحه 154 مراجعه کنید.
  </p>
<p>
   نقشه برداری کد منبع و <span style="color:blue">Build</span> ها به <span style="color:blue">Microservice</span> ها
   |
   211
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 237" src="page_0237/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 237" src="page_0237/image_2.png"/></div>
</div>
                <div class="page-number">صفحه 0237</div>
            </div>
        </div>
        <!-- Page 0238 -->
        <div class="chapter" id="page-0238">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>نقشه برداری به <span style="color:blue">Build</span></h4>
<p>
   با یک <span style="color:blue">repository</span> کد منبع واحد در هر <span style="color:blue">microservice</span>، نقشه برداری از کد منبع
   به یک فرآیند <span style="color:blue">build</span> ساده است. هر تغییری در آن <span style="color:blue">repository</span> کد منبع می تواند یک
   <span style="color:blue">build</span> <span style="color:blue">CI</span> منطبق را فعال کند. با یک <span style="color:blue">monorepo</span>، کمی پیچیده تر می شود.
  </p>
<p>
   یک نقطه شروع ساده این است که پوشه ها را در داخل <span style="color:blue">monorepo</span> به یک <span style="color:blue">build</span> نگاشت کنید، همانطور که در
   شکل 7-10 نشان داده شده است. به عنوان مثال، تغییری که در پوشه <span style="color:blue">user-service</span> ایجاد می شود،
   <span style="color:blue">build</span> سرویس <span style="color:blue">User</span> را فعال می کند. اگر کدی را وارد کرده اید که فایل ها را هم در
   پوشه <span style="color:blue">user-service</span> و هم در پوشه <span style="color:blue">catalog-service</span> تغییر داده است، سپس
   هم <span style="color:blue">build</span> <span style="color:blue">User</span> و هم <span style="color:blue">build</span> <span style="color:blue">Catalog</span> فعال می شوند.
  </p>
<p>
<strong>شکل 7-10.</strong> یک <span style="color:blue">repo</span> منبع واحد با زیرشاخه هایی که به <span style="color:blue">build</span> های مستقل نگاشت شده اند
  </p>
<p>
   این موضوع با داشتن ساختارهای پوشه پیچیده تر، پیچیده تر می شود. در بزرگتر
   پروژه ها می توانید با چندین پوشه مختلف که می خواهند همان
   <span style="color:blue">build</span> را فعال کنید، و با برخی از پوشه ها که بیش از یک <span style="color:blue">build</span> را فعال می کنند. در انتهای ساده
   طیف، ممکن است یک پوشه "مشترک" داشته باشید که توسط همه <span style="color:blue">microservice</span> ها استفاده می شود، تغییری به
   آن باعث می شود که همه <span style="color:blue">microservice</span> ها دوباره ساخته شوند. در انتهای پیچیده تر، تیم ها پایان می یابند
   نیاز به اتخاذ ابزارهای <span style="color:blue">build</span> مبتنی بر گراف بیشتر مانند ابزار منبع باز <span style="color:blue">Bazel</span> برای
   مدیریت این وابستگی ها به طور موثرتر ( <span style="color:blue">Bazel</span> یک نسخه منبع باز از
   ابزار <span style="color:blue">build</span> داخلی خود گوگل است). اجرای یک سیستم <span style="color:blue">build</span> جدید می تواند یک
   تعهد قابل توجه، بنابراین چیزی نیست که باید سبک انجام شود—اما خود <span style="color:blue">mono</span>-
   <span style="color:blue">repo</span> گوگل بدون ابزارهایی مانند این غیرممکن خواهد بود.
  </p>
<p>
   یکی از مزایای رویکرد <span style="color:blue">monorepo</span> این است که می توانیم استفاده مجدد دقیق تری را در
   پروژه ها انجام دهیم. با یک مدل <span style="color:blue">multirepo</span>، اگر بخواهم از کد شخص دیگری استفاده مجدد کنم،
   احتمالاً باید به عنوان یک <span style="color:blue">artifact</span> نسخه بندی شده بسته بندی شود که می توانم آن را به عنوان بخشی از
   <span style="color:blue">build</span> خود (مانند یک بسته <span style="color:blue">Nuget</span>، یک فایل <span style="color:blue">JAR</span> یا یک <span style="color:blue">NPM</span>) قرار دهم. با واحد استفاده مجدد ما
   کتابخانه بودن، ما به طور بالقوه کد بیشتری را نسبت به آنچه واقعاً می خواهیم، وارد می کنیم.
   از لحاظ تئوری، با یک <span style="color:blue">monorepo</span> من فقط می توانم به یک فایل منبع واحد از یک
  </p>
<p>
   212
   |
   فصل 7: ساخت
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 238" src="page_0238/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0238</div>
            </div>
        </div>
        <!-- Page 0239 -->
        <div class="chapter" id="page-0239">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   پروژه — اگرچه این البته باعث می شود که من نقشه برداری <span style="color:blue">build</span> پیچیده تری داشته باشم.
  </p>
<h4>تعریف مالکیت</h4>
<p>
   با اندازه تیم های کوچکتر و اندازه کدبیس های کوچک، <span style="color:blue">monorepo</span> ها احتمالاً می توانند به خوبی
   با ابزارهای سنتی مدیریت <span style="color:blue">build</span> و کد منبع که به آن ها عادت کرده اید، کار کنند.
   با این حال، با بزرگتر شدن <span style="color:blue">monorepo</span> شما، احتمالاً باید شروع به نگاه کردن به موارد مختلف کنید
   انواع ابزارها. ما مدل های مالکیت را با جزئیات بیشتر در فصل 15 بررسی خواهیم کرد، اما در
   در این میان، ارزش دارد که به طور خلاصه نحوه عملکرد این موضوع را هنگام فکر کردن بررسی کنیم
   کنترل منبع
  </p>
<p>
<span style="color:blue">Martin Fowler</span> قبلاً در مورد مدل های مالکیت مختلف نوشته است و یک
   مقیاس لغزنده از مالکیت از مالکیت قوی از طریق مالکیت ضعیف و به
   مالکیت جمعی. از آنجایی که <span style="color:blue">Martin</span> این اصطلاحات را ثبت کرده است، شیوه های توسعه
   تغییر کرده اند، بنابراین شاید ارزش داشته باشد که این اصطلاحات را دوباره بررسی و تعریف کنیم.
  </p>
<p>
   با مالکیت قوی، مقداری کد متعلق به یک گروه خاص از افراد است. اگر مقداری
   از خارج از آن گروه می خواهد تغییری ایجاد کند، باید از صاحبان درخواست کنند که
   تغییر را برای آنها ایجاد کنید. مالکیت ضعیف هنوز مفهوم صاحبان تعریف شده را دارد،
   اما به افرادی که خارج از گروه مالکیت هستند اجازه داده می شود که تغییراتی ایجاد کنند، اگرچه هر
   از این تغییرات باید توسط شخصی در گروه مالکیت بررسی و پذیرفته شود.
   این درخواست <span style="color:blue">pull</span> را پوشش می دهد که برای بررسی به تیم اصلی مالکیت ارسال می شود،
   قبل از اینکه درخواست <span style="color:blue">pull</span> ادغام شود. با مالکیت جمعی، هر توسعه دهنده می تواند
   هر قطعه کد را تغییر دهید.
  </p>
<p>
   با تعداد کمی از توسعه دهندگان (20 یا کمتر، به عنوان یک راهنمای کلی)، می توانید
   از مالکیت جمعی استفاده کنید - جایی که هر توسعه دهنده می تواند هر <span style="color:blue">micro</span>-
   <span style="color:blue">service</span>. با این حال، با داشتن افراد بیشتر، احتمالاً می خواهید به سمت آن حرکت کنید
   یا یک مدل مالکیت قوی یا ضعیف برای ایجاد مرزهای تعریف شده تر
   مسئولیت. این می تواند یک چالش برای تیم هایی که از <span style="color:blue">monorepo</span> استفاده می کنند ایجاد کند، اگر منبع آنها
   ابزار کنترل از کنترل های مالکیت دقیق تر پشتیبانی نمی کند.
  </p>
<p>
   برخی از ابزارهای کد منبع به شما اجازه می دهند مالکیت دایرکتوری های خاص یا حتی
   مسیرهای فایل خاص را در داخل یک <span style="color:blue">repository</span> واحد مشخص کنید. <span style="color:blue">Google</span> در ابتدا این سیستم را پیاده سازی کرد
   در بالای <span style="color:blue">Perforce</span> برای <span style="color:blue">monorepo</span> خود قبل از توسعه کنترل منبع خود
   سیستم، و این همچنین چیزی است که <span style="color:blue">GitHub</span> از سال 2016 از آن پشتیبانی می کند. با <span style="color:blue">GitHub</span>،
   شما یک فایل <span style="color:blue">CODEOWNERS</span> ایجاد می کنید، که به شما امکان می دهد صاحبان را به دایرکتوری ها یا مسیرهای فایل نگاشت کنید.
   می توانید چند نمونه را در مثال 7-1 ببینید که از سند خود <span style="color:blue">GitHub</span> گرفته شده است
   که نشان می دهد این نوع سیستم ها چه انعطاف پذیری را می توانند به ارمغان بیاورند.
  </p>
<p>
   نقشه برداری کد منبع و <span style="color:blue">Build</span> ها به <span style="color:blue">Microservice</span> ها
   |
   213
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0239</div>
            </div>
        </div>
        <!-- Page 0240 -->
        <div class="chapter" id="page-0240">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   5 <span style="color:blue">Rachel Potvin</span> و <span style="color:blue">Josh Levenberg</span>، "چرا <span style="color:blue">Google</span> میلیاردها خط کد را در یک <span style="color:blue">Repository</span> واحد ذخیره می کند"،
   ارتباطات <span style="color:blue">ACM</span> 59، شماره 7 (ژوئیه 2016): 78–87.
  </p>
<p>
<strong>مثال 7-1.</strong> نمونه هایی از نحوه مشخص کردن مالکیت در دایرکتوری های خاص در یک <span style="color:blue">GitHub</span>
   فایل <span style="color:blue">CODEOWNERS</span>
</p>
<p>
<span style="color:blue"># In this example, @doctocat owns any files in the build/logs
   # directory at the root of the repository and any of its
   # subdirectories.
   /build/logs/ @doctocat</span>
</p>
<p>
<span style="color:blue"># In this example, @octocat owns any file in an apps directory
   # anywhere in your repository.
   apps/ @octocat
   # In this example, @doctocat owns any file in the /docs
   # directory in the root of your repository.
   /docs/ @doctocat</span>
</p>
<p>
   مفهوم مالکیت کد خود <span style="color:blue">GitHub</span> تضمین می کند که صاحبان کد برای فایل های منبع هستند
   هر زمان که یک درخواست <span style="color:blue">pull</span> برای فایل های مربوطه مطرح می شود، برای بررسی درخواست می شود. این می تواند
   مشکل با درخواست های <span style="color:blue">pull</span> بزرگتر، زیرا می توانید نیاز به تأیید از
   چندین بازبین، اما دلایل خوبی برای هدف قرار دادن درخواست های <span style="color:blue">pull</span> کوچکتر وجود دارد،
   در هر صورت.
  </p>
<h4>ابزارها</h4>
<p>
<span style="color:blue">monorepo</span> خود <span style="color:blue">Google</span> عظیم است و مقدار قابل توجهی مهندسی می طلبد
   برای کار در مقیاس. مواردی مانند یک سیستم <span style="color:blue">build</span> مبتنی بر گراف را در نظر بگیرید که داشته است
   نسل های متعددی را طی کرد، یک <span style="color:blue">linker</span> شیء توزیع شده برای سرعت بخشیدن به ساخت
   زمان‌ها، <span style="color:blue">plug-in</span> ها برای <span style="color:blue">IDE</span> ها و ویرایشگرهای متن که می‌توانند به طور پویا فایل‌های وابستگی را
   در بررسی—این مقدار زیادی کار است. با رشد <span style="color:blue">Google</span>، به طور فزاینده ای به آن ضربه زد
   محدودیت هایی در استفاده از <span style="color:blue">Perforce</span> و در نهایت مجبور به ایجاد اختصاصی خود شد
   ابزار کنترل منبع به نام <span style="color:blue">Piper</span>. وقتی در سال 2007–2008 در این بخش از <span style="color:blue">Google</span> کار می کردم،
   بیش از صد نفر ابزارهای مختلف توسعه دهندگان را نگهداری می کردند، با
   بخش مهمی از این تلاش برای رسیدگی به پیامدهای <span style="color:blue">monorepo</span>
   رویکرد. این چیزی است که شما می توانید آن را توجیه کنید اگر ده ها هزار <span style="color:blue">engi</span> -
   <span style="color:blue">neers</span>، البته.
  </p>
<p>
   برای یک مرور کلی تر از منطق پشت استفاده <span style="color:blue">Google</span> از یک <span style="color:blue">monorepo</span>، من
   توصیه می کنم "چرا <span style="color:blue">Google</span> میلیاردها خط کد را در یک <span style="color:blue">Repository</span> واحد ذخیره می کند" توسط
   <span style="color:blue">Rachel Potvin</span> و <span style="color:blue">Josh Levenberg</span>.5 در واقع، من پیشنهاد می کنم که خواندن آن برای هر
   کسی که فکر می کند، "ما باید از یک <span style="color:blue">monorepo</span> استفاده کنیم، زیرا <span style="color:blue">Google</span> انجام می دهد!" سازمان شما
   احتمالاً <span style="color:blue">Google</span> نیست و احتمالاً مشکلات، محدودیت های نوع <span style="color:blue">Google</span> را ندارد،
   214
   |
   فصل 7: ساخت
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0240</div>
            </div>
        </div>
        <!-- Page 0241 -->
        <div class="chapter" id="page-0241">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   6 تاریخچه طراحی سیستم فایل مجازی <span style="color:blue">Git</span> را ببینید.
   یا منابع. به عبارت دیگر، هر <span style="color:blue">monorepo</span> که در نهایت به آن می رسید احتمالاً نخواهد بود
   <span style="color:blue">Google</span> است.
  </p>
<p>
<span style="color:blue">Microsoft</span> مشکلات مشابهی را با مقیاس تجربه کرد. این <span style="color:blue">Git</span> را برای کمک به مدیریت اتخاذ کرد
   <span style="color:blue">repository</span> کد منبع اصلی برای ویندوز. یک فهرست کاری کامل برای این کدبیس
   حدود 270 گیگابایت از فایل های منبع است.6 دانلود همه اینها زمان زیادی می برد و
   همچنین ضروری نیست - توسعه دهندگان در نهایت فقط روی یک قسمت کوچک از
   سیستم کلی. بنابراین <span style="color:blue">Microsoft</span> مجبور شد یک سیستم فایل مجازی اختصاصی، <span style="color:blue">VFS</span> برای <span style="color:blue">Git</span> ایجاد کند
   (قبلاً به عنوان <span style="color:blue">GVFS</span> شناخته می شد)، که تضمین می کند فقط فایل های منبع مورد نیاز یک توسعه دهنده
   واقعاً دانلود می شوند.
  </p>
<p>
<span style="color:blue">VFS</span> برای <span style="color:blue">Git</span> یک موفقیت چشمگیر است، همانطور که زنجیره ابزار <span style="color:blue">Google</span> است، اگرچه
   توجیه این نوع سرمایه گذاری ها در این نوع فناوری برای شرکت هایی مانند این بسیار آسان تر است.
   همچنین شایان ذکر است که اگرچه <span style="color:blue">VFS</span> برای <span style="color:blue">Git</span> منبع باز است،
   من هنوز با تیمی خارج از <span style="color:blue">Microsoft</span> ملاقات نکرده ام که از آن استفاده کند - و حجم عظیمی از <span style="color:blue">Google</span>
   زنجیره ابزار پشتیبانی از <span style="color:blue">monorepo</span> خود منبع بسته است (<span style="color:blue">Bazel</span> یک استثنای قابل توجه است، اما
   مشخص نیست که <span style="color:blue">Bazel</span> منبع باز واقعاً تا چه حد منعکس کننده چیزی است که در داخل استفاده می شود
   خود <span style="color:blue">Google</span>).
  </p>
<p>
   قطعه <span style="color:blue">Markus Oberlehner</span> "Monorepos in the Wild" <span style="color:blue">Lerna</span> را به من معرفی کرد، ابزاری
   ایجاد شده توسط تیمی که پشت کامپایلر <span style="color:blue">Babel JavaScript</span> قرار دارد. <span style="color:blue">Lerna</span> برای ساختن طراحی شده است
   تولید چندین <span style="color:blue">artifact</span> نسخه بندی شده از همان <span style="color:blue">repository</span> کد منبع آسان تر است.
   من نمی توانم مستقیماً در مورد اینکه <span style="color:blue">Lerna</span> در این کار چقدر موثر است صحبت کنم (علاوه بر شماره
   از دیگر کاستی های قابل توجه، من یک توسعه دهنده با تجربه <span style="color:blue">JavaScript</span> نیستم)، اما
   به نظر می رسد از یک بررسی سطحی این رویکرد را تا حدودی ساده می کند.
  </p>
<h4>چگونه "تک" است تک؟</h4>
<p>
<span style="color:blue">Google</span> همه کد خود را در یک <span style="color:blue">monorepo</span> ذخیره نمی کند. برخی از پروژه ها وجود دارند، به خصوص
   آنهایی که در حال توسعه در فضای باز هستند، در جای دیگری نگهداری می شوند. با این وجود، حداقل
   بر اساس مقاله <span style="color:blue">ACM</span> قبلی، 95٪ از کد <span style="color:blue">Google</span> در
   <span style="color:blue">monorepo</span> از سال 2016. در سازمان های دیگر، یک <span style="color:blue">monorepo</span> ممکن است فقط به یک سیستم محدود شود یا
   به تعداد کمی از سیستم ها. این بدان معناست که یک شرکت می تواند داشته باشد
   تعداد کمی <span style="color:blue">monorepo</span> برای بخش های مختلف سازمان.
  </p>
<p>
   من همچنین با تیم هایی صحبت کرده ام که <span style="color:blue">monorepo</span> های هر تیم را تمرین می کنند. در حالی که از نظر فنی صحبت می کنند
   این احتمالاً با تعریف اصلی این الگو مطابقت ندارد (که
   معمولاً در مورد چندین تیم صحبت می کند که همان <span style="color:blue">repository</span> را به اشتراک می گذارند)، هنوز فکر می کنم این کار را می کنم
   بیشتر "تک" از هر چیز دیگری. در این شرایط، هر تیم <span style="color:blue">mono</span> خود را دارد
   <span style="color:blue">repo</span> که کاملاً تحت کنترل آن است. تمام <span style="color:blue">microservice</span> های متعلق به آن تیم دارند
   کد در <span style="color:blue">monorepo</span> آن تیم ذخیره شده است، همانطور که در شکل 7-11 نشان داده شده است.
  </p>
<p>
   نقشه برداری کد منبع و <span style="color:blue">Build</span> ها به <span style="color:blue">Microservice</span> ها
   |
   215
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0241</div>
            </div>
        </div>
        <!-- Page 0242 -->
        <div class="chapter" id="page-0242">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<strong>شکل 7-11.</strong> یک نوع الگو که در آن هر تیم <span style="color:blue">monorepo</span> خود را دارد
  </p>
<p>
   برای تیم هایی که مالکیت جمعی را تمرین می کنند، این مدل مزایای زیادی دارد، که می توان گفت
   اکثر مزایای رویکرد <span style="color:blue">monorepo</span> را ارائه می دهد در حالی که از برخی از
   چالش هایی که در مقیاس بزرگتر رخ می دهد اجتناب می کند. این خانه نیمه راه می تواند معنای زیادی داشته باشد
   از نظر کار در محدوده های مالکیت سازمانی موجود، و می تواند
   تا حدودی نگرانی ها در مورد استفاده از این الگو در مقیاس بزرگتر را کاهش می دهد.
  </p>
<h4>از کجا این الگو را استفاده کنیم</h4>
<p>
   برخی از سازمان های فعال در مقیاس بسیار بزرگ، رویکرد <span style="color:blue">monorepo</span> را مؤثر یافته اند
   برای آنها خوب کار کنید. ما قبلاً از <span style="color:blue">Google</span> و <span style="color:blue">Microsoft</span> نام بردیم و می توانیم
   <span style="color:blue">Facebook</span>، <span style="color:blue">Twitter</span> و <span style="color:blue">Uber</span> را به لیست اضافه کنید. این سازمان ها همه یک چیز مشترک دارند - آنها هستند
   شرکت های بزرگ و متمرکز بر فناوری که قادر به اختصاص دادن سیگ هستند
   منابع قابل توجهی برای به دست آوردن بهترین نتیجه از این الگو. جایی که من <span style="color:blue">monorepo</span> ها را می بینم
   خوب کار کنید در انتهای دیگر طیف، با تعداد کمتری از توسعه دهندگان و
   تیم ها. با 10 تا 20 توسعه دهنده، مدیریت مرزهای مالکیت آسان تر است و
   فرآیند <span style="color:blue">build</span> را با رویکرد <span style="color:blue">monorepo</span> ساده نگه دارید. به نظر می رسد نقاط درد
   برای سازمان های میانی ظاهر می شود - آنهایی که مقیاس دارند تا شروع به ضربه زدن به مشکلات کنند
   که نیاز به ابزارهای جدید یا روش های کار دارد، اما بدون پهنای باند اضافی برای
   سرمایه گذاری در این ایده ها.
  </p>
<p>
   216
   |
   فصل 7: ساخت
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 242" src="page_0242/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0242</div>
            </div>
        </div>
        <!-- Page 0243 -->
        <div class="chapter" id="page-0243">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>از کدام رویکرد استفاده می کنم؟</h4>
<p>
   در تجربه من، مزایای اصلی رویکرد <span style="color:blue">monorepo</span>—استفاده مجدد دقیق تر و
   <span style="color:blue">commit</span> های اتمی - به نظر نمی رسد که بر چالش هایی که در مقیاس بزرگتر
   ظاهر می شوند، غلبه کنند. برای تیم های کوچکتر، هر دو رویکرد خوب است، اما با
   مقیاس، من احساس می کنم که رویکرد یک <span style="color:blue">repository</span> در هر <span style="color:blue">microservice</span> (چند <span style="color:blue">repo</span>)
   سرراست تر است. اساساً، من نگران تشویق به تغییرات بین سرویس ها هستم،
   خطوط مالکیت گیج کننده تر، و نیاز به ابزارهای جدیدی که <span style="color:blue">monorepo</span> ها می توانند به ارمغان بیاورند.
  </p>
<p>
   مشکلی که من بارها دیده ام این است که سازمان هایی که کوچک شروع کردند، جایی که
   مالکیت جمعی (و در نتیجه <span style="color:blue">monorepo</span> ها) در ابتدا به خوبی کار می کردند، تلاش کرده اند تا
   بعداً به مدل های مختلف بروید، زیرا مفهوم <span style="color:blue">monorepo</span> بسیار ریشه دار است. به عنوان
   سازمان تحویل رشد می کند، درد <span style="color:blue">monorepo</span> افزایش می یابد، اما همچنین هزینه
   مهاجرت به یک رویکرد جایگزین. این حتی برای
   سازمان هایی که به سرعت رشد کردند، زیرا اغلب فقط پس از این رشد سریع است که
   مشکلات آشکار می شوند، در این مرحله هزینه مهاجرت به یک چند
   رویکرد <span style="color:blue">repo</span> بیش از حد بالا به نظر می رسد. این می تواند منجر به مغالطه هزینه های غرق شده شود: شما سرمایه گذاری کرده اید
   بسیار در تلاش برای کار کردن <span style="color:blue">monorepo</span> تا این لحظه—فقط کمی بیشتر سرمایه گذاری
   باعث می شود که به خوبی کار کند، درست است؟ شاید نه—اما یک روحیه شجاع است که
   می تواند تشخیص دهد که آنها پول خوب را پس از بد می اندازند و تصمیمی برای
   تغییر دوره
  </p>
<p>
   نگرانی ها در مورد مالکیت و <span style="color:blue">monorepo</span> ها را می توان از طریق استفاده از
   کنترل های مالکیت دقیق، اما این تمایل به ابزار و / یا
   افزایش سطح دقت. نظر من در این مورد ممکن است با بلوغ ابزار تغییر کند
   در اطراف <span style="color:blue">monorepo</span> ها بهبود می یابد، اما علیرغم کارهای زیادی که در مورد
   توسعه منبع باز ابزارهای ساخت مبتنی بر گراف، من هنوز بسیار کم می بینم
   استفاده از این زنجیره های ابزار. بنابراین برای من چند <span style="color:blue">repo</span> است.
  </p>
<h4>خلاصه</h4>
<p>
   ما در این فصل به برخی از ایده های مهم پرداختیم که باید شما را در موقعیت خوبی قرار دهند
   اینکه آیا در نهایت از <span style="color:blue">microservice</span> ها استفاده می کنید یا نه. جنبه های بسیار بیشتری وجود دارد
   برای کاوش در اطراف این ایده ها، از تحویل مستمر تا توسعه مبتنی بر <span style="color:blue">trunk</span>،
   <span style="color:blue">monorepo</span> ها به چند <span style="color:blue">repo</span>. من میزبان منابع و مطالعه بیشتر را در اختیار شما قرار داده ام، اما
   وقت آن است که به موضوعی بپردازیم که بررسی آن با عمق زیاد مهم است -
   استقرار
  </p>
<p>
   خلاصه
   |
   217
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0243</div>
            </div>
        </div>
        <!-- Page 0245 -->
        <div class="chapter" id="page-0245">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>فصل 8</h3>
<h4>استقرار</h4>
<p>
   استقرار یک برنامه <span style="color:blue">monolithic</span> تک فرآیندی یک فرآیند نسبتاً ساده است.
   <span style="color:blue">Microservices</span>، با وابستگی متقابل و ثروت گزینه های فناوری خود، یک
   کتری ماهی متفاوت به طور کلی. وقتی ویرایش اول این کتاب را نوشتم، این
   فصل قبلاً حرف های زیادی در مورد تنوع گسترده گزینه های موجود داشت.
   از آن زمان، <span style="color:blue">Kubernetes</span> به جلو آمده است، و <span style="color:blue">Function</span> as a <span style="color:blue">Service</span> (<span style="color:blue">FaaS</span>) <span style="color:blue">plat</span> -
   فرم ها حتی راه های بیشتری را برای فکر کردن در مورد نحوه ارائه نرم افزار ما به ما داده اند.
  </p>
<p>
   اگرچه فناوری ممکن است در دهه گذشته تغییر کرده باشد، فکر می کنم بسیاری از
   اصول اصلی مرتبط با ساخت نرم افزار تغییر نکرده است. در واقع، من فکر می کنم این است
   به همان اندازه مهم است که ما این ایده های اساسی را کاملاً درک کنیم، به عنوان
   آنها می توانند به ما کمک کنند تا بفهمیم چگونه در این چشم انداز آشفته از فناوری جدید حرکت کنیم.
   با در نظر گرفتن این موضوع، این فصل برخی از اصول اصلی مربوط به
   استقرار که درک آنها مهم است، در حالی که نشان می دهد چگونه موارد مختلف
   ابزارهای موجود ممکن است در رابطه با قرار دادن این اصول به شما کمک کنند (یا مانع شوند).
   عمل کردن.
  </p>
<p>
   با این حال، برای شروع، بیایید کمی پشت پرده نگاهی بیندازیم و به آنچه اتفاق می افتد نگاه کنیم
   همانطور که از یک دید منطقی از معماری سیستم های خود به سمت یک فیزیکی واقعی حرکت می کنیم
   توپولوژی استقرار.
  </p>
<h4>از منطقی به فیزیکی</h4>
<p>
   تا این مرحله، وقتی در مورد <span style="color:blue">microservices</span> بحث کرده ایم، به آنها در یک لاگ صحبت کرده ایم.
   منطق، نه به معنای فیزیکی. ما می توانستیم در مورد چگونگی صحبت کنیم
   <span style="color:blue">microservice</span> <span style="color:blue">Invoice</span> با <span style="color:blue">microservice</span> <span style="color:blue">Order</span> ارتباط برقرار می کند، همانطور که در شکل 8-1 نشان داده شده است،
   بدون اینکه در واقع به توپولوژی فیزیکی چگونگی استقرار این سرویس ها نگاه کنیم.
  </p>
<p>
   یک دید منطقی از معماری معمولاً نگرانی های استقرار فیزیکی اساسی را خلاصه می کند -
   این مفهوم باید برای محدوده این فصل تغییر کند.
  </p>
<p>
   219
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0245</div>
            </div>
        </div>
        <!-- Page 0246 -->
        <div class="chapter" id="page-0246">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<strong>شکل 8-1.</strong> یک دید منطقی ساده از دو <span style="color:blue">microservice</span>
</p>
<p>
   این دید منطقی از <span style="color:blue">microservice</span> های ما می تواند ثروت پیچیدگی را پنهان کند
   برای اجرای واقعی آنها در زیرساخت های واقعی. بیایید نگاهی به این بیندازیم که چه نوع
   جزئیات ممکن است توسط نموداری مانند این پنهان شود.
  </p>
<h4>چندین نمونه</h4>
<p>
   وقتی در مورد توپولوژی استقرار دو <span style="color:blue">microservice</span> فکر می کنیم (در
   شکل 8-2)، به سادگی یک چیز نیست که با چیز دیگری صحبت کند. برای شروع، به نظر می رسد
   کاملاً محتمل است که ما بیش از یک نمونه از هر سرویس داشته باشیم. داشتن چندگانه
   نمونه های یک سرویس به شما امکان می دهد تا بار بیشتری را مدیریت کنید و همچنین می تواند
   استحکام سیستم شما را بهبود می بخشد، زیرا می توانید به راحتی شکست یک
   نمونه واحد. بنابراین ما به طور بالقوه یک یا چند نمونه از <span style="color:blue">Invoice</span> داریم که با یک یا
   نمونه های بیشتر <span style="color:blue">Order</span>. دقیقاً چگونگی ارتباط بین این نمونه ها
   بسته به ماهیت مکانیسم ارتباطی، رسیدگی می شود، اما اگر ما
   فرض کنید که در این شرایط ما از نوعی <span style="color:blue">API</span> مبتنی بر <span style="color:blue">HTTP</span> استفاده می کنیم، یک بالابر بار
   به اندازه کافی برای رسیدگی به مسیریابی درخواست ها به نمونه های مختلف است، همانطور که می بینیم
   در شکل 8-2.
  </p>
<p>
<strong>شکل 8-2.</strong> استفاده از یک تعادل بار برای نگاشت درخواست ها به نمونه های خاص <span style="color:blue">Order</span>
<span style="color:blue">microservice</span>
</p>
<p>
   220
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 246" src="page_0246/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 246" src="page_0246/image_2.png"/></div>
</div>
                <div class="page-number">صفحه 0246</div>
            </div>
        </div>
        <!-- Page 0247 -->
        <div class="chapter" id="page-0247">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   تعداد نمونه هایی که می خواهید به آن دسترسی داشته باشید به ماهیت برنامه شما بستگی دارد -
   شما باید افزونگی مورد نیاز، سطوح بار مورد انتظار و موارد مشابه را ارزیابی کنید
   برای رسیدن به یک عدد عملی. همچنین ممکن است نیاز داشته باشید که در نظر بگیرید که در کجا
   این نمونه ها اجرا می شوند. اگر شما چندین نمونه از یک سرویس را به دلایل استحکام دارید
   احتمالاً می خواهید مطمئن شوید که این نمونه ها همه روی همان زیربنا نیستند
   سخت افزار. با این حساب، این ممکن است مستلزم این باشد که شما نمونه های مختلفی داشته باشید
   نه تنها در سراسر ماشین های متعدد، بلکه در سراسر مراکز داده مختلف توزیع شده است،
   تا به شما در برابر در دسترس نبودن کل مرکز داده محافظت کند. این
   ممکن است منجر به یک توپولوژی استقرار مانند آنچه در شکل 8-3 است شود.
  </p>
<p>
<strong>شکل 8-3.</strong> توزیع نمونه ها در چندین مرکز داده مختلف
  </p>
<p>
   این ممکن است بیش از حد محتاطانه به نظر برسد - شانس در دسترس نبودن کل مرکز داده چیست؟
   خوب، من نمی توانم به این سوال برای هر موقعیتی پاسخ دهم، اما حداقل زمانی که
   با ارائه دهندگان اصلی ابر سروکار داریم، این قطعاً چیزی است که شما باید آن را بگیرید
   حساب. وقتی صحبت از چیزی مانند یک ماشین مجازی مدیریت شده می شود، نه
   <span style="color:blue">AWS</span> و نه <span style="color:blue">Azure</span> و نه <span style="color:blue">Google</span> به شما <span style="color:blue">SLA</span> برای یک دستگاه واحد نمی دهند، و نه آنها
   شما را برای یک منطقه در دسترس بودن (که نزدیکترین معادل یک داده است) <span style="color:blue">SLA</span> بدهید
   مرکز برای این ارائه دهندگان). در عمل، این بدان معناست که هر راه حلی که استقرار دهید
   باید در چندین منطقه در دسترس بودن توزیع شود.
  </p>
<p>
   از منطقی به فیزیکی
   |
   221
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 247" src="page_0247/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0247</div>
            </div>
        </div>
        <!-- Page 0248 -->
        <div class="chapter" id="page-0248">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>پایگاه داده</h4>
<p>
   با توجه به این موضوع، یک جزء اصلی دیگر وجود دارد که ما تا
   این لحظه—پایگاه داده را نادیده گرفته ایم. همانطور که قبلاً بحث کردم، ما یک
   <span style="color:blue">microservice</span> برای پنهان کردن مدیریت حالت داخلی خود، بنابراین هر پایگاه داده ای که توسط یک
   <span style="color:blue">microservice</span> برای مدیریت حالت آن استفاده می شود، پنهان در داخل <span style="color:blue">microservice</span> در نظر گرفته می شود. این
   منجر به مانترای مکرر "پایگاه داده ها را به اشتراک نگذارید" می شود، که امیدوارم
   تا به حال به اندازه کافی ساخته شده است.
  </p>
<p>
   اما این چگونه کار می کند وقتی ما این واقعیت را در نظر می گیریم که من چندین <span style="color:blue">microservice</span> دارم
   نمونه ها؟ آیا هر نمونه <span style="color:blue">microservice</span> باید پایگاه داده خود را داشته باشد؟ در یک کلمه، خیر. در
   بیشتر موارد، اگر من به هر نمونه از سرویس <span style="color:blue">Order</span> خود بروم، می خواهم بتوانم <span style="color:blue">infor</span>- را دریافت کنم
   مورد سفارش یکسان. بنابراین ما به مقداری حالت مشترک بین
   نمونه های مختلف از یک سرویس منطقی یکسان. این در شکل 8-4 نشان داده شده است.
  </p>
<p>
<strong>شکل 8-4.</strong> چندین نمونه از همان <span style="color:blue">microservice</span> می توانند یک پایگاه داده را به اشتراک بگذارند
  </p>
<p>
   اما آیا این قانون "پایگاه داده ها را به اشتراک نگذارید" را نقض نمی کند؟ نه واقعاً. یکی از اصلی
   نگرانی های ما این است که هنگام به اشتراک گذاشتن یک پایگاه داده در چندین <span style="color:blue">microservice</span> مختلف،
   منطق مرتبط با دسترسی و دستکاری آن حالت اکنون در سراسر <span style="color:blue">microservice</span> های مختلف پخش شده است.
   اما در اینجا داده ها توسط نمونه های مختلف از
   همان <span style="color:blue">microservice</span>. منطق دسترسی و دستکاری حالت همچنان در داخل
   یک <span style="color:blue">microservice</span> منطقی واحد.
  </p>
<p>
   222
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 248" src="page_0248/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0248</div>
            </div>
        </div>
        <!-- Page 0249 -->
        <div class="chapter" id="page-0249">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>استقرار و مقیاس بندی پایگاه داده</h4>
<p>
   مانند <span style="color:blue">microservice</span> های ما، ما تاکنون بیشتر در مورد یک پایگاه داده به صورت منطقی صحبت کرده ایم.
   در شکل 8-3، ما هرگونه نگرانی در مورد افزونگی یا نیازهای مقیاس بندی را نادیده گرفتیم
   پایگاه داده اساسی
  </p>
<p>
   به طور کلی، یک استقرار فیزیکی پایگاه داده ممکن است بر روی چندین
   دستگاه ها، به دلایل مختلف. یک مثال متداول این است که بار را برای خواندن تقسیم کنید
   و بین یک گره اصلی و یک یا چند گره که برای آن تعیین شده اند، می نویسد
   اهداف فقط خواندنی (این گره ها معمولاً به عنوان نسخه های خواندنی نامیده می شوند). اگر ما بودیم
   اجرای این ایده برای سرویس <span style="color:blue">Order</span> خود، ممکن است با موقعیتی مانند این پایان دهیم
   همانطور که در شکل 8-5 نشان داده شده است.
  </p>
<p>
<strong>شکل 8-5.</strong> استفاده از نسخه های خواندنی برای توزیع بار
  </p>
<p>
   تمام ترافیک فقط خواندنی به یکی از گره های نسخه خوانده شده می رود، و شما می توانید بیشتر مقیاس کنید
   ترافیک را با افزودن گره های خواندن اضافی بخوانید. با توجه به نحوه عملکرد پایگاه های داده رابطه ای
   کار می کند، مقیاس نوشتن با افزودن دستگاه های اضافی دشوارتر است (به طور معمول
   مدل های <span style="color:blue">sharding</span> مورد نیاز هستند، که پیچیدگی بیشتری را اضافه می کند)، بنابراین انتقال خواندن
   فقط ترافیک به این نسخه های خوانده شده اغلب می تواند ظرفیت بیشتری را در گره نوشتن آزاد کند تا
   اجازه مقیاس بندی بیشتر
  </p>
<p>
   به این تصویر پیچیده این واقعیت اضافه شده است که همان زیرساخت پایگاه داده می تواند
   پشتیبانی از چندین پایگاه داده منطقی جدا شده. بنابراین پایگاه های داده برای <span style="color:blue">Invoice</span> و <span style="color:blue">Order</span>
   ممکن است هر دو توسط همان موتور و سخت افزار پایگاه داده اساسی ارائه شوند، همانطور که
   در شکل 8-6 نشان داده شده است. این می تواند مزایای قابل توجهی داشته باشد - به شما امکان می دهد جمع آوری کنید
  </p>
<p>
   از منطقی به فیزیکی
   |
   223
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 249" src="page_0249/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0249</div>
            </div>
        </div>
        <!-- Page 0250 -->
        <div class="chapter" id="page-0250">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   سخت افزار برای ارائه چندین <span style="color:blue">microservice</span>، می تواند هزینه های صدور مجوز را کاهش دهد، و همچنین می تواند
   به کاهش کار در مورد مدیریت خود پایگاه داده کمک کند.
  </p>
<p>
<strong>شکل 8-6.</strong> همان زیرساخت فیزیکی پایگاه داده که دو پایگاه داده منطقی جدا شده را میزبانی می کند
  </p>
<p>
   نکته مهمی که باید در اینجا درک کنید این است که اگرچه این دو پایگاه داده ممکن است
   از همان سخت افزار و موتور پایگاه داده اجرا می شود، آنها هنوز هم به طور منطقی داده ها را جدا می کنند
   پایگاه ها. آنها نمی توانند با یکدیگر تداخل داشته باشند (مگر اینکه شما اجازه آن را بدهید). مهم
   چیزی که باید در نظر گرفت این است که اگر این زیرساخت پایگاه داده مشترک شکست بخورد، ممکن است
   چندین <span style="color:blue">microservice</span>، که می تواند تأثیر فاجعه باری داشته باشد.
  </p>
<p>
   در تجربه من، سازمان هایی که زیرساخت های خود را مدیریت می کنند و در یک
   روش "در محل" تمایل دارند که احتمال بیشتری داشته باشند که چندین پایگاه داده مختلف داشته باشند
   برای دلایل هزینه ای که قبلاً توضیح دادم، از زیرساخت پایگاه داده مشترک میزبانی می شود.
   تهیه و مدیریت سخت افزار دردناک است (و از نظر تاریخی حداقل، پایگاه های داده
   احتمال کمتری دارد که بر روی زیرساخت مجازی شده اجرا شوند)، بنابراین شما کمتر از آن می خواهید.
  </p>
<p>
   از سوی دیگر، تیم هایی که روی ارائه دهندگان ابر عمومی اجرا می شوند، احتمال بیشتری دارند
   زیرساخت پایگاه داده اختصاصی را بر اساس هر <span style="color:blue">microservice</span> تهیه کنید، همانطور که در
   شکل 8-7. هزینه های تهیه و مدیریت این زیرساخت بسیار است
   پایین تر. به عنوان مثال، سرویس پایگاه داده رابطه ای <span style="color:blue">AWS</span> (<span style="color:blue">RDS</span>) می تواند به طور خودکار
   نگرانی هایی مانند پشتیبان گیری، ارتقاء و خرابی چند ناحیه ای در دسترس بودن را مدیریت کنید، و مشابه
   محصولات از سایر ارائه دهندگان ابر عمومی در دسترس هستند. این باعث می شود
   داشتن زیرساخت ایزوله تر برای <span style="color:blue">microservice</span> شما مقرون به صرفه تر است، که به ارائه می دهد
   هر مالک <span style="color:blue">microservice</span> کنترل بیشتری دارد تا اینکه مجبور باشد به یک سرویس مشترک تکیه کند.
  </p>
<p>
   224
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 250" src="page_0250/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0250</div>
            </div>
        </div>
        <!-- Page 0251 -->
        <div class="chapter" id="page-0251">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<strong>شکل 8-7.</strong> هر <span style="color:blue">microservice</span> از زیرساخت <span style="color:blue">DB</span> اختصاصی خود استفاده می کند
  </p>
<h4>محیط ها</h4>
<p>
   وقتی نرم افزار خود را مستقر می کنید، در یک محیط اجرا می شود. هر محیط خواهد بود
   معمولاً اهداف مختلفی را دنبال می کند و تعداد دقیق محیط هایی که ممکن است داشته باشید
   بر اساس نحوه توسعه نرم افزار و نحوه عملکرد نرم افزار شما، بسیار متفاوت خواهد بود
   به کاربر نهایی شما مستقر می شود. برخی از محیط ها دارای داده های تولیدی هستند، در حالی که
   دیگران نخواهند داشت. برخی از محیط ها ممکن است همه سرویس ها را در خود داشته باشند. دیگران ممکن است فقط یک داشته باشند
   تعداد کمی از خدمات، با هر سرویس غیر حاضر جایگزین سرویس های جعلی برای
   اهداف آزمایش.
  </p>
<p>
   به طور معمول، ما به نرم افزار خود به عنوان عبور از تعدادی از قبل از تولید فکر می کنیم
   محیط ها، که هر کدام هدفی را برای اجازه دادن به توسعه نرم افزار دنبال می کنند
   و آمادگی آن برای تولید آزمایش می شود—ما این را در "Trade-Offs" بررسی کردیم
   و محیط ها" در صفحه 203. از لپ تاپ توسعه دهنده گرفته تا ادغام مداوم
   سرور <span style="color:blue">tion</span>، یک محیط تست یکپارچه، و فراتر از آن—ماهیت و تعداد دقیق
   محیط های شما به عوامل زیادی بستگی دارد اما در درجه اول هدایت می شود
   با نحوه انتخاب برای توسعه نرم افزار. در شکل 8-8، ما یک <span style="color:blue">pipeline</span> را برای
   <span style="color:blue">microservice</span> کاتالوگ <span style="color:blue">MusicCorp</span>. <span style="color:blue">microservice</span> از محیط های مختلف عبور می کند
   قبل از اینکه در نهایت وارد یک محیط تولید شود، جایی که کاربران ما خواهند بود
   برای استفاده از نرم افزار جدید
  </p>
<p>
   از منطقی به فیزیکی
   |
   225
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 251" src="page_0251/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0251</div>
            </div>
        </div>
        <!-- Page 0252 -->
        <div class="chapter" id="page-0252">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<strong>شکل 8-8.</strong> محیط های مختلف مورد استفاده برای بخش های مختلف <span style="color:blue">pipeline</span>
</p>
<p>
   اولین محیطی که <span style="color:blue">microservice</span> ما در آن اجرا می شود، جایی است که توسعه دهنده کار می کرد
   در کد قبل از <span style="color:blue">check-in</span>—احتمالاً لپ تاپ محلی آنها. پس از <span style="color:blue">commit</span> کردن
   کد، فرآیند <span style="color:blue">CI</span> با تست های سریع شروع می شود. هر دو مرحله تست سریع و کند
   در محیط <span style="color:blue">CI</span> ما مستقر می شود. اگر تست های کند انجام شود، <span style="color:blue">microservice</span> مستقر می شود
   به محیط قبل از تولید برای اجازه دادن به تأیید دستی (که هست
   کاملاً اختیاری است اما همچنان برای بسیاری مهم است). اگر این تأیید دستی انجام شود،
   <span style="color:blue">microservice</span> سپس در تولید مستقر می شود.
  </p>
<p>
   در حالت ایده‌آل، هر محیط در این فرآیند یک کپی دقیق از تولید خواهد بود
   محیط. این به ما اطمینان بیشتری می دهد که نرم افزار ما کار خواهد کرد
   وقتی به تولید رسید. با این حال، در واقعیت، ما اغلب نمی توانیم چندین
   نسخه هایی از کل محیط تولید ما به دلیل گران بودن این موضوع.
  </p>
<p>
   ما همچنین می‌خواهیم محیط‌ها را زودتر در این فرآیند تنظیم کنیم تا بازخورد سریع را امکان‌پذیر کنیم.
   بسیار مهم است که ما در اسرع وقت بدانیم که آیا نرم افزار ما کار می کند یا خیر
   تا در صورت نیاز بتوانیم به سرعت چیزها را اصلاح کنیم. هر چه زودتر در مورد یک مشکل با ما بدانیم
   نرم افزار، سریعتر تعمیر می شود، و تأثیر شکست کمتر است. خیلی بهتر است
   برای پیدا کردن یک مشکل در لپ تاپ محلی ما نسبت به اینکه آن را در تست قبل از تولید انتخاب کنید، اما
   به همین ترتیب انتخاب یک مشکل در تست قبل از تولید ممکن است برای ما بسیار بهتر باشد
   تا اینکه چیزی را در تولید انتخاب کنیم (اگرچه ما برخی از موارد مهم را بررسی خواهیم کرد
   مبادلات در این مورد در فصل 9).
  </p>
<p>
   این بدان معناست که محیط های نزدیکتر به توسعه دهنده تنظیم می شوند تا سریع ارائه دهند
   بازخورد، که ممکن است کیفیت "تولید" آنها را به خطر بیندازد. اما به عنوان محیط
   به تولید نزدیک تر می شوند، ما می خواهیم آنها بیشتر و بیشتر شبیه پایان باشند
   محیط تولید برای اطمینان از اینکه ما مشکلات را شناسایی می کنیم.
  </p>
<p>
   226
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 252" src="page_0252/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0252</div>
            </div>
        </div>
        <!-- Page 0253 -->
        <div class="chapter" id="page-0253">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   به عنوان یک مثال ساده از این کار، بیایید به مثال قبلی خود از <span style="color:blue">Service</span> کاتالوگ
   بازگردیم و نگاهی به محیط های مختلف بیندازیم. در شکل 8-9، توسعه دهنده محلی
   لپ تاپ ما سرویس ما را به عنوان یک نمونه واحد در حال اجرا به صورت محلی مستقر کرده است. نرم
   افزار سریع ساخته می شود اما به عنوان یک نمونه واحد اجرا می شود
   سخت افزار متفاوت از آنچه ما در تولید انتظار داریم. در محیط <span style="color:blue">CI</span>، ما دو
   نسخه از سرویس خود را برای آزمایش مستقر می کنیم و اطمینان حاصل می کنیم که منطق تعادل بار ما کار می کند
   خوب ما هر دو نمونه را در همان دستگاه مستقر می کنیم - این باعث کاهش هزینه ها می شود و
   امور را سریعتر می کند، و همچنان بازخورد کافی را در این مرحله از فرآیند به ما می دهد.
  </p>
<p>
<strong>شکل 8-9.</strong> یک <span style="color:blue">microservice</span> می تواند در نحوه استقرار آن از یک محیط به
   بعدی
  </p>
<p>
   در نهایت، در تولید، <span style="color:blue">microservice</span> ما به عنوان چهار نمونه، پخش شده در سراسر مستقر می شود
   چهار دستگاه، که به نوبه خود در دو مرکز داده مختلف توزیع شده اند.
  </p>
<p>
   این فقط یک مثال از نحوه استفاده از محیط ها است. دقیقاً چه چیزی تنظیم می کنید
   نیازها به شدت بسته به آنچه می سازید و نحوه استقرار آن متفاوت خواهد بود.
   به عنوان مثال، ممکن است چندین محیط تولید داشته باشید اگر نیاز دارید
   برای هر مشتری یک نسخه از نرم افزار خود را مستقر کنید.
  </p>
<p>
   با این حال، نکته اصلی این است که توپولوژی دقیق <span style="color:blue">microservice</span> شما از
   محیط به محیط. بنابراین شما باید راه هایی برای تغییر پیدا کنید
   تعداد نمونه ها از یک محیط به محیط دیگر، همراه با هر محیط-
   پیکربندی خاص شما همچنین می خواهید نمونه های سرویس خود را یک بار و یک بار بسازید
   فقط، بنابراین نتیجه می گیرد که هر گونه اطلاعات خاص محیط باید جداگانه باشد
   از <span style="color:blue">artifact</span> سرویس مستقر شده.
  </p>
<p>
   اینکه چگونه توپولوژی <span style="color:blue">microservice</span> خود را از یک محیط تغییر می دهید
   به محیط دیگر به مکانیسمی که برای استقرار استفاده می کنید و همچنین بستگی دارد
  </p>
<p>
   از منطقی به فیزیکی
   |
   227
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 253" src="page_0253/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0253</div>
            </div>
        </div>
        <!-- Page 0254 -->
        <div class="chapter" id="page-0254">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   در مورد میزان تنوع توپولوژی ها. اگر تنها چیزی که از یک محیط تغییر می کند
   به دیگری تعداد نمونه های <span style="color:blue">microservice</span> است، این می تواند به سادگی
   پارامتر کردن این مقدار برای اجازه دادن به اعداد مختلف به عنوان بخشی از
   فعالیت استقرار
  </p>
<p>
   بنابراین، برای خلاصه کردن، یک <span style="color:blue">microservice</span> منطقی واحد را می توان در چندین
   محیط ها. از یک محیط به محیط دیگر، تعداد نمونه های هر
   <span style="color:blue">microservice</span> می تواند بر اساس الزامات هر محیط متفاوت باشد.
  </p>
<h4>اصول استقرار <span style="color:blue">Microservice</span></h4>
<p>
   با گزینه های زیادی که برای چگونگی استقرار <span style="color:blue">microservice</span> های خود در اختیار دارید، فکر می کنم این است
   مهم است که من برخی از اصول اساسی را در این زمینه ایجاد کنم. درک درستی از
   این اصول، شما را بدون توجه به انتخاب هایی که در نهایت انجام می دهید، در موقعیت خوبی قرار می دهد
   ساختن ما به زودی به هر اصل با جزئیات نگاه خواهیم کرد، اما فقط برای شروع، در اینجا آمده است
   ایده های اصلی که ما پوشش خواهیم داد:
  </p>
<ul>
<li><strong>اجرای ایزوله</strong></li>
<li>نمونه های <span style="color:blue">microservice</span> را به صورت ایزوله اجرا کنید به گونه ای که منابع محاسباتی خود را داشته باشند، و
    اجرای آنها نمی تواند بر سایر نمونه های <span style="color:blue">microservice</span> که در نزدیکی اجرا می شوند تأثیر بگذارد.</li>
<li><strong>تمرکز بر اتوماسیون</strong></li>
<li>با افزایش تعداد <span style="color:blue">microservice</span> ها، اتوماسیون به طور فزاینده ای می شود
    مهم. بر انتخاب فناوری که اجازه می دهد درجه بالایی از خودکار را متمرکز شوید
    مسیریابی، و اتوماسیون را به عنوان بخش اصلی فرهنگ خود اتخاذ کنید.</li>
<li><strong>زیرساخت به عنوان کد</strong></li>
<li>پیکربندی زیرساخت خود را برای سهولت اتوماسیون نشان دهید و
    به اشتراک گذاری اطلاعات را ارتقا دهید. این کد را در کنترل منبع ذخیره کنید تا اجازه دهید
    محیط ها دوباره ایجاد شوند.</li>
<li><strong>استقرار بدون توقف</strong></li>
<li>استقرار مستقل را بیشتر انجام دهید و اطمینان حاصل کنید که استقرار نسخه جدید
    یک <span style="color:blue">microservice</span> را می توان بدون هیچگونه قطعی برای کاربران سرویس شما انجام داد (باشد
    آنها انسان یا سایر <span style="color:blue">microservice</span> ها).</li>
<li><strong>مدیریت حالت دلخواه</strong></li>
<li>از پلتفرمی استفاده کنید که <span style="color:blue">microservice</span> شما را در یک حالت تعریف شده حفظ می کند، راه اندازی
    نمونه های جدید در صورت قطعی یا افزایش ترافیک در صورت نیاز.</li>
</ul>
<h4>اجرای ایزوله</h4>
<p>
   ممکن است وسوسه شوید، به خصوص در مراحل اولیه سفر <span style="color:blue">microservice</span> خود، فقط همه را قرار دهید
   از نمونه های <span style="color:blue">microservice</span> خود را در یک دستگاه واحد (که می تواند یک فیزیکی واحد باشد
  </p>
<p>
   228
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0254</div>
            </div>
        </div>
        <!-- Page 0255 -->
        <div class="chapter" id="page-0255">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   دستگاه یا یک <span style="color:blue">VM</span> واحد)، همانطور که در شکل 8-10 نشان داده شده است. کاملاً از یک میزبان مدیریت
   دیدگاه، این مدل ساده تر است. در دنیایی که یک تیم زیرساخت را مدیریت می کند و
   یک تیم دیگر نرم افزار را مدیریت می کند، حجم کاری تیم زیرساخت
   اغلب تابعی از تعداد میزبان هایی است که باید مدیریت کند. اگر خدمات بیشتری هستند
   روی یک میزبان واحد بسته بندی شده، حجم کاری مدیریت میزبان با افزایش نمی یابد
   تعداد خدمات افزایش می یابد.
  </p>
<p>
<strong>شکل 8-10.</strong> چندین <span style="color:blue">microservice</span> در هر میزبان
  </p>
<p>
   با این حال، برخی از چالش ها با این مدل وجود دارد. اول، می تواند نظارت را ایجاد کند
   دشوارتر. به عنوان مثال، هنگام ردیابی <span style="color:blue">CPU</span>، آیا باید <span style="color:blue">CPU</span> یک را ردیابی کنم
   سرویس مستقل از دیگران؟ یا آیا به <span style="color:blue">CPU</span> میزبان به طور کلی اهمیت می دهم؟
   جلوه های جانبی نیز می توانند سخت اجتناب شوند. اگر یک سرویس تحت بار قابل توجهی باشد، می تواند
   در نهایت منابع موجود را برای سایر قسمت های سیستم کاهش می دهد. این بود
   مشکلی که <span style="color:blue">Gilt</span>، یک خرده فروش مد آنلاین، با آن مواجه شد. با شروع با یک <span style="color:blue">Ruby on Rails</span>
<span style="color:blue">monolith</span>، <span style="color:blue">Gilt</span> تصمیم گرفت برای سهولت مقیاس بندی برنامه، به <span style="color:blue">microservice</span> ها برود
   و همچنین برای تطبیق بهتر با تعداد فزاینده ای از توسعه دهندگان. در ابتدا <span style="color:blue">Gilt</span>
   بسیاری از <span style="color:blue">microservice</span> ها را در یک جعبه واحد همزیستی می کردند، اما بار ناهموار در یکی از <span style="color:blue">micro</span>-
   <span style="color:blue">services</span> ها تأثیر نامطلوبی بر هر چیز دیگری داشت که روی آن میزبان اجرا می شد. این
   تجزیه و تحلیل تأثیر شکست های میزبان را نیز پیچیده تر کرد—خارج کردن یک میزبان واحد
   از کمیسیون می تواند اثر موجی بزرگی داشته باشد.
  </p>
<p>
   استقرار خدمات نیز می تواند تا حدودی پیچیده تر باشد، زیرا اطمینان از استقرار
   تأثیری بر دیگری نمی گذارد که منجر به سردردهای اضافی می شود. به عنوان مثال، اگر هر کدام
   <span style="color:blue">microservice</span> وابستگی های مختلف (و بالقوه متناقض) دارد که باید داشته باشد
   در میزبان مشترک نصب شود، چگونه می توانم آن را کار کنم؟
  </p>
<p>
   این مدل همچنین می تواند استقلال تیم ها را محدود کند. اگر خدمات برای تیم های مختلف هستند
   روی همان میزبان نصب شده است، چه کسی میزبان را برای خدمات خود پیکربندی می کند؟ در همه
   به احتمال زیاد، این کار توسط یک تیم متمرکز انجام می شود، به این معنی که زمان بیشتری می برد
   هماهنگی برای استقرار خدمات.
  </p>
<p>
   اصول استقرار <span style="color:blue">Microservice</span>
   |
   229
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 255" src="page_0255/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0255</div>
            </div>
        </div>
        <!-- Page 0256 -->
        <div class="chapter" id="page-0256">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   اساساً، اجرای تعداد زیادی نمونه <span style="color:blue">microservice</span> در یک دستگاه واحد (مجازی
   یا فیزیکی) در نهایت یکی از اصول کلیدی <span style="color:blue">microservi</span>- را به طور چشمگیری تضعیف می کند
   <span style="color:blue">ces</span> به عنوان یک کل—استقرار مستقل. بنابراین، این نتیجه می شود که ما واقعاً می خواهیم
   نمونه های <span style="color:blue">microservice</span> را در انزوا اجرا کنید، همانطور که در شکل 8-11 می بینیم.
  </p>
<p>
<strong>شکل 8-11.</strong> یک <span style="color:blue">microservice</span> واحد در هر میزبان
  </p>
<p>
   هر نمونه <span style="color:blue">microservice</span> محیط اجرای جداگانه خود را دریافت می کند. می تواند نصب کند
   وابستگی های خود را داشته باشید و مجموعه ای از منابع حصاردار خود را داشته باشید.
  </p>
<p>
   همانطور که همکار قدیمی من نیل فورد می گوید، بسیاری از رویه های کاری ما در مورد استقرار
   و مدیریت میزبان تلاشی برای بهینه سازی برای کمبود منابع است. در
   گذشته، اگر ما یک دستگاه دیگر برای دستیابی به انزوا می خواستیم، تنها گزینه ما این بود که
   خرید یا اجاره دستگاه فیزیکی دیگر. این اغلب زمان طولانی داشت و در
   تعهد مالی بلندمدت نتیجه داد. در تجربه من، غیر معمول نیست که
   مشتریان فقط هر دو تا سه سال سرورهای جدیدی را تهیه می کنند، و تلاش برای دریافت اضافه
   ماشین های خارج از این جدول زمانی دشوار است. اما محاسبات درخواستی
   پلتفرم ها هزینه منابع محاسباتی را به شدت کاهش داده اند و بهبود
   پیشرفت ها در فناوری مجازی سازی به این معنی است که انعطاف پذیری بیشتری وجود دارد، حتی برای درون خانه
   زیرساخت میزبانی شده.
  </p>
<p>
   با پیوستن <span style="color:blue">containerization</span> به ترکیب، ما گزینه های بیشتری نسبت به همیشه برای
   تهیه یک محیط اجرای جدا شده. همانطور که شکل 8-12 نشان می دهد، به طور کلی
   صحبت کردن، ما از افراط در داشتن ماشین های فیزیکی اختصاصی برای خود می رویم
   خدمات، که بهترین انزوا را به ما می دهد اما احتمالاً بالاترین هزینه را دارد، به کانتینرها
   در انتهای دیگر، که انزوای ضعیف تری را به ما می دهد اما تمایل دارد مقرون به صرفه تر باشد
   و استقرار بسیار سریعتر. ما بعداً در این فصل به برخی از موارد خاص پیرامون فناوری ها، مانند
   <span style="color:blue">containerization</span> برمی گردیم.
  </p>
<p>
   230
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 256" src="page_0256/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0256</div>
            </div>
        </div>
        <!-- Page 0257 -->
        <div class="chapter" id="page-0257">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<strong>شکل 8-12.</strong> مبادلات مختلف در مورد مدل های انزوا
  </p>
<p>
   اگر شما در حال استقرار <span style="color:blue">microservice</span> های خود بر روی پلتفرم های انتزاعی تر مانند
   <span style="color:blue">AWS Lambda</span> یا <span style="color:blue">Heroku</span>، این انزوا برای شما فراهم می شود. بسته به
   ماهیت خود پلتفرم، شما احتمالاً می توانید انتظار داشته باشید که نمونه <span style="color:blue">microservice</span> شما
   در نهایت در یک کانتینر یا <span style="color:blue">VM</span> اختصاصی در پشت صحنه اجرا می شود.
  </p>
<p>
   به طور کلی، انزوا در اطراف کانتینرها به اندازه کافی بهبود یافته است تا آنها را ایجاد کند
   یک انتخاب طبیعی تر برای بارهای کاری <span style="color:blue">microservice</span>. تفاوت در انزوا بین
   کانتینرها و <span style="color:blue">VM</span> ها تا حدی کاهش یافته است که برای اکثریت قریب به اتفاق بارهای کاری،
   کانتینرها "به اندازه کافی خوب هستند"، که تا حد زیادی دلیل محبوبیت آنها است
   انتخاب و چرا آنها تمایل دارند در اکثر موقعیت ها انتخاب پیش فرض من باشند.
  </p>
<h4>تمرکز بر اتوماسیون</h4>
<p>
   با افزودن <span style="color:blue">microservice</span> های بیشتر، قطعات متحرک بیشتری برای مقابله خواهید داشت - بیشتر
   فرآیندها، کارهای بیشتری برای پیکربندی، نمونه های بیشتری برای نظارت. حرکت به <span style="color:blue">microser</span>-
   <span style="color:blue">vices</span> پیچیدگی زیادی را به فضای عملیاتی وارد می کند، و اگر شما در حال مدیریت هستید
   فرآیندهای عملیاتی خود را به روشی عمدتاً دستی، این به این معنی است که خدمات بیشتر
   به افراد بیشتری نیاز دارد تا کارها را انجام دهند.
  </p>
<p>
   در عوض، شما به یک تمرکز بی وقفه بر اتوماسیون نیاز دارید. ابزار و فناوری را انتخاب کنید
   که اجازه می دهد کارها به صورت خودکار انجام شوند، در حالت ایده آل با دید به کار
   با زیرساخت به عنوان کد (که به زودی آن را پوشش خواهیم داد).
  </p>
<p>
   با افزایش تعداد <span style="color:blue">microservice</span> ها، اتوماسیون به طور فزاینده ای مهم می شود
   انتخاب فناوری را جدی در نظر بگیرید که امکان درجه بالایی از اتو را فراهم می کند
   مسیریابی، و اتوماسیون را به عنوان بخش اصلی فرهنگ خود اتخاذ کنید.
  </p>
<p>
   اتوماسیون همچنین نحوه اطمینان شماست که توسعه دهندگان شما همچنان باقی می مانند
   مولد. دادن توانایی به توسعه دهندگان برای خدمات خود—تهیه خدمات فردی یا
   گروه هایی از خدمات کلید آسان تر کردن زندگی آنها است.
  </p>
<p>
   انتخاب فناوری که اتوماسیون را فعال می کند با ابزارهای مورد استفاده برای مدیریت شروع می شود
   میزبان ها آیا می توانید خطی از کد برای راه اندازی یک ماشین مجازی یا خاموش کردن آن بنویسید؟
   آیا می توانید نرم افزاری را که نوشته اید به طور خودکار مستقر کنید؟ آیا می توانید مستقر کنید
  </p>
<p>
   اصول استقرار <span style="color:blue">Microservice</span>
   |
   231
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 257" src="page_0257/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0257</div>
            </div>
        </div>
        <!-- Page 0258 -->
        <div class="chapter" id="page-0258">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   تغییرات پایگاه داده بدون مداخله دستی؟ در آغوش گرفتن فرهنگ اتوماسیون است
   اگر می خواهید پیچیدگی های معماری <span style="color:blue">microservice</span> را بررسی کنید، کلید است.
  </p>
<h4>دو مطالعه موردی در مورد قدرت اتوماسیون</h4>
<p>
   احتمالاً کمک کننده خواهد بود که چند نمونه ملموس به شما ارائه دهیم که توضیح می دهند
   قدرت اتوماسیون خوب <span style="color:blue">REA</span> شرکت استرالیایی realestate.com.au (
   فهرست های املاک و مستغلات را برای مشتریان خرده فروشی و تجاری در استرالیا و جای دیگر ارائه می دهد
   در منطقه آسیا و اقیانوس آرام. در طول چندین سال، پلت فرم خود را حرکت می داد
   به سمت یک طراحی <span style="color:blue">microservices</span> توزیع شده. وقتی این سفر را شروع کرد،
   او مجبور شد زمان زیادی را صرف درست کردن ابزارها در اطراف خدمات کند -
   سهولت در اختیار قرار دادن ماشین ها، استقرار کد و نظارت بر آنها برای توسعه دهندگان
   خدمات این باعث شد که بار کاری جلویی برای شروع کارها ایجاد شود.
  </p>
<p>
   در سه ماه اول این تمرین، <span style="color:blue">REA</span> توانست تنها دو <span style="color:blue">micro</span>- جدید را منتقل کند
   <span style="color:blue">services</span> وارد تولید می شود، با تیم توسعه که مسئولیت کامل
   کل ساخت، استقرار و پشتیبانی از خدمات. در سه ماه آینده،
   بین 10 تا 15 سرویس به همین ترتیب زنده شدند. تا پایان 18 ماه
   دوره، <span style="color:blue">REA</span> بیش از 70 سرویس در حال تولید داشت.
  </p>
<p>
   این نوع الگو نیز با تجربیات <span style="color:blue">Gilt</span>، که قبلاً به آن اشاره کردیم، مشخص شده است
   زودتر. باز هم، اتوماسیون، به خصوص ابزارهایی برای کمک به توسعه دهندگان، انفجار را هدایت کرد
   در استفاده از <span style="color:blue">microservices</span> توسط <span style="color:blue">Gilt</span>. یک سال پس از شروع مهاجرت به <span style="color:blue">microservices</span>، <span style="color:blue">Gilt</span>
   حدود 10 <span style="color:blue">microservices</span> زنده داشت. تا سال 2012، بیش از 100; و در سال 2014، بیش از 450 میکرو سرور
   <span style="color:blue">vices</span> زنده بودند—یا حدود سه <span style="color:blue">microservices</span> برای هر توسعه دهنده در <span style="color:blue">Gilt</span>. این نوع
   نسبت <span style="color:blue">microservices</span> به توسعه دهندگان در میان سازمان هایی که این کار را انجام می دهند غیر معمول نیست
   در استفاده از <span style="color:blue">microservices</span>، <span style="color:blue">Financial Times</span> شرکتی با a
   نسبت مشابه
  </p>
<h4>زیرساخت به عنوان کد (<span style="color:blue">IAC</span>)</h4>
<p>
   با در نظر گرفتن مفهوم اتوماسیون بیشتر، زیرساخت به عنوان کد (<span style="color:blue">IAC</span>) یک مفهوم است
   که به موجب آن زیرساخت شما با استفاده از کد قابل خواندن توسط ماشین پیکربندی می شود. تو
   ممکن است پیکربندی سرویس خود را در یک فایل سرآشپز یا عروسک تعریف کنید، یا شاید بنویسید
   برخی از <span style="color:blue">bash script</span> ها برای راه اندازی کارها—اما هر ابزاری که در نهایت از آن استفاده می کنید، سیستم شما
   می تواند از طریق استفاده از کد منبع به یک حالت شناخته شده وارد شود. می توان استدلال کرد، کانس
   تصور <span style="color:blue">IAC</span> می تواند به عنوان یک راه برای پیاده سازی اتوماسیون در نظر گرفته شود. من فکر می کنم، هرچند،
   که ارزش دارد آن را به عنوان چیز خودش مطرح کنیم، زیرا به نحوه اتوماسیون می پردازد
   باید انجام شود. زیرساخت به عنوان کد مفاهیمی را از توسعه نرم افزار به ارمغان آورده است
   به فضای عملیات. با تعریف زیرساخت های خود از طریق کد، این
  </p>
<p>
   232
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0258</div>
            </div>
        </div>
        <!-- Page 0259 -->
        <div class="chapter" id="page-0259">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   1 <span style="color:blue">Kief Morris</span>، زیرساخت به عنوان کد، ویرایش دوم (سباستوپول: <span style="color:blue">O'Reilly</span>، 2020).
   پیکربندی را می توان در صورت تمایل کنترل، آزمایش و تکرار کرد. برای اطلاعات بیشتر در مورد این
   موضوع، من زیرساخت به عنوان کد، ویرایش دوم، اثر <span style="color:blue">Kief Morris</span> را توصیه می کنم.1
  </p>
<p>
   از نظر تئوری، شما می توانید از هر زبان برنامه نویسی برای اعمال ایده های <span style="color:blue">infra</span>- استفاده کنید
   زیرساخت به عنوان کد، اما ابزارهای تخصصی در این زمینه وجود دارد مانند <span style="color:blue">Puppet</span>، <span style="color:blue">Chef</span>، <span style="color:blue">Ansi</span>-
   <span style="color:blue">ble</span>، و دیگران، که همه از <span style="color:blue">CFEngine</span> اولیه رهبری خود را گرفتند. این ابزارها هستند
   اعلامی - آنها به شما اجازه می دهند در فرم متنی تعریف کنید که انتظار دارید یک دستگاه (یا
   مجموعه دیگری از منابع) را ببینید، و هنگامی که این <span style="color:blue">script</span> ها اعمال می شوند، زیرساخت
   وارد آن ایالت می شود. ابزارهای اخیرتر از نگاه به پیکربندی فراتر رفته اند
   یک دستگاه و به نگاه به نحوه پیکربندی مجموعه کاملی از ابرها منتقل شد
   منابع—<span style="color:blue">Terraform</span> در این فضا بسیار موفق بوده است، و من خوشحالم که می بینم
   پتانسیل <span style="color:blue">Pulumi</span>، که هدف آن انجام کاری مشابه است، اگرچه با اجازه دادن
   مردم برای استفاده از زبان های برنامه نویسی معمولی به جای <span style="color:blue">lan</span>- خاص دامنه
   زبان هایی که اغلب توسط این ابزارها استفاده می شوند. <span style="color:blue">AWS CloudFormation</span> و <span style="color:blue">AWS Cloud</span>
<span style="color:blue">Development Kit</span> (<span style="color:blue">CDK</span>) نمونه هایی از ابزارهای خاص پلت فرم هستند، در این مورد پشتیبانی می شود
   فقط <span style="color:blue">AWS</span>—اگرچه شایان ذکر است که حتی اگر فقط با <span style="color:blue">AWS</span> کار می کردم،
   من انعطاف پذیری یک ابزار چند پلتفرمی مانند <span style="color:blue">Terraform</span> را ترجیح می دهم.
  </p>
<p>
   کنترل نسخه کد زیرساخت شما به شما شفافیت می دهد که چه کسی است
   تغییراتی ایجاد کرده است، چیزی که حسابرسان دوست دارند. همچنین بازتولید یک را آسان تر می کند
   محیط در یک نقطه مشخص در زمان. این چیزی است که می تواند به ویژه مفید باشد
   هنگام تلاش برای ردیابی نقص ها. در یک مثال به یاد ماندنی، یکی از مشتریان من، به عنوان
   بخشی از یک پرونده دادگاه، مجبور شد یک سیستم در حال اجرا را از یک زمان خاص دوباره ایجاد کند
   چند سال قبل، تا سطح پچ سیستم عامل ها و محتویات
   واسطه پیام. اگر پیکربندی محیط در کنترل نسخه ذخیره می شد،
   کار آنها بسیار آسان تر می شد—همانطور که بود، آنها در نهایت بیش از
   سه ماه با تلاش برای بازسازی یک تصویر آینه ای از تولید قبلی
   محیط با عبور از ایمیل ها و یادداشت های انتشار برای تلاش و کار
   چه کسی چه کرد پرونده دادگاه، که قبلاً برای مدت طولانی در حال انجام بود
   از زمانی که کارم را با مشتری تمام کردم هنوز حل نشده بود.
  </p>
<h4>استقرار بدون توقف</h4>
<p>
   همانطور که احتمالاً از شنیدن حرف های من خسته و خسته شده اید، استقرار مستقل است
   واقعاً مهم است. با این حال، این یک کیفیت مطلق نیز نیست. چقدر مستقل است
   چیزی دقیقاً؟ قبل از این فصل، ما در درجه اول به استقرار مستقل نگاه کرده بودیم
   از نظر اجتناب از اتصال پیاده سازی. در اوایل این فصل، ما
   در مورد اهمیت ارائه یک نمونه <span style="color:blue">microservice</span> با یک
   محیط اجرای جدا شده، برای اطمینان از داشتن درجه ای از استقلال در فیزیکی
   سطح استقرار. اما می توانیم فراتر برویم.
  </p>
<p>
   اصول استقرار <span style="color:blue">Microservice</span>
   |
   233
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0259</div>
            </div>
        </div>
        <!-- Page 0260 -->
        <div class="chapter" id="page-0260">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>پیاده سازی استقرار بدون توقف</h4>
<p>
   پیاده سازی قابلیت استقرار بدون توقف می تواند یک قدم بزرگ در جهت
   اجازه دادن به توسعه و استقرار <span style="color:blue">microservice</span> ها. بدون زمان غیرفعال
   استقرار، ممکن است مجبور باشم با مصرف کنندگان بالادستی هماهنگ کنم
   نرم افزار را آزاد کنید تا آنها را از یک اختلال احتمالی مطلع کنید.
  </p>
<p>
<span style="color:blue">Sarah Wells</span> در <span style="color:blue">Financial Times</span> توانایی پیاده سازی استقرار بدون توقف را به عنوان
   بزرگترین مزیت واحد از نظر بهبود سرعت
   تحویل با این اطمینان که نسخه‌ها کاربرانش را مختل نمی‌کنند، <span style="color:blue">Financial</span>
<span style="color:blue">Times</span> توانست فرکانس انتشارها را به شدت افزایش دهد. علاوه بر این، یک صفر
   نسخه استقرار می‌تواند در ساعات کاری بسیار آسان‌تر انجام شود. کاملاً جدا از
   واقعیت که این کار کیفیت زندگی افراد درگیر با
   انتشار (در مقایسه با کار در عصرها و آخر هفته ها)، یک تیم استراحت کرده که در
   روز کمتر احتمال دارد که مرتکب اشتباه شود و از بسیاری از آنها پشتیبانی خواهد کرد
   همکارانشان وقتی نیاز به رفع مشکلات دارند.
  </p>
<p>
   هدف در اینجا این است که مصرف کنندگان بالادستی نباید متوجه شوند در زمانی که شما
   انتشار انجام دهید. امکان پذیر کردن این موضوع می تواند تا حد زیادی به ماهیت <span style="color:blue">microservice</span> شما بستگی داشته باشد.
   اگر شما در حال حاضر از ارتباط ناهمزمان مبتنی بر میان افزار استفاده می کنید
   بین <span style="color:blue">microservice</span> شما و مصرف کنندگان شما، این ممکن است اجرای آن بی اهمیت باشد—
   پیام های ارسال شده به شما زمانی تحویل داده می شود که شما دوباره بالا آمده اید. اگر شما از
   با این حال، ارتباط مبتنی بر همزمان، این می تواند مشکل سازتر باشد.
  </p>
<p>
   مفاهیمی مانند ارتقاء های متحرک می توانند در اینجا مفید باشند، و این یکی از مواردی است که در آن استفاده می شود
   از پلتفرمی مانند <span style="color:blue">Kubernetes</span> زندگی شما را بسیار آسان تر می کند. با یک ارتقاء متحرک،
   <span style="color:blue">microservice</span> شما قبل از استقرار نسخه جدید به طور کامل خاموش نمی شود، در عوض
   نمونه هایی از <span style="color:blue">microservice</span> شما به آرامی کاهش می یابد زیرا نمونه های جدید در حال اجرا هستند
   نسخه های جدیدی از نرم افزار شما افزایش یافته است. با این حال، شایان ذکر است که اگر
   تنها چیزی که به دنبال آن هستید چیزی برای کمک به استقرار بدون توقف است
   <span style="color:blue">ments</span>، سپس اجرای <span style="color:blue">Kubernetes</span> احتمالاً بزرگ است. چیزی ساده مانند a
   مکانیسم استقرار آبی-سبز (که در "جدا کردن استقرار از انتشار" بیشتر بررسی خواهیم کرد)
   در صفحه 270) می تواند به همان اندازه مؤثر عمل کند.
  </p>
<p>
   چالش های اضافی می تواند از نظر برخورد با مشکلاتی مانند طول عمر وجود داشته باشد
   اتصالات و موارد مشابه. مطمئناً درست است که اگر یک <span style="color:blue">microservice</span> با صفر-
   استقرار زمان از کار افتادگی در ذهن، شما احتمالاً زمان بسیار آسان تری را خواهید داشت تا اگر شما
   یک معماری سیستم موجود را در نظر گرفت و سعی کرد این مفهوم را دوباره اصلاح کند
   بعد از آن. این که آیا شما قادر به پیاده سازی استقرار بدون توقف برای
   خدمات شما در ابتدا، اگر می توانید به آنجا برسید، مطمئناً از آن افزایش یافته است
   سطح استقلال
  </p>
<h4>مدیریت حالت مورد نظر</h4>
<p>
   مدیریت حالت مورد نظر توانایی تعیین نیازهای زیرساختی است
   شما برای برنامه خود دارید و برای آن الزامات بدون من-
   مداخله اوال. اگر سیستم در حال اجرا به گونه ای تغییر کند که حالت دلخواه شما
  </p>
<p>
   234
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0260</div>
            </div>
        </div>
        <!-- Page 0261 -->
        <div class="chapter" id="page-0261">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   دیگر نگهداری نمی‌شود، پلتفرم اساسی، مراحل لازم را برای آوردن سیستم
   به حالت دلخواه باز می گردد.
  </p>
<p>
   به عنوان یک مثال ساده از نحوه عملکرد مدیریت حالت مورد نظر، می توانید مشخص کنید
   تعداد نمونه هایی که <span style="color:blue">microservice</span> شما نیاز دارد، شاید همچنین مشخص کنید
   چه مقدار حافظه و <span style="color:blue">CPU</span> این نمونه ها نیاز دارند. برخی از پلتفرم های اساسی این را می گیرد
   پیکربندی و اعمال آن، سیستم را وارد حالت دلخواه می کند. به آن بستگی دارد
   پلتفرم، در میان چیزهای دیگر، شناسایی اینکه کدام دستگاه ها منابع یدکی دارند که
   می‌تواند برای اجرای تعداد درخواست‌شده نمونه‌ها اختصاص داده شود. همانطور که شکل 8-13 نشان می دهد، اگر
   یکی از آن نمونه ها از بین می رود، پلتفرم تشخیص می دهد که حالت فعلی،
   با حالت دلخواه مطابقت ندارد و با راه اندازی جایگزین اقدام مناسب را انجام می دهد
   نمونه
  </p>
<p>
<strong>شکل 8-13.</strong> پلتفرمی که مدیریت حالت مورد نظر را ارائه می دهد، راه اندازی یک جدید
   نمونه زمانی که یکی از بین می رود
  </p>
<p>
   زیبایی مدیریت حالت دلخواه این است که خود پلتفرم نحوه
   حالت مورد نظر حفظ می شود. این به همان اندازه افراد توسعه و عملیات را آزاد می کند
   برای اینکه مجبور نباشند دقیقاً در مورد چگونگی انجام کارها نگران باشند—آنها فقط مجبورند تمرکز کنند
   در وهله اول تعریف حالت مورد نظر را درست کنید. همچنین به این معنی است که در
   رویدادی که مشکلی رخ می دهد، مانند از بین رفتن یک نمونه، سخت افزار اساسی
   شکست می خورد، یا خاموش شدن یک مرکز داده، پلتفرم می تواند این موضوع را برای شما مدیریت کند
   بدون مداخله انسانی مورد نیاز است.
  </p>
<p>
   در حالی که می توان زنجیره ابزار خود را برای اعمال مدیریت حالت مورد نظر ساخت،
   به طور معمول از پلتفرمی استفاده می کنید که از قبل از آن پشتیبانی می کند. <span style="color:blue">Kubernetes</span> یکی از این ابزارها است که
   این ایده را در بر می گیرد، و شما همچنین می توانید چیزی مشابه را با استفاده از مفاهیمی مانند
   گروه های <span style="color:blue">autoscaling</span> در یک ارائه دهنده ابر عمومی مانند <span style="color:blue">Azure</span> یا <span style="color:blue">AWS</span>. یک پلتفرم دیگر
   که می تواند این قابلیت را فراهم کند <span style="color:blue">Nomad</span> است. برخلاف <span style="color:blue">Kubernetes</span>، که متمرکز است
   در استقرار و مدیریت بارهای کاری مبتنی بر کانتینر، <span style="color:blue">Nomad</span> بسیار انعطاف پذیر است
   مدل در اطراف اجرای انواع دیگر بارهای کاری برنامه نیز، مانند <span style="color:blue">Java</span>
</p>
<p>
   اصول استقرار <span style="color:blue">Microservice</span>
   |
   235
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 261" src="page_0261/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0261</div>
            </div>
        </div>
        <!-- Page 0262 -->
        <div class="chapter" id="page-0262">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   برنامه ها، <span style="color:blue">VM</span> ها، کارهای <span style="color:blue">Hadoop</span> و موارد دیگر. اگر می خواهید یک پلتفرم برای مدیریت
   بارهای کاری ترکیبی که همچنان از مفاهیمی مانند حالت دلخواه استفاده می کند، ممکن است ارزش داشته باشد
   مدیریت
  </p>
<p>
   این پلتفرم ها از در دسترس بودن منابع اساسی آگاه هستند و قادر به
   مطابقت درخواست ها برای حالت مورد نظر با منابع موجود (یا به شما می گویند این است
   امکان پذیر نیست). به عنوان یک اپراتور، از پیکربندی سطح پایین فاصله دارید—
   شما می توانید چیزی ساده مانند "من چهار نمونه را در دو مرکز داده می خواهم" بگویید
   و به پلتفرم خود تکیه کنید تا اطمینان حاصل شود که این کار برای شما انجام می شود. پلتفرم های مختلف
   سطوح مختلف کنترل را ارائه می دهند - شما می توانید با
   تعریف حالت دلخواه در صورت تمایل
  </p>
<p>
   استفاده از مدیریت حالت دلخواه می تواند گهگاه باعث ایجاد مشکلاتی شود اگر شما برای-
   فراموش کنید که از آن استفاده می کنید. من موقعیتی را به خاطر دارم که در آن یک را خاموش می کردم
   خوشه توسعه در <span style="color:blue">AWS</span> قبل از اینکه به خانه بروم. من در حال خاموش کردن مدیریت شده بودم
   نمونه های ماشین مجازی (ارائه شده توسط محصول <span style="color:blue">EC2</span> <span style="color:blue">AWS</span>) برای صرفه جویی در هزینه - آنها
   قرار نبود یک شب مورد استفاده قرار گیرند. با این حال، متوجه شدم که به محض اینکه یکی را کشتم
   از نمونه ها، یک نمونه دیگر ظاهر شد. مدتی طول کشید تا متوجه شدم که من
   یک گروه <span style="color:blue">autoscaling</span> را پیکربندی کرده بود تا اطمینان حاصل شود که حداقل تعداد
   دستگاه ها. <span style="color:blue">AWS</span> یک نمونه را دید که می مرد و جایگزینی را راه اندازی می کرد. طول کشید
   15 دقیقه بازی کردن به این شکل قبل از اینکه متوجه شوم چه خبر است.
   مشکل این بود که ما بر اساس ساعت برای <span style="color:blue">EC2</span> هزینه دریافت کردیم. حتی اگر یک نمونه
   فقط برای یک دقیقه اجرا شد، ما برای کل ساعت هزینه دریافت کردیم. بنابراین نوسانات من در
   پایان روز پرهزینه شد. به نوعی، این نشانه موفقیت بود (در
   حداقل این چیزی است که من به خودم گفتم) - ما گروه <span style="color:blue">autoscaling</span> را مدتی قبل تنظیم کردیم،
   و آنها فقط تا حدی کار کرده بودند که ما فراموش کرده بودیم که آنجا هستند. آن بود
   به سادگی نوشتن <span style="color:blue">script</span> برای غیرفعال کردن گروه <span style="color:blue">autoscaling</span> به عنوان بخشی از <span style="color:blue">clus</span>-
   تر خاموش کردن برای رفع مشکل در آینده.
  </p>
<h4>پیش نیازها</h4>
<p>
   برای بهره مندی از مدیریت حالت مورد نظر، پلتفرم به راهی نیاز دارد
   به طور خودکار نمونه هایی از <span style="color:blue">microservice</span> شما را راه اندازی کنید. بنابراین داشتن یک استقرار کاملاً خودکار
   برای نمونه های <span style="color:blue">microservice</span> یک پیش نیاز روشن برای مدیریت حالت دلخواه است
   سیستم عامل شما همچنین ممکن است نیاز داشته باشید که با دقت به مدت زمان اجرای <span style="color:blue">instan</span>- خود فکر کنید.
   ها را راه اندازی کنید. اگر شما از مدیریت حالت مورد نظر استفاده می کنید تا مطمئن شوید که کافی است
   منابع محاسباتی برای رسیدگی به بار کاربر، سپس اگر یک نمونه از بین رفت، شما
   یک نمونه جایگزین را در اسرع وقت می خواهید تا شکاف را پر کنید. اگر تهیه یک جدید
   نمونه زمان زیادی می برد، ممکن است نیاز داشته باشید که ظرفیت اضافی در نظر بگیرید
   بار را در صورت مرگ یک نمونه مدیریت کنید تا به خودتان نفس بدهید
   فضایی برای بالا بردن یک نسخه جدید.
  </p>
<p>
   اگرچه می‌توانید یک راه‌حل مدیریت حالت دلخواه را برای خود ایجاد کنید،
   من متقاعد نشده ام که استفاده خوبی از زمان شماست. اگر می خواهید این مفهوم را در آغوش بگیرید، من
  </p>
<p>
   236
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0262</div>
            </div>
        </div>
        <!-- Page 0263 -->
        <div class="chapter" id="page-0263">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   فکر می کنم بهتر است پلتفرمی را اتخاذ کنید که آن را به عنوان یک مفهوم درجه یک در آغوش بگیرد.
   از آنجایی که این بدان معناست که باید با آنچه ممکن است یک پلتفرم استقرار جدید را نشان دهد کنار بیایید
   و تمام ایده ها و ابزارهای مرتبط، ممکن است بخواهید اتخاذ حالت دلخواه را به تاخیر بیندازید
   مدیریت تا زمانی که از قبل چند <span style="color:blue">microservice</span> را راه اندازی کرده اید. این
   به شما این امکان را می دهد که قبل از تبدیل شدن به <span style="color:blue">over</span>- با اصول اولیه <span style="color:blue">microservice</span> ها آشنا شوید
   بارگذاری شده با فناوری جدید. پلتفرم هایی مانند <span style="color:blue">Kubernetes</span> واقعاً در مواقعی که دارید کمک می کنند
   چیزهای زیادی برای مدیریت—اگر فقط چند فرآیند دارید که نگران آنها هستید، می توانید
   تا بعداً صبر کنید تا این ابزارها را اتخاذ کنید.
  </p>
<h4><span style="color:blue">GitOps</span></h4>
<p>
<span style="color:blue">GitOps</span>، یک مفهوم نسبتاً اخیر که توسط <span style="color:blue">Weaveworks</span> پیشگام شده است، موارد زیر را گرد هم می آورد
   مفاهیم مدیریت حالت دلخواه و زیرساخت به عنوان کد. <span style="color:blue">GitOps</span> در اصل بود
   در زمینه کار با <span style="color:blue">Kubernetes</span> تصور شد، و اینجاست که مرتبط است
   ابزار متمرکز شده است، اگرچه می توان گفت گردش کاری را توصیف می کند که دیگران از آن استفاده کرده اند
   قبلا.
  </p>
<p>
   با <span style="color:blue">GitOps</span>، حالت مورد نظر شما برای زیرساخت های شما در کد تعریف شده است و ذخیره می شود
   در کنترل منبع. هنگامی که تغییراتی در این حالت دلخواه ایجاد می شود، برخی ابزارها تضمین می کنند
   که این حالت دلخواه به روز شده برای سیستم در حال اجرا اعمال می شود. ایده این است که بدهیم
   توسعه دهندگان گردش کاری ساده برای کار با برنامه های خود.
  </p>
<p>
   اگر از ابزارهای پیکربندی زیرساخت مانند <span style="color:blue">Chef</span> یا <span style="color:blue">Puppet</span> استفاده کرده اید، این مدل است
   برای مدیریت زیرساخت آشناست. هنگام استفاده از سرور <span style="color:blue">Chef</span> یا <span style="color:blue">Puppet Master</span>، شما
   یک سیستم متمرکز داشت که می توانست به طور پویا تغییرات را در صورت وجود ارسال کند
   ساخته شده است. تغییر با <span style="color:blue">GitOps</span> این است که این ابزار از قابلیت های داخلی استفاده می کند
   <span style="color:blue">Kubernetes</span> برای کمک به مدیریت برنامه ها و نه فقط زیرساخت ها.
  </p>
<p>
   ابزارهایی مانند <span style="color:blue">Flux</span>، درک این ایده ها را بسیار آسان تر می کنند. شایان ذکر است، البته
   که در حالی که ابزارها می توانند کار شما را آسان تر کنند، آنها نمی توانند شما را مجبور به اتخاذ روش های کار جدید کنند.
   به عبارت دیگر، فقط به این دلیل که شما <span style="color:blue">Flux</span> (یا یک ابزار <span style="color:blue">GitOps</span> دیگر) دارید، به این معنی نیست که شما در حال درک ایده ها هستید
   مدیریت حالت دلخواه یا زیرساخت به عنوان کد.
  </p>
<p>
   اگر در دنیای <span style="color:blue">Kubernetes</span> هستید، اتخاذ ابزاری مانند <span style="color:blue">Flux</span> و گردش کاری که آن را تبلیغ می کند، ممکن است به خوبی سرعت بخشد
   معرفی مفاهیمی مانند مدیریت حالت دلخواه و زیرساخت به عنوان کد. فقط مطمئن شوید
   در مورد اهداف خود دید خود را از دست ندهید
   مفاهیم اساسی و توسط تمام فناوری های جدید در این فضا کور نشوید!
  </p>
<h4>گزینه های استقرار</h4>
<p>
   وقتی نوبت به رویکردها و ابزارهایی می رسد که می توانیم برای کار <span style="color:blue">microservice</span> خود استفاده کنیم، ما
   گزینه های بارها ما باید به این گزینه ها از نظر
   اصولی که من تازه بیان کردم. ما می خواهیم <span style="color:blue">microservice</span> های ما به صورت ایزوله اجرا شوند
   و در حالت ایده آل به گونه ای مستقر شود که از زمان خرابی جلوگیری شود. ما ابزارهایی را می خواهیم که ما
  </p>
<p>
   گزینه های استقرار
   |
   237
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0263</div>
            </div>
        </div>
        <!-- Page 0264 -->
        <div class="chapter" id="page-0264">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   به شما اجازه می دهد تا فرهنگ اتوماسیون را در آغوش بگیرید، زیرساخت ها و
   پیکربندی برنامه را در کد تعریف کنید، و در حالت ایده آل نیز حالت مورد نظر را برای ما مدیریت کنید.
  </p>
<p>
   بیایید به طور خلاصه گزینه های مختلف استقرار را قبل از اینکه ببینیم چقدر خوب است
   آنها این ایده ها را ارائه می دهند:
  </p>
<ul>
<li><strong>دستگاه فیزیکی</strong></li>
<li>یک نمونه <span style="color:blue">microservice</span> مستقیماً بر روی یک دستگاه فیزیکی مستقر می شود، بدون
    مجازی سازی</li>
<li><strong>ماشین مجازی</strong></li>
<li>یک نمونه <span style="color:blue">microservice</span> بر روی یک ماشین مجازی مستقر می شود.</li>
<li><strong>کانتینر</strong></li>
<li>یک نمونه <span style="color:blue">microservice</span> به عنوان یک کانتینر جداگانه در یک مجازی یا فیزیکی اجرا می شود
    ماشین این <span style="color:blue">runtime</span> کانتینر ممکن است توسط یک ابزار ارکستراسیون کانتینر مانند <span style="color:blue">Kubernetes</span> مدیریت شود.</li>
<li><strong>کانتینر برنامه</strong></li>
<li>یک نمونه <span style="color:blue">microservice</span> در داخل یک کانتینر برنامه اجرا می شود که مدیریت می کند
    نمونه های برنامه دیگر، معمولاً در همان <span style="color:blue">runtime</span>.</li>
<li><strong>پلتفرم به عنوان سرویس (<span style="color:blue">PaaS</span>)</strong></li>
<li>یک پلتفرم انتزاعی تر برای استقرار نمونه های <span style="color:blue">microservice</span> استفاده می شود،
    اغلب تمام مفاهیم سرورهای اساسی را که برای اجرای شما استفاده می شود، خلاصه می کند
    <span style="color:blue">microservices</span>. نمونه ها عبارتند از <span style="color:blue">Heroku</span>، <span style="color:blue">Google App Engine</span> و <span style="color:blue">AWS</span>
<span style="color:blue">Beanstalk</span>.</li>
<li><strong>عملکرد به عنوان سرویس (<span style="color:blue">FaaS</span>)</strong></li>
<li>یک نمونه <span style="color:blue">microservice</span> به عنوان یک یا چند تابع مستقر می شود که اجرا می شوند و
    توسط پلتفرمی اساسی مانند <span style="color:blue">AWS Lambda</span> یا <span style="color:blue">Azure Functions</span> مدیریت می شود.</li>
</ul>
<p>
   می توان گفت، <span style="color:blue">FaaS</span> یک نوع خاص از <span style="color:blue">PaaS</span> است، اما با توجه به جدید بودن، شایسته کاوش است
   محبوبیت ایده و سؤالاتی که در مورد
   نگاشت از یک <span style="color:blue">microservice</span> به یک <span style="color:blue">artifact</span> مستقر شده است.
  </p>
<h4>ماشین های فیزیکی</h4>
<p>
   یک گزینه فزاینده نادر، ممکن است خود را مستقیماً استقرار <span style="color:blue">microservice</span> ها بیابید
   روی ماشین های فیزیکی با "مستقیم"، منظورم این است که هیچ لایه ای از مجازی سازی وجود ندارد
   یا <span style="color:blue">containerization</span> بین شما و سخت افزار اساسی. این کمتر و کمتر شده است
   رایج به چند دلیل مختلف. اول، استقرار مستقیم روی فیزیکی
   سخت افزار می تواند منجر به استفاده کمتر در سراسر اموال شما شود. اگر من یک نمونه واحد داشته باشم
   از یک <span style="color:blue">microservice</span> که روی یک دستگاه فیزیکی اجرا می شود و من فقط از نیمی از <span style="color:blue">CPU</span>، حافظه استفاده می کنم،
   یا <span style="color:blue">I/O</span> ارائه شده توسط سخت افزار، سپس منابع باقی مانده هدر می روند. این
   این مشکل منجر به مجازی سازی اکثر زیرساخت های محاسباتی شده است که به شما امکان می دهد
   ماشین های مجازی متعدد را در یک دستگاه فیزیکی مشترک داشته باشید. به شما می دهد بسیار
  </p>
<p>
   238
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0264</div>
            </div>
        </div>
        <!-- Page 0265 -->
        <div class="chapter" id="page-0265">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   استفاده بیشتر از زیرساخت های شما، که از نظر
   مقرون به صرفه بودن
  </p>
<p>
   اگر شما به سخت افزار فیزیکی بدون گزینه مجازی سازی دسترسی مستقیم دارید،
   وسوسه این است که چندین <span style="color:blue">microservice</span> را روی یک دستگاه قرار دهید—از
   البته، این اصل را که در مورد داشتن یک <span style="color:blue">execution</span> محیط جدا شده برای شما صحبت کردیم، نقض می کند
   خدمات شما می توانید از ابزارهایی مانند <span style="color:blue">Puppet</span> یا <span style="color:blue">Chef</span> برای پیکربندی استفاده کنید
   ماشین—کمک به پیاده سازی زیرساخت به عنوان کد. مشکل این است که اگر
   شما فقط در سطح یک دستگاه فیزیکی واحد کار می کنید، پیاده سازی
   مفاهیمی مانند مدیریت حالت دلخواه، استقرار بدون توقف و غیره نیاز دارد
   ما باید در سطح بالاتری از انتزاع کار کنیم، با استفاده از نوعی لایه مدیریت در
   بالا. این نوع سیستم ها معمولاً در ارتباط با مجازی استفاده می شوند
   ماشین ها، چیزی که ما در لحظه ای بیشتر بررسی خواهیم کرد.
  </p>
<p>
   به طور کلی، استقرار مستقیم <span style="color:blue">microservice</span> ها بر روی ماشین های فیزیکی چیزی است که من
   امروزه تقریباً هرگز نمی بینم، و احتمالاً باید الزامات بسیار خاصی داشته باشید
   (یا محدودیت ها) در شرایط شما برای توجیه این رویکرد نسبت به افزایش
   انعطاف پذیری که یا مجازی سازی یا <span style="color:blue">containerization</span> ممکن است به ارمغان بیاورد.
  </p>
<h4>ماشین های مجازی</h4>
<p>
   مجازی سازی با اجازه دادن به ما برای تکه تکه کردن موجود، مراکز داده را متحول کرده است
   دستگاه های فیزیکی به دستگاه های مجازی کوچکتر. مجازی سازی سنتی مانند
   <span style="color:blue">VMware</span> یا آنهایی که توسط ارائه دهندگان اصلی ابر استفاده می شوند، زیرساخت ماشین مجازی مدیریت شده
   (مانند سرویس <span style="color:blue">EC2</span> <span style="color:blue">AWS</span>) مزایای زیادی را در افزایش <span style="color:blue">uti</span>- به همراه داشته است
   <span style="color:blue">lization</span> زیرساخت های محاسباتی، در حالی که در عین حال سربار را کاهش می دهد
   مدیریت میزبان.
  </p>
<p>
   اساساً، مجازی سازی به شما اجازه می دهد تا یک دستگاه اساسی را به چند
   ماشین‌های "مجازی" کوچکتر که درست مثل سرورهای معمولی برای نرم‌افزار اجرا می‌شوند
   در داخل ماشین های مجازی می توانید قسمت هایی از <span style="color:blue">CPU</span> اساسی را اختصاص دهید،
   حافظه، <span style="color:blue">I/O</span> و قابلیت ذخیره سازی به هر ماشین مجازی، که در زمینه ما
   به شما امکان می دهد محیط های اجرای ایزوله بیشتری را برای <span style="color:blue">microser</span> خود بار کنید
   نمونه ها بر روی یک دستگاه فیزیکی واحد
  </p>
<p>
   هر ماشین مجازی حاوی یک سیستم عامل کامل و مجموعه ای از منابع است که می تواند باشد
   توسط نرم افزاری که در داخل <span style="color:blue">VM</span> در حال اجرا است، استفاده می شود. این تضمین می کند که شما بسیار خوب هستید
   درجه انزوا بین نمونه ها زمانی که هر نمونه بر روی جداگانه مستقر می شود
   <span style="color:blue">VM</span>. هر نمونه <span style="color:blue">microservice</span> می تواند سیستم عامل را به طور کامل در <span style="color:blue">VM</span> پیکربندی کند
   برای نیازهای محلی خود. با این حال، ما هنوز این مشکل را داریم که اگر سخت افزار اساسی
   اجرای این ماشین های مجازی با شکست مواجه می شود، می توانیم چندین نمونه <span style="color:blue">microservice</span> را از دست بدهیم.
  </p>
<p>
   راه هایی برای کمک به حل این مشکل خاص وجود دارد، از جمله مواردی مانند
   مدیریت حالت دلخواه، که قبلاً مورد بحث قرار دادیم.
  </p>
<p>
   گزینه های استقرار
   |
   239
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0265</div>
            </div>
        </div>
        <!-- Page 0266 -->
        <div class="chapter" id="page-0266">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>هزینه مجازی سازی</h4>
<p>
   همانطور که ماشین‌های مجازی بیشتری را روی همان سخت‌افزار اساسی بسته‌بندی می‌کنید،
   متوجه خواهید شد که از نظر منابع محاسباتی، بازدهی کمتری دریافت می‌کنید
   موجود در خود <span style="color:blue">VM</span> ها. چرا اینطور است؟
  </p>
<p>
   دستگاه فیزیکی خود را به عنوان یک کشوی جوراب در نظر بگیرید. اگر تقسیم‌کننده‌های چوبی زیادی را قرار دهیم
   وارد کشوی ما می شویم، آیا می توانیم جوراب های بیشتری را ذخیره کنیم یا کمتر؟ پاسخ کمتر است: تقسیم کننده ها
   خودشان هم جا می گیرند! ممکن است رسیدگی و سازماندهی کشوی ما آسان‌تر باشد،
   و شاید ما بتوانیم تصمیم بگیریم که اکنون پیراهن‌های تی شرت را در یکی از فضاها قرار دهیم تا اینکه فقط
   جوراب، اما تقسیم‌کننده‌های بیشتر به معنای فضای کلی کمتر است.
  </p>
<p>
   در دنیای مجازی سازی، ما یک سربار مشابه به عنوان تقسیم کننده های کشوی جوراب خود داریم.
   برای درک منشاء این سربار، بیایید نگاهی به نحوه انجام اکثر مجازی سازی بیندازیم.
   شکل 8-14 مقایسه ای از دو نوع مجازی سازی را نشان می دهد. در سمت چپ،
   ما لایه‌های مختلف درگیر در چیزی به نام مجازی‌سازی نوع 2 را می‌بینیم و در
   در سمت راست ما مجازی سازی مبتنی بر کانتینر را می بینیم، که به زودی بیشتر بررسی خواهیم کرد.
  </p>
<p>
   مجازی سازی نوع 2 نوعی است که توسط <span style="color:blue">AWS</span>، <span style="color:blue">VMware</span>، <span style="color:blue">vSphere</span>، <span style="color:blue">Xen</span>، و
   <span style="color:blue">KVM</span>. (مجازی سازی نوع 1 به فناوری اشاره دارد که در آن <span style="color:blue">VM</span> ها مستقیماً اجرا می شوند
   سخت افزار، نه در بالای سیستم عامل دیگر.) در زیرساخت فیزیکی ما
   ما یک سیستم عامل میزبان داریم. در این سیستم عامل ما چیزی به نام هایپروایزر را اجرا می کنیم،
   که دو کار کلیدی دارد. اول، منابعی مانند <span style="color:blue">CPU</span> و حافظه را از ویرایش می کند
   میزبان مجازی به میزبان فیزیکی. دوم، به عنوان یک لایه کنترل عمل می کند و به ما اجازه می دهد تا دستکاری کنیم
   خود ماشین های مجازی
  </p>
<p>
<strong>شکل 8-14.</strong> مقایسه مجازی سازی استاندارد نوع 2 و کانتینرهای سبک وزن
  </p>
<p>
   در داخل <span style="color:blue">VM</span> ها، ما آنچه را که شبیه میزبان های کاملاً متفاوت هستند، دریافت می کنیم. آنها می توانند اجرا کنند
   سیستم عامل های خودشان، با هسته های خودشان. آنها تقریباً هرمتیک در نظر گرفته می شوند
   ماشین‌های مهر و موم شده، که توسط هایپروایزر از میزبان فیزیکی اساسی و
   ماشین های مجازی دیگر
  </p>
<p>
   240
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 266" src="page_0266/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0266</div>
            </div>
        </div>
        <!-- Page 0267 -->
        <div class="chapter" id="page-0267">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   مشکل مجازی سازی نوع 2 این است که هایپروایزر در اینجا نیاز دارد
   منابعی را برای انجام کارش کنار بگذارید. این <span style="color:blue">CPU</span>، <span style="color:blue">I/O</span> و حافظه ای را می گیرد که می تواند مورد استفاده قرار گیرد
   جای دیگری. هر چه میزبان هایپروایزر بیشتر مدیریت کند، به منابع بیشتری نیاز دارد. در یک
   یک نقطه خاص، این سربار به یک محدودیت در تقسیم زیرساخت فیزیکی شما تبدیل می شود
   ساختار بیشتر در عمل، این بدان معناست که اغلب بازدهی کاهنده وجود دارد
   در برش یک جعبه فیزیکی به قسمت های کوچکتر و کوچکتر، زیرا به نسبت بیشتر
   و منابع بیشتر وارد سربار هایپروایزر می شود.
  </p>
<h4>برای <span style="color:blue">microservice</span> ها خوب است؟</h4>
<p>
   با بازگشت به اصول ما، ماشین های مجازی از نظر انزوا بسیار خوب عمل می کنند،
   اما با هزینه. سهولت اتوماسیون آنها می تواند بر اساس فناوری دقیقی که مورد استفاده قرار می گیرد متفاوت باشد
   استفاده شده - <span style="color:blue">VM</span> های مدیریت شده در <span style="color:blue">Google Cloud</span>، <span style="color:blue">Azure</span>، یا <span style="color:blue">AWS</span>، به عنوان مثال، همه آسان هستند
   اتوماتیک کردن از طریق <span style="color:blue">API</span> های خوب پشتیبانی شده و یک اکوسیستم ابزاری که بر اساس این <span style="color:blue">API</span> ها ساخته شده است.
   علاوه بر این، این پلتفرم ها مفاهیمی مانند گروه های <span style="color:blue">autoscaling</span> را ارائه می دهند و به اجرا کمک می کنند
   مدیریت حالت مورد نظر استقرار بدون توقف قرار است کار بیشتری را انجام دهد، اما اگر
   پلتفرم <span style="color:blue">VM</span> که از آن استفاده می کنید، یک <span style="color:blue">API</span> خوب به شما می دهد، بلوک های ساختمانی وجود دارد.
   مسئله این است که بسیاری از مردم از <span style="color:blue">VM</span> های مدیریت شده ارائه شده توسط
   پلتفرم های مجازی سازی سنتی مانند آنهایی که توسط
   <span style="color:blue">VMware</span>، که، در حالی که از نظر تئوری ممکن است امکان اتوماسیون را فراهم کند، معمولاً نیست
   در این زمینه استفاده می شود. در عوض این پلتفرم ها تمایل دارند تحت کنترل مرکزی یک
   تیم عملیاتی اختصاصی، و توانایی اتوماسیون مستقیم در برابر آنها می تواند باشد
   در نتیجه محدود شد.
  </p>
<p>
   اگرچه کانتینرها به طور کلی برای <span style="color:blue">microservice</span> ها محبوب تر می شوند
   بارهای کاری، بسیاری از سازمان ها از ماشین های مجازی برای اجرای در مقیاس بزرگ استفاده کرده اند
   سیستم های <span style="color:blue">microservice</span>، با اثر عالی. <span style="color:blue">Netflix</span>، یکی از بچه های پوستر برای <span style="color:blue">microser</span>-
   <span style="color:blue">vices</span>، بخش بزرگی از <span style="color:blue">microservice</span> های خود را بر روی ماشین های مجازی مدیریت شده <span style="color:blue">AWS</span> ساخت
   از طریق <span style="color:blue">EC2</span>. اگر به سطوح انزوای سخت تری که می توانند بیاورند نیاز دارید، یا شما ندارید
   توانایی <span style="color:blue">containerize</span> کردن برنامه خود را، <span style="color:blue">VM</span> ها می توانند یک انتخاب عالی باشند.
  </p>
<h4>کانتینرها</h4>
<p>
   از زمان انتشار اولین ویرایش این کتاب، کانتینرها به یک مفهوم غالب در
   استقرار نرم افزار سمت سرور و برای بسیاری انتخاب واقعی برای بسته بندی
   و اجرای معماری <span style="color:blue">microservice</span> ها. مفهوم کانتینر، که محبوبیت یافت
   <span style="color:blue">Docker</span>، و متحد با یک پلتفرم ارکستراسیون کانتینر پشتیبانی کننده مانند <span style="color:blue">Kuber</span>-
   <span style="color:blue">netes</span>، به انتخاب بسیاری از مردم برای اجرای معماری <span style="color:blue">microservice</span> ها تبدیل شده است
   در مقیاس.
  </p>
<p>
   قبل از اینکه به دلیل وقوع این اتفاق و رابطه بین کانتینرها برسیم،
   <span style="color:blue">Kubernetes</span> و <span style="color:blue">Docker</span>، ابتدا باید بررسی کنیم که دقیقاً یک کانتینر چیست و نگاه کنیم
   به طور خاص چگونه با ماشین های مجازی متفاوت است.
  </p>
<p>
   گزینه های استقرار
   |
   241
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0267</div>
            </div>
        </div>
        <!-- Page 0268 -->
        <div class="chapter" id="page-0268">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   به طور جداگانه، متفاوت
  </p>
<p>
   کانتینرها ابتدا در سیستم عامل های سبک <span style="color:blue">UNIX</span> ظاهر شدند و برای سالهای زیادی بودند
   واقعاً فقط یک چشم انداز مناسب در آن سیستم عامل ها، مانند <span style="color:blue">Linux</span>. اگرچه
   کانتینرهای ویندوز بسیار زیاد هستند، سیستم عامل های <span style="color:blue">Linux</span> هستند که
   کانتینرها تا کنون بیشترین تأثیر را داشته اند.
  </p>
<p>
   در <span style="color:blue">Linux</span>، فرآیندها توسط یک کاربر معین اجرا می شوند و دارای قابلیت های خاصی هستند
   چگونه مجوزها تنظیم می شوند. فرآیندها می توانند فرآیندهای دیگر را تولید کنند. به عنوان مثال، اگر من
   یک فرآیند را در یک ترمینال راه اندازی کنید، آن فرآیند عموماً یک فرزند از تر در نظر گرفته می شود
   فرآیند <span style="color:blue">minal</span>. وظیفه هسته <span style="color:blue">Linux</span> حفظ این درخت فرآیندها است، اطمینان حاصل می کند
   که فقط کاربران مجاز می توانند به فرآیندها دسترسی داشته باشند. علاوه بر این، هسته <span style="color:blue">Linux</span> است
   قادر به اختصاص منابع به این فرآیندهای مختلف است - این همه بخشی است
   ساختن یک سیستم عامل چندکاربره مناسب، که در آن شما نمی خواهید فعالیت های
   یک کاربر برای از بین بردن بقیه سیستم.
  </p>
<p>
   کانتینرهایی که روی همان دستگاه اجرا می شوند، از همان هسته اساسی استفاده می کنند
   (اگرچه استثناهایی برای این قانون وجود دارد که به زودی بررسی خواهیم کرد). به جای
   مدیریت مستقیم فرآیندها، می توانید به یک کانتینر به عنوان انتزاعی بر روی یک
   زیر درخت درخت فرآیند سیستم کلی، با هسته که تمام کارهای سخت را انجام می دهد.
   این کانتینرها می توانند منابع فیزیکی را به آنها اختصاص دهند، چیزی که هسته
   برای ما دستکاری می کند. این رویکرد کلی در اشکال مختلفی وجود داشته است، مانند <span style="color:blue">Solaris</span>
<span style="color:blue">Zones</span> و <span style="color:blue">OpenVZ</span>، اما این با <span style="color:blue">LXC</span> بود که این ایده وارد اصلی شد
   جریان سیستم عامل های <span style="color:blue">Linux</span>. مفهوم کانتینرهای <span style="color:blue">Linux</span> بیشتر بود
   زمانی که <span style="color:blue">Docker</span> یک سطح انتزاع بالاتر را نسبت به کانتینرها ارائه کرد، پیشرفت کرد،
   در ابتدا از <span style="color:blue">LXC</span> در زیر هود استفاده می کرد و سپس آن را به طور کامل جایگزین کرد.
  </p>
<p>
   اگر به نمودار پشته برای یک میزبان در حال اجرا در یک کانتینر در شکل 8-14 نگاه کنیم، ما یک
   چند تفاوت هنگام مقایسه آن با مجازی سازی نوع 2. اول، ما نیازی نداریم
   هایپروایزر دوم، به نظر نمی رسد کانتینر هسته ای داشته باشد—این به این دلیل است که
   از هسته دستگاه اساسی استفاده می کند. در شکل 8-15 این را بیشتر می بینیم
   روشن. یک کانتینر می تواند سیستم عامل خود را اجرا کند، اما آن سیستم عامل
   از بخشی از هسته مشترک استفاده می کند - در این هسته است که درخت فرآیند برای
   هر کانتینر زندگی می کند. این بدان معناست که سیستم عامل میزبان ما می تواند <span style="color:blue">Ubuntu</span> را اجرا کند،
   و کانتینرهای ما <span style="color:blue">CentOS</span>، تا زمانی که هر دو بتوانند به عنوان بخشی از همان تحت اجرا شوند
   هسته زیربنایی
  </p>
<p>
<strong>شکل 8-15.</strong> به طور معمول، کانتینرها روی همان دستگاه، هسته یکسانی را به اشتراک می گذارند
  </p>
<p>
   242
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 268" src="page_0268/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0268</div>
            </div>
        </div>
        <!-- Page 0269 -->
        <div class="chapter" id="page-0269">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   با کانتینرها، ما نه تنها از منابع ذخیره شده با عدم نیاز به یک
   هایپروایزر؛ ما همچنین از نظر بازخورد به دست می آوریم. کانتینرهای <span style="color:blue">Linux</span> بسیار سریعتر هستند
   نسبت به ماشین های مجازی تمام چرب. غیر معمول نیست که یک <span style="color:blue">VM</span> زمان زیادی را بگیرد
   دقیقه برای شروع—اما با کانتینرهای <span style="color:blue">Linux</span>، راه اندازی می تواند فقط چند ثانیه طول بکشد. شما
   همچنین کنترل دقیق تری بر روی خود کانتینرها از نظر اختصاصی دارید
   منابع به آنها، که تنظیمات را بسیار آسان تر می کند تا بیشترین میزان را دریافت کنید
   از سخت افزار اساسی
  </p>
<p>
   به دلیل ماهیت سبک تر کانتینرها، می توانیم تعداد بیشتری از آنها را داشته باشیم
   اجرای آن بر روی همان سخت افزار نسبت به ماشین های مجازی ممکن خواهد بود. با استقرار یک
   سرویس در هر کانتینر، همانطور که در شکل 8-16 نشان داده شده است، ما درجه ای از انزوا را از سایر کانتینرها دریافت می کنیم
   <span style="color:blue">tainers</span> (اگرچه این کامل نیست) و می تواند این کار را بسیار مقرون به صرفه تر از
   در صورت تمایل به اجرای هر سرویس در <span style="color:blue">VM</span> خود، ممکن است. با بازگشت به
   تشابه کشوی جوراب ما از قبل، با کانتینرها تقسیم کننده های کشوی جوراب هستند
   بسیار نازک تر از <span style="color:blue">VM</span> ها هستند، به این معنی که نسبت بیشتری از جوراب
   کشو برای جوراب استفاده می شود.
  </p>
<p>
<strong>شکل 8-16.</strong> اجرای سرویس ها در کانتینرهای جداگانه
  </p>
<p>
   کانتینرها می توانند به خوبی با مجازی سازی تمام چربی نیز استفاده شوند. در واقع، این یک است
   معمول من بیش از یک پروژه را دیده ام که یک نمونه بزرگ <span style="color:blue">AWS EC2</span> را ارائه می دهد و اجرا می کند
   در آن کانتینرهای متعدد برای به دست آوردن بهترین های هر دو جهان: یک محاسبات زودگذر درخواستی
   پلت فرم در قالب <span style="color:blue">EC2</span>، همراه با کانتینرهای بسیار انعطاف پذیر و سریع در حال اجرا
   روی آن
  </p>
<p>
   گزینه های استقرار
   |
   243
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 269" src="page_0269/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0269</div>
            </div>
        </div>
        <!-- Page 0270 -->
        <div class="chapter" id="page-0270">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>کامل نیست</h4>
<p>
   کانتینرهای <span style="color:blue">Linux</span> با این حال، بدون مشکل نیستند. تصور کنید که من تعداد زیادی دارم
   <span style="color:blue">microservices</span> ها در کانتینرهای خودشان در یک میزبان در حال اجرا هستند. دنیای بیرون چگونه است
   آنها را می بینید؟ شما به نوعی به مسیر دنیای بیرون به کانتینرهای اساسی نیاز دارید، چیزی که بسیاری از
   هایپروایزرها این کار را برای شما با مجازی سازی معمولی انجام می دهند.
  </p>
<p>
   با فناوری قبلی مانند <span style="color:blue">LXC</span>، این چیزی بود که شما باید خودتان آن را مدیریت می کردید -
   این یک حوزه است که <span style="color:blue">Docker</span> در کانتینرها به شدت کمک کرده است.
  </p>
<p>
   نکته دیگری که باید در نظر داشت این است که این کانتینرها می توانند از هم جدا شوند
   از نظر منبع—من می توانم مجموعه های حلقه ای از <span style="color:blue">CPU</span>، حافظه، و
   بنابراین به هر کانتینر—اما این لزوماً همان درجه انزوا نیست
   شما از ماشین های مجازی دریافت می کنید، یا در این مورد با داشتن فیزیکی جداگانه
   ماشین ها در اوایل، تعدادی از روش‌های مستند و شناخته شده وجود داشت که در آن‌ها
   یک فرآیند از یک کانتینر می توانست از بین برود و با سایر کانتینرها یا
   میزبان اساسی.
  </p>
<p>
   مقدار زیادی کار برای حل این مسائل انجام شده است و کانتینر
   سیستم های ارکستراسیون و <span style="color:blue">runtimes</span> کانتینر اساسی کار خوبی انجام داده اند
   بررسی نحوه اجرای بهتر بارهای کاری کانتینر به طوری که این انزوا بهبود یابد، اما
   شما باید توجه لازم را به انواع بارهای کاری که می خواهید اجرا کنید داشته باشید. مال من
   راهنمایی در اینجا این است که به طور کلی شما باید کانتینرها را راهی عالی برای جداسازی در نظر بگیرید
   اجرای نرم افزار مورد اعتماد اگر شما در حال اجرای کدی هستید که توسط دیگران نوشته شده است و هستید
   نگران یک مهمانی مخرب هستید که سعی می کند از انزوا در سطح کانتینر عبور کند، پس شما
   می خواهید خودتان در مورد آخرین وضعیت هنر تحقیقات عمیق تری انجام دهید
   برای رسیدگی به چنین موقعیت هایی—که برخی از آنها را در یک لحظه لمس خواهیم کرد.
  </p>
<h4>کانتینرهای ویندوز</h4>
<p>
   از نظر تاریخی، کاربران ویندوز به همتایان <span style="color:blue">Linux</span> خود با حسرت نگاه می کردند، زیرا
   کانتینرها چیزی بودند که از سیستم عامل ویندوز محروم شده بودند. بر
   با این حال، در چند سال گذشته، این تغییر کرده است، به طوری که کانتینرها اکنون به طور کامل پشتیبانی می شوند
   مفهوم <span style="color:blue">.</span> تأخیر واقعاً در مورد سیستم عامل و هسته ویندوز اساسی بود
   سیستم عامل های <span style="color:blue">Linux</span> همان نوع قابلیت ها را دارند که در سرزمین
   <span style="color:blue">Linux</span> برای کار کردن کانتینرها. این با تحویل <span style="color:blue">Windows Server</span> 2016 بود
   بسیاری از این موارد تغییر کرد و از آن زمان کانتینرهای ویندوز به تکامل خود ادامه داده اند.
  </p>
<p>
   یکی از موانع اولیه در پذیرش کانتینرهای ویندوز بوده است
   اندازه خود سیستم عامل ویندوز. به یاد داشته باشید که شما باید یک اجرا کنید
   سیستم عامل در داخل هر کانتینر، بنابراین هنگام دانلود یک تصویر کانتینر،
   شما همچنین در حال دانلود یک سیستم عامل هستید. با این حال، ویندوز بزرگ است—به قدری بزرگ که آن را
   کانتینرها را بسیار سنگین کرد، نه فقط از نظر اندازه تصاویر، بلکه در
   از نظر منابع مورد نیاز برای اجرای آنها.
  </p>
<p>
<span style="color:blue">Microsoft</span> با ایجاد یک سیستم عامل کاهش یافته به این موضوع واکنش نشان داد
   <span style="color:blue">Windows</span> <span style="color:blue">Nano Server</span> نامیده می شود. ایده این است که <span style="color:blue">Nano Server</span> باید <span style="color:blue">OS</span> با ردپای کوچک داشته باشد و باشد
  </p>
<p>
   244
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0270</div>
            </div>
        </div>
        <!-- Page 0271 -->
        <div class="chapter" id="page-0271">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   قادر به اجرای چیزهایی مانند نمونه های <span style="color:blue">microservice</span>. در کنار این، <span style="color:blue">Microsoft</span> نیز
   پشتیبانی از یک <span style="color:blue">Windows Server Core</span> بزرگتر، که برای پشتیبانی از اجرای قدیمی وجود دارد
   برنامه های ویندوز به عنوان کانتینر. مسئله این است که این چیزها هنوز هم بسیار بزرگ هستند
   در مقایسه با معادل های <span style="color:blue">Linux</span> - نسخه های اولیه <span style="color:blue">Nano Server</span> هنوز هم خواهد بود
   بیش از 1 گیگابایت در اندازه، در مقایسه با سیستم عامل های سبک وزن <span style="color:blue">Linux</span> مانند
   <span style="color:blue">Alpine</span> که تنها چند مگابایت طول می کشد.
  </p>
<p>
   در حالی که <span style="color:blue">Microsoft</span> همچنان در تلاش است اندازه <span style="color:blue">Nano Server</span> را کاهش دهد، این اندازه
   تفاوت هنوز وجود دارد. اما در عمل، با توجه به نحوه لایه های مشترک در سراسر
   تصاویر کانتینر را می توان <span style="color:blue">cache</span> کرد، این ممکن است یک مسئله عظیم نباشد.
  </p>
<p>
   از علاقه ویژه در دنیای کانتینرهای ویندوز این واقعیت است که آنها پشتیبانی می کنند
   سطوح مختلف انزوا یک کانتینر ویندوز استاندارد از جداسازی فرآیند استفاده می کند،
   بسیار شبیه به همتایان <span style="color:blue">Linux</span> آن با انزوا فرآیند، هر کانتینر به صورت جزئی اجرا می شود
   از همان هسته اساسی، که انزوا بین کانتینرها را مدیریت می کند.
   با کانتینرهای ویندوز، شما همچنین این گزینه را دارید که با ارائه انزوای بیشتر،
   اجرای کانتینرها در داخل <span style="color:blue">VM</span> <span style="color:blue">Hyper-V</span> خود. این چیزی به شما می دهد
   به سطح انزوا مجازی سازی کامل نزدیک تر است، اما نکته خوب این است که شما می توانید انتخاب کنید
   بین <span style="color:blue">Hyper-V</span> یا جداسازی فرآیند هنگام راه‌اندازی کانتینر - تصویر
   نیازی به تغییر ندارد.
  </p>
<p>
   داشتن انعطاف پذیری در مورد اجرای تصاویر در انواع مختلف انزوا می تواند داشته باشد
   فواید. در برخی شرایط، مدل تهدید شما ممکن است دیکته کند که شما قوی تر می خواهید
   انزوا بین فرآیندهای در حال اجرا شما نسبت به جداسازی ساده در سطح فرآیند. برای
   به عنوان مثال، ممکن است در حال اجرای کد شخص ثالث "غیرقابل اعتماد" در کنار
   فرآیندهای خود در چنین شرایطی، توانایی اجرای آن بارهای کاری کانتینر به عنوان <span style="color:blue">Hyper</span>-
   کانتینرهای <span style="color:blue">V</span> بسیار مفید است. البته توجه داشته باشید که انزوای <span style="color:blue">Hyper-V</span> احتمالاً خواهد داشت
   تاثیر از نظر زمان <span style="color:blue">spin-up</span> و هزینه <span style="color:blue">runtime</span> نزدیکتر به حالت عادی
   مجازی سازی
  </p>
<h4>خطوط تار</h4>
<p>
   یک روند رو به رشد از افرادی وجود دارد که به دنبال راه‌حل‌هایی هستند که <span style="color:blue">iso</span>- قوی‌تر را ارائه می‌دهند
   <span style="color:blue">lation</span> ارائه شده توسط <span style="color:blue">VM</span> ها در حالی که دارای ماهیت سبک کانتینرها هستند. مثال ها
   شامل کانتینرهای <span style="color:blue">Hyper-V</span> مایکروسافت، که امکان وجود هسته های جداگانه و
   <span style="color:blue">Fire</span>- <span style="color:blue">cracker</span>، که به طور گیج کننده یک <span style="color:blue">VM</span> مبتنی بر هسته نامیده می شود. <span style="color:blue">Firecracker</span> ثابت کرده است که پاپو
   <span style="color:blue">lar</span> به عنوان یک جزئیات پیاده سازی از ارائه خدمات مانند <span style="color:blue">AWS Lambda</span>، جایی که وجود دارد
   نیاز به جداسازی کامل بارهای کاری از مشتریان مختلف در حالی که هنوز سعی می کنید
   زمان <span style="color:blue">spin-up</span> را کاهش داده و ردپای عملیاتی بارهای کاری را کاهش دهید.
  </p>
<p>
   گزینه های استقرار
   |
   245
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0271</div>
            </div>
        </div>
        <!-- Page 0272 -->
        <div class="chapter" id="page-0272">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>داکر</h4>
<p>
   کانتینرها قبل از ظهور <span style="color:blue">Docker</span> که مفهوم را به جلو برد، استفاده محدودی داشتند
   اصلی <span style="color:blue">.</span> زنجیره ابزار <span style="color:blue">Docker</span> بسیاری از کارهای اطراف کانتینرها را مدیریت می کند.
   <span style="color:blue">Docker</span> مدیریت تهیه کانتینر، برخی از مشکلات شبکه را برای شما مدیریت می کند، و حتی ارائه می دهد
   مفهوم رجیستری خود که به شما امکان می دهد برنامه های <span style="color:blue">Docker</span> را ذخیره کنید. قبل از <span style="color:blue">Docker</span>، ما مفهوم "تصویر" را نداشتیم.
   برای کانتینرها - این جنبه، همراه با مجموعه بسیار زیباتری از ابزارها برای کار با
   کانتینرها، به آسان‌تر شدن استفاده از کانتینرها کمک کرد.
  </p>
<p>
   انتزاع تصویر <span style="color:blue">Docker</span> برای ما مفید است، زیرا جزئیات نحوه
   <span style="color:blue">microservice</span> پیاده سازی شده پنهان شده است. ما می سازد برای ایجاد <span style="color:blue">microservice</span> ما
   یک تصویر <span style="color:blue">Docker</span> به عنوان یک <span style="color:blue">artifact</span> ساخت و تصویر را در رجیستری <span style="color:blue">Docker</span> ذخیره می کنیم، و دور
   می رویم. هنگامی که شما یک نمونه از یک تصویر <span style="color:blue">Docker</span> را راه اندازی می کنید، مجموعه ای عمومی از
   ابزارها برای مدیریت آن نمونه، صرف نظر از فناوری اساسی مورد استفاده — <span style="color:blue">micro</span>-
   <span style="color:blue">services</span> نوشته شده در <span style="color:blue">Go</span>، <span style="color:blue">Python</span>، <span style="color:blue">NodeJS</span>، یا هر چیز دیگری را می توان یکسان در نظر گرفت.
  </p>
<p>
<span style="color:blue">Docker</span> همچنین می تواند برخی از جنبه های منفی اجرای تعداد زیادی سرویس را به صورت محلی کاهش دهد
   برای اهداف توسعه و آزمایش. قبلاً، ممکن بود از ابزاری مانند <span style="color:blue">Vagrant</span> استفاده کنم که اجازه می دهد
   من میزبان ماشین های مجازی مستقل متعدد در دستگاه توسعه خود هستم. این
   به من اجازه می دهد که یک <span style="color:blue">VM</span> شبیه تولید داشته باشم که نمونه های سرویس من را به صورت محلی اجرا می کند. این
   اگرچه رویکردی بسیار سنگین بود، و من در مورد تعداد <span style="color:blue">VM</span> هایی که می توانستم اجرا کنم، محدود می شدم. با <span style="color:blue">Docker</span>، آسان است
   فقط <span style="color:blue">Docker</span> را مستقیماً روی دستگاه توسعه‌دهنده خود اجرا کنید، احتمالاً از <span style="color:blue">Docker Desktop</span> استفاده می‌کنید. اکنون می توانم یک <span style="color:blue">Docker</span> بسازم
   تصویر برای نمونه <span style="color:blue">microservice</span> من، یا یک تصویر از قبل ساخته شده را پایین بکشید و آن را به صورت محلی اجرا کنید. اینها
   تصاویر <span style="color:blue">Docker</span> می توانند (و باید) با تصویر کانتینری که در نهایت اجرا خواهم کرد یکسان باشند
   در تولید
  </p>
<p>
   وقتی <span style="color:blue">Docker</span> برای اولین بار ظهور کرد، دامنه آن به مدیریت کانتینرها در یک مورد محدود شد
   ماشین. این استفاده محدودی داشت—اگر می خواهید کانتینرها را در سراسر مدیریت کنید چه؟
   ماشین های متعدد؟ این چیزی است که برای حفظ سلامت سیستم ضروری است، اگر شما دارید
   یک دستگاه از بین می رود، یا اگر فقط می خواهید کانتینرهای کافی را اجرا کنید تا
   بار سیستم را مدیریت کنید. <span style="color:blue">Docker</span> با دو محصول کاملاً متفاوت از خود بیرون آمد
   برای حل این مشکل، که به طرز گیج کننده ای " <span style="color:blue">Docker Swarm</span> " و " <span style="color:blue">Docker Swarm</span> " نامیده می شود
   حالت" - چه کسی دوباره گفت نامگذاری سخت است؟ واقعاً، اگر به آن برسیم
   مدیریت تعداد زیادی کانتینر در سراسر ماشین های زیاد، <span style="color:blue">Kubernetes</span> در اینجا پادشاه است، حتی
   اگر ممکن است از زنجیره ابزار <span style="color:blue">Docker</span> برای ساخت و مدیریت فردی استفاده کنید
   کانتینرها
  </p>
<h4>تناسب برای <span style="color:blue">microservice</span> ها</h4>
<p>
   کانتینرها به عنوان یک مفهوم برای <span style="color:blue">microservice</span> ها به خوبی کار می کنند و <span style="color:blue">Docker</span> ساخت
   کانتینرها را به طور قابل توجهی به عنوان یک مفهوم بیشتر امکان پذیر کرد. ما انزوا خود را دریافت می کنیم اما در یک <span style="color:blue">man</span>-
   هزینه <span style="color:blue">ageable</span>. ما همچنین فناوری اساسی را پنهان می کنیم و به ما اجازه می دهد تا فناوری های مختلف را ترکیب کنیم
  </p>
<p>
   گزینه های استقرار
   |
   246
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0272</div>
            </div>
        </div>
        <!-- Page 0273 -->
        <div class="chapter" id="page-0273">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<span style="color:blue">stacks</span>. اما وقتی نوبت به اجرای مفاهیمی مانند مدیریت حالت دلخواه می رسد،
   با این حال، ما به چیزی مانند <span style="color:blue">Kubernetes</span> نیاز داریم تا آن را برای ما مدیریت کند.
  </p>
<p>
<span style="color:blue">Kubernetes</span> به اندازه کافی مهم است که یک بحث دقیق تر را تضمین کند، بنابراین ما خواهیم شد
   بعداً در فصل به آن بازگردید. اما در حال حاضر فقط به آن به عنوان راهی برای مدیریت <span style="color:blue">con</span>- فکر کنید
   <span style="color:blue">tainers</span> در بسیاری از دستگاه ها، که برای این لحظه کافی است.
  </p>
<h4>کانتینرهای برنامه</h4>
<p>
   اگر با استقرار برنامه های <span style="color:blue">NET</span> در پشت <span style="color:blue">IIS</span> یا برنامه های <span style="color:blue">Java</span> آشنا هستید
   به چیزی مانند <span style="color:blue">Weblogic</span> یا <span style="color:blue">Tomcat</span>، با مدلی که در آن هستید آشنا خواهید بود
   در آن چندین سرویس یا برنامه مجزا در داخل یک کانتینر برنامه واحد قرار می گیرند،
   که به نوبه خود بر روی یک میزبان واحد قرار می گیرد، همانطور که در شکل 8-17 می بینیم. ایده این است که
   کانتینر برنامه ای که سرویس های شما در آن قرار دارند به شما از نظر
   قابلیت مدیریت بهبود یافته، مانند پشتیبانی از خوشه بندی برای رسیدگی به گروه بندی نمونه های متعدد
   با هم، ابزارهای نظارت و موارد مشابه.
  </p>
<p>
<strong>شکل 8-17.</strong> چندین <span style="color:blue">microservice</span> در هر کانتینر برنامه
  </p>
<p>
   این تنظیمات همچنین می تواند از نظر کاهش سربار زبان مزایایی را به همراه داشته باشد
   <span style="color:blue">times</span>. اجرای پنج سرویس <span style="color:blue">Java</span> را در یک کانتینر <span style="color:blue">servlet</span> واحد در نظر بگیرید. من
   فقط سربار یک <span style="color:blue">JVM</span> واحد را دارم. این را با اجرای پنج <span style="color:blue">JVM</span> مستقل مقایسه کنید
   بر روی همان میزبان هنگام استفاده از کانتینرها. با این حال، من هنوز هم احساس می کنم که این برنامه
   کانتینرها به اندازه کافی کاستی دارند که باید خودتان را به چالش بکشید تا ببینید
   واقعاً مورد نیاز است
  </p>
<p>
   اولین چیزی که از نظر کاستی است این است که آنها به ناچار انتخاب فناوری را محدود می کنند. شما
   باید به یک پشته فناوری بخرید. این می تواند نه تنها انتخاب های فناوری را محدود کند
   برای پیاده سازی خود سرویس، بلکه گزینه هایی که شما از نظر
  </p>
<p>
   گزینه های استقرار
   |
   247
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 273" src="page_0273/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0273</div>
            </div>
        </div>
        <!-- Page 0274 -->
        <div class="chapter" id="page-0274">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   اتوماسیون و مدیریت سیستم های شما. همانطور که به زودی بحث خواهیم کرد، یکی از
   راه‌هایی که ما می‌توانیم به سربار مدیریت میزبان‌های متعدد بپردازیم، اتوماسیون است،
   و بنابراین محدود کردن گزینه‌های ما برای حل این مشکل ممکن است دوبار آسیب زننده باشد.
  </p>
<p>
   من همچنین ارزش برخی از ویژگی‌های ارائه شده توسط این برنامه‌ها را زیر سوال می‌برم
   کانتینرها. بسیاری از آنها توانایی مدیریت خوشه ها را برای پشتیبانی از اشتراک در <span style="color:blue">in</span>-
   حالت جلسه حافظه، چیزی که ما در هر صورت به دلیل این می خواهیم از آن اجتناب کنیم
   چالش هایی که این هنگام مقیاس بندی خدمات ما ایجاد می کند. و قابلیت های نظارتی
   که ارائه می‌دهند، وقتی انواع نظارت‌های مشترک را در نظر می‌گیریم، کافی نخواهد بود
   ما می خواهیم در دنیای <span style="color:blue">microservices</span> انجام دهیم، همانطور که در فصل 10 خواهیم دید. بسیاری از آنها نیز
   زمان راه اندازی بسیار کندی داشته باشید که بر چرخه های بازخورد توسعه دهنده تأثیر می گذارد.
  </p>
<p>
   مجموعه دیگری از مشکلات نیز وجود دارد. تلاش برای انجام مدیریت چرخه عمر مناسب
   برنامه‌ها در بالای پلتفرم‌هایی مانند <span style="color:blue">JVM</span> می‌تواند مشکل‌ساز و پیچیده‌تر باشد
   از راه اندازی مجدد یک <span style="color:blue">JVM</span>. تجزیه و تحلیل استفاده از منابع و رشته ها نیز بسیار است
   پیچیده‌تر، زیرا شما چندین برنامه در حال اشتراک فرآیند هستید. و
   به یاد داشته باشید، حتی اگر از کانتینرهای مخصوص فناوری ارزش می‌گیرید، آنها
   رایگان نیستند. جدا از این واقعیت که بسیاری از آنها تجاری هستند و در نتیجه هزینه دارند
   تلویحات، آنها یک سربار منبع به خودی خود اضافه می کنند.
  </p>
<p>
   در نهایت، این رویکرد دوباره تلاشی برای بهینه سازی برای کمبود منابع است
   که به سادگی دیگر ممکن است حفظ نشود. این که آیا شما تصمیم می گیرید که داشته باشید یا نداشته باشید
   چندین سرویس در هر میزبان به عنوان یک مدل استقرار، من اکیداً پیشنهاد می کنم که به خود نگاه کنید
   <span style="color:blue">microservices</span> های قابل استقرار خودمحور به عنوان <span style="color:blue">artifact</span> ها، با هر نمونه <span style="color:blue">microservice</span> اجرا می شود
   به عنوان فرآیند جدا شده خود.
  </p>
<p>
   اساساً، فقدان انزوا که این مدل ارائه می دهد یکی از دلایل اصلی است
   چرا این مدل برای افرادی که معماری های <span style="color:blue">microservice</span> را اتخاذ می کنند به طور فزاینده ای نادر است.
  </p>
<h4>پلتفرم به عنوان سرویس (<span style="color:blue">PaaS</span>)</h4>
<p>
   هنگام استفاده از پلتفرم به عنوان سرویس (<span style="color:blue">PaaS</span>)، شما در یک انتزاع سطح بالاتر کار می کنید
   از یک میزبان واحد. برخی از این پلتفرم ها به گرفتن یک فناوری خاص وابسته هستند
   <span style="color:blue">artifact</span>، مانند یک فایل <span style="color:blue">Java WAR</span> یا <span style="color:blue">gem Ruby</span>، و به طور خودکار تهیه و
   در حال اجرا برای شما. برخی از این پلتفرم ها به طور شفاف تلاش خواهند کرد تا مقیاس را مدیریت کنند
   سیستم را برای شما بالا و پایین می آورد. دیگران به شما مقداری کنترل می دهند
   تعداد گره هایی که سرویس شما ممکن است روی آنها اجرا شود، اما بقیه را کنترل می کنند.
  </p>
<p>
   همانطور که در زمان نوشتن اولین نسخه بودم، اکثر بهترین، عالی ترین <span style="color:blue">PaaS</span>
   راه حل ها میزبانی می شوند. <span style="color:blue">Heroku</span> معیار را برای ارائه یک توسعه دهنده دوستانه تعیین کرد
   رابط، و می توان گفت که علیرغم محدودیت، استاندارد طلایی برای <span style="color:blue">PaaS</span> باقی مانده است
   رشد از نظر مجموعه ویژگی های خود در چند سال گذشته. پلتفرم هایی مانند <span style="color:blue">Heroku</span> انجام نمی دهند
   فقط نمونه برنامه شما را اجرا کنید. آنها همچنین قابلیت هایی مانند اجرا را ارائه می دهند
   نمونه های پایگاه داده برای شما - چیزی که انجام آن می تواند بسیار دردناک باشد.
  </p>
<p>
   248
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0274</div>
            </div>
        </div>
        <!-- Page 0275 -->
        <div class="chapter" id="page-0275">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   وقتی راه‌حل‌های <span style="color:blue">PaaS</span> خوب عمل می‌کنند، در واقع بسیار خوب عمل می‌کنند. با این حال، زمانی که آنها
   کاملاً برای شما کار نمی کنند، شما اغلب کنترل زیادی از نظر دریافت ندارید
   زیر هود برای رفع مشکلات این بخشی از مبادله ای است که شما انجام می دهید. من می گویم که
   در تجربه من هر چه راه حل های <span style="color:blue">PaaS</span> باهوش تر سعی می کنند باشند، بیشتر اشتباه می کنند.
   من بیش از یک <span style="color:blue">PaaS</span> استفاده کرده‌ام که تلاش می‌کند بر اساس استفاده از برنامه مقیاس خودکار داشته باشد، اما
   آن را بد انجام می دهد. به طور معمول، اکتشافاتی که این هوشمندی ها را هدایت می کنند، تمایل دارند که برای
   میانگین برنامه به جای مورد استفاده خاص شما. هرچه غیر استانداردتر باشد
   برنامه شما، احتمال بیشتری وجود دارد که ممکن است با یک <span style="color:blue">PaaS</span> خوب عمل نکند.
  </p>
<p>
   از آنجایی که راه‌حل‌های خوب <span style="color:blue">PaaS</span> خیلی چیزها را برای شما مدیریت می‌کنند، می‌توانند راهی عالی برای
   مدیریت سربار افزایش یافته ای که ما با داشتن قطعات متحرک بسیار بیشتری دریافت می کنیم. آن
   گفت، من هنوز مطمئن نیستم که ما هنوز همه مدل ها را در این فضا درست داریم، و <span style="color:blue">limi</span>-
   گزینه های میزبانی خود به این معنی است که این رویکرد ممکن است برای شما کارساز نباشد. کی
   نسخه اول را نوشتم، امیدوار بودم که رشد بیشتری در این فضا ببینیم، اما آن
   آنطور که انتظار داشتم اتفاق نیفتاده است. در عوض، من فکر می کنم رشد <span style="color:blue">serverless</span>
   محصولاتی که در درجه اول توسط ارائه دهندگان ابر عمومی ارائه می شوند، شروع به رفع این نیاز کرده است.
   به جای ارائه پلتفرم های جعبه سیاه برای میزبانی یک برنامه، آنها در عوض
   راه حل های مدیریت شده کلید در دست برای چیزهایی مانند واسطه های پیام، پایگاه های داده، ذخیره سازی ارائه می دهند.
   و مواردی که به ما امکان می دهند قطعاتی را که دوست داریم برای ساخت آنچه نیاز داریم ترکیب و مطابقت دهیم.
  </p>
<p>
   در برابر این پس زمینه است که <span style="color:blue">Function</span> as a <span style="color:blue">Service</span>، نوع خاصی از <span style="color:blue">serverless</span>
   محصول، طرفداران زیادی داشته است.
  </p>
<p>
   ارزیابی مناسب بودن پیشنهادات <span style="color:blue">PaaS</span> برای <span style="color:blue">microservices</span> ها دشوار است، زیرا آنها می آیند
   در اشکال و اندازه‌های زیادی. به عنوان مثال، <span style="color:blue">Heroku</span> کاملاً متفاوت از <span style="color:blue">Netlify</span> به نظر می رسد، اما
   هر دو می توانند برای شما به عنوان یک پلتفرم استقرار برای <span style="color:blue">microservices</span> شما کار کنند، بسته به
   ماهیت برنامه شما.
  </p>
<h4>عملکرد به عنوان سرویس (<span style="color:blue">FaaS</span>)</h4>
<p>
   در چند سال گذشته، تنها فناوری که از نظر
   ایجاد تبلیغات (حداقل در زمینه <span style="color:blue">microservices</span>) بی فایده است. <span style="color:blue">Serverless</span> است
   در واقع یک اصطلاح چتری برای مجموعه‌ای از فناوری‌های مختلف که از این نظر است
   دیدگاه شخصی که از آنها استفاده می کند، رایانه های زیربنایی مهم نیستند. جزئیات
   مدیریت و پیکربندی ماشین ها از شما گرفته می شود. به گفته <span style="color:blue">Ken</span>
<span style="color:blue">Fromm</span> (که تا آنجا که من می توانم بگویم این اصطلاح <span style="color:blue">serverless</span> را ابداع کرد):
  </p>
<p>
   عبارت "serverless" به این معنی نیست که سرورها دیگر درگیر نیستند. به سادگی به این معنی است
   که توسعه دهندگان دیگر مجبور نیستند زیاد به آنها فکر کنند. منابع محاسباتی
   به عنوان خدمات بدون نیاز به مدیریت ظرفیت ها یا محدودیت های فیزیکی استفاده می شود. سر-
   ارائه دهندگان خدمات به طور فزاینده ای مسئولیت مدیریت سرورها، فروشگاه های داده را بر عهده می گیرند
   و سایر منابع زیرساختی. توسعه دهندگان می توانند راه حل های منبع باز خود را راه اندازی کنند، اما
   به این معنی است که آنها باید سرورها و صف ها و بارها را مدیریت کنند.
   — <span style="color:blue">Ken Fromm</span>، "چرا آینده نرم افزار و برنامه ها <span style="color:blue">Serverless</span> است"
  </p>
<p>
   گزینه های استقرار
   |
   249
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0275</div>
            </div>
        </div>
        <!-- Page 0276 -->
        <div class="chapter" id="page-0276">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   عملکرد به عنوان یک سرویس، یا <span style="color:blue">FaaS</span>، به چنین بخش بزرگی از <span style="color:blue">serverless</span> تبدیل شده است که برای
   بسیاری از این دو اصطلاح قابل تعویض هستند. این نامطلوب است، زیرا نادیده می گیرد
   اهمیت سایر محصولات <span style="color:blue">serverless</span> مانند پایگاه داده ها، صف ها، راه حل های ذخیره سازی، و
   و مانند این. با این وجود، این نشان دهنده هیجانی است که <span style="color:blue">FaaS</span> ایجاد کرده است که آن
   بر بحث تسلط داشته است.
  </p>
<p>
   این محصول <span style="color:blue">Lambda</span> از <span style="color:blue">AWS</span> بود که در سال 2014 راه اندازی شد و این شور و شوق را برانگیخت
   <span style="color:blue">FaaS</span>. در یک سطح، این مفهوم لذت بخش ساده است. شما مقداری کد (یک "عملکرد") مستقر می کنید.
   آن کد غیرفعال است، تا زمانی که چیزی اتفاق بیفتد تا آن کد را فعال کند. شما مسئول هستید
   تصمیم گیری در مورد اینکه این محرک چه می تواند باشد - می تواند یک فایل باشد که به مکان خاصی می رسد،
   یک آیتم که در یک صف پیام ظاهر می شود، یک تماس که از طریق <span style="color:blue">HTTP</span> می آید، یا برخی
   چیز دیگر
  </p>
<p>
   وقتی تابع شما فعال می شود، اجرا می شود و وقتی کارش تمام شد، خاموش می شود. زیر
   پلتفرم اساسی این توابع را بر اساس تقاضا یا پایین می آورد و خواهد بود
   اجرای همزمان توابع شما را مدیریت می کند تا بتوانید کپی های متعددی داشته باشید
   در صورت لزوم همزمان اجرا می شود.
  </p>
<p>
   مزایای اینجا بسیار زیاد است. کدی که در حال اجرا نیست برای شما هزینه ای ندارد—
   شما فقط برای آنچه استفاده می کنید پرداخت می کنید. این می تواند <span style="color:blue">FaaS</span> را به گزینه ای عالی برای موقعیت ها تبدیل کند
   که در آن شما بار کم یا غیرقابل پیش بینی دارید. پلتفرم اساسی می چرخد
   توابع را برای شما بالا و پایین می آورد، به شما درجه ای از دسترسی بالا و دسترس پذیری می دهد
   قابلیت اطمینان و استحکام بدون اینکه مجبور باشید کاری انجام دهید. اساساً استفاده از a
   پلتفرم <span style="color:blue">FaaS</span>، مانند بسیاری از پیشنهادات <span style="color:blue">serverless</span> دیگر، به شما امکان می دهد
   مقدار سربار عملیاتی مورد نیاز خود را کاهش دهید.
  </p>
<h4>محدودیت ها</h4>
<p>
   در زیر هود، تمام پیاده سازی های <span style="color:blue">FaaS</span> که من از آنها آگاه هستم از نوعی استفاده می کنند
   فناوری کانتینر. این از شما پنهان است—معمولاً شما مجبور نیستید نگران باشید
   درباره ساختن کانتینری که اجرا می شود، شما فقط نوعی بسته ارائه می دهید
   از کد این به این معنی است، اگرچه، شما از درجه کنترل آنچه دقیقاً می توانید بهره مند شوید
   اجرا شود؛ در نتیجه شما به ارائه دهنده <span style="color:blue">FaaS</span> نیاز دارید تا از زبان انتخابی شما پشتیبانی کند.
  </p>
<p>
<span style="color:blue">Azure Functions</span> در اینجا از نظر فروشندگان اصلی ابر بهترین عملکرد را داشته اند
   پشتیبانی از انواع مختلف <span style="color:blue">runtimes</span> ها، در حالی که <span style="color:blue">Cloud</span> خود <span style="color:blue">Google</span>
   عملکردها، در مقایسه با آن، از تعداد بسیار کمی زبان پشتیبانی می کند (در زمان نوشتن، <span style="color:blue">Google</span> پشتیبانی می کند
   فقط <span style="color:blue">Go</span>، برخی از نسخه های <span style="color:blue">Node</span>، و <span style="color:blue">Python</span>). شایان ذکر است
   که <span style="color:blue">AWS</span> اکنون به شما اجازه می دهد <span style="color:blue">runtime</span> سفارشی خود را برای <span style="color:blue">func</span>- تعریف کنید
   <span style="color:blue">tions</span>، از نظر تئوری شما را قادر می سازد تا از زبان هایی که در آن ارائه نشده اند، پشتیبانی کنید
   خارج از جعبه، اگرچه این پس از آن تبدیل به قطعه دیگری از عملیاتی می شود
   سربار شما باید آن را حفظ کنید.
  </p>
<p>
   این عدم کنترل <span style="color:blue">runtime</span> اساسی نیز به فقدان کنترل گسترش می یابد
   بر منابعی که به هر فراخوانی تابع داده شده است. در سراسر <span style="color:blue">Google Cloud</span>، <span style="color:blue">Azure</span>،
   و <span style="color:blue">AWS</span>، شما فقط می توانید حافظه داده شده به هر تابع را کنترل کنید. این به نوبه خود
  </p>
<p>
   250
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0276</div>
            </div>
        </div>
        <!-- Page 0277 -->
        <div class="chapter" id="page-0277">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   2 <span style="color:blue">Senthil Padmanabhan</span> و <span style="color:blue">Pranav Jha</span>، "وب اسمبلی در <span style="color:blue">eBay</span>: یک مورد استفاده در دنیای واقعی"، <span style="color:blue">eBay</span>، 22 مه 2019،
   <span style="color:blue">https://oreil.ly/SfvHT</span>.
   به نظر می رسد اینطور است که مقدار معینی از <span style="color:blue">CPU</span> و <span style="color:blue">I/O</span> به عملکرد شما داده می شود
   <span style="color:blue">time</span>، اما شما نمی توانید آن جنبه ها را مستقیماً کنترل کنید. این ممکن است به این معنی باشد که شما به پایان می رسید
   مجبورید حافظه بیشتری به یک تابع بدهید، حتی اگر به آن نیاز ندارد، فقط برای دریافت
   <span style="color:blue">CPU</span> مورد نیاز شما در نهایت، اگر احساس می کنید که باید تنظیمات زیادی را در اطراف
   منابع موجود برای توابع شما، پس من احساس می کنم که، حداقل در این مرحله، <span style="color:blue">FaaS</span> است
   احتمالاً یک گزینه عالی برای شما نیست.
  </p>
<p>
   یکی دیگر از محدودیت هایی که باید از آن آگاه باشید این است که فراخوانی تابع می تواند محدودیت هایی را ارائه دهد
   از نظر مدت زمان اجرا. توابع <span style="color:blue">Google Cloud</span>، به عنوان مثال، در حال حاضر هستند
   در 9 دقیقه اجرا، در حالی که توابع <span style="color:blue">AWS Lambda</span> می توانند تا 15 دقیقه اجرا شوند. <span style="color:blue">Azure</span>
   توابع می توانند برای همیشه اجرا شوند اگر بخواهید (بسته به نوع
   برنامه‌ای که در آن هستید). من شخصاً فکر می کنم اگر توابعی را برای مدت طولانی اجرا می کنید
   زمان، این احتمالاً به نوع مشکلی اشاره می کند که توابع برای آن مناسب نیستند.
  </p>
<p>
   در نهایت، اکثر فراخوانی های تابع بی حالت در نظر گرفته می شوند. از نظر مفهومی، این
   به این معنی است که یک تابع نمی تواند به حالتی که توسط یک فراخوانی تابع قبلی باقی مانده است دسترسی داشته باشد
   مگر اینکه آن حالت در جای دیگری ذخیره شود (به عنوان مثال، در یک پایگاه داده). این باعث شده است که آن
   به سختی می توان توابع متعددی را به هم متصل کرد—یک تابع را در نظر بگیرید
   یک سری تماس با توابع دیگر پایین دست را هماهنگ می کند. یک استثنا قابل توجه است <span style="color:blue">Azure</span>
<span style="color:blue">Durable Functions</span>، که این مشکل را به روشی واقعاً جالب حل می کند. بادوام
   توابع از توانایی تعلیق وضعیت یک تابع معین پشتیبانی می کنند و به آن اجازه می دهند تا
   جایی که فراخوانی متوقف شد را دوباره راه اندازی کنید - همه اینها به طور شفاف از طریق استفاده انجام می شود
   از افزونه های واکنشی این راه حلی است که فکر می کنم به طور قابل توجهی توسعه دهنده است
   دوستانه تر از عملکردهای مرحله <span style="color:blue">AWS</span>، که توابع متعددی را به هم متصل می کند
   با استفاده از پیکربندی مبتنی بر <span style="color:blue">JSON</span>.
  </p>
<h4>وب اسمبلی (<span style="color:blue">Wasm</span>)</h4>
<p>
<span style="color:blue">Wasm</span> یک استاندارد رسمی است که در اصل برای دادن راهی به توسعه دهندگان تعریف شد
   اجرای برنامه های <span style="color:blue">sandboxed</span> نوشته شده در انواع زبان های برنامه نویسی در <span style="color:blue">cli</span>-
   مرورگرهای <span style="color:blue">ent</span>. با تعریف هر دو قالب بسته بندی و یک محیط <span style="color:blue">runtime</span>، هدف
   از <span style="color:blue">Wasm</span> این است که به کد دلخواه اجازه می دهد تا به روشی ایمن و کارآمد در کلاینت اجرا شود
   دستگاه ها. این می تواند به برنامه های سمت کلاینت بسیار پیشرفته تر اجازه ایجاد دهد
   هنگام استفاده از مرورگرهای وب معمولی. به عنوان یک مثال ملموس، <span style="color:blue">eBay</span> از <span style="color:blue">Wasm</span> برای
   ارائه نرم افزار اسکنر بارکد، هسته آن به زبان <span style="color:blue">C++</span> نوشته شده بود و قبلاً
   فقط در دسترس برنامه های بومی <span style="color:blue">Android</span> یا <span style="color:blue">iOS</span>، به وب.2
  </p>
<p>
<span style="color:blue">WebAssembly System Interface</span> (<span style="color:blue">WASI</span>) به عنوان راهی برای اجازه دادن به <span style="color:blue">Wasm</span> تعریف شد تا حرکت کند
   از مرورگر و در هر جایی که یک پیاده سازی سازگار <span style="color:blue">WASI</span> را می توان یافت کار کنید. یک مثال از این
   توانایی اجرای <span style="color:blue">Wasm</span> در شبکه‌های تحویل محتوا مانند <span style="color:blue">Fastly</span> یا <span style="color:blue">Cloudflare</span> است.
  </p>
<p>
   گزینه های استقرار
   |
   251
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0277</div>
            </div>
        </div>
        <!-- Page 0278 -->
        <div class="chapter" id="page-0278">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   به دلیل ماهیت سبک و مفاهیم <span style="color:blue">sandboxing</span> قوی که در هسته آن ساخته شده است
   مشخصات، <span style="color:blue">Wasm</span> پتانسیل به چالش کشیدن استفاده از کانتینرها را به عنوان <span style="color:blue">go</span>- دارد
   فرمت استقرار برای برنامه های سمت سرور. در کوتاه مدت، آنچه که آن را نگه می دارد
   عقب احتمالاً پلتفرم های سمت سروری هستند که برای اجرای <span style="color:blue">Wasm</span> در دسترس هستند. در حالی که شما می توانید از لحاظ نظری
   به عنوان مثال، <span style="color:blue">Wasm</span> را روی <span style="color:blue">Kubernetes</span> اجرا کنید، در نهایت <span style="color:blue">Wasm</span> را در داخل جاسازی می کنید
   کانتینرها، که می توان گفت تا حدودی بیهوده است، زیرا شما در حال اجرا هستید الف
   استقرار سبک تر در داخل یک کانتینر (نسبتاً) سنگین تر.
  </p>
<p>
   یک پلتفرم استقرار سمت سرور با پشتیبانی بومی از <span style="color:blue">WASI</span> احتمالاً خواهد بود
   برای بهره بردن از پتانسیل <span style="color:blue">Wasm</span> مورد نیاز است. از نظر تئوری حداقل، یک زمانبند مانند
   <span style="color:blue">Nomad</span> در موقعیت بهتری برای پشتیبانی از <span style="color:blue">Wasm</span> قرار می گیرد، زیرا از یک درایور قابل اتصال پشتیبانی می کند
   مدل. زمان مشخص خواهد کرد!
  </p>
<h4>چالش ها</h4>
<p>
   جدا از محدودیت هایی که به تازگی به آنها نگاه کردیم، چالش های دیگری نیز وجود دارد
   هنگام استفاده از <span style="color:blue">FaaS</span> ممکن است تجربه کنید.
  </p>
<p>
   اولاً، پرداختن به نگرانی که اغلب با <span style="color:blue">FaaS</span> مطرح می شود، مهم است، و این است
   مفهوم زمان راه اندازی. از نظر مفهومی، توابع به هیچ وجه اجرا نمی شوند مگر اینکه آنها
   مورد نیاز است. این بدان معناست که آنها باید برای ارائه درخواست های دریافتی راه اندازی شوند. اکنون،
   برای برخی از <span style="color:blue">runtime</span> ها، راه اندازی یک نسخه جدید از <span style="color:blue">runtime</span> زمان زیادی می برد-
   اغلب به عنوان زمان "شروع سرد" یاد می شود. <span style="color:blue">JVM</span> و <span style="color:blue">NET</span> <span style="color:blue">runtimes</span> از این رنج می برند، بنابراین الف
   زمان شروع سرد برای توابع با استفاده از این <span style="color:blue">runtimes</span> ها اغلب می تواند قابل توجه باشد.
  </p>
<p>
   با این حال، در واقعیت، این <span style="color:blue">runtimes</span> ها به ندرت شروع سرد دارند. حداقل در <span style="color:blue">AWS</span>، <span style="color:blue">runtimes</span> ها هستند
   "گرم" نگه داشته می شود، به طوری که درخواست هایی که وارد می شوند توسط از قبل راه اندازی شده و در حال اجرا هستند
   نمونه ها این تا حدی اتفاق می افتد که می تواند ارزیابی این موضوع دشوار باشد
   تأثیر یک "شروع سرد" امروزه به دلیل بهینه سازی هایی که تحت انجام می شود
   هود توسط ارائه دهندگان <span style="color:blue">FaaS</span> با این وجود، اگر این یک نگرانی است، چسبیدن به زبان ها
   که <span style="color:blue">runtimes</span> آنها زمان راه اندازی سریع دارند (<span style="color:blue">Go</span>، <span style="color:blue">Python</span>، <span style="color:blue">Node</span>، و <span style="color:blue">Ruby</span> به ذهن می آیند)
   می تواند این مشکل را به طور موثر دور بزند.
  </p>
<p>
   در نهایت، جنبه مقیاس بندی پویا توابع در واقع می تواند به یک موضوع ختم شود.
   توابع هنگام فعال شدن راه اندازی می شوند. همه پلتفرم هایی که من استفاده کرده ام یک حد سخت دارند
   در مورد حداکثر تعداد فراخوانی های تابع همزمان، که چیزی است
   شما ممکن است مجبور شوید توجه دقیقی به آن داشته باشید. من با بیش از یک تیم صحبت کرده ام که دارد
   مشکل مقیاس بندی توابع و غلبه بر سایر بخش های زیرساخت های آن است
   که خواص مقیاس گذاری یکسانی نداشتند. <span style="color:blue">Steve Faulkner</span> از <span style="color:blue">Bustle</span> به اشتراک گذاشت
   یک نمونه از این دست، جایی که مقیاس‌بندی توابع، زیرساخت <span style="color:blue">Redis</span> <span style="color:blue">Bustle</span> را بارگذاری کرد،
   ایجاد مسائل تولید. اگر یک بخش از سیستم شما می تواند به طور پویا مقیاس شود، اما
   سایر قسمت های سیستم شما نمی توانند، ممکن است متوجه شوید که این عدم تطابق می تواند باعث ایجاد
   سردردهای قابل توجه.
  </p>
<p>
   252
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0278</div>
            </div>
        </div>
        <!-- Page 0279 -->
        <div class="chapter" id="page-0279">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>نقشه برداری به <span style="color:blue">microservices</span></h4>
<p>
   تاکنون در بحث های خود در مورد گزینه های مختلف استقرار، نقشه برداری از الف
   نمونه <span style="color:blue">microservice</span> به یک مکانیسم استقرار بسیار ساده بوده است. آ
   یک نمونه <span style="color:blue">microservice</span> واحد می تواند بر روی یک ماشین مجازی، بسته بندی شده به عنوان a
   یک کانتینر واحد، یا حتی روی یک کانتینر برنامه مانند <span style="color:blue">Tomcat</span> یا <span style="color:blue">IIS</span> رها شده است.
   با <span style="color:blue">FaaS</span>، همه چیز کمی گیج کننده تر می شود.
  </p>
<ul>
<li>تابع در هر <span style="color:blue">microservice</span>.</li>
<li>اکنون بدیهی است که یک نمونه <span style="color:blue">microservice</span> واحد می تواند به عنوان یک تابع واحد مستقر شود، همانطور که در شکل 8-18 نشان داده شده است.
    این احتمالاً مکان مناسبی برای شروع است. این مفهوم یک نمونه <span style="color:blue">microservice</span> را به عنوان یک واحد از <span style="color:blue">deploy</span>- حفظ می کند
    <span style="color:blue">ment</span>، که مدلی است که ما تاکنون بیشتر به آن پرداخته ایم.</li>
</ul>
<p>
<strong>شکل 8-18.</strong> سرویس هزینه های ما به عنوان یک تابع واحد پیاده سازی شده است
  </p>
<p>
   هنگامی که فراخوانی شد، پلتفرم <span style="color:blue">FaaS</span> یک نقطه ورود واحد در استقرار شما را فعال می کند
   تابع. این بدان معناست که اگر قرار است استقرار یک تابع واحد برای داشته باشید
   کل سرویس شما، شما باید راهی برای اعزام از آن نقطه ورودی داشته باشید
   به قسمت های مختلف عملکرد در <span style="color:blue">microservice</span> شما. اگر در حال پیاده سازی هستید
   سرویس هزینه ها به عنوان یک <span style="color:blue">microservice</span> مبتنی بر <span style="color:blue">REST</span>، ممکن است منابع مختلفی داشته باشید
   در معرض دید، مانند / <span style="color:blue">receipt</span>، / <span style="color:blue">claim</span>، یا / <span style="color:blue">report</span>. با این مدل، درخواستی برای
   هر یک از این منابع از طریق همین نقطه ورودی وارد می‌شود، بنابراین شما نیاز دارید
   تماس ورودی را بر اساس مسیر درخواست ورودی، به قطعه مناسبی از عملکرد هدایت کنید.
  </p>
<ul>
<li>تابع در هر جمع آوری.</li>
<li>بنابراین چگونه می توانیم یک نمونه <span style="color:blue">microservice</span> را به توابع کوچکتر تقسیم کنیم؟ اگر شما در حال استفاده از طراحی مبتنی بر دامنه هستید، ممکن است قبلاً
    اجتماعات خود را صریحاً مدل کرده اید (مجموعه ای از اشیاء که به عنوان یک
    یک موجودیت واحد، که معمولاً به مفاهیم دنیای واقعی اشاره دارد). اگر نمونه <span style="color:blue">microservice</span> شما
    چندین تجمع را مدیریت می کند، یک مدل که برای من منطقی است این است که از یک عملکرد خارج شویم.
    برای هر جمع آوری، همانطور که در شکل 8-19 نشان داده شده است. این تضمین می کند که تمام منطق برای یک
  </li>
<p>
   گزینه های استقرار
   |
   253
  </p>
</ul></div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 279" src="page_0279/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0279</div>
            </div>
        </div>
        <!-- Page 0280 -->
        <div class="chapter" id="page-0280">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   مجرد تجمیع خود محصور در داخل تابع است، و اطمینان از a را آسان تر می کند
   اجرای سازگار مدیریت چرخه عمر جمع.
  </p>
<p>
<strong>شکل 8-19.</strong> سرویس هزینه ها که به عنوان توابع متعدد مستقر می شود، هر کدام <span style="color:blue">han</span>-
   تجمع متفاوتی را مدیریت می کند
  </p>
<p>
   با این مدل، نمونه <span style="color:blue">microservice</span> ما دیگر به یک واحد <span style="color:blue">deploy</span>- نقشه برداری نمی شود
   <span style="color:blue">ment</span>. در عوض، <span style="color:blue">microservice</span> ما اکنون بیشتر یک مفهوم منطقی متشکل از <span style="color:blue">multi</span>- است
   توابع مختلفی که از نظر تئوری می توانند مستقل از یکدیگر مستقر شوند.
  </p>
<p>
   چند هشدار در اینجا. اولاً، من اکیداً از شما می خواهم که یک
   رابط خارجی دانه درشت تر. به مصرف کنندگان بالادستی، آنها هنوز در حال صحبت با <span style="color:blue">Service</span> هزینه ها هستند -
   آنها از اینکه درخواست ها به مجامع با محدوده کوچکتر نگاشت می شوند بی اطلاع هستند. این
   تضمین می کند که اگر نظر خود را تغییر دهید و بخواهید چیزها را دوباره ترکیب کنید یا حتی
   مدل تجمع را دوباره ساختار دهید، بر مصرف کنندگان بالادستی تأثیر نخواهید گذاشت.
  </p>
<p>
   مشکل دوم مربوط به داده ها است. آیا این مجامع باید به استفاده از یک مشترک ادامه دهند
   پایگاه داده؟ در این مورد، من تا حدودی آرام هستم. با فرض اینکه همان تیم <span style="color:blue">man</span>-
   این توابع را مدیریت می کند، و از نظر مفهومی یک "سرویس" واحد باقی می ماند، من خوب خواهم بود
   با آنها هنوز از همان پایگاه داده استفاده می کنند، همانطور که شکل 8-20 نشان می دهد.
  </p>
<p>
   با گذشت زمان، اگرچه، اگر نیازهای هر تابع تجمیع متفاوت باشد، من تمایل دارم که
   به جداسازی استفاده از داده های آنها نگاه کنید، همانطور که در شکل 8-21 مشاهده می شود، به خصوص اگر شما شروع کنید
   دیدن جفت شدن در سطح داده، توانایی شما را در تغییر آنها به راحتی مختل می کند. در این مرحله،
   شما می توانید استدلال کنید که این توابع اکنون در حق خود <span style="color:blue">microservices</span> خواهند بود - اگرچه همانطور که من
   به تازگی توضیح دادم، ممکن است در نمایش دادن آنها به عنوان یک <span style="color:blue">microservice</span> واحد برای بالادست ارزش داشته باشد
   مصرف کنندگان.
  </p>
<p>
   254
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 280" src="page_0280/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0280</div>
            </div>
        </div>
        <!-- Page 0281 -->
        <div class="chapter" id="page-0281">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<strong>شکل 8-20.</strong> توابع مختلف با استفاده از همان پایگاه داده، زیرا همه آنها منطقاً قسمت
   از همان <span style="color:blue">microservice</span> هستند و توسط همان تیم مدیریت می شوند
  </p>
<p>
<strong>شکل 8-21.</strong> هر تابع با استفاده از پایگاه داده خود
  </p>
<p>
   این نگاشت از یک <span style="color:blue">microservice</span> واحد به چندین واحد قابل استقرار ریزدانه
   تا حدودی تعریف قبلی ما از یک <span style="color:blue">microservice</span> را تاب می دهد. ما معمولاً در نظر می گیریم
   <span style="color:blue">microservice</span> به عنوان یک واحد مستقل قابل استقرار—اکنون یک <span style="color:blue">microservice</span> از <span style="color:blue">multi</span>- ساخته شده است
   توابع مختلفی که به طور نظری می توانند مستقل از یکدیگر مستقر شوند.
   یک هشدار در اینجا. اولاً، من اکیداً شما را تشویق می کنم که یک درشت تر را حفظ کنید
   رابط خارجی دانه دانه. به مصرف کنندگان بالادستی، آنها هنوز با <span style="color:blue">Service</span> هزینه ها صحبت می کنند—
   آنها از این که درخواست ها به مجامع با محدوده کوچکتر نگاشت می شوند بی اطلاع هستند. این
   اطمینان می دهد که اگر نظر خود را تغییر دهید و بخواهید چیزها را دوباره ترکیب کنید یا حتی
   مدل تجمع را دوباره ساختار دهید، بر مصرف کنندگان بالادستی تأثیر نخواهید گذاشت.
  </p>
<ul>
<li>حتی ریزدانه تر شوید.</li>
<li>اگر می خواهید حتی کوچکتر بروید، وسوسه وجود دارد که توابع خود را به ازای هر جمع به قطعات کوچکتر تقسیم کنید. من بسیار بیشتر هستم
    در اینجا محتاطانه. جدا از انفجار توابع، این احتمالاً ایجاد خواهد کرد، همچنین نقض می کند
    یکی از اصول اصلی یک تجمع—که ما می‌خواهیم با آن به‌عنوان یک واحد رفتار کنیم تا
    اطمینان حاصل کنیم که می توانیم یکپارچگی خود تجميع را بهتر مدیریت کنیم.</li>
</ul>
<p>
   گزینه های استقرار
   |
   255
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 281" src="page_0281/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 281" src="page_0281/image_2.png"/></div>
</div>
                <div class="page-number">صفحه 0281</div>
            </div>
        </div>
        <!-- Page 0282 -->
        <div class="chapter" id="page-0282">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   3 <span style="color:blue">Johnathan Ishmael</span>، "بهینه سازی <span style="color:blue">Serverless</span> برای <span style="color:blue">BBC Online</span>"، فناوری و خلاقیت در <span style="color:blue">BBC</span> (وبلاگ)،
   <span style="color:blue">BBC</span>، 26 ژانویه 2021، <span style="color:blue">https://oreil.ly/gkSdp</span>.
  </p>
<p>
   من قبلاً این ایده را سرگرم کرده بودم که هر انتقال حالت یک تجميع را به آن تبدیل کنم
   تابع خود، اما من به دلیل مشکلات مربوط به این ایده، از این ایده عقب نشینی کرده ام
   ناسازگاری. وقتی چیزهای مختلف مستقل از هم وجود داشته باشند، هر کدام <span style="color:blue">man</span>-
   مدیریت بخش های مختلفی از یک انتقال حالت کلی، اطمینان از انجام صحیح کارها
   واقعاً بسیار دشوار می شود. این ما را وارد فضای <span style="color:blue">sagas</span> می کند، که ما در آن بحث کردیم
   فصل 6. هنگام اجرای فرآیندهای تجاری پیچیده، مفاهیمی مانند <span style="color:blue">sagas</span> هستند
   مهم است، و کار قابل توجیه است. با این حال، من تلاش می کنم تا ارزشی را در اضافه کردن ببینم
   این پیچیدگی در سطح مدیریت یک مجموعه واحد که می تواند به راحتی <span style="color:blue">han</span>-
   توسط یک تابع واحد
  </p>
<h4>راه پیش رو</h4>
<p>
   من همچنان متقاعد شده ام که آینده برای اکثر توسعه دهندگان استفاده از پلتفرمی است که پنهان می کند
   بسیاری از جزئیات اساسی از آنها. برای سالهای زیادی، <span style="color:blue">Heroku</span> نزدیکترین بود
   چیزی که می‌توانستم از نظر چیزی که تعادل درستی را پیدا کرد به آن اشاره کنم، اما اکنون ما
   <span style="color:blue">FaaS</span> و اکوسیستم گسترده تر از پیشنهادات <span style="color:blue">serverless</span> <span style="color:blue">turnkey</span> که متفاوت ترسیم می کنند
   مسیر.
  </p>
<p>
   هنوز مشکلاتی وجود دارد که باید با <span style="color:blue">FaaS</span> برطرف شوند، اما من احساس می کنم که، در حالی که محصول فعلی
   از پیشنهادات هنوز هم نیاز به تغییر برای حل مشکلات مربوط به آنها دارد، این نوع <span style="color:blue">plat</span>- است
   شما راه‌اندازی که بیشتر توسعه‌دهندگان در نهایت از آن استفاده خواهند کرد. همه برنامه ها به طور مرتب وارد نمی شوند
   اکوسیستم <span style="color:blue">FaaS</span> با توجه به محدودیت ها، اما برای کسانی که این کار را می کنند، مردم در حال حاضر می بینند
   مزایای قابل توجهی با کار بیشتر و بیشتر به <span style="color:blue">FaaS</span> پشتیبانی شده توسط <span style="color:blue">Kubernetes</span>
   ارائه دهندگان ابر اصلی به طور فزاینده ای قادر خواهند بود از این روش جدید استفاده کنند
   کار کردن
  </p>
<p>
   بنابراین، در حالی که <span style="color:blue">FaS</span> ممکن است برای همه چیز کار نکند، مطمئناً چیزی است که من از مردم می خواهم
   کاوش کنید و برای مشتریانم که به دنبال رفتن به <span style="color:blue">Kubernetes</span> مبتنی بر ابر هستند
   راه حل ها، من بسیاری از آنها را ترغیب کرده ام که ابتدا <span style="color:blue">FaaS</span> را بررسی کنند، زیرا ممکن است آنها را بدهد
   همه چیزهایی که نیاز دارند در حالی که پیچیدگی قابل توجهی را پنهان می کنند و بار زیادی را کاهش می دهند
   کار
  </p>
<p>
   من شاهد این هستم که سازمان های بیشتری از <span style="color:blue">FaaS</span> به عنوان بخشی از یک راه حل گسترده تر استفاده می کنند و انتخاب می کنند
   <span style="color:blue">FaaS</span> برای موارد استفاده خاص که در آن مناسب است. یک مثال خوب <span style="color:blue">BBC</span> خواهد بود،
   که از توابع <span style="color:blue">Lambda</span> به عنوان بخشی از پشته فناوری اصلی خود استفاده می کند
   وب سایت خبری <span style="color:blue">BBC</span>. این سیستم کلی از ترکیبی از <span style="color:blue">Lambda</span> و <span style="color:blue">EC2</span> استفاده می کند
   نمونه ها - با نمونه های <span style="color:blue">EC2</span> که اغلب در موقعیت هایی استفاده می شوند که در آن <span style="color:blue">Lambda</span>
   فراخوانی توابع بسیار گران خواهد بود.
  </p>
<p>
   256
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0282</div>
            </div>
        </div>
        <!-- Page 0283 -->
        <div class="chapter" id="page-0283">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   4 من ممکن است این قانون را مطرح نکرده باشم.
  </p>
<h4>کدام گزینه استقرار برای شما مناسب است؟</h4>
<p>
   آی. ما گزینه های زیادی داریم، درسته؟ و من احتمالاً خیلی کمک نکرده ام
   که تمام راه را برای به اشتراک گذاشتن بارها از جوانب مثبت و منفی برای هر رویکرد طی می کنم. اگر شما <span style="color:blue">got</span>-
   ten این حد، ممکن است کمی گیج شوید که چه باید کرد.
  </p>
<p>
   خب، قبل از اینکه جلوتر بروم، واقعاً امیدوارم که این را بدون گفتن بگوید
   این که اگر کاری که در حال حاضر انجام می دهید برای شما مفید است، پس به
   انجام دادن آن! اجازه ندهید مد تصمیمات فنی شما را دیکته کند.
  </p>
<p>
   اگر فکر می کنید باید نحوه استقرار <span style="color:blue">microservices</span> خود را تغییر دهید، پس اجازه دهید سعی کنم
   و بسیاری از آنچه را که قبلاً بحث کردیم، تقطیر کنید و برخی از موارد مفید را ارائه دهید
   راهنمایی
  </p>
<p>
   با بررسی مجدد اصول استقرار <span style="color:blue">microservice</span> ها، یکی از مهم ترین
   جنبه هایی که ما روی آن تمرکز کردیم، اطمینان از انزوا <span style="color:blue">microservices</span> های ما بود. اما فقط
   استفاده از این به عنوان یک اصل راهنما ممکن است ما را به سمت استفاده از فیزیکی اختصاصی هدایت کند
   ماشین ها برای هر نمونه <span style="color:blue">microservice</span>! این البته احتمالاً بسیار گران خواهد بود، و به عنوان
   همانطور که قبلاً بحث کردیم، ابزارهای بسیار قدرتمندی وجود دارد که ما
   اگر از این مسیر پایین برویم نمی توانیم از آن استفاده کنیم.
  </p>
<p>
   معاملات در اینجا فراوان است. تعادل هزینه در برابر سهولت استفاده، انزوا، آشنایی...
   می تواند طاقت فرسا شود. پس بیایید مجموعه ای از قوانینی را مرور کنیم که دوست دارم آنها را قوانین اصلی سام بنامم
   برای کار در مورد جایی که وسایل را استقرار دهید:
  </p>
<ol>
<li>اگر خراب نیست، آن را درست نکنید.4</li>
<li>تا جایی که احساس خوشحالی می کنید، کنترل را کنار بگذارید و سپس کمی بیشتر آن را رها کنید
    بیت. اگر می توانید تمام کار خود را به یک <span style="color:blue">PaaS</span> خوب مانند <span style="color:blue">Heroku</span> (یا یک پلتفرم <span style="color:blue">FaaS</span>) واگذار کنید،
    پس این کار را انجام دهید و خوشحال باشید. آیا واقعاً نیاز دارید که هر تنظیمات آخری را درست کنید؟</li>
<li><span style="color:blue">Containerizing</span> <span style="color:blue">microservices</span> شما بدون درد نیست، اما یک <span style="color:blue">com</span>- خوب است
    مصالحه در اطراف هزینه انزوا و دارای مزایای فوق العاده برای توسعه محلی
    <span style="color:blue">ment</span>، در حالی که هنوز هم به شما درجه ای از کنترل بر آنچه اتفاق می افتد می دهد. انتظار
    <span style="color:blue">Kubernetes</span> در آینده شما</li>
</ol>
<p>
   بسیاری از مردم " <span style="color:blue">Kubernetes</span> یا ورشکستگی!" را اعلام می کنند که من احساس می کنم غیر مفید است. اگر
   شما در ابر عمومی هستید، و مشکل شما به عنوان یک مدل استقرار مناسب است، انجام دهید
   در عوض این کار را انجام دهید و <span style="color:blue">Kubernetes</span> را رد کنید. توسعه دهندگان شما احتمالاً در نهایت بسیار خواهند بود
  </p>
<p>
   کدام گزینه استقرار برای شما مناسب است؟
   |
   257
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 283" src="page_0283/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0283</div>
            </div>
        </div>
        <!-- Page 0284 -->
        <div class="chapter" id="page-0284">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<span style="color:blue">more</span> تولیدی. همانطور که در فصل 16 بیشتر بحث خواهیم کرد، نگذارید ترس از
   <span style="color:blue">lock-in</span> شما را در آشفتگی های خودتان به دام اندازد.
  </p>
<p>
   یک <span style="color:blue">PaaS</span> عالی مانند <span style="color:blue">Heroku</span> یا <span style="color:blue">Zeit</span> پیدا کردید، و برنامه ای دارید که مناسب است
   محدودیت های پلتفرم؟ تمام کار را به پلتفرم منتقل کنید و زمان بیشتری را صرف کنید
   کار کردن روی محصول شما. <span style="color:blue">Heroku</span> و <span style="color:blue">Zeit</span> هر دو پلتفرم بسیار فوق العاده ای با
   قابلیت استفاده عالی از دیدگاه توسعه دهنده. آیا توسعه دهندگان شما سزاوار هستند که
   به هر حال خوشحال باشید؟
  </p>
<p>
   برای بقیه شما، <span style="color:blue">containerization</span> راهی است که باید بروید، به این معنی که ما باید صحبت کنیم
   درباره <span style="color:blue">Kubernetes</span>.
  </p>
<h4>نقش <span style="color:blue">Puppet</span>، <span style="color:blue">Chef</span> و سایر ابزارها؟</h4>
<p>
   این فصل از زمان انتشار نسخه اول به طور قابل توجهی تغییر کرده است. این است
   این تا حدی به دلیل تکامل صنعت به طور کلی، بلکه به فناوری جدیدی نیز بستگی دارد که به طور فزاینده ای
   مفید. ظهور فناوری جدید همچنین منجر به کاهش نقش دیگر شده است
   فناوری - و بنابراین ما شاهد ابزارهایی مانند <span style="color:blue">Puppet</span>، <span style="color:blue">Chef</span>، <span style="color:blue">Ansible</span> و <span style="color:blue">Salt</span> هستیم که نقش بسیار
   نقش کوچکتر در استقرار معماری های <span style="color:blue">microservice</span> نسبت به آنچه در سال 2014 انجام دادیم.
  </p>
<p>
   دلیل اصلی این امر اساساً ظهور کانتینر است. قدرت
   ابزارهایی مانند <span style="color:blue">Puppet</span> و <span style="color:blue">Chef</span> این است که به شما راهی برای آوردن یک دستگاه به حالت دلخواه می دهند،
   با آن حالت دلخواه در برخی از فرم های کد تعریف شده است. شما می توانید اجرا را تعریف کنید
   <span style="color:blue">times</span> شما نیاز دارید، کجا فایل های پیکربندی باید باشند، و غیره، به گونه ای که می تواند تعیین کننده
   به طور قطعی در زمان و دوباره بر روی همان دستگاه اجرا می شود و اطمینان حاصل می شود که همیشه می تواند
   به همان حالت منتقل شد.
  </p>
<p>
   اکثر مردم چگونه یک کانتینر را می سازند با تعریف <span style="color:blue">Dockerfile</span>. این به شما اجازه می دهد تا
   همان الزامات را همانطور که با <span style="color:blue">Puppet</span> یا <span style="color:blue">Chef</span> انجام می دهید، با برخی <span style="color:blue">differ</span>- تعریف کنید
   <span style="color:blue">ences</span>. یک کانتینر هنگامی که دوباره مستقر می شود از بین می رود، بنابراین هر ایجاد کانتینر انجام می شود
   از ابتدا (من در اینجا تا حدودی ساده سازی می کنم). این بدان معناست که بسیاری از
   پیچیدگی ذاتی در <span style="color:blue">Puppet</span> و <span style="color:blue">Chef</span> برای مدیریت آن ابزارها که اجرا می شوند و
   روی همان ماشین‌ها، لازم نیست.
  </p>
<p>
<span style="color:blue">Puppet</span>، <span style="color:blue">Chef</span>، و ابزارهای مشابه هنوز هم فوق العاده مفید هستند، اما نقش آنها اکنون بوده است
   از کانتینر و پایین تر در پشته بیرون رانده شد. مردم از ابزارهایی مانند این برای
   مدیریت برنامه ها و زیرساخت های قدیمی، یا برای ساخت خوشه هایی که
   بارهای کاری کانتینر اکنون در حال اجرا هستند. اما توسعه دهندگان حتی کمتر احتمال دارد که وارد شوند
   در گذشته با این ابزارها در تماس باشید.
  </p>
<p>
   مفهوم زیرساخت به عنوان کد هنوز حیاتی است. فقط این است که نوع
   ابزارهایی که توسعه دهندگان احتمالاً از آنها استفاده می کنند تغییر کرده است. برای کسانی که با ابر کار می کنند، برای
   به عنوان مثال، چیزهایی مانند <span style="color:blue">Terraform</span> می توانند برای تهیه <span style="color:blue">infra</span>- ابر بسیار مفید باشند
   <span style="color:blue">structure</span>. اخیراً، من طرفدار بزرگی از <span style="color:blue">Pulumi</span> شده‌ام، که از استفاده از دامنه اجتناب می‌کند-
   زبان های خاص (<span style="color:blue">DSL</span>) به نفع استفاده از زبان های برنامه نویسی معمولی برای کمک
   توسعه دهندگان زیرساخت های ابری خود را مدیریت می کنند. من چیزهای بزرگی را پیش رو می بینم
   برای <span style="color:blue">Pulumi</span> همانطور که تیم های تحویل مالکیت بیشتری از دنیای عملیاتی می گیرند، و من مشکوکم
  </p>
<p>
   258
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0284</div>
            </div>
        </div>
        <!-- Page 0285 -->
        <div class="chapter" id="page-0285">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   که <span style="color:blue">Puppet</span>، <span style="color:blue">Chef</span>، و موارد مشابه، در حالی که به ایفای نقش مفیدی در اپرا ادامه خواهند داد
   <span style="color:blue">tions</span>، احتمالاً از فعالیت های توسعه روزمره دورتر و دورتر خواهند شد.
  </p>
<h4><span style="color:blue">Kubernetes</span> و ارکستراسیون کانتینر</h4>
<p>
   همانطور که کانتینرها شروع به جذب کردند، بسیاری از مردم شروع به جستجوی راه حل هایی برای
   چگونه می توان کانتینرها را در چندین دستگاه مدیریت کرد. <span style="color:blue">Docker</span> دو تلاش برای این کار داشت
   (به ترتیب با حالت <span style="color:blue">Docker Swarm</span> و <span style="color:blue">Docker Swarm</span>)؛ شرکت هایی مانند
   <span style="color:blue">Rancher</span> و <span style="color:blue">CoreOS</span> نظرات خود را ارائه کردند. و بیشتر پلتفرم های عمومی
   مانند <span style="color:blue">Mesos</span> برای اجرای کانتینرها در کنار انواع دیگر بارهای کاری استفاده می شد.
  </p>
<p>
   در نهایت، با وجود تلاش زیاد روی این محصولات، <span style="color:blue">Kubernetes</span> در
   در دو سال گذشته آمده است تا بر این فضا مسلط شود.
  </p>
<p>
   قبل از اینکه در مورد خود <span style="color:blue">Kubernetes</span> صحبت کنیم، باید بحث کنیم که چرا به ابزاری مانند این نیاز است
   در وهله اول
  </p>
<h4>مورد ارکستراسیون کانتینر</h4>
<p>
   به طور کلی، <span style="color:blue">Kubernetes</span> می تواند به طور متفاوتی به عنوان یک ارکستراسیون کانتینر توصیف شود
   پلتفرم، یا، برای استفاده از اصطلاحی که از مد افتاده است، یک زمانبند کانتینر. پس چه
   این پلتفرم ها هستند، و چرا ممکن است آنها را بخواهیم؟
  </p>
<p>
   کانتینرها با ایزوله کردن مجموعه ای از منابع بر روی یک دستگاه اساسی ایجاد می شوند.
   ابزارهایی مانند <span style="color:blue">Docker</span> به ما اجازه می دهند تا تعریف کنیم که یک کانتینر باید چگونه به نظر برسد و a ایجاد کنیم
   نمونه ای از آن کانتینر در یک دستگاه. اما اکثر راه حل ها مستلزم آن هستند که نرم افزار ما
   در چندین دستگاه تعریف شود، شاید برای رسیدگی به بار کافی، یا برای اطمینان از آن
   سیستم دارای افزونگی در محل برای تحمل خرابی یک گره واحد است. کانتینر
   پلتفرم های ارکستراسیون نحوه و مکان اجرای بارهای کاری کانتینر را مدیریت می کنند.
   اصطلاح "زمان بندی" در این زمینه منطقی تر می شود. اپراتور می گوید: "من
   می خواهم این کار را انجام دهم،" و ارکستراتور نحوه زمان بندی آن کار را مشخص می کند—
   یافتن منابع موجود، تخصیص مجدد آنها در صورت لزوم، و رسیدگی به جزئیات
   برای اپراتور
  </p>
<p>
   پلتفرم‌های مختلف ارکستراسیون کانتینر، مدیریت حالت دلخواه را نیز مدیریت می‌کنند
   برای ما، اطمینان حاصل می شود که حالت مورد انتظار مجموعه ای از کانتینرها (نمونه های <span style="color:blue">microservice</span>،
   در مورد ما) نگهداری می شود. آنها همچنین به ما اجازه می دهند تا نحوه این را مشخص کنیم
   بارهای کاری باید توزیع شوند، و به ما اجازه می دهند تا برای استفاده از منابع، تأخیر بهینه سازی کنیم
   بین فرآیندها، یا دلایل استحکام
  </p>
<p>
   بدون چنین ابزاری، شما باید توزیع کانتینرهای خود را مدیریت کنید، برخی از
   چیزی که می توانم از تجربه دست اول به شما بگویم خیلی سریع قدیمی می شود. نوشتن <span style="color:blue">script</span> ها
   برای مدیریت راه اندازی و شبکه نمونه های کانتینر سرگرم کننده نیست.
  </p>
<p>
<span style="color:blue">Kubernetes</span> و ارکستراسیون کانتینر
   |
   259
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0285</div>
            </div>
        </div>
        <!-- Page 0286 -->
        <div class="chapter" id="page-0286">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   به طور کلی، تمام پلتفرم‌های ارکستراسیون کانتینر، از جمله <span style="color:blue">Kubernetes</span>،
   این قابلیت‌ها را به شکلی یا فرمی ارائه می دهند. اگر به مقاصد عمومی نگاه کنید
   زمان‌بندهایی مانند <span style="color:blue">Mesos</span> یا <span style="color:blue">Nomad</span>، راه‌حل‌های مدیریت شده مانند <span style="color:blue">ECS</span> <span style="color:blue">AWS</span>، <span style="color:blue">Docker Swarm</span>
   حالت، و غیره، یک مجموعه ویژگی مشابه را خواهید دید. اما به دلایلی که به زودی بررسی خواهیم کرد،
   <span style="color:blue">Kubernetes</span> این فضا را برده است. همچنین یک یا دو مفهوم جالب دارد که هستند
   ارزش یک بررسی مختصر را دارند.
  </p>
<h4>یک نمای ساده از مفاهیم <span style="color:blue">Kubernetes</span></h4>
<p>
   مفاهیم زیادی در <span style="color:blue">Kubernetes</span> وجود دارد، بنابراین مرا ببخشید که وارد آن نمی شوم
   همه آنها (این قطعاً یک کتاب را در خود جای می دهد). آنچه در اینجا سعی می کنم انجام دهم این است
   ایده های کلیدی را مشخص کنید که هنگام شروع کار با این کار باید درگیر شوید
   ابزار. بیایید ابتدا به مفهوم یک خوشه نگاه کنیم، همانطور که در شکل 8-22 نشان داده شده است.
  </p>
<p>
<strong>شکل 8-22.</strong> یک مرور کلی ساده از توپولوژی <span style="color:blue">Kubernetes</span>
</p>
<p>
   اساساً، یک خوشه <span style="color:blue">Kubernetes</span> از دو چیز تشکیل شده است. اول، مجموعه ای وجود دارد
   دستگاه هایی که بارهای کاری روی آنها اجرا می شوند، گره نامیده می شوند. ثانیا، وجود دارد
   مجموعه ای از نرم افزارهای کنترلی که این گره ها را مدیریت می کنند و به عنوان صفحه کنترل از آن یاد می شود
   هواپیما. این گره ها می توانند ماشین های فیزیکی یا ماشین های مجازی را در زیر اجرا کنند
   کلاه. به جای زمان بندی یک کانتینر، <span style="color:blue">Kubernetes</span> به جای آن چیزی را زمان بندی می کند
   یک <span style="color:blue">pod</span> می نامد. یک <span style="color:blue">pod</span> از یک یا چند کانتینر تشکیل شده است که با هم مستقر می شوند.
   معمولاً، شما فقط یک کانتینر در یک <span style="color:blue">pod</span> خواهید داشت—به عنوان مثال، یک نمونه از
   <span style="color:blue">microservice</span> شما. چند موقعیت وجود دارد (به ندرت، در تجربه من) که داشتن
  </p>
<p>
   260
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 286" src="page_0286/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0286</div>
            </div>
        </div>
        <!-- Page 0287 -->
        <div class="chapter" id="page-0287">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   با این حال، کانتینرهای متعدد که با هم مستقر شده اند می توانند منطقی باشند. یک مثال خوب از
   این استفاده از <span style="color:blue">proxy</span> های <span style="color:blue">sidecar</span> مانند <span style="color:blue">Envoy</span> است، که اغلب به عنوان بخشی از یک <span style="color:blue">mesh</span> سرویس - الف
   موضوعی که در "خدمات <span style="color:blue">Meshes</span> و دروازه های <span style="color:blue">API</span>" در صفحه 162 بحث کردیم.
  </p>
<p>
   مفهوم بعدی که دانستن آن مفید است، سرویس نامیده می شود. در زمینه
   <span style="color:blue">Kubernetes</span>، شما می توانید یک سرویس را به عنوان یک <span style="color:blue">endpoint</span> مسیریابی پایدار در نظر بگیرید - اساساً، راهی است
   برای نقشه برداری از <span style="color:blue">pods</span> هایی که در حال اجرا دارید به یک رابط شبکه پایدار که در دسترس است
   در داخل خوشه. <span style="color:blue">Kubernetes</span> مسیریابی را در داخل خوشه مدیریت می کند، همانطور که در آن می بینیم
   شکل 8-23.
  </p>
<p>
<strong>شکل 8-23.</strong> نحوه عملکرد یک <span style="color:blue">pod</span>، یک سرویس، و یک استقرار با هم
  </p>
<p>
   ایده این است که یک <span style="color:blue">pod</span> معین را می توان زودگذر در نظر گرفت—ممکن است برای آن خاموش شود
   به هر دلیلی- در حالی که یک سرویس به عنوان یک کل به حیات خود ادامه می دهد. سرویس وجود دارد
   فراخوانی‌ها را به و از <span style="color:blue">pods</span> هدایت کنید و می‌تواند <span style="color:blue">pods</span> را که خاموش می‌شوند یا <span style="color:blue">pods</span> جدید را مدیریت کند
   راه اندازی می شود. صرفاً از نقطه نظر اصطلاحات، این می تواند گیج کننده باشد. ما
   به طور کلی تر در مورد استقرار یک سرویس صحبت کنید، اما در <span style="color:blue">Kubernetes</span> شما یک سرویس را مستقر نمی کنید—شما
   <span style="color:blue">pods</span> هایی را مستقر می کنید که به یک سرویس نگاشت می شوند. ممکن است مدتی طول بکشد تا سر خود را بگیرید
   درباره این
  </p>
<p>
   بعد، ما یک مجموعه <span style="color:blue">replica</span> داریم. با یک مجموعه <span style="color:blue">replica</span>، شما حالت مورد نظر خود را از یک مجموعه تعریف می کنید
   از <span style="color:blue">pods</span>. اینجاست که می گویید: "من چهار مورد از این <span style="color:blue">pods</span> را می خواهم"، و <span style="color:blue">Kubernetes</span> بقیه را مدیریت می کند.
   در عمل، دیگر انتظار نمی رود که مستقیماً با مجموعه‌های <span style="color:blue">replica</span> کار کنید. در عوض،
   آنها از طریق یک استقرار برای شما مدیریت می شوند، آخرین مفهومی که به آن نگاه خواهیم کرد. یک استقرار
   این است که چگونه تغییرات را در <span style="color:blue">pods</span> و مجموعه های <span style="color:blue">replica</span> خود اعمال کنید. با یک استقرار،
  </p>
<p>
<span style="color:blue">Kubernetes</span> و ارکستراسیون کانتینر
   |
   261
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 287" src="page_0287/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0287</div>
            </div>
        </div>
        <!-- Page 0288 -->
        <div class="chapter" id="page-0288">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شما می توانید کارهایی مانند انتشار ارتقاء متحرک را انجام دهید (بنابراین شما <span style="color:blue">pods</span> ها را با جدیدتر جایگزین می کنید
   نسخه به روشی تدریجی برای جلوگیری از خرابی)، بازگرداندن، مقیاس گذاری تعداد
   گره ها، و بیشتر
  </p>
<p>
   بنابراین، برای استقرار <span style="color:blue">microservice</span> خود، شما یک <span style="color:blue">pod</span> تعریف می کنید، که شامل <span style="color:blue">microser</span> شما می شود
   نمونه در داخل آن؛ شما یک سرویس را تعریف می کنید، که به <span style="color:blue">Kubernetes</span> می گوید چگونه شما
   به <span style="color:blue">microservice</span> دسترسی خواهد داشت؛ و شما با استفاده از یک تغییرات را به <span style="color:blue">pods</span> در حال اجرا اعمال می کنید
   استقرار. وقتی این را می گویم آسان به نظر می رسد، مگر نه؟ بیایید فقط بگوییم که من کاملاً ترک کرده ام
   چیزهای زیادی در اینجا برای اختصار
  </p>
<h4>چند مستأجر و فدراسیون</h4>
<p>
   از دیدگاه کارایی، شما می‌خواهید تمام منابع محاسباتی را جمع کنید
   در یک خوشه <span style="color:blue">Kubernetes</span> واحد در دسترس شما است و بگذارید تمام بارهای کاری از آنجا اجرا شود
   در سراسر سازمان شما. این احتمالاً استفاده شما را بالاتر می برد
   منابع اساسی، زیرا منابع استفاده نشده می توانند آزادانه به هر کسی تخصیص داده شوند
   به آنها نیاز دارد. این به نوبه خود باید هزینه ها را بر این اساس کاهش دهد.
  </p>
<p>
   چالش این است که در حالی که <span style="color:blue">Kubernetes</span> به خوبی می تواند <span style="color:blue">microservices</span> های مختلف را مدیریت کند
   برای اهداف مختلف، محدودیت هایی در رابطه با میزان "چند مستأجر" بودن پلتفرم دارد
   هستند. بخش های مختلف در سازمان شما ممکن است درجات مختلفی از <span style="color:blue">con</span>- را بخواهند
   کنترل بر منابع مختلف این نوع کنترل ها در <span style="color:blue">Kubernetes</span> ساخته نشده اند، a
   تصمیمی که از نظر تلاش برای نگه داشتن دامنه <span style="color:blue">Kubernetes</span> منطقی به نظر می رسد
   تا حدودی محدود است. برای حل این مشکل، به نظر می رسد سازمان ها در حال بررسی چند هستند
   از مسیرهای مختلف
  </p>
<p>
   اولین گزینه این است که پلتفرمی را در بالای <span style="color:blue">Kubernetes</span> اتخاذ کنید که اینها را ارائه می دهد
   قابلیت ها - به عنوان مثال، <span style="color:blue">OpenShift</span> از <span style="color:blue">Red Hat</span>، مجموعه ای غنی از کنترل های دسترسی دارد
   و سایر قابلیت هایی که با در نظر گرفتن سازمان های بزرگتر ساخته شده اند و می توانند
   مفهوم چند مستاجری را تا حدودی آسان تر می کند. جدا از هر گونه پیامد مالی
   با استفاده از این نوع پلتفرم ها، برای اینکه آنها کار کنند، گاهی اوقات مجبور خواهید بود با
   انتزاع هایی که توسط فروشنده ای که انتخاب کرده اید به شما داده شده است - به این معنی که توسعه دهندگان شما
   نیاز به دانستن دارد نه تنها نحوه استفاده از <span style="color:blue">Kubernetes</span>، بلکه نحوه استفاده از آن خاص
   پلتفرم فروشنده
  </p>
<p>
   رویکرد دیگر این است که یک مدل فدرال را در نظر بگیرید که در شکل 8-24 نشان داده شده است. با
   فدراسیون، شما چندین خوشه جداگانه دارید، با مقداری لایه نرم افزاری که می نشیند
   بالای آن به شما امکان می دهد در صورت نیاز تغییراتی در تمام خوشه ها ایجاد کنید. در بسیاری از موارد،
   مردم مستقیماً در برابر یک خوشه کار می کردند و به آنها یک <span style="color:blue">Kuber</span>- آشنا می دادند
   تجربه <span style="color:blue">netes</span>، اما در برخی شرایط، ممکن است بخواهید یک برنامه را توزیع کنید
   در چندین خوشه، شاید اگر آن خوشه ها در مناطق جغرافیایی مختلف بودند و
   شما می خواستید برنامه خود را با مقداری توانایی برای رسیدگی به تلفات یک
   خوشه کامل
  </p>
<p>
   262
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0288</div>
            </div>
        </div>
        <!-- Page 0289 -->
        <div class="chapter" id="page-0289">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<strong>شکل 8-24.</strong> نمونه ای از فدراسیون در <span style="color:blue">Kubernetes</span>
</p>
<p>
   ماهیت فدرال، تجمیع منابع را چالش برانگیزتر می کند. همانطور که در
   شکل 8-24، خوشه A کاملاً مورد استفاده قرار می گیرد، در حالی که خوشه B ظرفیت استفاده نشده زیادی دارد.
   اگر ما می خواستیم بارهای کاری بیشتری را در خوشه A اجرا کنیم، انجام این کار فقط در صورت امکان پذیر خواهد بود
   ما می‌توانستیم منابع بیشتری به آن بدهیم، مانند انتقال گره خالی روی خوشه B به
   خوشه A. چقدر آسان خواهد بود که گره را از یک خوشه به خوشه دیگر منتقل کنید
   به ماهیت نرم افزار فدراسیون مورد استفاده بستگی دارد، اما من می توانم به خوبی تصور کنم
   این یک تغییر غیر جزئی است. به خاطر داشته باشید که یک گره واحد می تواند بخشی از هر یک باشد
   یک خوشه یا خوشه دیگر و بنابراین نمی تواند <span style="color:blue">pods</span> را برای هر دو خوشه A و خوشه B اجرا کند.
  </p>
<p>
   شایان ذکر است که داشتن خوشه های متعدد می تواند زمانی مفید باشد که ما
   چالش های ارتقاء خود خوشه را در نظر بگیرید. ممکن است آسان تر و ایمن تر باشد
   یک <span style="color:blue">micro</span>- را به یک خوشه تازه ارتقا یافته منتقل کنید تا اینکه خوشه را در جای خود ارتقا دهید.
  </p>
<p>
   اساساً، اینها چالش های مقیاس هستند. برای برخی از سازمان‌ها، شما هرگز
   دارای این مشکلات هستید، زیرا شما خوشحال هستید که یک خوشه واحد را به اشتراک می گذارید. برای سایر سازمان ها
   که به دنبال کسب کارایی در مقیاس بزرگتر هستند، این قطعاً حوزه ای است که شما می خواهید
   با جزئیات بیشتر به آن بپردازید. لازم به ذکر است که دیدگاه های متفاوتی وجود دارد
   برای اینکه فدراسیون <span style="color:blue">Kubernetes</span> چگونه باید به نظر برسد، و تعدادی از ابزارهای مختلف
   زنجیره‌هایی در آنجا برای مدیریت آنها.
  </p>
<p>
<span style="color:blue">Kubernetes</span> و ارکستراسیون کانتینر
   |
   263
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 289" src="page_0289/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0289</div>
            </div>
        </div>
        <!-- Page 0290 -->
        <div class="chapter" id="page-0290">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   5 <span style="color:blue">Daniel Bryant</span>، "ساخت مجدد سرویس‌های <span style="color:blue">Backend</span> <span style="color:blue">Siri</span> با استفاده از <span style="color:blue">Apache Mesos</span>،" <span style="color:blue">InfoQ</span>، 3 مه 2015،
   <span style="color:blue">https://oreil.ly/NLUMX</span>.
  </p>
<h4>زمینه ای پشت <span style="color:blue">Kubernetes</span></h4>
<p>
<span style="color:blue">Kubernetes</span> به عنوان یک پروژه منبع باز در <span style="color:blue">Google</span> آغاز شد، که الهام خود را دریافت کرد
   از سیستم های مدیریت کانتینر قبلی <span style="color:blue">Omega</span> و <span style="color:blue">Borg</span>. بسیاری از هسته
   مفاهیم در <span style="color:blue">Kubernetes</span> بر اساس مفاهیمی در مورد نحوه اداره بارهای کاری کانتینر هستند
   در داخل <span style="color:blue">Google</span> مدیریت می شود، اگرچه با یک هدف کمی متفاوت در ذهن. <span style="color:blue">Borg</span> اجرا می شود
   سیستم ها در مقیاس جهانی عظیم، که ده ها یا صدها هزار نفر را مدیریت می کنند
   کانتینرها در سراسر مراکز داده در سطح جهانی. اگر جزئیات بیشتری در مورد چگونگی تفاوت می خواهید
   ذهنیت های مختلف پشت این سه پلتفرم <span style="color:blue">Google</span> را مقایسه کنید، اگرچه از نظر <span style="color:blue">Google</span>-محور
   دیدگاه، من "Borg، <span style="color:blue">Omega</span>، و <span style="color:blue">Kubernetes</span>" اثر <span style="color:blue">Brendan Burns</span> و همکاران را به عنوان a توصیه می کنم
   مرور کلی خوب
  </p>
<p>
   در حالی که <span style="color:blue">Kubernetes</span> مقداری <span style="color:blue">DNA</span> را با <span style="color:blue">Borg</span> و <span style="color:blue">Omega</span> به اشتراک می گذارد، کار در مقیاس عظیم
   یک محرک اصلی در پشت این پروژه نبوده است. هر دو <span style="color:blue">Nomad</span> و <span style="color:blue">Mesos</span> (هر کدام از
   که از <span style="color:blue">Borg</span> نشانه‌ای گرفت) در شرایطی که در آن خوشه‌هایی از
   هزاران دستگاه مورد نیاز است، همانطور که در استفاده <span style="color:blue">Apple</span> از <span style="color:blue">Mesos</span> برای <span style="color:blue">Siri</span> نشان داده شد5
   یا استفاده <span style="color:blue">Roblox</span> از <span style="color:blue">Nomad</span>.
  </p>
<p>
<span style="color:blue">Kubernetes</span> می خواست ایده هایی را از <span style="color:blue">Google</span> بگیرد اما یک <span style="color:blue">developer</span>-دوستانه تر ارائه دهد
   تجربه ای از آنچه توسط <span style="color:blue">Borg</span> یا <span style="color:blue">Omega</span> ارائه شده است. می‌توان به <span style="color:blue">Google</span> نگاه کرد
   تصمیم به سرمایه گذاری مقدار زیادی تلاش مهندسی در ایجاد یک ابزار منبع باز در a
   نور صرفاً بشردوستانه، و در حالی که من مطمئن هستم که این نیت برخی از مردم بود،
   واقعیت این است که این به همان اندازه در مورد خطری است که <span style="color:blue">Google</span> از رقابت در حال مشاهده بود
   فضای ابر عمومی، به طور خاص <span style="color:blue">AWS</span>.
  </p>
<p>
   در بازار ابر عمومی، <span style="color:blue">Google Cloud</span> به دست آورده است اما هنوز از آن دور است
   سومین رتبه پس از <span style="color:blue">Azure</span> و <span style="color:blue">AWS</span> (که در جلو هستند)، و برخی از تحلیل ها باعث شده است که آن را
   توسط <span style="color:blue">Alibaba Cloud</span> به مقام چهارم سوق داده شد. با وجود سهم بازار در حال بهبود، آن است
   هنوز هم تقریباً به جایی که <span style="color:blue">Google</span> می خواهد، نزدیک نیست.
  </p>
<p>
   به نظر می رسد که یک نگرانی اصلی این بود که رهبر بازار، <span style="color:blue">AWS</span>، می تواند
   در نهایت یک انحصار نزدیک در فضای محاسبات ابری داشته باشید. علاوه بر این، نگرانی ها
   مربوط به هزینه مهاجرت از یک ارائه دهنده به ارائه دهنده دیگر به این معنی بود که چنین موضعی
   تسلط بر بازار به سختی می تواند تغییر کند. و سپس <span style="color:blue">Kubernetes</span> می آید،
   با وعده خود برای توانایی ارائه یک پلتفرم استاندارد برای اجرای کانتینر
   بارهای کاری که می تواند توسط چندین فروشنده اجرا شود. امید این بود که این
   امکان مهاجرت از یک ارائه دهنده به دیگری و اجتناب از آینده فقط <span style="color:blue">AWS</span> را فراهم می کند.
  </p>
<p>
   بنابراین شما می توانید <span style="color:blue">Kubernetes</span> را به عنوان یک مشارکت سخاوتمندانه از <span style="color:blue">Google</span> به گسترده تر
   صنعت فناوری اطلاعات، یا به عنوان تلاشی از سوی <span style="color:blue">Google</span> برای مرتبط ماندن در حال حرکت سریع
   فضای ابر عمومی من مشکلی ندارم که هر دو چیز را به یک اندازه درست ببینم.
  </p>
<p>
   264
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0290</div>
            </div>
        </div>
        <!-- Page 0291 -->
        <div class="chapter" id="page-0291">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>بنیاد محاسبات <span style="color:blue">Cloud Native</span></h4>
<p>
   بنیاد محاسبات <span style="color:blue">Cloud Native</span> (<span style="color:blue">CNCF</span> به طور خلاصه) یک شاخه از
   غیرانتفاعی <span style="color:blue">Linux Foundation</span>. <span style="color:blue">CNCF</span> بر روی سرپرستی اکوسیستم تمرکز دارد
   پروژه ها برای کمک به ارتقای توسعه <span style="color:blue">cloud native</span>، اگرچه در عمل این به معنی است
   پشتیبانی از <span style="color:blue">Kubernetes</span> و پروژه‌هایی که با <span style="color:blue">Kubernetes</span> کار می‌کنند یا بر روی خود <span style="color:blue">Kubernetes</span> ساخته می‌شوند. در
   خود پروژه‌ها توسط <span style="color:blue">CNCF</span> ایجاد یا مستقیماً توسعه نمی‌یابند. در عوض، شما
   می توانید <span style="color:blue">CNCF</span> را به عنوان مکانی ببینید که این پروژه‌ها در آن توسعه می‌یابند
   در انزوا می تواند با هم در یک مکان میزبانی شود و در جایی که استانداردهای مشترک
   و قابلیت همکاری را می توان توسعه داد.
  </p>
<p>
   به این ترتیب، <span style="color:blue">CNCF</span> من را به یاد نقش بنیاد نرم افزار <span style="color:blue">Apache</span> می اندازد -
   همانطور که با <span style="color:blue">CNCF</span>، یک پروژه که بخشی از بنیاد نرم‌افزار <span style="color:blue">Apache</span> است، معمولاً
   به معنای سطح کیفیت و پشتیبانی جامعه گسترده تر است. همه پروژه‌های میزبانی‌شده توسط
   <span style="color:blue">CNCF</span> منبع باز هستند، اگرچه توسعه این پروژه‌ها ممکن است باشد
   توسط نهادهای تجاری هدایت می شود.
  </p>
<p>
   جدا از کمک به هدایت توسعه این پروژه‌های مرتبط، <span style="color:blue">CNCF</span>
   همچنین رویدادهایی را برگزار می کند، اسناد و مواد آموزشی ارائه می دهد و تعریف می کند
   برنامه های گواهی مختلف در اطراف <span style="color:blue">Kubernetes</span>. خود این گروه اعضایی از
   در سراسر صنعت، و اگرچه ممکن است برای گروه‌های کوچکتر یا مستقل دشوار باشد
   نقش زیادی در خود سازمان ایفا می کنند، درجه پشتیبانی بین صنعت
   (از جمله بسیاری از شرکت هایی که با یکدیگر رقابت می کنند) چشمگیر است.
  </p>
<p>
   به عنوان یک فرد خارجی، به نظر می رسد <span style="color:blue">CNCF</span> در کمک به گسترش کلمه موفقیت زیادی داشته است
   در مورد سودمندی پروژه هایی که سرپرستی می کند. همچنین به عنوان مکانی عمل کرده است که در آن
   تکامل پروژه های بزرگ را می توان در فضای باز مورد بحث قرار داد و از گسترده اطمینان حاصل کرد
   ورودی <span style="color:blue">CNCF</span> نقش مهمی در موفقیت <span style="color:blue">Kubernetes</span> داشته است - آسان است
   تصور کنید که بدون آن، ما هنوز یک چشم انداز تکه تکه در این منطقه خواهیم داشت.
  </p>
<h4>پلتفرم ها و قابلیت حمل</h4>
<p>
   شما اغلب می شنوید که <span style="color:blue">Kubernetes</span> به عنوان یک "پلتفرم" توصیف می شود. این واقعاً یک پلتفرم نیست
   با این حال، به این معنا که یک توسعه دهنده این اصطلاح را درک کند. خارج از جعبه، همه آن
   واقعاً به شما می دهد توانایی اجرای بارهای کاری کانتینر است. اکثر مردم با استفاده از <span style="color:blue">Kubernetes</span>
   در نهایت پلتفرم خود را با نصب نرم افزارهای پشتیبانی کننده مانند <span style="color:blue">ser</span>- مونتاژ می کنند
   شبکه‌ها، واسطه‌های پیام، ابزارهای جمع‌آوری گزارش، و موارد دیگر. در سازمان‌های بزرگ‌تر،
   این در نهایت مسئولیت یک تیم مهندسی پلتفرم است که قرار می دهند
   این پلتفرم را با هم و مدیریت آن، و به توسعه دهندگان کمک می کند تا از پلتفرم استفاده کنند
   به طور موثر
  </p>
<p>
   این می تواند هم یک نعمت باشد و هم یک نفرین. این رویکرد <span style="color:blue">pick-and-mix</span> ممکن شده است
   به دلیل یک اکوسیستم نسبتاً سازگار از ابزارها (تا حد زیادی به لطف کار
   <span style="color:blue">CNCF</span>). این بدان معناست که شما می توانید ابزارهای مورد علاقه خود را برای کارهای خاص انتخاب کنید، اگر
   می خواهید
  </p>
<p>
   اما همچنین می تواند منجر به استبداد انتخاب شود - ما به راحتی می توانیم تحت تأثیر قرار بگیریم
   <span style="color:blue">Kubernetes</span> و ارکستراسیون کانتینر
   |
   265
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0291</div>
            </div>
        </div>
        <!-- Page 0292 -->
        <div class="chapter" id="page-0292">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   با گزینه های بسیار زیاد. محصولاتی مانند <span style="color:blue">OpenShift</span> <span style="color:blue">Red Hat</span> تا حدودی این انتخاب را می گیرند
   از ما، زیرا آنها یک پلتفرم آماده با برخی از تصمیمات از قبل ساخته شده به ما می دهند
   برای ما
  </p>
<p>
   آنچه این بدان معناست این است که اگرچه در سطح پایه <span style="color:blue">Kubernetes</span> یک
   انتزاع قابل حمل برای اجرای کانتینر، در عمل به سادگی گرفتن یک برنامه نیست
   که در یک خوشه کار می کند و انتظار می رود که در جای دیگری کار کند. برنامه شما،
   عملیات شما و گردش کار توسعه‌دهنده، ممکن است به پلتفرم سفارشی خود وابسته باشد.
   انتقال از یک خوشه <span style="color:blue">Kubernetes</span> به خوشه دیگر نیز ممکن است به شما نیاز داشته باشد
   آن پلتفرم را در مقصد جدید خود بازسازی کنید. من با بسیاری از سازمان‌ها صحبت کرده‌ام
   که <span style="color:blue">Kubernetes</span> را در درجه اول اتخاذ کرده اند زیرا نگران قفل شدن هستند
   در یک فروشنده واحد، اما این سازمان ها این تفاوت ظریف را درک نکرده اند
   برنامه های ساخته شده بر روی <span style="color:blue">Kubernetes</span> از نظر تئوری در سراسر خوشه های <span style="color:blue">Kubernetes</span> قابل حمل هستند، اما نه
   همیشه در عمل
  </p>
<h4><span style="color:blue">Helm</span>، اپراتورها، و <span style="color:blue">CRD</span> ها، اوه من!</h4>
<p>
   یکی از حوزه‌های سردرگمی مداوم در فضای <span style="color:blue">Kubernetes</span> این است که چگونه مدیریت کنیم
   استقرار و چرخه حیات برنامه ها و زیرسیستم های شخص ثالث. در نظر گرفتن
   نیاز به اجرای <span style="color:blue">Kafka</span> در خوشه <span style="color:blue">Kubernetes</span> شما. شما می توانید <span style="color:blue">pod</span>، <span style="color:blue">ser</span>- خود را ایجاد کنید
   <span style="color:blue">vice</span>، و مشخصات استقرار و اجرای آنها خودتان. اما در مورد مدیریت چه
   ارتقاء به تنظیمات <span style="color:blue">Kafka</span> شما؟ در مورد دیگر کارهای تعمیر و نگهداری مشترک شما چه می کنید
   ممکن است بخواهید با آن مقابله کنید، مانند ارتقاء نرم افزار با حالت <span style="color:blue">stateful</span> در حال اجرا؟
  </p>
<p>
   تعدادی ابزار ظاهر شده اند که هدف آنها این است که به شما این توانایی را بدهند که این کار را مدیریت کنید
   انواع برنامه ها در سطح انتزاعی معقول تر. ایده این است که کسی
   چیزی شبیه یک بسته برای <span style="color:blue">Kafka</span> ایجاد می کند، و شما آن را در <span style="color:blue">Kubernetes</span> خود اجرا می کنید
   خوشه به روشی سیاه چال تر. دو مورد از شناخته شده ترین راه حل ها در این فضا
   هستند <span style="color:blue">Operator</span> و <span style="color:blue">Helm</span>. <span style="color:blue">Helm</span> خود را به عنوان "مدیر بسته گمشده" برای می شناسد
   <span style="color:blue">Kubernetes</span>، و در حالی که <span style="color:blue">Operator</span> می تواند نصب اولیه را مدیریت کند، به نظر می رسد
   بیشتر بر مدیریت مداوم برنامه متمرکز شده است. گیج کننده، در حالی که شما
   می‌توانید <span style="color:blue">Operator</span> و <span style="color:blue">Helm</span> را به عنوان جایگزین یکدیگر ببینید، در برخی شرایط نیز می‌توانید استفاده کنید
   هر دوی آنها را با هم ( <span style="color:blue">Helm</span> برای نصب اولیه، <span style="color:blue">Operator</span> برای عملیات چرخه عمر).
  </p>
<p>
   یک تکامل اخیرتر در این فضا چیزی است که به نام تعریف منبع سفارشی نامیده می شود،
   یا <span style="color:blue">CRD</span> ها با <span style="color:blue">CRD</span> ها می توانید <span style="color:blue">API</span> های اصلی <span style="color:blue">Kubernetes</span> را گسترش دهید و به شما اجازه می دهد
   با خوشه خود رفتار جدیدی را وارد کنید. نکته خوب در مورد <span style="color:blue">CRD</span> ها این است که آنها <span style="color:blue">inte</span>- می شوند
   به طور نسبتاً یکپارچه در رابط خط فرمان موجود، کنترل دسترسی و
   بیشتر - بنابراین افزونه سفارشی شما احساس یک افزوده بیگانه را ندارد. آنها اساساً
   به شما اجازه می دهند تا انتزاع های <span style="color:blue">Kubernetes</span> خود را پیاده سازی کنید. به <span style="color:blue">pod</span>، <span style="color:blue">replica</span> فکر کنید
   مجموعه، سرویس، و انتزاع‌های استقرار که قبلاً بحث کردیم—با <span style="color:blue">CRD</span> ها، شما می توانید
   خود را به ترکیب اضافه کنید
  </p>
<p>
   266
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0292</div>
            </div>
        </div>
        <!-- Page 0293 -->
        <div class="chapter" id="page-0293">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   شما می توانید از <span style="color:blue">CRD</span> ها برای همه چیز از مدیریت قطعات کوچک پیکربندی استفاده کنید
   کنترل مش های سرویس مانند <span style="color:blue">Istio</span> یا نرم افزار مبتنی بر خوشه مانند <span style="color:blue">Kafka</span>. با این
   مفهوم انعطاف پذیر و قدرتمند، درک اینکه <span style="color:blue">CRD</span> ها در کجا بهترین استفاده را دارند، دشوار است
   و به نظر نمی رسد که یک اجماع کلی در بین
   کارشناسانی که با آنها چت کرده ام نیز. به نظر نمی رسد که این کل فضا هنوز در حال حل و فصل باشد
   به سرعت، و آنطور که دوست داشتم اجماع وجود ندارد—یک روند در
   اکوسیستم <span style="color:blue">Kubernetes</span>.
  </p>
<h4>و <span style="color:blue">Knative</span></h4>
<p>
<span style="color:blue">Knative</span> یک پروژه منبع باز است که با هدف ارائه گردش کار به سبک <span style="color:blue">FaaS</span> به توسعه دهندگان،
   با استفاده از <span style="color:blue">Kubernetes</span> در زیر هود اساساً، <span style="color:blue">Kubernetes</span> وحشتناک نیست
   دوستانه توسعه دهنده، به خصوص اگر آن را با قابلیت استفاده از چیزهایی مانند <span style="color:blue">Heroku</span> یا
   پلتفرم های مشابه هدف <span style="color:blue">Knative</span> این است که تجربه توسعه دهنده <span style="color:blue">FaaS</span> را به
   <span style="color:blue">Kubernetes</span>، پنهان کردن پیچیدگی <span style="color:blue">Kubernetes</span> از توسعه دهندگان. به نوبه خود، این
   باید به این معنی باشد که تیم های توسعه می توانند چرخه کامل زندگی را آسان تر مدیریت کنند
   نرم افزارشان
  </p>
<p>
   ما قبلاً در مورد مش های سرویس بحث کرده ایم، و به طور خاص در فصل 5 به <span style="color:blue">Istio</span> اشاره کردیم.
   یک مش سرویس برای اجرای <span style="color:blue">Knative</span> ضروری است. در حالی که <span style="color:blue">Knative</span> از نظر تئوری
   به شما امکان می دهد که مش های سرویس متفاوتی را متصل کنید، تنها <span style="color:blue">Istio</span> در این زمان پایدار در نظر گرفته می شود
   (با پشتیبانی از مش های دیگر مانند <span style="color:blue">Ambassador</span> و <span style="color:blue">Gloo</span> همچنان در آلفا است). در
   عمل، این به این معنی است که اگر می خواهید <span style="color:blue">Knative</span> را اتخاذ کنید، همچنین باید قبلاً
   به <span style="color:blue">Istio</span> خرید
  </p>
<p>
   با هر دو <span style="color:blue">Kubernetes</span> و <span style="color:blue">Istio</span>، پروژه‌هایی که عمدتاً توسط <span style="color:blue">Google</span> هدایت می‌شوند، زمان زیادی برد
   تا به مرحله ای برسند که بتوان آنها را پایدار در نظر گرفت. <span style="color:blue">Kubernetes</span> هنوز داشت
   تغییرات عمده بعد از نسخه 1.0 آن، و فقط اخیراً <span style="color:blue">Istio</span>، که قرار است باشد
   زیربنای <span style="color:blue">Knative</span>، به طور کامل بازسازی شد. این سوابق تحویل <span style="color:blue">sta</span>-
   پروژه های <span style="color:blue">ble</span> و آماده برای تولید باعث می شود که من فکر کنم که <span style="color:blue">Knative</span> ممکن است طول بکشد
   آماده استفاده برای اکثر ما. در حالی که برخی از سازمان ها از آن استفاده می کنند، و
   شما احتمالاً می توانید از آن نیز استفاده کنید، تجربه می گوید که فقط مدت زیادی طول خواهد کشید تا برخی
   تغییر عمده ای رخ خواهد داد که نیاز به مهاجرت دردناک دارد. این تا حدودی به همین دلیل است
   که من پیشنهاد کرده‌ام که سازمان‌های محافظه‌کارتر که <span style="color:blue">FaaS</span> را در نظر می‌گیرند
   ارائه برای خوشه <span style="color:blue">Kubernetes</span> خود را در جای دیگری جستجو کنید—پروژه هایی مانند <span style="color:blue">Open</span>-
   <span style="color:blue">FaaS</span> در حال حاضر توسط سازمان هایی در سراسر جهان در حال استفاده است و
   به یک مش سرویس اساسی نیاز ندارد. اما اگر در حال حاضر به قطار <span style="color:blue">Knative</span> بپرید
   درست است اگر در آینده خود هیچ انحرافی نداشته باشید، تعجب نکنید.
  </p>
<p>
   یک نکته دیگر: دیدن اینکه <span style="color:blue">Google</span> تصمیم گرفته است که <span style="color:blue">Knative</span> را بسازد، شرم آور بود
   بخشی از <span style="color:blue">CNCF</span>—فقط می توان فرض کرد که این به این دلیل است که <span style="color:blue">Google</span> می خواهد هدایت کند
   جهت خود ابزار <span style="color:blue">Kubernetes</span> برای بسیاری زمانی که
   راه اندازی شد، تا حدی به این دلیل که طرز فکر <span style="color:blue">Google</span> را در مورد چگونگی اداره کانتینرها منعکس می کرد.
   به شدت از مشارکت مجموعه وسیع تری از صنعت بهره برد،
  </p>
<p>
<span style="color:blue">Kubernetes</span> و ارکستراسیون کانتینر
   |
   267
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0293</div>
            </div>
        </div>
        <!-- Page 0294 -->
        <div class="chapter" id="page-0294">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   و خیلی بد است که حداقل در این مرحله، <span style="color:blue">Google</span> تصمیم گرفته است که علاقه ای به این کار ندارد
   همان مشارکت گسترده صنعتی برای <span style="color:blue">Knative</span>.
  </p>
<h4>آینده</h4>
<p>
   با حرکت به جلو، من هیچ نشانه ای نمی بینم که جاگرنات سرکش <span style="color:blue">Kubernetes</span> متوقف شود
   به زودی، و من کاملاً انتظار دارم که سازمان های بیشتری را ببینم که خود را اجرا می کنند
   خوشه های <span style="color:blue">Kubernetes</span> برای ابرهای خصوصی یا استفاده از خوشه های مدیریت شده در عموم
   تنظیمات ابری با این حال، فکر می کنم آنچه که ما در حال حاضر می بینیم، با توسعه دهندگانی که مجبورند
   یاد بگیرید که چگونه مستقیماً از <span style="color:blue">Kubernetes</span> استفاده کنید، یک ناهنجاری نسبتاً کوتاه مدت خواهد بود. <span style="color:blue">Kubernetes</span>
   در مدیریت بارهای کاری کانتینر و ارائه یک پلتفرم برای موارد دیگر عالی است
   ساخته شود. این چیزی نیست که بتوان یک تجربه دوستانه با توسعه دهنده در نظر گرفت،
   اگرچه. خود <span style="color:blue">Google</span> با فشار پشت <span style="color:blue">Knative</span> به ما نشان داده است، و من فکر می کنم
   ما همچنان می بینیم که <span style="color:blue">Kubernetes</span> تحت لایه‌های انتزاعی سطح بالاتر پنهان شده است. پس در
   آینده، انتظار دارم <span style="color:blue">Kubernetes</span> در همه جا باشد. شما فقط آن را نمی دانید.
  </p>
<p>
   این به این معنی نیست که توسعه دهندگان می توانند فراموش کنند که در حال ساختن یک سیستم توزیع شده هستند.
   آنها هنوز هم باید چالش‌های بی‌شماری را که این نوع معماری دارد درک کنند
   به ارمغان می آورد. فقط این است که آنها مجبور نخواهند بود زیاد در مورد جزئیات نگران باشند
   نرم افزار آنها به منابع محاسباتی اساسی نگاشت شده است.
  </p>
<h4>آیا باید از آن استفاده کنید؟</h4>
<p>
   بنابراین برای کسانی از شما که هنوز اعضای کاملاً پرداخت شده باشگاه <span style="color:blue">Kubernetes</span> نیستید،
   آیا باید بپیوندید؟ خب، اجازه دهید چند دستورالعمل را به اشتراک بگذارم. اولاً، پیاده سازی و <span style="color:blue">man</span>-
   مدیریت خوشه <span style="color:blue">Kubernetes</span> خود برای ضعیفان نیست—این یک امر مهم است
   تعهد. بسیاری از کیفیت تجربه ای که توسعه دهندگان شما خواهند داشت
   استفاده از نصب <span style="color:blue">Kubernetes</span> شما به اثربخشی تیم در حال اجرا بستگی دارد
   خوشه. به همین دلیل، تعدادی از سازمان‌های بزرگ‌تری که با آنها صحبت کرده‌ام
   مسیر <span style="color:blue">Kubernetes</span> در محل رفته اند این کار را به شرکت های تخصصی برون سپاری کرده اند.
  </p>
<p>
   حتی بهتر است، از یک خوشه کاملاً مدیریت شده استفاده کنید. اگر می توانید از ابر عمومی استفاده کنید، پس
   از راه‌حل‌های کاملاً مدیریت شده مانند راه‌حل‌های ارائه شده توسط <span style="color:blue">Google</span>، <span style="color:blue">Azure</span> و <span style="color:blue">AWS</span> استفاده کنید. چه چیزی
   با این حال، من می‌گویم که اگر می‌توانید از ابر عمومی استفاده کنید، پس در نظر بگیرید
   آیا <span style="color:blue">Kubernetes</span> در واقع همان چیزی است که شما می خواهید. اگر به دنبال توسعه دهنده هستید
   پلتفرم دوستانه برای مدیریت استقرار و چرخه عمر <span style="color:blue">microservices</span> های شما، پس
   پلتفرم های <span style="color:blue">FaaS</span> که قبلاً به آنها نگاه کردیم می توانند مناسب باشند. شما همچنین می توانید به
   سایر پیشنهادات <span style="color:blue">PaaS</span>-like، مانند <span style="color:blue">Azure Web Apps</span>، <span style="color:blue">Google App Engine</span>، یا برخی از
   ارائه دهندگان کوچکتر مانند <span style="color:blue">Zeit</span> یا <span style="color:blue">Heroku</span>.
  </p>
<p>
   قبل از اینکه تصمیم بگیرید استفاده از <span style="color:blue">Kubernetes</span> را شروع کنید، تعدادی از مدیران خود را دریافت کنید و
   توسعه دهندگان در حال استفاده از آن هستند. توسعه دهندگان می توانند با اجرای چیزهای سبک وزن شروع کنند
   به صورت محلی، مانند <span style="color:blue">minikube</span> یا <span style="color:blue">MicroK8s</span>، و چیزی نسبتاً نزدیک به یک کامل به آنها می دهد
   تجربه <span style="color:blue">Kubernetes</span>، اما در لپ تاپ های آنها. افرادی که شما در حال مدیریت هستید
   268
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0294</div>
            </div>
        </div>
        <!-- Page 0295 -->
        <div class="chapter" id="page-0295">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   6 <span style="color:blue">Nicole Forsgren</span>، <span style="color:blue">Jez Humble</span>، و <span style="color:blue">Gene Kim</span>، <span style="color:blue">Accelerate</span>: علم ساخت و مقیاس گذاری
   سازمان های فناوری با عملکرد بالا (<span style="color:blue">Portland</span>، <span style="color:blue">OR</span>: انقلاب فناوری اطلاعات، 2018).
  </p>
<p>
   پلتفرم ممکن است نیاز به غواصی عمیق تری داشته باشد. <span style="color:blue">Katacoda</span> دارای آموزش های آنلاین عالی برای <span style="color:blue">com</span>- است
   با مفاهیم اصلی درگیر شوید، و <span style="color:blue">CNCF</span> به انتشار بسیاری از آموزش ها کمک می کند
   مواد در این فضا. اطمینان حاصل کنید افرادی که واقعاً از این چیزها استفاده می کنند،
   قبل از اینکه تصمیم خود را بگیرید، با آن بازی کنید.
  </p>
<p>
   در دام این فکر نیفتید که باید <span style="color:blue">Kubernetes</span> داشته باشید "زیرا همه
   دیگران این کار را انجام می دهند." این به همان اندازه توجیه خطرناکی برای انتخاب <span style="color:blue">Kubernetes</span> است
   همانطور که برای انتخاب <span style="color:blue">microservices</span> است. به خوبی <span style="color:blue">Kubernetes</span>، برای همه مناسب نیست—انجام دهید
   ارزیابی خود را انجام دهید. اما بیایید صریح باشیم - اگر شما تعداد انگشت شماری توسعه دهنده دارید و
   فقط چند <span style="color:blue">microservice</span>، <span style="color:blue">Kubernetes</span> احتمالاً زیاده روی عظیمی است، حتی اگر از یک
   پلتفرم کاملاً مدیریت شده
  </p>
<h4>تحویل پیشرونده</h4>
<p>
   در دهه گذشته یا بیشتر، ما در استقرار نرم افزار برای کاربران خود هوشمندتر شده ایم.
   تکنیک‌های جدیدی پدیدار شده‌اند که توسط تعدادی از موارد استفاده مختلف هدایت می‌شوند
   و از بخش های مختلف صنعت فناوری اطلاعات آمده اند، اما در درجه اول آنها همه بودند
   متمرکز بر کاهش ریسک عمل بیرون راندن نرم افزار جدید. و اگر
   انتشار نرم افزار کم خطرتر می شود، می توانیم نرم افزار را با فراوانی بیشتری منتشر کنیم.
  </p>
<p>
   فعالیت های متعددی وجود دارد که ما قبل از ارسال نرم افزار خود به صورت زنده انجام می دهیم
   به ما کمک می کند مشکلات را قبل از تأثیرگذاری بر کاربران واقعی انتخاب کنیم. تست قبل از تولید a
   بخش بزرگی از این کار است، اگرچه، همانطور که در فصل 9 بحث خواهیم کرد، این فقط می تواند ما را به این اندازه برساند.
  </p>
<p>
   در کتاب خود <span style="color:blue">Accelerate</span>،6 <span style="color:blue">Nicole Forsgren</span>، <span style="color:blue">Jez Humble</span> و <span style="color:blue">Gene Kim</span> شواهدی روشن را نشان می دهند
   به دست آمده از تحقیقات گسترده که شرکت های با عملکرد بالا استقرار
   بیشتر از همتایان کم بازده خود و در عین حال دارند
   نرخ شکست تغییر بسیار کمتری دارد.
  </p>
<p>
   به نظر نمی رسد این ایده که شما "سریع می روید و چیزها را می شکنید" زمانی اعمال می شود که نوبت می رسد
   به حمل و نقل نرم افزار—حمل و نقل مکرر و داشتن نرخ شکست پایین دست به دست هم می دهد، و
   سازمان هایی که این را درک کرده اند نحوه تفکر خود را در مورد انتشار تغییر داده اند
   نرم افزار
  </p>
<p>
   این سازمان‌ها از تکنیک‌هایی مانند کلیدهای ویژگی، انتشارهای قناری، <span style="color:blue">par</span>- استفاده می‌کنند
   اجراها، و موارد دیگر، که ما در این بخش جزئیات آن را بررسی خواهیم کرد. این تغییر در نحوه ما
   در مورد انتشار قابلیت ها فکر می کنیم، تحت عنوان چیزی به نام پیشرونده قرار می گیرد
   تحویل قابلیت به کاربران به روشی کنترل شده منتشر می شود. به جای یک بزرگ
   استقرار انفجاری، ما می توانیم در مورد اینکه چه کسی چه عملکردی را می بیند، هوشمند باشیم - به عنوان مثال،
   با راه‌اندازی یک نسخه جدید از نرم‌افزارمان برای زیرمجموعه‌ای از کاربرانمان.
  </p>
<p>
   تحویل پیشرونده
   |
   269
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0295</div>
            </div>
        </div>
        <!-- Page 0296 -->
        <div class="chapter" id="page-0296">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   اساساً، آنچه همه این تکنیک ها در قلب خود دارند، یک تغییر ساده در چگونگی است
   ما در مورد ارسال نرم افزار فکر می کنیم. یعنی اینکه می توانیم مفهوم
   استقرار از آن انتشار
  </p>
<h4>جدا کردن استقرار از انتشار</h4>
<p>
<span style="color:blue">Jez Humble</span>، نویسنده مشترک تحویل مستمر، موردی را برای جداسازی اینها بیان می کند
   دو ایده، و او این را به یک اصل اساسی برای انتشار نرم افزار کم خطر تبدیل می کند:
  </p>
<p>
   استقرار این است که وقتی نسخه ای از نرم افزار خود را در یک نصب می کنید، چه اتفاقی می افتد
   محیط خاص (محیط تولید اغلب ضمنی است). انتشار است
   هنگامی که شما یک سیستم یا بخشی از آن (به عنوان مثال، یک ویژگی) را در اختیار کاربران قرار می دهید.
  </p>
<p>
<span style="color:blue">Jez</span> استدلال می کند که با جدا کردن این دو ایده، می توانیم اطمینان حاصل کنیم که نرم افزار ما کار می کند
   در تنظیمات تولیدی خود بدون اینکه کاربران ما شکست را ببینند. استقرار آبی-سبز
   یکی از ساده‌ترین نمونه‌های این مفهوم در عمل است—شما یک نسخه دارید
   نرم افزار شما زنده (آبی)، و سپس یک نسخه جدید را در کنار قدیمی ها مستقر می کنید
   نسخه در تولید (سبز). شما بررسی می کنید که مطمئن شوید نسخه جدید در حال کار است
   همانطور که انتظار می رود، و اگر چنین است، مشتریان را به دیدن نسخه جدید نرم افزار خود هدایت می کنید
   نرم افزار. اگر قبل از جابجایی مشکلی پیدا کردید، هیچ مشتری تحت تأثیر قرار نمی گیرد.
  </p>
<p>
   در حالی که استقرار آبی-سبز در میان ساده ترین نمونه های این اصل قرار دارد،
   تعدادی از تکنیک های پیچیده تری وجود دارد که می توانیم هنگام استفاده از آن از آنها استفاده کنیم
   این مفهوم
  </p>
<h4>به تحویل پیشرونده</h4>
<p>
<span style="color:blue">James Governor</span>، بنیانگذار شرکت تحلیلگر صنعت متمرکز بر توسعه دهنده <span style="color:blue">RedMonk</span>،
   اولین بار اصطلاح تحویل پیشرونده را برای پوشش تعدادی از تکنیک های مختلف ارائه کرد
   که در این فضا استفاده می شود. او در ادامه تحویل پیشرونده را به عنوان "ادامه می دهد
   تحویل با کنترل دقیق بر شعاع انفجار” - بنابراین این یک پسوند از
   تحویل مستمر اما همچنین تکنیکی که به ما توانایی کنترل پتانسیل را می دهد
   تأثیر نرم افزار تازه منتشر شده ما.
  </p>
<p>
   در این مورد، <span style="color:blue">Adam Zimman</span> از <span style="color:blue">LaunchDarkly</span> نحوه تاثیر تحویل پیشرونده را توضیح می دهد
   تحویل بر "کسب و کار". از آن نقطه نظر، ما به تغییری در فکر نیاز داریم
   در مورد چگونگی رسیدن قابلیت های جدید به مشتریان ما. این دیگر یک راه اندازی نیست
   —اکنون می تواند یک فعالیت مرحله ای باشد. با این حال، مهمتر از همه، تحویل پیشرونده می تواند
   صاحب محصول را با، همانطور که <span style="color:blue">Adam</span> بیان می کند، «تفویض کنترل ویژگی توانمند کنید
   به مالکی که نزدیکترین مسئول نتیجه است." با این حال، برای اینکه این کار انجام شود،
   صاحب محصول مورد نظر باید مکانیک‌های
   تکنیک تحویل پیشرونده مورد استفاده است، که دلالت بر یک فرد دارد
   صاحب محصول یا پشتیبانی مناسب از گروهی از افراد ماهر.
  </p>
<p>
   ما قبلاً در مورد استقرار آبی-سبز به عنوان یک فناوری تحویل پیشرونده صحبت کرده ایم.
   بیایید به طور خلاصه به چند مورد دیگر نگاهی بیندازیم.
  </p>
<p>
   270
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0296</div>
            </div>
        </div>
        <!-- Page 0297 -->
        <div class="chapter" id="page-0297">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   7 این نقل قول اغلب به زیست شناس پل ارلیش نسبت داده می شود، اما منشأ واقعی آن نامشخص است.
  </p>
<h4>کلیدهای ویژگی</h4>
<p>
   با کلیدهای ویژگی (که با نام <span style="color:blue">feature flags</span> نیز شناخته می شوند)، ما عملکرد مستقر شده را پشت یک کلید پنهان می کنیم
   می توان از آن برای خاموش یا روشن کردن عملکرد استفاده کرد. این بیشتر است
   معمولاً به عنوان بخشی از توسعه مبتنی بر <span style="color:blue">trunk</span> استفاده می شود، که در آن عملکردی که نیست
   هنوز تمام شده می تواند وارد شود و مستقر شود اما همچنان از کاربران نهایی پنهان است، اما آن
   بسیاری از برنامه ها در خارج از این. این می تواند برای روشن کردن یک ویژگی در یک
   زمان مشخص شده، یا خاموش کردن یک ویژگی که باعث ایجاد مشکل می شود.
  </p>
<p>
   همچنین می توانید از کلیدهای ویژگی به روشی دقیق تر استفاده کنید، شاید به یک اجازه دهید
   پرچم بر اساس ماهیت کاربری که در حال درخواست است، حالت متفاوتی داشته باشد. بنابراین شما
   به عنوان مثال می تواند گروهی از مشتریان داشته باشید که یک ویژگی روشن را می بینند (شاید یک
   گروه تست بتا)، در حالی که اکثر مردم ویژگی را خاموش می بینند—این می تواند
   به شما کمک می کند تا یک <span style="color:blue">canary rollout</span> را پیاده سازی کنید، چیزی که ما در ادامه مورد بحث قرار می دهیم. راه حل های کاملاً مدیریت شده
   برای مدیریت کلیدهای ویژگی وجود دارد، از جمله <span style="color:blue">LaunchDarkly</span> و <span style="color:blue">Split</span>. تأثیرگذار همانطور که این پلتفرم ها هستند، من
   فکر می‌کنم می‌توانید با چیزی بسیار ساده‌تر شروع کنید—فقط یک فایل پیکربندی می‌تواند انجام دهد
   برای شروع، سپس به این فناوری ها نگاه کنید زیرا شما شروع به فشار دادن می کنید که چگونه می خواهید از کلیدها استفاده کنید.
  </p>
<p>
   برای یک غواصی عمیق تر در دنیای کلیدهای ویژگی، من می توانم صمیمانه توصیه کنم
   نوشته <span style="color:blue">Pete Hodgson</span> " <span style="color:blue">Feature Toggles</span> (aka <span style="color:blue">Feature Flags</span>)"، که وارد
   جزئیات زیادی در مورد نحوه اجرای آنها و بسیاری از روش های مختلف استفاده از آنها.
  </p>
<h4>انتشار قناری</h4>
<p>
   خطا کردن انسان است، اما برای واقعاً خراب کردن او، به یک کامپیوتر نیاز دارید.7
  </p>
<p>
   ما همه اشتباه می کنیم و کامپیوترها می توانند به ما اجازه دهند تا سریعتر و در سطح بزرگتری اشتباه کنیم
   مقیاس از همیشه قبلا. با توجه به اینکه اشتباهات اجتناب ناپذیر هستند (و به من اعتماد کنید، آنها هستند)،
   پس منطقی است که کارهایی را انجام دهیم که به ما اجازه می دهند تأثیر این اشتباهات را محدود کنیم.
   انتشارهای قناری یکی از این تکنیک ها هستند.
  </p>
<p>
   به نام قناری هایی که به عنوان یک سیستم هشدار اولیه برای معدنچیان به معادن برده شده اند
   به آنها در مورد وجود گازهای خطرناک هشدار می دهد، با یک <span style="color:blue">canary rollout</span> ایده این است که a
   زیر مجموعه محدودی از مشتریان ما عملکرد جدید را می بینند. اگر مشکلی وجود داشته باشد
   <span style="color:blue">rollout</span>، پس فقط آن بخش از مشتریان ما تحت تأثیر قرار می گیرند. اگر این ویژگی کار می کند
   برای آن گروه قناری، سپس می توان آن را برای مشتریان بیشتر شما منتشر کرد تا همه
   نسخه جدید را می بیند.
  </p>
<p>
   برای معماری <span style="color:blue">microservice</span>، یک کلید می تواند در یک <span style="color:blue">micro</span>- پیکربندی شود
   سطح <span style="color:blue">service</span>، روشن کردن (یا خاموش کردن) عملکرد برای درخواست‌ها به آن عملکرد از
   دنیای بیرون یا سایر <span style="color:blue">microservice</span> ها یک تکنیک دیگر داشتن دو
  </p>
<p>
   تحویل پیشرونده
   |
   271
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0297</div>
            </div>
        </div>
        <!-- Page 0298 -->
        <div class="chapter" id="page-0298">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   8 <span style="color:blue">Sam Newman</span>، <span style="color:blue">Monolith</span> به <span style="color:blue">Microservices</span> (<span style="color:blue">Sebastopol</span>: <span style="color:blue">O'Reilly</span>، 2019).
  </p>
<p>
   دو نسخه از یک <span style="color:blue">microservice</span> که در کنار هم اجرا می شوند، و از کلید برای مسیریابی به هر یک استفاده کنید
   نسخه قدیمی یا جدید در اینجا، پیاده سازی <span style="color:blue">canary</span> باید در جایی باشد
   مسیر مسیریابی/شبکه، نه اینکه در یک <span style="color:blue">microservice</span> باشد.
  </p>
<p>
   وقتی برای اولین بار یک انتشار <span style="color:blue">canary</span> انجام دادم، انتشار را به صورت دستی کنترل کردیم. ما می توانستیم <span style="color:blue">con</span>-
   درصد ترافیک ما که عملکرد جدید را می بیند، و در طول یک دوره
   در یک هفته ما به تدریج این را افزایش دادیم تا همه عملکرد جدید را دیدند. در طول
   هفته، ما به نرخ خطا، گزارش باگ و موارد مشابه چشم داشتیم. امروزه، آن است
   رایج تر است که این فرآیند را به صورت خودکار انجام شود. ابزارهایی مانند <span style="color:blue">Spin</span>-
   به عنوان مثال، <span style="color:blue">naker</span> توانایی افزایش خودکار تماس ها را بر اساس معیارها دارد،
   مانند افزایش درصد تماس ها به یک نسخه جدید <span style="color:blue">microservice</span> اگر خطا
   نرخ ها در سطح قابل قبولی قرار دارند.
  </p>
<h4>اجرای موازی</h4>
<p>
   با انتشار یک <span style="color:blue">canary</span>، یک درخواست برای یک قطعه عملکرد یا توسط
   نسخه قدیمی یا جدید. این بدان معناست که ما نمی توانیم دو نسخه از <span style="color:blue">func</span>- را مقایسه کنیم
   <span style="color:blue">tionality</span> همان درخواست را مدیریت می کند، چیزی که می تواند مهم باشد اگر شما
   می خواهید مطمئن شوید که عملکرد جدید دقیقاً به همان روشی کار می کند که قدیم
   نسخه عملکرد
  </p>
<p>
   با یک اجرای موازی دقیقاً همین کار را انجام می دهید - شما دو پیاده سازی متفاوت از
   همان عملکرد در کنار هم، و یک درخواست برای عملکرد به هر دو ارسال کنید
   پیاده سازی ها. با یک معماری <span style="color:blue">microservice</span>، واضح ترین رویکرد
   ممکن است یک تماس سرویس را به دو نسخه مختلف از همان سرویس ارسال کنید و
   نتایج را مقایسه کنید. یک جایگزین این است که هر دو پیاده‌سازی <span style="color:blue">func</span> را همزیستی کنید
   <span style="color:blue">tionality</span> در داخل همان سرویس، که اغلب می‌تواند مقایسه را آسان‌تر کند.
  </p>
<p>
   هنگام اجرای هر دو پیاده‌سازی، مهم است که بدانید که شما احتمالاً فقط
   نتایج یکی از فراخوان‌ها. یک پیاده‌سازی منبع حقیقت در نظر گرفته می‌شود—این است
   پیاده سازی ای که شما در حال حاضر به آن اعتماد دارید، و به طور معمول پیاده سازی موجود است. بسته به ماهیت
   از عملکردی که شما در حال مقایسه با یک اجرای موازی هستید، ممکن است مجبور شوید این ظرافت را در نظر بگیرید - شما
   نمی خواهید دو به روز رسانی سفارش یکسان را به یک مشتری بفرستید، یا مثلاً یک فاکتور را پرداخت کنید
   دو بار!
  </p>
<p>
   من الگوی اجرای موازی را با جزئیات بیشتری در فصل 3 کتابم بررسی می کنم <span style="color:blue">Mono</span>-
   <span style="color:blue">lith</span> به <span style="color:blue">Microservices</span>.8 در آنجا من استفاده از آن را در کمک به انتقال عملکرد از الف بررسی می کنم
   سیستم <span style="color:blue">monolithic</span> به معماری <span style="color:blue">microservice</span>، جایی که ما می خواهیم اطمینان حاصل کنیم که ما
   <span style="color:blue">microservice</span> جدید همانطور که عملکرد معادل <span style="color:blue">equivilent</span> <span style="color:blue">monolith</span> رفتار می کند.
  </p>
<p>
   در یک زمینه دیگر، <span style="color:blue">GitHub</span> از این الگو هنگام بازسازی بخش های اصلی خود استفاده می کند
   کدبیس خود، و ابزار منبع باز <span style="color:blue">Scientist</span> را برای کمک به این فرآیند منتشر کرده است.
  </p>
<p>
   272
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0298</div>
            </div>
        </div>
        <!-- Page 0299 -->
        <div class="chapter" id="page-0299">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   در اینجا، اجرای موازی در یک فرآیند واحد انجام می شود، با دانشمند که به <span style="color:blue">com</span>- کمک می کند
   مقایسه فراخوانی ها
  </p>
<p>
   با استقرار آبی-سبز، کلیدهای ویژگی، انتشارهای قناری، و
   اجرای موازی ما به تازگی سطح این زمینه را خراش داده ایم
   تحویل پیشرونده این ایده ها می توانند با هم خوب عمل کنند (ما قبلاً
   لمس شده است که چگونه می توانید از کلیدهای ویژگی برای پیاده سازی یک <span style="color:blue">can</span>- استفاده کنید
   به عنوان مثال، انتشار <span style="color:blue">ary</span>)، اما احتمالاً می خواهید خودتان را آسان کنید.
  </p>
<p>
   برای شروع، فقط به یاد داشته باشید که دو مفهوم <span style="color:blue">deploy</span>- را جدا کنید
   <span style="color:blue">ment</span> و انتشار. در مرحله بعد، شروع به جستجوی راه‌هایی برای کمک به شما کنید
   نرم افزار خود را با دفعات بیشتری مستقر کنید، اما به روشی ایمن. با
   صاحب محصول یا سایر ذینفعان کسب و کار خود برای درک
   چگونه برخی از این تکنیک ها می توانند به شما در سریعتر رفتن کمک کنند، اما همچنین کمک می کنند
   شکست ها را نیز کاهش دهید
  </p>
<h4>خلاصه</h4>
<p>
   بسیار خوب، ما در اینجا زمین زیادی را پوشش دادیم. بیایید قبل از رفتن، به طور خلاصه خلاصه کنیم. اولاً،
   بیایید اصول استقرار را که قبلاً مشخص کردم، به خودمان یادآوری کنیم:
  </p>
<ul>
<li><strong>اجرای ایزوله</strong></li>
<li>نمونه های <span style="color:blue">microservice</span> را به صورت ایزوله اجرا کنید که در آن منابع محاسباتی خود را دارند، و
    اجرای آنها نمی تواند بر سایر نمونه های <span style="color:blue">microservice</span> که در نزدیکی اجرا می شوند تأثیر بگذارد.</li>
<li><strong>تمرکز بر اتوماسیون</strong></li>
<li>فناوری را انتخاب کنید که امکان اتوماسیون را در حد بالایی فراهم می کند و اتو را اتخاذ کنید
    <span style="color:blue">mation</span> به عنوان بخش اصلی فرهنگ شما.</li>
<li><strong>زیرساخت به عنوان کد</strong></li>
<li>پیکربندی زیرساخت های خود را برای سهولت اتوماسیون و <span style="color:blue">pro</span>- نشان دهید
    تبادل اطلاعات <span style="color:blue">.</span> این کد را در کنترل منبع ذخیره کنید تا محیط ها را قادر سازد
    دوباره ایجاد شود.</li>
<li><strong>هدف استقرار بدون توقف</strong></li>
<li>استقرار مستقل را بیشتر انجام دهید، و اطمینان حاصل کنید که استقرار نسخه جدید
    یک <span style="color:blue">microservice</span> را می توان بدون هیچ گونه قطعی برای کاربران سرویس شما انجام داد (باشد
    انسان ها یا <span style="color:blue">microservices</span> های دیگر).</li>
<li><strong>مدیریت حالت دلخواه</strong></li>
<li>از پلتفرمی استفاده کنید که <span style="color:blue">microservice</span> شما را در یک حالت تعریف شده حفظ می کند و راه‌اندازی می کند
    نمونه های جدید در صورت قطعی یا افزایش ترافیک.</li>
</ul>
<p>
   علاوه بر این، من دستورالعمل های خودم را برای انتخاب پلتفرم استقرار مناسب به اشتراک گذاشتم:
  </p>
<p>
   خلاصه
   |
   273
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 299" src="page_0299/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0299</div>
            </div>
        </div>
        <!-- Page 0300 -->
        <div class="chapter" id="page-0300">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   9 من ممکن است این قانون را مطرح نکرده باشم.
  </p>
<ol>
<li>اگر خراب نیست، آن را درست نکنید.9</li>
<li>تا جایی که احساس خوشحالی می کنید، کنترل را کنار بگذارید، سپس کمی بیشتر آن را رها کنید
    بیت. اگر می توانید تمام کار خود را به یک <span style="color:blue">PaaS</span> خوب مانند <span style="color:blue">Heroku</span> (یا <span style="color:blue">FaaS</span>) واگذار کنید
    فرم)، پس این کار را انجام دهید و خوشحال باشید. آیا واقعاً نیاز دارید که هر آخرین را دستکاری کنید
    تنظیم؟</li>
<li><span style="color:blue">Containerizing</span> <span style="color:blue">microservices</span> شما بدون درد نیست، اما یک <span style="color:blue">com</span>- واقعاً خوب است
    سازش در مورد هزینه انزوا و دارای مزایای فوق العاده برای توسعه محلی
    <span style="color:blue">ment</span>، در حالی که هنوز هم به شما درجه ای از کنترل بر آنچه اتفاق می افتد، می دهد. انتظار داشته باشید
    <span style="color:blue">Kubernetes</span> در آینده شما
   </li>
</ol>
<p>
   همچنین درک الزامات شما مهم است. <span style="color:blue">Kubernetes</span> می تواند یک <span style="color:blue">fit</span> عالی باشد
   برای شما، اما شاید چیزی ساده‌تر به همان اندازه کار کند. خجالت نکشید
   برای انتخاب یک راه حل ساده تر، و همچنین نگران نباشید که کار را به دیگری واگذار کنید
   در غیر این صورت—اگر بتوانم کار را به ابر عمومی منتقل کنم، پس این کار را خواهم کرد، زیرا به من اجازه می دهد
   روی کار خودم تمرکز کنید.
  </p>
<p>
   بالاتر از همه، این فضا در حال گذراندن آشفتگی زیادی است. امیدوارم که من به شما داده باشم
   بینش هایی در فناوری کلیدی در این فضا، اما همچنین برخی از اصولی که هستند را به اشتراک گذاشته است
   به احتمال زیاد از برداشت فعلی فناوری داغ زنده می مانند. هر چه بعد می آید، امیدوارم
   شما بسیار بیشتر آماده اید که آن را گام به گام در پیش بگیرید.
  </p>
<p>
   در فصل بعد، ما قرار است در موضوعی عمیق تر شویم که در اینجا به آن اشاره کردیم:
   آزمایش <span style="color:blue">microservices</span> های ما تا مطمئن شویم که واقعاً کار می کنند.
  </p>
<p>
   274
   |
   فصل 8: استقرار
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0300</div>
            </div>
        </div>
        <!-- Page 0301 -->
        <div class="chapter" id="page-0301">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>فصل 9</h3>
<h4>آزمایش</h4>
<p>
   جهان آزمایش خودکار از زمانی که نوشتن کد را شروع کردم، به طور قابل توجهی پیشرفت کرده است،
   و به نظر می رسد هر ماه یک ابزار یا تکنیک جدید برای بهتر کردن آن وجود دارد. اما چالش ها همچنان باقی مانده است
   در مورد نحوه آزمایش موثر و کارآمد عملکرد کد ما زمانی که یک سیستم توزیع شده است. این فصل این کار را می کند
   مشکلات مرتبط با آزمایش سیستم های ظریف تر را تجزیه می کند و راه حل هایی را ارائه می دهد
   به شما کمک می کند تا مطمئن شوید که می توانید عملکرد جدید خود را با اطمینان منتشر کنید.
  </p>
<p>
   آزمایش زمینه های زیادی را پوشش می دهد. حتی زمانی که فقط در مورد آزمایش های خودکار صحبت می کنیم،
   تعداد زیادی وجود دارد که باید در نظر گرفته شوند. با <span style="color:blue">microservices</span>، ما دیگری اضافه کرده ایم
   سطح پیچیدگی درک انواع مختلف تست هایی که می توانیم اجرا کنیم،
   مهم است که به ما کمک کند تا نیروهای گاهی متضاد را متعادل کنیم
   نرم افزار ما را در اسرع وقت وارد تولید می کند در مقابل اطمینان از اینکه نرم افزار ما کافی است
   کیفیت با توجه به دامنه آزمایش به عنوان یک کل، من قصد ندارم گسترده ای را انجام دهم
   کاوش این موضوع. در عوض، این فصل در درجه اول بر این تمرکز دارد که چگونه
   آزمایش معماری <span style="color:blue">microservice</span> با مقایسه با سیستم های کمتر توزیع شده متفاوت است
   سیستم هایی مانند برنامه های <span style="color:blue">monolithic</span> تک فرآیندی.
  </p>
<p>
   از زمان انتشار اولین نسخه این کتاب، محل انجام آزمایش نیز تغییر کرده است. قبلا،
   آزمایش عمدتاً قبل از رسیدن نرم افزار به تولید انجام می شد. به طور فزاینده
   اگرچه، ما به آزمایش برنامه‌های خود پس از رسیدن آنها به تولید نگاه می‌کنیم -
   بیشتر مرزهای بین توسعه و فعالیت های مرتبط با تولید را محو می کند. این
   چیزی است که ما در این فصل قبل از بررسی آزمایش در تولید بیشتر بررسی خواهیم کرد
   به طور کامل در فصل 10.
  </p>
<p>
   275
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0301</div>
            </div>
        </div>
        <!-- Page 0302 -->
        <div class="chapter" id="page-0302">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   1 <span style="color:blue">Lisa Crispin</span> و <span style="color:blue">Janet Gregory</span>، <span style="color:blue">Agile Testing</span>: یک راهنمای عملی برای آزمایش کنندگان و تیم های چابک
   (<span style="color:blue">Upper Saddle River</span>، <span style="color:blue">NJ</span>: <span style="color:blue">Addison-Wesley</span>، 2008).
  </p>
<h4>انواع تست ها</h4>
<p>
   مانند بسیاری از مشاوران، من گناهکار هستم که گاهی از ربع ها به عنوان راهی برای
   طبقه بندی جهان استفاده می کنم، و من شروع به نگرانی کردم که این کتاب چنین نخواهد بود. خوشبختانه،
   <span style="color:blue">Brian Marick</span> یک سیستم طبقه بندی فوق العاده برای آزمایشات ارائه داد که کاملاً مناسب است.
  </p>
<p>
   شکل 9-1 تغییری از ربع <span style="color:blue">Marick</span> را از کتاب <span style="color:blue">Lisa Crispin</span> و <span style="color:blue">Janet Greg</span>- نشان می دهد
   <span style="color:blue">ory</span>'s کتاب <span style="color:blue">Agile Testing</span>1 که به دسته بندی انواع مختلف آزمایشات کمک می کند.
  </p>
<p>
<strong>شکل 9-1.</strong> ربع آزمایش <span style="color:blue">Brian Marick</span>. <span style="color:blue">Lisa Crispin</span> و <span style="color:blue">Janet Gregory</span>، <span style="color:blue">Agile</span>
   آزمایش: یک راهنمای عملی برای آزمایش کنندگان و تیم های چابک، © 2009
  </p>
<p>
   در پایین ربع، ما آزمایش هایی داریم که با فناوری مواجه هستند—یعنی آزمایش ها
   که به توسعه دهندگان در ایجاد سیستم در وهله اول کمک می کند. تست‌های خواص مانند
   تست‌های عملکرد و تست‌های واحد با محدوده کوچک در این دسته قرار می‌گیرند. همه معمولاً هستند
   خودکار. نیمه بالایی ربع شامل آن دسته از آزمایشاتی است که به غیر <span style="color:blue">techni</span>- کمک می کند
   <span style="color:blue">cal</span> سهامداران درک می کنند که سیستم شما چگونه کار می کند، که ما آن را تجارت می نامیم
   آزمایش ها این می تواند گسترده باشد، تست های <span style="color:blue">end-to-end</span>، همانطور که در <span style="color:blue">Acceptance</span> نشان داده شده است
   ربع تست در بالا سمت چپ؛ یا تست دستی (همانطور که توسط تست کاربر انجام می شود
   در برابر یک سیستم <span style="color:blue">UAT</span>)، همانطور که در ربع تست اکتشافی نشان داده شده است.
  </p>
<p>
   در این مرحله ارزش دارد که به این واقعیت اشاره کنیم که بخش وسیعی از این آزمایشات تمرکز دارند
   در تأیید اعتبار قبل از تولید. به طور خاص، ما از این آزمایشات برای اطمینان از اینکه
   نرم افزار قبل از استقرار در محیط تولید از کیفیت کافی برخوردار است.
   به طور معمول، این تست ها که می گذرند (یا شکست می خورند) یک شرط دروازه برای تصمیم گیری خواهد بود
   این که آیا نرم افزار باید مستقر شود یا خیر.
  </p>
<p>
   به طور فزاینده ای، ما ارزش آزمایش نرم افزار خود را پس از ورود به یک محیط تولید می بینیم.
   بعداً در این فصل بیشتر در مورد تعادل بین این دو صحبت خواهیم کرد
   ایده ها، اما در حال حاضر ارزش دارد که یک محدودیت از ربع <span style="color:blue">Marick</span> را در این مورد برجسته کنیم.
  </p>
<p>
   276
   |
   فصل 9: تست
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 302" src="page_0302/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0302</div>
            </div>
        </div>
        <!-- Page 0303 -->
        <div class="chapter" id="page-0303">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
   هر نوع آزمون نشان داده شده در این ربع مکانی دارد. دقیقاً چقدر از هر آزمایش
   که می خواهید انجام دهید به ماهیت سیستم شما بستگی دارد، اما نکته کلیدی برای <span style="color:blue">under</span>-
   درک این است که شما چندین انتخاب از نظر نحوه آزمایش سیستم خود دارید. روند
   اخیراً از هر نوع تست دستی در مقیاس بزرگ به سمت اتوماسیون دور شده است
   تا حد امکان آزمایش های تکراری و من قطعاً با این رویکرد موافقم. اگر شما
   در حال حاضر مقادیر زیادی تست دستی انجام دهید، پیشنهاد می کنم قبل از انجام این کار به آن بپردازید
   بیش از حد در مسیر <span style="color:blue">microservices</span> ها، زیرا شما بسیاری از موارد را دریافت نخواهید کرد
   مزایای آنها را در صورتی که نتوانید نرم افزار خود را سریع و کارآمد تأیید کنید.
  </p>
<h4>آزمایش اکتشافی دستی</h4>
<p>
   به طور کلی، تغییر از معماری <span style="color:blue">monolithic</span> به یک معماری <span style="color:blue">microservice</span> خواهد بود
   تأثیر کمی بر آزمایش اکتشافی دارد، جدا از هر گونه سازمانی گسترده تر
   تغییری که ممکن است رخ دهد. همانطور که در "به سوی تیم های هم‌تراز شده با جریان" در صفحه بررسی خواهیم کرد
   459، انتظار داریم رابط کاربری برنامه نیز در امتداد شکسته شود
   خطوط تیم در چنین زمینه‌ای، مالکیت آزمایش دستی ممکن است تغییر کند.
  </p>
<p>
   توانایی خودکار کردن برخی از وظایف، مانند تأیید چگونگی ظاهری، قبلاً بود
   منحصراً به تست اکتشافی دستی محدود می شود. بلوغ ابزارسازی
   که اظهارات بصری را فعال می کند به ما اجازه داده است تا وظایفی را که قبلاً بودند خودکار کنیم
   به صورت دستی انجام می شود. شما نباید این را دلیلی برای نداشتن تست دستی بدانید،
   اگرچه؛ در عوض، باید آن را به عنوان فرصتی برای آزاد کردن زمان آزمایش‌کنندگان برای تمرکز بر روی آن ببینید
   آزمایش اکتشافی کمتر تکراری
  </p>
<p>
   وقتی به خوبی انجام شود، آزمایش اکتشافی دستی تا حد زیادی در مورد کشف است. تنظیم
   کنار گذاشتن زمان برای کاوش در برنامه به عنوان یک کاربر نهایی می تواند مسائل را کشف کند
   در غیر این صورت آشکار نمی شود. تست دستی همچنین می تواند در موقعیت هایی حیاتی باشد
   آزمایش خودکار غیرممکن است، شاید به دلیل هزینه نوشتن
   تست. اتوماسیون در مورد حذف کارهای تکراری است تا انسان ها را آزاد کند تا انجام دهند
   فعالیت های خلاقانه تر و موقت. بنابراین به اتوماسیون به عنوان راهی برای آزاد کردن ما فکر کنید
   نیروی مغز برای کارهایی که ما بهتر انجام می دهیم.
  </p>
<p>
   برای اهداف این فصل، ما بیشتر آزمایش اکتشافی دستی را نادیده می گیریم. این
   این به این معنی نیست که این نوع آزمایش مهم نیست، بلکه فقط این است که دامنه این است
   این فصل در درجه اول بر این تمرکز دارد که چگونه آزمایش <span style="color:blue">microservices</span> با آزمایش متفاوت است
   برنامه های <span style="color:blue">monolithic</span> معمولی تر. اما وقتی صحبت از تست های خودکار می شود، چند مورد از
   آیا ما می خواهیم هر آزمون؟ مدل دیگری به ما در پاسخ به این سوال کمک می کند و <span style="color:blue">under</span>-
   تفاهم در مورد این که مبادلات مختلف چه هستند.
  </p>
<p>
   انواع تست ها
   |
   277
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0303</div>
            </div>
        </div>
        <!-- Page 0304 -->
        <div class="chapter" id="page-0304">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>2 Mike Cohn, Succeeding with Agile (Upper Saddle River, NJ: Addison-Wesley, 2009).</h3>
<h4>Test Scope</h4>
<p>
        در کتاب <em>Succeeding with Agile</em>،<sup>2</sup> <strong>Mike Cohn</strong> مدلی به نام <strong>test pyramid</strong> را تشریح می‌کند تا به توضیح انواع <strong>automated tests</strong> مورد نیاز کمک کند. این <strong>pyramid</strong> به ما کمک می‌کند تا نه تنها در مورد <strong>scope</strong> تست‌ها، بلکه در مورد نسبت‌های انواع مختلف تست‌هایی که باید هدف‌گذاری کنیم، فکر کنیم. مدل اصلی <strong>Cohn</strong>، تست‌های خودکار را به سه دسته تقسیم کرد: <strong>unit tests</strong>، <strong>service tests</strong> و <strong>UI tests</strong>، که در شکل 9-2 نشان داده شده است.
    </p>
<figure>
<img alt="Mike Cohn’s test pyramid" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b2/Test_pyramid.svg/1200px-Test_pyramid.svg.png"/>
<figcaption>شکل 9-2. <strong>Mike Cohn</strong>’s test pyramid. Mike Cohn, Succeeding with Agile: Software Development Using Scrum, 1st ed., © 2010</figcaption>
</figure>
<p>
        نکته کلیدی که باید هنگام خواندن این <strong>pyramid</strong> به آن توجه کرد این است که با بالا رفتن از <strong>pyramid</strong>، <strong>test scope</strong> افزایش می‌یابد، همانطور که اعتماد ما به عملکرد <strong>functionality</strong> در حال تست شدن نیز افزایش می‌یابد. از طرف دیگر، زمان چرخه بازخورد با طولانی‌تر شدن اجرای تست‌ها افزایش می‌یابد و هنگامی که یک تست شکست می‌خورد، تعیین اینکه کدام <strong>functionality</strong> خراب شده است، می‌تواند دشوارتر باشد. به طور کلی، با پایین آمدن از <strong>pyramid</strong>، تست‌ها بسیار سریع‌تر می‌شوند، بنابراین ما چرخه‌های بازخورد بسیار سریع‌تری دریافت می‌کنیم. ما <strong>functionality</strong> خراب شده را سریع‌تر پیدا می‌کنیم، <strong>continuous integration builds</strong> ما سریع‌تر هستند و احتمال کمتری دارد که قبل از اینکه بفهمیم چیزی را خراب کرده‌ایم، به کار جدیدی برویم. هنگامی که این تست‌های با <strong>scope</strong> کوچک‌تر شکست می‌خورند، ما همچنین تمایل داریم بدانیم چه چیزی خراب شده است، اغلب تا خط دقیق کد—هر تست بهتر جدا شده است، و درک و رفع خرابی‌ها را برای ما آسان‌تر می‌کند. از سوی دیگر، اگر فقط یک خط کد را تست کرده باشیم، به سیستممان به عنوان یک کل، اعتماد زیادی نداریم که درست کار می‌کند!
    </p>
<p>
        مشکل این مدل این است که همه این اصطلاحات برای افراد مختلف معانی متفاوتی دارند. <strong>Service</strong> به ویژه بارگذاری بیش از حد شده است و تعاریف زیادی از یک <strong>unit test</strong> وجود دارد. آیا یک تست، یک <strong>unit test</strong> است اگر فقط یک خط کد را تست کنم؟ من می‌گویم هست. آیا هنوز یک <strong>unit test</strong> است اگر چندین <strong>function</strong> یا <strong>class</strong> را تست کنم؟ من می‌گویم نه، اما بسیاری مخالفند! من تمایل دارم...
    </p>
<p>
        278 | Chapter 9: Testing
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 304" src="page_0304/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0304</div>
            </div>
        </div>
        <!-- Page 0305 -->
        <div class="chapter" id="page-0305">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        من ترجیح می دهم با وجود ابهام، به نام‌های <strong>unit</strong> و <strong>service</strong> پایبند باشم، اما ترجیح می دهم <strong>UI tests</strong> را <strong>end-to-end tests</strong> بنامم که از این به بعد این کار را خواهم کرد.
    </p>
<p>
        تقریباً هر تیمی که من با آن کار کرده‌ام، از نام‌های متفاوتی برای تست‌ها نسبت به نام‌هایی که <strong>Cohn</strong> در <strong>pyramid</strong> استفاده می‌کند، استفاده کرده است. مهم نیست چه می‌نامیدشان، نکته کلیدی این است که شما تست‌های خودکار <strong>functional</strong> با <strong>scope</strong>های مختلف را برای اهداف مختلف می‌خواهید.
    </p>
<p>
        با توجه به این سردرگمی، ارزش دارد که به این نگاه کنیم که این لایه‌های مختلف چه معنایی دارند.
    </p>
<p>
        بیایید به یک مثال عملی نگاه کنیم. در شکل 9-3، ما برنامه <strong>helpdesk</strong> و وب‌سایت اصلی خود را داریم که هر دو با <strong>Customer microservice</strong> ما در تعامل هستند تا جزئیات مشتری را بازیابی، بررسی و ویرایش کنند. <strong>Customer microservice</strong> ما به نوبه خود با <strong>Loyalty microservice</strong> ما صحبت می‌کند، جایی که مشتریان ما با خرید <strong>CD</strong> های <strong>Justin Bieber</strong> امتیاز کسب می‌کنند. احتمالاً. این بدیهی است که یک بخش کوچکی از سیستم کلی <strong>MusicCorp</strong> ما است، اما برای اینکه ما به چند سناریوی مختلفی که ممکن است بخواهیم تست کنیم، وارد شویم، به اندازه کافی خوب است.
    </p>
<figure>
<img alt="Part of our music shop under test" src="https://www.plantuml.com/plantuml/png/VP11QiCm38JpUeT9uJ5H9x8S6U0Oq_f0000"/>
<figcaption>شکل 9-3. بخشی از فروشگاه موسیقی ما در حال تست</figcaption>
</figure>
<h4>Unit Tests</h4>
<p>
<strong>Unit tests</strong> معمولاً یک <strong>function</strong> یا فراخوانی متد واحد را تست می‌کنند. تست‌های تولید شده به عنوان یک اثر جانبی <strong>test-driven design (TDD)</strong> در این دسته قرار می‌گیرند، همانطور که انواع تست‌های تولید شده توسط تکنیک‌هایی مانند تست مبتنی بر ویژگی قرار می‌گیرند. ما اینجا <strong>microservices</strong> را راه‌اندازی نمی‌کنیم و استفاده از فایل‌های خارجی یا اتصالات شبکه را محدود می‌کنیم. به طور کلی، شما تعداد زیادی از این نوع تست‌ها را می‌خواهید. اگر درست انجام شوند، بسیار، بسیار سریع هستند، و بر روی سخت‌افزار مدرن می‌توانید انتظار داشته باشید که هزاران مورد از اینها را در کمتر از یک دقیقه اجرا کنید. من بسیاری از افرادی را می‌شناسم که این تست‌ها را به طور خودکار هنگام تغییر فایل‌ها به صورت محلی اجرا می‌کنند - به خصوص با زبان‌های تفسیر شده، این می‌تواند چرخه‌های بازخورد بسیار سریعی ارائه دهد.
    </p>
<p>
<strong>Unit tests</strong> به ما توسعه‌دهندگان کمک می‌کنند و بنابراین از نظر اصطلاحات <strong>Marick</strong>، رویکردی <strong>technology facing</strong> و نه <strong>business facing</strong> دارند. همچنین اینها جایی هستند که ما امیدواریم اکثر باگ‌هایمان را بگیریم.
    </p>
<p>
<strong>Test Scope</strong> | 279
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 305" src="page_0305/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0305</div>
            </div>
        </div>
        <!-- Page 0306 -->
        <div class="chapter" id="page-0306">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        بنابراین در مثال ما، وقتی به <strong>Customer microservice</strong> فکر می‌کنیم، <strong>unit tests</strong> بخش‌های کوچکی از کد را به صورت ایزوله پوشش می‌دهند، همانطور که در شکل 9-4 نشان داده شده است.
    </p>
<figure>
<img alt="Scope of unit tests on our example system" src="https://www.plantuml.com/plantuml/png/VP11QiCm38JpUeT9uJ5H9x8S6U0Oq_f0000"/>
<figcaption>شکل 9-4. <strong>Scope</strong> <strong>unit tests</strong> در سیستم مثال ما</figcaption>
</figure>
<p>
        هدف اصلی این تست‌ها این است که به ما بازخورد بسیار سریعی در مورد خوب بودن <strong>functionality</strong> ما بدهند. <strong>Unit tests</strong> همچنین برای پشتیبانی از <strong>refactoring</strong> کد مهم هستند و به ما اجازه می‌دهند تا کد خود را در حین انجام، بازسازی کنیم، با اطمینان از اینکه تست‌های با <strong>scope</strong> کوچک ما در صورت اشتباه، ما را می‌گیرند.
    </p>
<h4>Service Tests</h4>
<p>
<strong>Service tests</strong> برای دور زدن رابط کاربری و تست مستقیم <strong>microservices</strong> ما طراحی شده‌اند. در یک برنامه <strong>monolithic</strong>، ممکن است ما فقط مجموعه‌ای از کلاس‌ها را که یک <strong>service</strong> را به <strong>UI</strong> ارائه می‌دهند، تست کنیم. برای یک سیستم متشکل از تعدادی <strong>microservices</strong>، یک <strong>service test</strong>، قابلیت‌های یک <strong>microservice</strong> فردی را تست می‌کند.
    </p>
<p>
        با اجرای تست‌ها در برابر یک <strong>microservice</strong> واحد به این روش، ما اطمینان بیشتری حاصل می‌کنیم که <strong>service</strong> همانطور که انتظار داریم رفتار می‌کند، اما همچنان <strong>scope</strong> تست را تا حدودی ایزوله نگه می‌داریم. علت شکست تست باید فقط به <strong>microservice</strong> تحت تست محدود شود. برای دستیابی به این ایزولاسیون، ما باید تمام همکاران خارجی را <strong>stub</strong> کنیم تا فقط خود <strong>microservice</strong> در <strong>scope</strong> باشد، همانطور که شکل 9-5 نشان می‌دهد.
    </p>
<p>
        برخی از این تست‌ها می‌توانند به سرعت <strong>unit tests</strong> با <strong>scope</strong> کوچک ما باشند، اما اگر تصمیم دارید در برابر یک پایگاه داده واقعی تست کنید یا از طریق شبکه‌ها به همکاران <strong>stubbed downstream</strong> بروید، زمان تست می‌تواند افزایش یابد. این تست‌ها همچنین <strong>scope</strong> بیشتری را نسبت به یک <strong>unit test</strong> ساده پوشش می‌دهند، بنابراین وقتی شکست می‌خورند، تشخیص اینکه چه چیزی خراب شده است، نسبت به یک <strong>unit test</strong> سخت‌تر می‌شود. با این حال، قطعات متحرک بسیار کمتری دارند و بنابراین نسبت به تست‌های با <strong>scope</strong> بزرگتر شکننده‌تر هستند.
    </p>
<p>
        280 | Chapter 9: Testing
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 306" src="page_0306/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0306</div>
            </div>
        </div>
        <!-- Page 0307 -->
        <div class="chapter" id="page-0307">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<figure>
<img alt="Scope of service tests on our example system" src="https://www.plantuml.com/plantuml/png/VP11QiCm38JpUeT9uJ5H9x8S6U0Oq_f0000"/>
<figcaption>شکل 9-5. <strong>Scope</strong> تست‌های <strong>service</strong> در سیستم مثال ما</figcaption>
</figure>
<h4>End-to-End Tests</h4>
<p>
<strong>End-to-end tests</strong> تست‌هایی هستند که در برابر کل سیستم شما اجرا می‌شوند. اغلب آنها یک <strong>GUI</strong> را از طریق یک مرورگر هدایت می‌کنند، اما می‌توانند به راحتی تعاملات دیگری از کاربر را شبیه‌سازی کنند، مانند آپلود یک فایل.
    </p>
<p>
        این تست‌ها، کد تولید زیادی را پوشش می‌دهند، همانطور که در شکل 9-6 می‌بینیم. بنابراین وقتی قبول می‌شوند، احساس خوبی دارید: شما درجه بالایی از اطمینان دارید که کدی که در حال تست است، در <strong>production</strong> کار خواهد کرد. اما این <strong>scope</strong> افزایش یافته با نقاط ضعفی همراه است و همانطور که به زودی خواهیم دید، انجام خوب <strong>end-to-end tests</strong> در زمینه <strong>microservices</strong> می‌تواند بسیار دشوار باشد.
    </p>
<figure>
<img alt="Scope of end-to-end tests on our example system" src="https://www.plantuml.com/plantuml/png/VP11QiCm38JpUeT9uJ5H9x8S6U0Oq_f0000"/>
<figcaption>شکل 9-6. <strong>Scope</strong> تست‌های <strong>end-to-end</strong> در سیستم مثال ما</figcaption>
</figure>
<p>
<strong>Test Scope</strong> | 281
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 307" src="page_0307/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 307" src="page_0307/image_2.png"/></div>
</div>
                <div class="page-number">صفحه 0307</div>
            </div>
        </div>
        <!-- Page 0308 -->
        <div class="chapter" id="page-0308">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>What About Integration Tests?</h4>
<p>
        ممکن است متوجه شوید که من صریحاً <strong>integration tests</strong> را توصیف نکرده‌ام. این کار هدفمند است. من دریافته‌ام که این اصطلاح اغلب توسط افراد مختلف برای توصیف انواع مختلف تست‌ها استفاده می‌شود. برای برخی، یک <strong>integration test</strong> ممکن است فقط به تعاملات بین دو <strong>service</strong> نگاه کند، یا شاید ارتباط بین کد و یک پایگاه داده. برای دیگران، <strong>integration tests</strong> در نهایت همانند تست‌های کامل <strong>end-to-end</strong> می‌شوند. من سعی کرده‌ام از اصطلاحات صریح‌تری در این فصل استفاده کنم. امیدوارم برای شما آسان باشد که هر آنچه را که به عنوان "<strong>integration test</strong>" به آن اشاره می‌کنید، با اصطلاحات مورد استفاده من در اینجا مطابقت دهید.
    </p>
<h4>Trade-Offs</h4>
<p>
        آنچه ما با انواع مختلف تست‌هایی که <strong>pyramid</strong> پوشش می‌دهد، به دنبال آن هستیم، یک تعادل منطقی است. ما بازخورد سریع می‌خواهیم و می‌خواهیم اطمینان حاصل کنیم که سیستم ما کار می‌کند.
    </p>
<p>
<strong>Unit tests</strong> در <strong>scope</strong> کوچک هستند، بنابراین وقتی شکست می‌خورند، می‌توانیم مشکل را به سرعت پیدا کنیم. همچنین نوشتن آنها سریع و اجرا کردن آنها واقعاً سریع است. با بزرگتر شدن <strong>scope</strong> تست‌های ما، اعتماد بیشتری به سیستم خود پیدا می‌کنیم، اما بازخورد ما شروع به رنج بردن می‌کند زیرا تست‌ها زمان بیشتری برای اجرا می‌برند. همچنین نوشتن و نگهداری آنها نیز پرهزینه‌تر است.
    </p>
<p>
        شما مرتباً در حال تعادل بین تعداد هر نوع تست هستید که برای یافتن آن نقطه مطلوب نیاز دارید. متوجه شدید که اجرای <strong>test suite</strong> شما خیلی طول می‌کشد؟ هنگامی که تست‌های با <strong>scope</strong> گسترده‌تری مانند <strong>service</strong> یا <strong>end-to-end tests</strong> ما شکست می‌خورند، یک <strong>unit test</strong> با <strong>scope</strong> کوچکتر بنویسید تا زودتر این خرابی را شناسایی کنید. به دنبال جایگزینی برخی از تست‌های با <strong>scope</strong> بزرگتر (و کندتر) با تست‌های <strong>unit</strong> سریع‌تر و با <strong>scope</strong> کوچکتر باشید. از طرف دیگر، هنگامی که یک باگ به <strong>production</strong> می‌لغزد، ممکن است نشانه‌ای از این باشد که شما یک تست را از دست داده‌اید.
    </p>
<p>
        بنابراین اگر این تست‌ها همگی <strong>trade-offs</strong> دارند، شما چه تعداد از هر نوع تست می‌خواهید؟ یک قانون خوب این است که احتمالاً به ترتیب بزرگی تست‌های بیشتری می‌خواهید، همانطور که از <strong>pyramid</strong> پایین می‌آیید. مهم است بدانید که شما انواع مختلف تست‌های خودکار را دارید و درک این موضوع مهم است که آیا تعادل فعلی شما مشکلی ایجاد می‌کند یا خیر!
    </p>
<p>
        به عنوان مثال، من روی یک سیستم <strong>monolithic</strong> کار کردم، جایی که ما 4000 <strong>unit tests</strong>، 1000 <strong>service tests</strong> و 60 <strong>end-to-end tests</strong> داشتیم. ما تصمیم گرفتیم که از دیدگاه بازخورد، تعداد زیادی <strong>service</strong> و <strong>end-to-end tests</strong> داشتیم (که دومی بدترین مقصر در تأثیرگذاری بر حلقه‌های بازخورد بودند)، بنابراین ما سخت تلاش کردیم تا پوشش تست را با تست‌های با <strong>scope</strong> کوچکتر جایگزین کنیم.
    </p>
<p>
        یک <strong>antipattern</strong> رایج، چیزی است که اغلب به عنوان یک <strong>test snow cone</strong> یا <strong>inverted pyramid</strong> از آن یاد می‌شود. در اینجا، تست‌های با <strong>scope</strong> کوچک کمی وجود دارد یا اصلاً وجود ندارد، و همه پوشش در تست‌های با <strong>scope</strong> بزرگ است. این پروژه‌ها اغلب اجراهای تست به شدت کند و چرخه‌های بازخورد بسیار طولانی دارند. اگر این تست‌ها به عنوان بخشی از <strong>continuous integration</strong> اجرا شوند، شما زیاد دریافت نخواهید کرد...
    </p>
<p>
        282 | Chapter 9: Testing
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0308</div>
            </div>
        </div>
        <!-- Page 0309 -->
        <div class="chapter" id="page-0309">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        ساخت، و ماهیت زمان ساخت به این معنی است که ساخت می‌تواند برای مدت طولانی شکسته بماند، وقتی چیزی خراب می‌شود.
    </p>
<h4>Implementing Service Tests</h4>
<p>
        پیاده‌سازی <strong>unit tests</strong> در طرح کلی نسبتاً ساده است و مستندات زیادی برای توضیح نحوه نوشتن آنها وجود دارد. <strong>Service</strong> و <strong>end-to-end tests</strong> مواردی هستند که جالب‌تر هستند، به خصوص در زمینه <strong>microservices</strong>، بنابراین ما در ادامه روی آنها تمرکز خواهیم کرد.
    </p>
<p>
        تست‌های <strong>service</strong> ما می‌خواهند بخشی از <strong>functionality</strong> را در سراسر <strong>microservice</strong> تست کنند، و فقط همان <strong>microservice</strong> را. بنابراین اگر می‌خواستیم یک <strong>service test</strong> برای <strong>Customer microservice</strong> از شکل 9-3 بنویسیم، یک نمونه از <strong>Customer microservice</strong> را پیاده‌سازی می‌کردیم - و همانطور که قبلاً بحث شد، می‌خواستیم <strong>Loyalty microservice</strong> را <strong>stub</strong> کنیم تا بهتر اطمینان حاصل شود که خرابی تست می‌تواند به مشکلی در خود <strong>Customer microservice</strong> مرتبط شود.
    </p>
<p>
        همانطور که در فصل 7 بررسی کردیم، پس از تحویل نرم‌افزار، یکی از اولین کارهایی که <strong>automated build</strong> ما انجام می‌دهد، ایجاد یک <strong>binary artifact</strong> برای <strong>microservice</strong> ما است - به عنوان مثال، ایجاد یک <strong>container image</strong> برای آن نسخه از نرم‌افزار. بنابراین پیاده‌سازی آن بسیار ساده است. اما چگونه <strong>collaborators</strong>های <strong>downstream</strong> را <strong>faking</strong> می‌کنیم؟
    </p>
<p>
<strong>Test suite service</strong> ما باید <strong>collaborators downstream</strong> را <strong>stub</strong> کند و <strong>microservice</strong> تحت تست را پیکربندی کند تا به سرویس‌های <strong>stub</strong> متصل شود. سپس باید <strong>stubs</strong> را پیکربندی کنیم تا پاسخ‌هایی را برای تقلید از <strong>microservices</strong> دنیای واقعی ارسال کنند.
    </p>
<h4>Mocking or Stubbing</h4>
<p>
        وقتی در مورد <strong>stubbing collaborators downstream</strong> صحبت می‌کنم، منظورم این است که ما یک <strong>microservice stub</strong> ایجاد می‌کنیم که با پاسخ‌های از پیش تعیین شده به درخواست‌های شناخته شده از <strong>microservice</strong> تحت تست پاسخ می‌دهد. به عنوان مثال، ممکن است به <strong>Loyalty microservice</strong> <strong>stubbed</strong> خود بگویم که وقتی برای مانده حساب مشتری 123 درخواست می‌شود، باید 15000 را برگرداند. تست اهمیتی نمی‌دهد که <strong>stub</strong> 0، 1 یا 100 بار فراخوانی شده باشد. یک تغییر در این مورد، استفاده از <strong>mock</strong> به جای <strong>stub</strong> است.
    </p>
<p>
        هنگام استفاده از <strong>mock</strong>، من در واقع جلوتر می‌روم و اطمینان حاصل می‌کنم که تماس برقرار شده است. اگر تماس مورد انتظار برقرار نشود، تست شکست می‌خورد. پیاده‌سازی این رویکرد به <strong>smarts</strong> بیشتری در <strong>collaborators fake</strong> که ایجاد می‌کنیم نیاز دارد و اگر بیش از حد استفاده شود، می‌تواند باعث شود که تست‌ها شکننده شوند. با این حال، همانطور که ذکر شد، یک <strong>stub</strong> اهمیتی نمی‌دهد که 0، 1 یا چندین بار فراخوانی شود.
    </p>
<p>
        اما گاهی اوقات، <strong>mocks</strong> می‌توانند برای اطمینان از وقوع اثرات جانبی مورد انتظار، بسیار مفید باشند. به عنوان مثال، ممکن است بخواهم بررسی کنم که آیا هنگام ایجاد یک مشتری، یک مانده حساب جدید برای آن مشتری تنظیم شده است یا خیر. تعادل بین <strong>stubbing</strong> و...
    </p>
<p>
        Implementing Service Tests | 283
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0309</div>
            </div>
        </div>
        <!-- Page 0310 -->
        <div class="chapter" id="page-0310">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        3 Steve Freeman and Nat Pryce, Growing Object-Oriented Software, Guided by Tests (Upper Saddle River, NJ: Addison-Wesley, 2009).
        4 Jason D. Valentino, “Moving One of Capital One’s Largest Customer-Facing Apps to AWS,” Capital One Tech, May 24, 2017, https://oreil.ly/5UM5W.
    </p>
<p>
<strong>mocking calls</strong> یک موضوع ظریف است و در <strong>service tests</strong> به همان اندازه در <strong>unit tests</strong> مشکل‌ساز است. به طور کلی، من برای <strong>service tests</strong> از <strong>stubs</strong> خیلی بیشتر از <strong>mocks</strong> استفاده می‌کنم. برای بحثی عمیق‌تر در مورد این <strong>trade-off</strong>، به کتاب <em>Growing Object-Oriented Software, Guided by Tests</em> نوشته <strong>Steve Freeman</strong> و <strong>Nat Pryce</strong> نگاهی بیندازید.<sup>3</sup>
</p>
<p>
        به طور کلی، من به ندرت از <strong>mocks</strong> برای این نوع تست استفاده می‌کنم. اما داشتن ابزاری که بتواند هم <strong>mocks</strong> و هم <strong>stubs</strong> را پیاده‌سازی کند، مفید است.
    </p>
<p>
        در حالی که من احساس می‌کنم که <strong>stubs</strong> و <strong>mocks</strong> در واقع کاملاً از هم متمایز هستند، می‌دانم که این تمایز می‌تواند برای برخی گیج‌کننده باشد، به خصوص زمانی که برخی افراد اصطلاحات دیگری مانند <strong>fakes, spies</strong> و <strong>dummies</strong> را اضافه می‌کنند. <strong>Gerard Meszaros</strong> همه این موارد، از جمله <strong>stubs</strong> و <strong>mocks</strong> را "<strong>Test Doubles</strong>" می‌نامد.
    </p>
<h4>A Smarter Stub Service</h4>
<p>
        معمولاً، برای سرویس‌های <strong>stub</strong>، خودم آنها را راه‌اندازی کرده‌ام. من از همه چیز، از سرور وب <strong>Apache</strong> یا <strong>nginx</strong> گرفته تا کانتینرهای <strong>Jetty</strong> تعبیه شده یا حتی سرورهای وب <strong>Python</strong> که از طریق خط فرمان راه‌اندازی می‌شوند، برای راه‌اندازی سرورهای <strong>stub</strong> برای چنین موارد آزمایشی استفاده کرده‌ام. من احتمالاً در ایجاد این <strong>stubs</strong>، کار یکسانی را بارها و بارها تکرار کرده‌ام. یکی از همکاران قدیمی <strong>Thoughtworks</strong> من، <strong>Brandon Byars</strong>، با سرور <strong>stub/mock</strong> خود به نام <strong>mountebank</strong>، به طور بالقوه کار زیادی را برای بسیاری از ما ذخیره کرده است.
    </p>
<p>
        شما می‌توانید <strong>mountebank</strong> را به عنوان یک <strong>software appliance</strong> کوچک در نظر بگیرید که از طریق <strong>HTTP</strong> قابل برنامه‌ریزی است. این واقعیت که به طور اتفاقی در <strong>NodeJS</strong> نوشته شده است، برای هر <strong>service</strong> فراخوان کاملاً غیرشفاف است. هنگامی که <strong>mountebank</strong> راه‌اندازی می‌شود، به آن دستوراتی را ارسال می‌کنید که به آن می‌گویید یک یا چند "<strong>imposters</strong>" ایجاد کند، که در یک <strong>port</strong> داده شده با یک <strong>protocol</strong> خاص (در حال حاضر از <strong>TCP, HTTP, HTTPS</strong> و <strong>SMTP</strong> پشتیبانی می‌شود) پاسخ می‌دهد، و این <strong>imposters</strong> باید هنگام ارسال درخواست‌ها چه پاسخ‌هایی را ارسال کنند. همچنین اگر می‌خواهید از آن به عنوان <strong>mock</strong> استفاده کنید، از تنظیم انتظارات نیز پشتیبانی می‌کند. از آنجایی که یک نمونه <strong>mountebank</strong> واحد می‌تواند از ایجاد چندین <strong>imposters</strong> پشتیبانی کند، می‌توانید از آن برای <strong>stub</strong> کردن چندین <strong>microservices downstream</strong> استفاده کنید.
    </p>
<p>
<strong>mountebank</strong> در خارج از تست‌های <strong>automated functional</strong> کاربردهایی دارد. به عنوان مثال، <strong>Capital One</strong> از <strong>mountebank</strong> برای جایگزینی زیرساخت <strong>mocking</strong> موجود برای تست‌های عملکرد در مقیاس بزرگ خود استفاده کرد.<sup>4</sup>
</p>
<p>
        یک محدودیت <strong>mountebank</strong> این است که از <strong>stubbing</strong> برای پروتکل‌های پیام‌رسانی پشتیبانی نمی‌کند—به عنوان مثال، اگر می‌خواهید مطمئن شوید که یک رویداد به درستی ارسال شده است (و...
    </p>
<p>
        284 | Chapter 9: Testing
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0310</div>
            </div>
        </div>
        <!-- Page 0311 -->
        <div class="chapter" id="page-0311">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        شاید از طریق یک <strong>broker</strong> دریافت شده باشد، باید به دنبال راه‌حل دیگری باشید. این یک حوزه‌ای است که <strong>Pact</strong> ممکن است بتواند کمک کند—این چیزی است که ما در ادامه بیشتر به آن خواهیم پرداخت.
    </p>
<p>
        بنابراین اگر می‌خواهیم تست‌های <strong>service</strong> خود را فقط برای <strong>Customer microservice</strong> خود اجرا کنیم، می‌توانیم <strong>Customer microservice</strong> و یک نمونه <strong>mountebank</strong> را که به عنوان <strong>Loyalty microservice</strong> ما در همان دستگاه عمل می‌کند، راه‌اندازی کنیم. و اگر آن تست‌ها با موفقیت انجام شوند، می‌توانم <strong>service</strong> <strong>Customer</strong> را بلافاصله پیاده‌سازی کنم! یا می‌توانم؟ در مورد <strong>services</strong>هایی که <strong>Customer microservice</strong> را فراخوانی می‌کنند—<strong>helpdesk</strong> و <strong>web shop</strong> چطور؟ آیا می‌دانیم که تغییری ایجاد کرده‌ایم که ممکن است آنها را خراب کند؟ البته، ما تست‌های مهم را در بالای <strong>pyramid</strong> فراموش کرده‌ایم: تست‌های <strong>end-to-end</strong>.
    </p>
<h4>Implementing (Those Tricky) End-to-End Tests</h4>
<p>
        در یک سیستم <strong>microservice</strong>، قابلیت‌هایی که ما از طریق رابط‌های کاربری خود ارائه می‌دهیم، توسط تعدادی <strong>microservices</strong> ارائه می‌شوند. هدف از تست‌های <strong>end-to-end</strong> که در <strong>Mike Cohn</strong>’s <strong>pyramid</strong> مشخص شده است، این است که <strong>functionality</strong> را از طریق این رابط‌های کاربری در برابر همه چیز در زیر هدایت کنیم تا به ما بازخوردی در مورد کیفیت سیستم به عنوان یک کل ارائه دهیم.
    </p>
<p>
        بنابراین، برای پیاده‌سازی یک <strong>end-to-end test</strong>، باید چندین <strong>microservices</strong> را با هم پیاده‌سازی کنیم، و سپس یک تست را در برابر همه آنها اجرا کنیم. بدیهی است که این تست <strong>scope</strong> بسیار بزرگتری دارد که منجر به اطمینان بیشتر از عملکرد سیستم ما می‌شود! از طرف دیگر، این تست‌ها مستعد کندتر شدن هستند و تشخیص شکست را دشوارتر می‌کنند. بیایید با استفاده از مثال قبلی، کمی بیشتر به آنها بپردازیم تا ببینیم چگونه این تست‌ها می‌توانند در آن قرار بگیرند.
    </p>
<p>
        تصور کنید که ما می‌خواهیم یک نسخه جدید از <strong>Customer microservice</strong> را منتشر کنیم. ما می‌خواهیم تغییرات خود را در اسرع وقت در <strong>production</strong> پیاده‌سازی کنیم، اما نگران هستیم که ممکن است تغییری ایجاد کرده باشیم که می‌تواند <strong>helpdesk</strong> یا <strong>web shop</strong> را خراب کند. مشکلی نیست—بیایید همه سرویس‌هایمان را با هم پیاده‌سازی کنیم و برخی از تست‌ها را در برابر <strong>helpdesk</strong> و <strong>web shop</strong> اجرا کنیم تا ببینیم آیا باگی ایجاد کرده‌ایم یا خیر. اکنون، یک رویکرد ساده این است که این تست‌ها را به انتهای <strong>pipeline</strong> سرویس مشتری خود اضافه کنیم، همانطور که در شکل 9-7 نشان داده شده است.
    </p>
<figure>
<img alt="Adding our end-to-end tests stage: the right approach?" src="https://www.plantuml.com/plantuml/png/VP11QiCm38JpUeT9uJ5H9x8S6U0Oq_f0000"/>
<figcaption>شکل 9-7. اضافه کردن مرحله تست‌های <strong>end-to-end</strong> ما: رویکرد درست؟</figcaption>
</figure>
<p>
        تا اینجا همه چیز خوب است. اما اولین سوالی که باید از خود بپرسیم این است که، از کدام نسخه از <strong>microservices</strong>های دیگر باید استفاده کنیم؟ آیا باید تست‌های خود را در برابر نسخه‌های <strong>helpdesk</strong> و <strong>web shop</strong> که در <strong>production</strong> هستند اجرا کنیم؟ این یک فرض منطقی است—اما اگر نسخه جدیدی از <strong>helpdesk</strong> یا <strong>web shop</strong> برای راه‌اندازی در صف قرار داشته باشد چه؟ در این صورت چه باید بکنیم؟
    </p>
<p>
        Implementing (Those Tricky) End-to-End Tests | 285
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 311" src="page_0311/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0311</div>
            </div>
        </div>
        <!-- Page 0312 -->
        <div class="chapter" id="page-0312">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        در اینجا مشکل دیگری وجود دارد: اگر مجموعه‌ای از تست‌های <strong>end-to-end</strong> <strong>Customer</strong> داشته باشیم که تعداد زیادی <strong>microservices</strong> را پیاده‌سازی می‌کنند و تست‌هایی را در برابر آنها اجرا می‌کنند، در مورد تست‌های <strong>end-to-end</strong> که سایر <strong>microservices</strong> اجرا می‌کنند، چه می‌شود؟ اگر آنها در حال تست یک چیز هستند، ممکن است خودمان را در حال پوشش دادن به بخش زیادی از یک مسیر یکسان بیابیم و ممکن است بسیاری از تلاش‌ها را برای پیاده‌سازی همه آن <strong>microservices</strong> در وهله اول تکرار کنیم.
    </p>
<p>
        ما می‌توانیم با داشتن چندین <strong>pipeline</strong> که به یک مرحله تست <strong>end-to-end</strong> واحد "<strong>fan-in</strong>" می‌شوند، با هر دوی این مشکلات به شکلی ظریف برخورد کنیم. در اینجا، هنگامی که یکی از تعدادی از <strong>build</strong>های مختلف فعال می‌شود، می‌تواند منجر به فعال شدن مراحل ساخت مشترک شود. به عنوان مثال، در شکل 9-8، یک <strong>build</strong> موفقیت‌آمیز برای هر یک از چهار <strong>microservices</strong> در نهایت باعث راه‌اندازی مرحله تست‌های <strong>end-to-end</strong> مشترک می‌شود. برخی از ابزارهای <strong>CI</strong> با پشتیبانی بهتر از <strong>build pipeline</strong>، مدل‌های <strong>fan-in</strong> مانند این را از جعبه خارج خواهند کرد.
    </p>
<figure>
<img alt="A standard way to handle end-to-end tests across services" src="https://www.plantuml.com/plantuml/png/VP11QiCm38JpUeT9uJ5H9x8S6U0Oq_f0000"/>
<figcaption>شکل 9-8. یک راه استاندارد برای مدیریت تست‌های <strong>end-to-end</strong> در سراسر <strong>services</strong></figcaption>
</figure>
<p>
        بنابراین هر زمان که یکی از سرویس‌های ما تغییر می‌کند، تست‌های محلی را برای آن <strong>service</strong> اجرا می‌کنیم. اگر آن تست‌ها با موفقیت انجام شدند، تست‌های <strong>integration</strong> خود را فعال می‌کنیم. عالی، نه؟ خب، متاسفانه معایب زیادی برای تست <strong>end-to-end</strong> وجود دارد.
    </p>
<h4>Flaky and Brittle Tests</h4>
<p>
        با افزایش <strong>test scope</strong>، تعداد قطعات متحرک نیز افزایش می‌یابد. این قطعات متحرک می‌توانند خطاهای آزمایشی را معرفی کنند که نشان نمی‌دهند <strong>functionality</strong> تحت تست خراب شده است، بلکه نشان می‌دهند که مشکل دیگری رخ داده است. به عنوان مثال، اگر ما یک تست برای تأیید اینکه می‌توانیم یک سفارش برای یک <strong>CD</strong> واحد ثبت کنیم و آن تست را در برابر چهار یا پنج <strong>microservices</strong> اجرا می‌کنیم، اگر هر یک از آنها از کار بیفتد، ممکن است با شکستی مواجه شویم که هیچ ربطی به ماهیت خود تست ندارد. به همین ترتیب، یک <strong>glitch</strong> موقت شبکه می‌تواند باعث شود که یک تست بدون گفتن چیزی در مورد <strong>functionality</strong> تحت تست شکست بخورد.
    </p>
<p>
        286 | Chapter 9: Testing
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 312" src="page_0312/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0312</div>
            </div>
        </div>
        <!-- Page 0313 -->
        <div class="chapter" id="page-0313">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        5 Diane Vaughan, The Challenger Launch Decision: Risky Technology, Culture, and Deviance at NASA (Chi‐cago: University of Chicago Press, 1996).
        6 Martin Fowler, “Eradicating Non-Determinism in Tests,” martinfowler.com, April 14, 2011, https://oreil.ly/7Ve7e.
    </p>
<p>
        هرچه قطعات متحرک بیشتر باشند، تست‌های ما شکننده‌تر و کمتر <strong>deterministic</strong> می‌شوند. اگر تست‌هایی دارید که گاهی اوقات شکست می‌خورند، اما همه فقط آنها را دوباره اجرا می‌کنند زیرا ممکن است بعداً دوباره قبول شوند، در این صورت شما <strong>flaky tests</strong> دارید. و تست‌هایی که عملکردهای زیادی را پوشش می‌دهند، تنها مقصر نیستند. تست‌هایی که <strong>functionality</strong> را که در چندین <strong>thread</strong> (و در سراسر چندین <strong>process</strong>) اعمال می‌شوند، پوشش می‌دهند نیز اغلب مشکل‌ساز هستند. شکست می‌تواند به معنای یک <strong>race condition</strong> یا یک <strong>time-out</strong> باشد، یا اینکه <strong>functionality</strong> در واقع خراب است. <strong>Flaky tests</strong> دشمن هستند. وقتی شکست می‌خورند، چیز زیادی به ما نمی‌گویند.
    </p>
<p>
        ما <strong>CI builds</strong> خود را دوباره اجرا می‌کنیم به این امید که بعداً دوباره موفق شوند، فقط برای اینکه ببینیم <strong>check-ins</strong> جمع می‌شوند، و ناگهان خودمان را با حجم زیادی از <strong>broken functionality</strong> مواجه می‌شویم.
    </p>
<p>
        هنگامی که <strong>flaky tests</strong> را شناسایی می‌کنیم، ضروری است که تمام تلاش خود را برای حذف آنها انجام دهیم. در غیر این صورت، ما شروع به از دست دادن اعتماد به یک <strong>test suite</strong> می‌کنیم که "همیشه اینطور شکست می‌خورد." یک <strong>test suite</strong> با <strong>flaky tests</strong> می‌تواند قربانی چیزی شود که <strong>Diane Vaughan</strong> آن را عادی‌سازی انحراف می‌نامد—ایده‌ای که با گذشت زمان می‌توانیم آنقدر به اشتباه عادت کنیم که شروع به پذیرش آنها به عنوان طبیعی و نه یک مشکل کنیم.<sup>5</sup> این گرایش بسیار انسانی به این معنی است که ما باید این <strong>flaky tests</strong> را در اسرع وقت پیدا کرده و حذف کنیم، قبل از اینکه شروع به فرض کنیم که شکست تست‌ها اشکالی ندارد.
    </p>
<p>
        در مقاله "Eradicating Non-Determinism in Tests"،<sup>6</sup> <strong>Martin Fowler</strong> از این رویکرد حمایت می‌کند که اگر شما <strong>flaky tests</strong> دارید، باید آنها را ردیابی کنید و—اگر نمی‌توانید فوراً آنها را برطرف کنید—آنها را از <strong>suite</strong> حذف کنید تا بتوانید به آنها رسیدگی کنید. ببینید آیا می‌توانید آنها را بازنویسی کنید تا از تست کد در حال اجرا در چندین <strong>thread</strong> اجتناب کنید. ببینید آیا می‌توانید محیط اساسی را پایدارتر کنید. بهتر از این، ببینید آیا می‌توانید <strong>flaky test</strong> را با یک تست با <strong>scope</strong> کوچک‌تر که احتمال کمتری دارد مشکلات را نشان دهد، جایگزین کنید. در برخی موارد، تغییر نرم‌افزار تحت تست برای آسان‌تر کردن تست نیز می‌تواند راه درستی باشد.
    </p>
<h4>Who Writes These End-to-End Tests?</h4>
<p>
        با تست‌هایی که به عنوان بخشی از <strong>pipeline</strong> برای یک <strong>microservice</strong> خاص اجرا می‌شوند، نقطه شروع منطقی این است که تیمی که مالک آن <strong>service</strong> است، آن تست‌ها را بنویسد (ما در فصل 15 بیشتر در مورد مالکیت <strong>service</strong> صحبت خواهیم کرد). اما اگر در نظر بگیریم که ممکن است چندین تیم درگیر باشند، و مرحله تست <strong>end-to-end</strong> اکنون به طور موثر بین تیم‌ها به اشتراک گذاشته می‌شود، چه کسی این تست‌ها را می‌نویسد و از آنها مراقبت می‌کند؟
    </p>
<p>
        من مشکلات زیادی را در اینجا دیده‌ام. این تست‌ها به یک فضای آزاد تبدیل می‌شوند، و به همه تیم‌ها اجازه داده می‌شود بدون هیچ درکی از سلامت کل <strong>suite</strong>، تست اضافه کنند. این اغلب می‌تواند منجر به انفجار موارد تست شود، گاهی اوقات...
    </p>
<p>
        Implementing (Those Tricky) End-to-End Tests | 287
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0313</div>
            </div>
        </div>
        <!-- Page 0314 -->
        <div class="chapter" id="page-0314">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        7 Emily Bache, “End-to-End Automated Testing in a Microservices Architecture—Emily Bache,” NDC Confer‐ences, July 5, 2017, YouTube video, 56:48, NDC Oslo 2017, https://oreil.ly/QX3EK.
        که به <strong>test snow cone</strong> ختم می‌شود که قبلاً در مورد آن صحبت کردیم. من همچنین موقعیت‌هایی را دیده‌ام که در آنها، به دلیل عدم وجود مالکیت مشخص برای این تست‌ها، نتایج آنها نادیده گرفته می‌شود. وقتی شکست می‌خورند، همه فرض می‌کنند که این مشکل شخص دیگری است، بنابراین اهمیتی نمی‌دهند که تست‌ها با موفقیت انجام می‌شوند یا خیر.
    </p>
<p>
        یک راه‌حل که من در اینجا دیده‌ام، این است که تست‌های <strong>end-to-end</strong> خاصی را به عنوان مسئولیت یک تیم معین تعیین کنیم، حتی اگر ممکن است از <strong>microservices</strong> که توسط چندین تیم مختلف روی آنها کار می‌شود، عبور کنند. من اولین بار این رویکرد را از <strong>Emily Bache</strong> یاد گرفتم.<sup>7</sup> ایده این است که حتی اگر ما از یک مرحله "<strong>fan in</strong>" در <strong>pipeline</strong> خود استفاده می‌کنیم، آنها سپس <strong>test suite end-to-end</strong> را به گروه‌هایی از <strong>functionality</strong> تقسیم می‌کنند که متعلق به تیم‌های مختلف هستند، همانطور که در شکل 9-9 خواهیم دید.
    </p>
<figure>
<img alt="A standard way to handle end-to-end tests across services" src="https://www.plantuml.com/plantuml/png/VP11QiCm38JpUeT9uJ5H9x8S6U0Oq_f0000"/>
<figcaption>شکل 9-9. یک راه استاندارد برای مدیریت تست‌های <strong>end-to-end</strong> در سراسر <strong>services</strong></figcaption>
</figure>
<p>
        در این مثال خاص، یک تغییر در <strong>Web Shop</strong> که مرحله تست <strong>service</strong> را پشت سر می‌گذارد، تست‌های <strong>end-to-end</strong> مرتبط را فعال می‌کند، که <strong>suite</strong> متعلق به همان تیمی است که مالک <strong>Web Shop</strong> است. به همین ترتیب، هرگونه تغییر در <strong>Helpdesk</strong> فقط تست‌های <strong>end-to-end</strong> مرتبط را فعال می‌کند. اما تغییرات در <strong>Customer</strong> یا <strong>Loyalty</strong> هر دو مجموعه تست را فعال می‌کند. این می‌تواند ما را به شرایطی سوق دهد که در آن تغییری که در <strong>Loyalty microservice</strong> ایجاد می‌شود، می‌تواند هر دو مجموعه تست <strong>end-to-end</strong> را خراب کند، که به طور بالقوه مستلزم این است که تیم‌هایی که مالک این دو <strong>test suite</strong> هستند، مالک <strong>Loyalty microservice</strong> را برای یک <strong>fix</strong> دنبال کنند. اگرچه این مدل در مورد <strong>Emily</strong> کمک کرد، همانطور که می‌بینیم، همچنان دارای...
    </p>
<p>
        288 | Chapter 9: Testing
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 314" src="page_0314/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0314</div>
            </div>
        </div>
        <!-- Page 0315 -->
        <div class="chapter" id="page-0315">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        چالش‌ها. اساساً، داشتن تیمی که مسئولیت تست‌ها را بر عهده دارد، جایی که افراد از یک تیم متفاوت می‌توانند باعث شکست این تست‌ها شوند، مشکل‌ساز است.
    </p>
<p>
        گاهی اوقات سازمان‌ها با داشتن یک تیم اختصاصی به نوشتن این تست‌ها واکنش نشان می‌دهند. این می‌تواند فاجعه‌بار باشد. تیمی که نرم‌افزار را توسعه می‌دهد، به طور فزاینده‌ای از تست‌های مربوط به کد خود دور می‌شود. زمان چرخه‌ها افزایش می‌یابد، زیرا مالکان <strong>service</strong> در نهایت منتظر می‌مانند تا تیم تست، تست‌های <strong>end-to-end</strong> را برای <strong>functionality</strong> که اخیراً نوشته است، بنویسد. از آنجایی که تیم دیگری این تست‌ها را می‌نویسد، تیمی که <strong>service</strong> را نوشته است، کمتر درگیر است و بنابراین، احتمال کمتری دارد که بداند چگونه این تست‌ها را اجرا و رفع کند. اگرچه متاسفانه همچنان یک الگوی سازمانی رایج است، هر زمان که یک تیم از نوشتن تست‌ها برای کدی که در وهله اول نوشته است، دور می‌شود، آسیب‌های قابل توجهی می‌بینم.
    </p>
<p>
        درست انجام دادن این جنبه واقعاً دشوار است. ما نمی‌خواهیم تلاش‌ها را تکرار کنیم، و همچنین نمی‌خواهیم این را کاملاً متمرکز کنیم تا جایی که تیم‌های سازنده <strong>services</strong>، خیلی از این مسائل دور شوند. اگر می‌توانید راهی پاک برای اختصاص تست‌های <strong>end-to-end</strong> به یک تیم خاص پیدا کنید، این کار را انجام دهید. اگر نه، و اگر نمی‌توانید راهی برای حذف تست‌های <strong>end-to-end</strong> و جایگزینی آنها با چیز دیگری پیدا کنید، احتمالاً باید با <strong>test suite end-to-end</strong> به عنوان یک پایگاه کد مشترک، اما با مالکیت مشترک رفتار کنید. تیم‌ها می‌توانند آزادانه در این <strong>suite</strong> <strong>check in</strong> کنند، اما مالکیت سلامت <strong>suite</strong> باید بین تیم‌هایی که خود <strong>services</strong> را توسعه می‌دهند، به اشتراک گذاشته شود. اگر می‌خواهید از تست‌های <strong>end-to-end</strong> با چندین تیم به طور گسترده استفاده کنید، فکر می‌کنم این رویکرد ضروری است، و با این حال، من آن را به ندرت دیده‌ام و هرگز بدون مشکل نبوده است. در نهایت، من متقاعد شده‌ام که در یک سطح خاص از مقیاس سازمانی، به همین دلیل باید از تست‌های <strong>end-to-end</strong> بین تیمی دور شوید.
    </p>
<h4>How Long Should End-to-End Tests Run?</h4>
<p>
        این تست‌های <strong>end-to-end</strong> می‌توانند مدتی طول بکشند. من دیده‌ام که اجرای آنها تا یک روز طول می‌کشد، اگر نه بیشتر، و در یک پروژه‌ای که روی آن کار می‌کردم، یک <strong>suite</strong> رگرسیون کامل شش هفته طول کشید! من به ندرت می‌بینم که تیم‌ها در واقع <strong>test suites end-to-end</strong> خود را برای کاهش همپوشانی در پوشش تست، انتخاب کنند یا زمان کافی را صرف سریع کردن آنها کنند.
    </p>
<p>
        این کندی، همراه با این واقعیت که این تست‌ها اغلب می‌توانند <strong>flaky</strong> باشند، می‌تواند یک مشکل بزرگ باشد. یک <strong>test suite</strong> که تمام روز طول می‌کشد و اغلب خرابی‌هایی دارد که هیچ ربطی به <strong>broken functionality</strong> ندارند، یک فاجعه است. حتی اگر <strong>functionality</strong> شما خراب باشد، ممکن است ساعت‌ها طول بکشد تا متوجه شوید—در این مرحله احتمالاً قبلاً به فعالیت‌های دیگری رفته‌اید، و تغییر زمینه در انتقال مغزتان برای رفع مشکل دردناک خواهد بود.
    </p>
<p>
        ما می‌توانیم با اجرای تست‌ها به صورت موازی، برخی از این موارد را بهبود بخشیم—به عنوان مثال، استفاده از ابزارهایی مانند <strong>Selenium Grid</strong>. با این حال، این رویکرد جایگزینی برای درک آنچه باید تست شود و حذف فعالانه تست‌هایی که دیگر مورد نیاز نیستند، نیست.
    </p>
<p>
        Implementing (Those Tricky) End-to-End Tests | 289
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0315</div>
            </div>
        </div>
        <!-- Page 0316 -->
        <div class="chapter" id="page-0316">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        حذف تست‌ها گاهی یک تمرین دشوار است، و من گمان می‌کنم کسانی که آن را امتحان می‌کنند، اشتراکات زیادی با افرادی دارند که می‌خواهند برخی از اقدامات امنیتی فرودگاه را حذف کنند. مهم نیست اقدامات امنیتی چقدر بی‌اثر باشند، هر بحثی در مورد حذف آنها اغلب با واکنش‌های ناگهانی در مورد عدم توجه به ایمنی مردم یا تمایل به پیروزی تروریست‌ها مواجه می‌شود. داشتن یک گفتگوی متعادل در مورد ارزشی که چیزی اضافه می‌کند در مقابل بار آن، دشوار است. همچنین می‌تواند یک <strong>trade-off</strong> دشوار در زمینه ریسک/پاداش باشد. آیا اگر یک تست را حذف کنید از شما تشکر می‌شود؟ شاید. اما اگر یک تستی که حذف کرده‌اید اجازه دهد یک باگ وارد شود، مطمئناً سرزنش خواهید شد. با این حال، وقتی صحبت از <strong>test suites</strong> با <strong>scope</strong> بزرگتر می‌شود، این دقیقاً همان کاری است که باید بتوانیم انجام دهیم. اگر یک ویژگی یکسان در 20 تست مختلف پوشش داده شده است، شاید بتوانیم از شر نیمی از آنها خلاص شویم، زیرا آن 20 تست 10 دقیقه طول می‌کشد تا اجرا شوند! آنچه این نیاز دارد، درک بهتری از ریسک است، که چیزی است که انسان‌ها به طرز عجیبی در آن ضعیف هستند. در نتیجه، این انتخاب و مدیریت هوشمندانه تست‌های با <strong>scope</strong> بزرگتر و با بار زیاد، به طرز باورنکردنی نادر اتفاق می‌افتد. آرزوی اینکه مردم این کار را بیشتر انجام دهند، با تحقق بخشیدن به آن یکسان نیست.
    </p>
<h4>The Great Pile-Up</h4>
<p>
        چرخه‌های بازخورد طولانی مرتبط با تست‌های <strong>end-to-end</strong>، فقط در مورد بهره‌وری توسعه‌دهنده یک مشکل نیست. با یک <strong>test suite</strong> طولانی، هر شکست مدتی طول می‌کشد تا برطرف شود، که باعث کاهش زمانی می‌شود که انتظار می‌رود تست‌های <strong>end-to-end</strong> در حال گذر باشند. اگر فقط نرم‌افزاری را پیاده‌سازی کنیم که با موفقیت از تمام تست‌های ما عبور کرده باشد (که باید اینطور باشد!)، به این معنی است که سرویس‌های کمتری به مرحله استقرار در <strong>production</strong> می‌رسند.
    </p>
<p>
        این می‌تواند منجر به انباشتگی شود. در حالی که مرحله تست <strong>integration</strong> شکسته شده در حال رفع است، تغییرات بیشتری از تیم‌های <strong>upstream</strong> می‌توانند جمع شوند. جدا از این واقعیت که این می‌تواند رفع <strong>build</strong> را دشوارتر کند، به این معنی است که <strong>scope</strong> تغییرات برای پیاده‌سازی افزایش می‌یابد. راه ایده‌آل برای رسیدگی به این موضوع این است که به افراد اجازه ندهیم اگر تست‌های <strong>end-to-end</strong> شکست می‌خورند، <strong>check in</strong> کنند، اما با توجه به زمان طولانی <strong>test suite</strong>، این اغلب غیرعملی است. سعی کنید بگویید: "شما 30 توسعه‌دهنده: تا زمانی که این <strong>build</strong> هفت ساعته را برطرف نکنیم، <strong>check-in</strong> ممنوع!" با این حال، اجازه دادن به <strong>check-ins</strong> در یک <strong>test suite end-to-end</strong> شکسته، واقعاً حل مشکل اشتباه است. اگر در یک <strong>build</strong> شکسته <strong>check-ins</strong> را مجاز کنید، ممکن است <strong>build</strong> برای مدت طولانی‌تری شکسته بماند، و اثربخشی آن را به عنوان راهی برای ارائه بازخورد سریع در مورد کیفیت کد، تضعیف کنید. پاسخ صحیح این است که <strong>test suite</strong> را سریع‌تر کنید.
    </p>
<p>
        هر چه <strong>scope</strong> استقرار بزرگتر باشد و ریسک انتشار بالاتر باشد، احتمال بیشتری دارد که چیزی را خراب کنیم. بنابراین ما می‌خواهیم مطمئن شویم که می‌توانیم تغییرات کوچک و خوب تست شده را به طور مکرر منتشر کنیم. هنگامی که تست‌های <strong>end-to-end</strong> توانایی ما در انتشار تغییرات کوچک را کند می‌کنند، می‌توانند بیش از آنکه مفید باشند، آسیب برسانند.
    </p>
<p>
        290 | Chapter 9: Testing
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0316</div>
            </div>
        </div>
        <!-- Page 0317 -->
        <div class="chapter" id="page-0317">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>The Metaversion</h4>
<p>
        با مرحله تست <strong>end-to-end</strong>، شروع به فکر کردن آسان است، من می‌دانم که همه این <strong>services</strong> در این نسخه‌ها با هم کار می‌کنند، پس چرا همه آنها را با هم پیاده‌سازی نکنیم؟ این خیلی سریع به یک مکالمه در راستای این موضوع تبدیل می‌شود، پس چرا از شماره نسخه برای کل سیستم استفاده نکنیم؟ به نقل از <strong>Brandon Byars</strong>: "اکنون شما 2.1.0 مشکل دارید."
    </p>
<p>
        با <strong>versioning</strong> کردن تغییرات ایجاد شده در چندین <strong>service</strong> با هم، ما در واقع از این ایده استقبال می‌کنیم که تغییر و پیاده‌سازی چندین <strong>service</strong> به طور همزمان قابل قبول است. این به یک هنجار تبدیل می‌شود. این خوب می‌شود. با انجام این کار، ما یکی از مزیت‌های اصلی معماری <strong>microservice</strong> را واگذار می‌کنیم: توانایی پیاده‌سازی یک <strong>service</strong> به تنهایی، مستقل از <strong>services</strong> دیگر.
    </p>
<p>
        بسیار زیاد، رویکرد پذیرش پیاده‌سازی چندین <strong>service</strong> با هم، به موقعیتی ختم می‌شود که در آن <strong>services</strong> به هم متصل می‌شوند. طولی نمی‌کشد که <strong>services</strong>های خوب جدا شده، به طور فزاینده‌ای با دیگران درهم می‌شوند، و شما هرگز متوجه نمی‌شوید، زیرا هرگز سعی نمی‌کنید آنها را به تنهایی پیاده‌سازی کنید. شما در نهایت با یک آشفتگی درهم‌تنیده مواجه می‌شوید که در آن باید استقرار چندین <strong>service</strong> را به طور همزمان هماهنگ کنید، و همانطور که قبلاً بحث کردیم، این نوع اتصال می‌تواند ما را در مکانی بدتر از آنچه که با یک برنامه <strong>monolithic</strong> واحد خواهیم داشت، قرار دهد.
    </p>
<p>
        این بد است.
    </p>
<h4>Lack of Independent Testability</h4>
<p>
        ما بارها و بارها به موضوع استقرار مستقل برگشته‌ایم و این یک ویژگی مهم برای تسهیل کار تیم‌ها به روشی مستقل‌تر است و به نرم‌افزار اجازه می‌دهد تا به طور مؤثرتری منتشر شود. اگر تیم‌های شما به طور مستقل کار می‌کنند، منطقی است که آنها باید بتوانند به طور مستقل تست کنند. همانطور که دیده‌ایم، تست‌های <strong>end-to-end</strong> می‌توانند استقلال تیم‌ها را کاهش دهند و می‌توانند سطوح هماهنگی افزایش یافته را مجبور کنند، با چالش‌های مرتبطی که می‌تواند به همراه داشته باشد.
    </p>
<p>
        تمایل به تست‌پذیری مستقل به استفاده ما از زیرساخت‌های مرتبط با تست نیز گسترش می‌یابد. اغلب، می‌بینم که افراد مجبور هستند از محیط‌های تست مشترک استفاده کنند که در آن تست‌های چندین تیم اجرا می‌شود. چنین محیطی اغلب بسیار محدود است و هر مشکلی می‌تواند باعث ایجاد مشکلات قابل توجهی شود. در حالت ایده‌آل، اگر می‌خواهید تیم‌های شما بتوانند به روشی مستقل توسعه و تست کنند، آنها نیز باید محیط‌های تست خود را داشته باشند.
    </p>
<p>
        Implementing (Those Tricky) End-to-End Tests | 291
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0317</div>
            </div>
        </div>
        <!-- Page 0318 -->
        <div class="chapter" id="page-0318">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        8 Nicole Forsgren, Jez Humble, and Gene Kim, Accelerate: The Science of Building and Scaling High Performing Technology Organizations (Portland, OR: IT Revolution, 2018).
    </p>
<p>
        تحقیقاتی که در <strong>Accelerate</strong> خلاصه شده است نشان داد که تیم‌های با عملکرد بالا، احتمال بیشتری داشتند که "اکثر تست‌های خود را بر اساس تقاضا انجام دهند، بدون نیاز به یک محیط تست یکپارچه."<sup>8</sup>
</p>
<h4>Should You Avoid End-to-End Tests?</h4>
<p>
        علیرغم معایب ذکر شده، برای بسیاری از کاربران، تست‌های <strong>end-to-end</strong> هنوز هم با تعداد کمی از <strong>microservices</strong> قابل مدیریت هستند، و در این شرایط هنوز هم منطقی به نظر می‌رسند. اما با 3، 4، 10 یا 20 سرویس چه اتفاقی می‌افتد؟ خیلی سریع این <strong>test suites</strong> به شدت متورم می‌شوند، و در بدترین حالت می‌توانند منجر به یک انفجار کارتزینی‌مانند در سناریوهای تحت تست شوند.
    </p>
<p>
        در واقع، حتی با تعداد کمی از <strong>microservices</strong>، این تست‌ها زمانی دشوار می‌شوند که شما چندین تیم دارید که تست‌های <strong>end-to-end</strong> را به اشتراک می‌گذارند. با یک <strong>test suite end-to-end</strong> مشترک، شما هدف خود را در مورد استقرار مستقل تضعیف می‌کنید. توانایی شما به عنوان یک تیم برای پیاده‌سازی یک <strong>microservice</strong> اکنون مستلزم این است که یک <strong>test suite</strong> مشترک بین چندین تیم قبول شود.
    </p>
<p>
        یکی از مشکلات کلیدی که ما در تلاش برای حل آن هستیم، هنگامی که ما از تست‌های <strong>end-to-end</strong> که قبلاً مشخص شد استفاده می‌کنیم، چیست؟ ما در تلاشیم تا اطمینان حاصل کنیم که وقتی یک <strong>service</strong> جدید را در <strong>production</strong> پیاده‌سازی می‌کنیم، تغییرات ما مصرف‌کنندگان را خراب نمی‌کند. اکنون، همانطور که با جزئیات در "شکستگی‌های قرارداد ساختاری در مقابل معنایی" در صفحه 142 پوشش دادیم، داشتن <strong>schema</strong>های صریح برای رابط‌های <strong>microservice</strong> ما می‌تواند به ما در گرفتن شکست‌های ساختاری کمک کند، و این قطعاً می‌تواند نیاز به تست‌های <strong>end-to-end</strong> پیچیده‌تر را کاهش دهد.
    </p>
<p>
        با این حال، <strong>schema</strong>ها نمی‌توانند شکست‌های معنایی را شناسایی کنند، یعنی تغییراتی در رفتار که باعث شکست به دلیل عدم سازگاری به عقب می‌شود. تست‌های <strong>end-to-end</strong> قطعاً می‌توانند به گرفتن این <strong>semantic breakagaes</strong> کمک کنند، اما آنها این کار را با هزینه زیادی انجام می‌دهند. در حالت ایده‌آل، ما می‌خواهیم نوعی تست داشته باشیم که بتواند تغییرات شکستنی معنایی را شناسایی کرده و در یک <strong>scope</strong> کاهش‌یافته اجرا شود، که باعث بهبود <strong>test isolation</strong> (و در نتیجه سرعت بازخورد) می‌شود. اینجاست که تست‌های قرارداد و قراردادهای <strong>consumer-driven</strong> وارد می‌شوند.
    </p>
<h4>Contract Tests and Consumer-Driven Contracts (CDCs)</h4>
<p>
        با تست‌های قرارداد، تیمی که <strong>microservice</strong> آن یک <strong>service</strong> خارجی را مصرف می‌کند، تست‌هایی را می‌نویسد که نحوه انتظار آن را از رفتار یک <strong>service</strong> خارجی توصیف می‌کند. این کمتر در مورد تست <strong>microservice</strong> خود شماست و بیشتر در مورد مشخص کردن چگونگی رفتار یک <strong>service</strong> خارجی است. یکی از دلایل اصلی که این تست‌های قرارداد می‌توانند مفید باشند این است که آنها را می‌توان در برابر هر <strong>stubs</strong> یا <strong>mocks</strong> که شما از آنها برای نشان دادن خارجی استفاده می‌کنید، اجرا کرد...
    </p>
<p>
        292 | Chapter 9: Testing
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0318</div>
            </div>
        </div>
        <!-- Page 0319 -->
        <div class="chapter" id="page-0319">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<strong>services</strong>—تست‌های قرارداد شما باید هنگام اجرای <strong>stubs</strong> خودتان، همانطور که باید برای <strong>service</strong> خارجی واقعی، با موفقیت انجام شوند.
    </p>
<p>
        تست‌های قرارداد، زمانی که به عنوان بخشی از قراردادهای <strong>consumer-driven (CDCs)</strong> استفاده می‌شوند، بسیار مفید می‌شوند. تست‌های قرارداد در واقع یک نمایش صریح و برنامه‌نویسی از نحوه انتظار <strong>microservice</strong> مصرف‌کننده (<strong>upstream</strong>) از <strong>microservice</strong> تولیدکننده (<strong>downstream</strong>) برای رفتار است. با <strong>CDCs</strong>، تیم مصرف‌کننده اطمینان حاصل می‌کند که این تست‌های قرارداد با تیم تولیدکننده به اشتراک گذاشته می‌شوند تا به تیم تولیدکننده اجازه دهند اطمینان حاصل کند که <strong>microservice</strong> آن، این انتظارات را برآورده می‌کند. معمولاً، این کار با این انجام می‌شود که تیم تولیدکننده <strong>downstream</strong>، قراردادهای مصرف‌کننده را برای هر <strong>microservice</strong> مصرف‌کننده به عنوان بخشی از <strong>test suite</strong> خود اجرا کند که در هر <strong>build</strong> اجرا می‌شود. از منظر بازخورد تست، این تست‌ها باید فقط در برابر یک تولیدکننده واحد و ایزوله اجرا شوند، بنابراین می‌توانند سریع‌تر و قابل اطمینان‌تر از تست‌های <strong>end-to-end</strong> باشند که ممکن است جایگزین شوند.
    </p>
<p>
        به عنوان مثال، بیایید سناریوی خود را از قبل مرور کنیم. <strong>Customer microservice</strong> دو مصرف‌کننده مجزا دارد: <strong>helpdesk</strong> و <strong>web shop</strong>. هر دوی این برنامه‌های مصرف‌کننده انتظاراتی در مورد نحوه رفتار <strong>Customer microservice</strong> دارند. در این مثال، شما مجموعه‌ای از تست‌ها را برای هر مصرف‌کننده ایجاد می‌کنید: یکی که نشان‌دهنده انتظارات <strong>helpdesk</strong> از <strong>Customer microservice</strong> است، و مجموعه دیگری که نشان‌دهنده انتظارات <strong>web shop</strong> است.
    </p>
<p>
        از آنجایی که این <strong>CDCs</strong>، انتظاراتی در مورد نحوه رفتار <strong>Customer microservice</strong> هستند، ما فقط باید خود <strong>Customer microservice</strong> را اجرا کنیم، به این معنی که ما همان <strong>scope</strong> تست را به عنوان تست‌های <strong>service</strong> خود داریم. آنها ویژگی‌های عملکردی مشابهی خواهند داشت و مستلزم این است که ما فقط خود <strong>Customer microservice</strong> را با <strong>stubbed</strong> کردن هرگونه وابستگی خارجی اجرا کنیم.
    </p>
<p>
        یک روش خوب در اینجا این است که کسی از تیم‌های تولیدکننده و مصرف‌کننده در ایجاد تست‌ها همکاری کند، بنابراین شاید افرادی از تیم‌های <strong>web shop</strong> و <strong>helpdesk</strong> با افرادی از تیم خدمات مشتری جفت شوند. می‌توان گفت که قراردادهای <strong>consumer-driven</strong> به همان اندازه مربوط به تقویت خطوط ارتباطی شفاف و همکاری، در صورت نیاز، بین <strong>microservices</strong> و تیم‌هایی است که آنها را مصرف می‌کنند. در واقع، می‌توان استدلال کرد که پیاده‌سازی <strong>CDCs</strong> فقط آشکارتر کردن ارتباط بین تیم‌هایی است که از قبل باید وجود داشته باشند. در همکاری بین تیمی، <strong>CDCs</strong> یک یادآوری صریح از قانون <strong>Conway</strong> است.
    </p>
<p>
<strong>CDCs</strong> در همان سطح تست <strong>pyramid</strong> قرار دارند، مانند تست‌های <strong>service</strong>، اگرچه با تمرکز بسیار متفاوت، همانطور که در شکل 9-10 نشان داده شده است. این تست‌ها بر نحوه استفاده یک مصرف‌کننده از <strong>service</strong> متمرکز هستند و اگر شکست بخورند، محرک بسیار متفاوتی در مقایسه با تست‌های <strong>service</strong> دارد. اگر یکی از این <strong>CDCs</strong> در طول یک <strong>build</strong> از <strong>service Customer</strong> شکست بخورد، مشخص می‌شود که کدام مصرف‌کننده تحت تأثیر قرار خواهد گرفت. در این مرحله، می‌توانید مشکل را برطرف کنید یا بحث را در مورد معرفی یک تغییر شکستنی به روشی که در "مدیریت تغییر بین <strong>Microservices</strong>" در صفحه 144 بحث کردیم، شروع کنید.
    </p>
<p>
        Should You Avoid End-to-End Tests? | 293
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0319</div>
            </div>
        </div>
        <!-- Page 0320 -->
        <div class="chapter" id="page-0320">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        بنابراین با <strong>CDCs</strong>، ما می‌توانیم یک تغییر شکستنی را قبل از اینکه نرم‌افزارمان به <strong>production</strong> برود، شناسایی کنیم، بدون اینکه مجبور باشیم از یک تست <strong>end-to-end</strong> بالقوه گران‌قیمت استفاده کنیم.
    </p>
<figure>
<img alt="Integrating consumer-driven tests into the test pyramid" src="https://www.plantuml.com/plantuml/png/VP11QiCm38JpUeT9uJ5H9x8S6U0Oq_f0000"/>
<figcaption>شکل 9-10. ادغام تست‌های <strong>consumer-driven</strong> در <strong>test pyramid</strong></figcaption>
</figure>
<h4>Pact</h4>
<p>
<strong>Pact</strong> یک ابزار تست <strong>consumer-driven</strong> است که در ابتدا در realestate.com.au داخلی توسعه یافت، اما اکنون <strong>open source</strong> است. در ابتدا فقط برای <strong>Ruby</strong> و فقط بر روی پروتکل‌های <strong>HTTP</strong> متمرکز بود، <strong>Pact</strong> اکنون از زبان‌ها و پلتفرم‌های مختلفی مانند <strong>JVM، JavaScript، Python</strong> و <strong>.NET</strong> پشتیبانی می‌کند و همچنین می‌تواند با تعاملات پیام‌رسانی استفاده شود.
    </p>
<p>
        با <strong>Pact</strong>، شما با تعریف انتظارات تولیدکننده با استفاده از یک <strong>DSL</strong> در یکی از زبان‌های پشتیبانی‌شده شروع می‌کنید. سپس شما یک سرور <strong>Pact</strong> محلی را راه‌اندازی می‌کنید و این انتظار را در برابر آن اجرا می‌کنید تا فایل مشخصات <strong>Pact</strong> را ایجاد کنید. فایل <strong>Pact</strong> فقط یک مشخصات <strong>JSON</strong> رسمی است. شما بدیهی است که می‌توانید این را <strong>handcode</strong> کنید، اما استفاده از <strong>SDK</strong> خاص زبان بسیار آسان‌تر است.
    </p>
<p>
        یک ویژگی واقعاً خوب این مدل این است که سرور <strong>mock</strong> در حال اجرای محلی که برای تولید فایل <strong>Pact</strong> استفاده می‌شود، به عنوان یک <strong>stub</strong> محلی برای <strong>microservices downstream</strong> نیز کار می‌کند. با تعریف انتظارات خود به صورت محلی، شما نحوه پاسخگویی این <strong>service stub</strong> محلی را تعریف می‌کنید. این می‌تواند جایگزین نیاز به ابزارهایی مانند <strong>mountebank</strong> (یا راه‌حل‌های <strong>stubbing</strong> یا <strong>mocking</strong> خودتان) شود.
    </p>
<p>
        در سمت تولیدکننده، شما سپس تأیید می‌کنید که این مشخصات مصرف‌کننده با استفاده از مشخصات <strong>JSON Pact</strong> برای هدایت تماس‌ها در برابر <strong>microservice</strong> شما و تأیید پاسخ‌ها برآورده شده است. برای اینکه این کار انجام شود، تولیدکننده نیاز به دسترسی به فایل <strong>Pact</strong> دارد. همانطور که قبلاً در "نگاشت کد منبع و ساخت به <strong>Microservices</strong>" در صفحه 205 بحث کردیم، ما انتظار داریم که مصرف‌کننده و تولیدکننده در <strong>build</strong>های مختلف قرار داشته باشند. این بدان معناست که ما به نوعی برای این فایل <strong>JSON</strong> نیاز داریم، که به <strong>build</strong> مصرف‌کننده تولید می‌شود، تا توسط تولیدکننده در دسترس قرار گیرد.
    </p>
<p>
        294 | Chapter 9: Testing
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 320" src="page_0320/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0320</div>
            </div>
        </div>
        <!-- Page 0321 -->
        <div class="chapter" id="page-0321">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        شما می‌توانید فایل <strong>Pact</strong> را در <strong>artifact repository</strong> ابزار <strong>CI/CD</strong> خود ذخیره کنید، یا می‌توانید از <strong>Pact Broker</strong> استفاده کنید، که به شما امکان می‌دهد چندین نسخه از مشخصات <strong>Pact</strong> خود را ذخیره کنید. این می‌تواند به شما اجازه دهد تست‌های قرارداد <strong>consumer-driven</strong> خود را در برابر چندین نسخه مختلف از مصرف‌کنندگان اجرا کنید، اگر بخواهید در برابر، مثلاً نسخه مصرف‌کننده در <strong>production</strong> و نسخه مصرف‌کننده‌ای که اخیراً ساخته شده است، تست کنید.
    </p>
<p>
<strong>Pact Broker</strong> در واقع دارای مجموعه‌ای از قابلیت‌های مفید است. جدا از عمل به عنوان مکانی که در آن قراردادها را می‌توان ذخیره کرد، شما همچنین می‌توانید متوجه شوید که چه زمانی این قراردادها اعتبارسنجی شده‌اند. همچنین، از آنجایی که <strong>Pact Broker</strong> در مورد رابطه بین مصرف‌کننده و تولیدکننده می‌داند، می‌تواند به شما نشان دهد که کدام <strong>microservices</strong> به کدام <strong>microservices</strong> دیگر وابسته هستند.
    </p>
<h4>Other options</h4>
<p>
<strong>Pact</strong> تنها گزینه برای ابزارسازی در اطراف قراردادهای <strong>consumer-driven</strong> نیست. <strong>Spring Cloud Contract</strong> یکی از این نمونه‌ها است. با این حال، شایان ذکر است که—برخلاف <strong>Pact</strong>، که از ابتدا برای پشتیبانی از <strong>technology stack</strong>های مختلف طراحی شده بود—<strong>Spring Cloud Contract</strong> فقط در یک <strong>ecosystem JVM</strong> خالص واقعاً مفید است.
    </p>
<h4>It’s about conversations</h4>
<p>
        در <strong>Agile</strong>، داستان‌ها اغلب به عنوان یک <strong>placeholder</strong> برای یک مکالمه ارجاع داده می‌شوند. <strong>CDCs</strong> دقیقاً مانند آن هستند. آنها به <strong>codification</strong> مجموعه‌ای از بحث‌ها در مورد چگونگی ظاهر یک <strong>API service</strong> تبدیل می‌شوند، و وقتی شکست می‌خورند، به یک نقطه ماشه برای داشتن مکالماتی در مورد چگونگی تکامل آن <strong>API</strong> تبدیل می‌شوند.
    </p>
<p>
        درک این نکته مهم است که <strong>CDCs</strong> به ارتباط خوب و اعتماد بین <strong>service</strong> مصرف‌کننده و تولیدکننده نیاز دارد. اگر هر دو طرف در یک تیم (یا یک نفر!) باشند، این نباید سخت باشد. با این حال، اگر شما در حال مصرف یک <strong>service</strong> هستید که با یک شخص ثالث ارائه شده است، ممکن است فراوانی ارتباط یا اعتماد را نداشته باشید تا <strong>CDCs</strong> را عملی کنید. در این شرایط، ممکن است مجبور شوید فقط با تست‌های <strong>integration</strong> با <strong>scope</strong> محدودتر و بزرگ‌تر در اطراف مؤلفه غیرقابل اعتماد کنار بیایید. از طرف دیگر، اگر در حال ایجاد یک <strong>API</strong> برای هزاران مصرف‌کننده بالقوه هستید، مانند یک <strong>API web service</strong> که به صورت عمومی در دسترس است، ممکن است مجبور شوید خودتان نقش مصرف‌کننده را بازی کنید (یا شاید با زیرمجموعه‌ای از مصرف‌کنندگان خود کار کنید) در تعریف این تست‌ها. شکستن تعداد زیادی از مصرف‌کنندگان خارجی ایده بسیار بدی است، بنابراین اگر چیزی وجود داشته باشد، اهمیت <strong>CDCs</strong> افزایش می‌یابد!
    </p>
<h4>The Final Word</h4>
<p>
        همانطور که با جزئیات قبلاً در این فصل مشخص شد، تست‌های <strong>end-to-end</strong> دارای تعدادی زیادی از معایب هستند که با افزودن قطعات متحرک بیشتر تحت تست، به طور قابل توجهی افزایش می‌یابند. از صحبت با افرادی که مدتی است <strong>microservices</strong> را در مقیاس اجرا می‌کنند، من آموخته‌ام که اکثر آنها با گذشت زمان، نیاز به <strong>end-to-</strong>...
    </p>
<p>
        Should You Avoid End-to-End Tests? | 295
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0321</div>
            </div>
        </div>
        <!-- Page 0322 -->
        <div class="chapter" id="page-0322">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        تست‌ها به نفع مکانیسم‌های دیگری برای اعتبارسنجی کیفیت نرم‌افزار خود—به عنوان مثال، استفاده از <strong>schema</strong>های صریح و <strong>CDCs</strong>، تست در <strong>production</strong>، یا شاید برخی از تکنیک‌های تحویل تدریجی که ما در مورد آنها صحبت کرده‌ایم، مانند <strong>canary releases</strong>.
    </p>
<p>
        شما می‌توانید اجرای تست‌های <strong>end-to-end</strong> قبل از استقرار در <strong>production</strong> را به عنوان چرخ‌های آموزشی در نظر بگیرید. در حالی که شما در حال یادگیری نحوه عملکرد <strong>CDCs</strong> و بهبود تکنیک‌های نظارت و پیاده‌سازی خود هستید، این تست‌های <strong>end-to-end</strong> ممکن است یک شبکه ایمنی مفید را تشکیل دهند، جایی که شما زمان چرخه را برای کاهش ریسک مبادله می‌کنید. اما همانطور که شما آن حوزه‌های دیگر را بهبود می‌بخشید، و با افزایش هزینه نسبی ایجاد تست‌های <strong>end-to-end</strong>، می‌توانید به کاهش اتکای خود به تست‌های <strong>end-to-end</strong> تا حدی که دیگر مورد نیاز نباشند، شروع کنید. رها کردن تست‌های <strong>end-to-end</strong> بدون درک کامل آنچه از دست داده‌اید، احتمالاً ایده بدی است.
    </p>
<p>
        بدیهی است که شما درک بهتری از مشخصات ریسک سازمان خود نسبت به من خواهید داشت، اما من شما را به چالش می‌کشم که در مورد اینکه چقدر به تست <strong>end-to-end</strong> واقعاً نیاز دارید، طولانی و سخت فکر کنید.
    </p>
<h4>Developer Experience</h4>
<p>
        یکی از چالش‌های مهمی که می‌تواند زمانی ظاهر شود که توسعه‌دهندگان نیاز به کار بر روی <strong>microservices</strong> بیشتری پیدا می‌کنند، این است که <strong>developer experience</strong> می‌تواند شروع به رنج بردن کند، به این دلیل ساده که آنها در حال تلاش برای اجرای <strong>microservices</strong> بیشتری به صورت محلی هستند. این اغلب در موقعیت‌هایی رخ می‌دهد که در آن یک توسعه‌دهنده نیاز به اجرای یک تست با <strong>scope</strong> بزرگ دارد که چندین <strong>microservices</strong> غیر <strong>stubbed</strong> را به هم متصل می‌کند.
    </p>
<p>
        سرعت تبدیل این به یک مسئله به تعدادی از عوامل بستگی دارد. چند <strong>microservices</strong> یک توسعه‌دهنده نیاز دارد که به صورت محلی اجرا کند، <strong>technology stack</strong> که این <strong>microservices</strong> در آن نوشته شده‌اند، و قدرت دستگاه محلی، همه می‌توانند نقشی داشته باشند. برخی از <strong>technology stack</strong>ها از نظر ردپای اولیه خود، از نظر منابع فشرده‌تر هستند—<strong>microservices</strong> مبتنی بر <strong>JVM</strong> به ذهن می‌آیند. از طرف دیگر، برخی از <strong>tech stacks</strong>ها می‌توانند منجر به <strong>microservices</strong> با ردپای منبع سریع‌تر و سبک‌تر شوند، شاید به شما اجازه دهند <strong>microservices</strong> بسیار بیشتری را به صورت محلی اجرا کنید.
    </p>
<p>
        یک رویکرد برای مقابله با این چالش این است که به جای آن، توسعه‌دهندگان، توسعه و تست خود را در یک محیط ابری انجام دهند. ایده این است که شما می‌توانید منابع بسیار بیشتری را در اختیار داشته باشید تا <strong>microservices</strong> مورد نیاز خود را اجرا کنید. جدا از این واقعیت که این مدل مستلزم این است که شما همیشه به اتصال به منابع ابری خود دسترسی داشته باشید، مسئله اصلی دیگر این است که چرخه‌های بازخورد شما می‌توانند رنج ببرند. اگر شما نیاز دارید که یک تغییر کد را به صورت محلی ایجاد کنید و نسخه جدید این کد (یا یک <strong>artifact</strong> ساخته شده محلی) را در <strong>cloud</strong> آپلود کنید، می‌تواند تأخیر قابل توجهی را به چرخه‌های توسعه و تست شما اضافه کند، به خصوص اگر شما در بخشی از جهان با اتصال به اینترنت محدودتر فعالیت می‌کنید.
    </p>
<p>
        توسعه کامل در <strong>cloud</strong> یک امکان برای رسیدگی به مسئله چرخه‌های بازخورد است. <strong>IDEs</strong> مبتنی بر <strong>cloud</strong> مانند <strong>Cloud9</strong>، که اکنون متعلق به <strong>AWS</strong> است، نشان داده‌اند که این...
    </p>
<p>
        296 | Chapter 9: Testing
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0322</div>
            </div>
        </div>
        <!-- Page 0323 -->
        <div class="chapter" id="page-0323">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        ممکن. با این حال، در حالی که چیزی شبیه به این ممکن است آینده توسعه باشد، مطمئناً در حال حاضر برای اکثریت قریب به اتفاق ما اینطور نیست.
    </p>
<p>
        اساساً، من فکر می‌کنم که استفاده از محیط‌های <strong>cloud</strong> برای اجازه دادن به یک توسعه‌دهنده برای اجرای <strong>microservices</strong> بیشتر برای چرخه‌های توسعه و تست خود، نادیده گرفتن نکته است و در نتیجه، علاوه بر هزینه‌های بالاتر، پیچیدگی بیشتری نسبت به نیاز ایجاد می‌کند. در حالت ایده‌آل، شما می‌خواهید توسعه‌دهنده‌ای را هدف قرار دهید که فقط نیاز به اجرای <strong>microservices</strong>هایی دارد که واقعاً روی آنها کار می‌کند. اگر یک توسعه‌دهنده بخشی از تیمی است که مالک پنج <strong>microservices</strong> است، پس آن توسعه‌دهنده باید بتواند آن <strong>microservices</strong> را تا حد امکان مؤثر اجرا کند، و برای بازخورد سریع، ترجیح من همیشه این است که آنها را به صورت محلی اجرا کنند.
    </p>
<p>
        اما اگر پنج <strong>microservices</strong> که تیم شما مالک آن است، بخواهند با سیستم‌ها و <strong>microservices</strong>های دیگری که متعلق به تیم‌های دیگر هستند، تماس بگیرند، چه؟ بدون آنها، محیط توسعه و تست محلی کار نخواهد کرد، درست است؟ در اینجا دوباره، <strong>stubbing</strong> وارد عمل می‌شود. من باید بتوانم <strong>stubs</strong>های محلی را راه‌اندازی کنم که از <strong>microservices</strong> که خارج از <strong>scope</strong> تیم من هستند، تقلید می‌کنند. تنها <strong>microservices</strong>های واقعی که باید به صورت محلی اجرا کنید، مواردی هستند که روی آنها کار می‌کنید. اگر شما در سازمانی کار می‌کنید که انتظار می‌رود روی صدها <strong>microservices</strong> مختلف کار کنید، پس، شما مشکلات بسیار بزرگ‌تری برای مقابله دارید—این موضوعی است که ما در "مالکیت قوی در مقابل جمعی" در صفحه 499 با عمق بیشتری به آن خواهیم پرداخت.
    </p>
<h4>From Preproduction to In-Production Testing</h4>
<p>
        از نظر تاریخی، بیشتر تمرکز تست‌ها بر روی تست سیستم‌های ما قبل از ورود به <strong>production</strong> بوده است. با تست‌های خود، ما در حال تعریف مجموعه‌ای از مدل‌ها هستیم که با استفاده از آنها امیدواریم ثابت کنیم که آیا سیستم ما به درستی کار می‌کند و همانطور که می‌خواهیم، هم از نظر عملکردی و هم غیرعملکردی رفتار می‌کند. اما اگر مدل‌های ما کامل نباشند، هنگام استفاده از سیستم‌هایمان با مشکلاتی مواجه خواهیم شد. باگ‌ها وارد <strong>production</strong> می‌شوند، حالت‌های شکست جدید کشف می‌شوند، و کاربران ما از سیستم به روش‌هایی استفاده می‌کنند که ما هرگز نمی‌توانیم انتظار داشته باشیم.
    </p>
<p>
        یک واکنش به این امر اغلب تعریف تست‌های بیشتر و بیشتر، و اصلاح مدل‌های ما است، تا مشکلات بیشتری را زودتر شناسایی کنیم و تعداد مشکلاتی را که در سیستم <strong>production</strong> در حال اجرا با آن مواجه می‌شویم، کاهش دهیم. با این حال، در یک نقطه خاص، ما باید بپذیریم که با این رویکرد به بازدهی کاهشی می‌رسیم. با تست قبل از استقرار، ما نمی‌توانیم احتمال شکست را به صفر کاهش دهیم.
    </p>
<p>
        پیچیدگی یک سیستم توزیع شده به گونه‌ای است که گرفتن تمام مشکلات احتمالی که ممکن است قبل از رسیدن به خود <strong>production</strong> رخ دهد، غیرممکن است.
    </p>
<p>
        به طور کلی، هدف از یک تست این است که به ما بازخوردی در مورد اینکه آیا نرم‌افزار ما از کیفیت کافی برخوردار است یا خیر، ارائه دهد. در حالت ایده‌آل، ما می‌خواهیم آن بازخورد را در اسرع وقت داشته باشیم، و می‌خواهیم بتوانیم متوجه شویم که آیا مشکلی در نرم‌افزار ما وجود دارد یا خیر، قبل از اینکه یک کاربر نهایی آن مشکل را تجربه کند. به همین دلیل است که تست‌های زیادی قبل از انتشار نرم‌افزار ما انجام می‌شود.
    </p>
<p>
        From Preproduction to In-Production Testing | 297
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0323</div>
            </div>
        </div>
        <!-- Page 0324 -->
        <div class="chapter" id="page-0324">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        محدود کردن خودمان به تست فقط در یک محیط قبل از <strong>production</strong>، ما را محدود می‌کند. ما در حال کاهش مکان‌هایی هستیم که می‌توانیم مشکلات را در آنها شناسایی کنیم، و همچنین امکان تست کیفیت نرم‌افزار خود را در مهم‌ترین مکان—جایی که قرار است از آن استفاده شود—از بین می‌بریم.
    </p>
<p>
        ما همچنین می‌توانیم و باید به دنبال اعمال تست در یک محیط <strong>production</strong> باشیم. این کار را می‌توان به شیوه‌ای ایمن انجام داد، می‌تواند بازخورد با کیفیت بالاتری نسبت به تست قبل از <strong>production</strong> ارائه دهد، و، همانطور که می‌بینیم، احتمالاً کاری است که شما در حال حاضر انجام می‌دهید، خواه متوجه شوید یا نه.
    </p>
<h4>Types of In-Production Testing</h4>
<p>
        لیست بلندی از تست‌های مختلف وجود دارد که می‌توانیم در <strong>production</strong> انجام دهیم، از ساده تا پیچیده. برای شروع، بیایید به چیزی به سادگی یک بررسی <strong>ping</strong> فکر کنیم تا مطمئن شویم که یک <strong>microservice</strong> فعال است. به سادگی بررسی اینکه آیا یک نمونه <strong>microservice</strong> در حال اجرا است یا خیر، نوعی تست است—ما فقط آن را به این عنوان نمی‌بینیم، زیرا این فعالیتی است که معمولاً توسط افراد "عملیاتی" انجام می‌شود. اما اساساً، چیزی به سادگی تعیین اینکه آیا یک <strong>microservice</strong> فعال است یا نه، می‌تواند به عنوان یک تست در نظر گرفته شود—تستی که ما اغلب بر روی نرم‌افزار خود اجرا می‌کنیم.
    </p>
<p>
        تست‌های <strong>smoke</strong> نمونه دیگری از تست‌های در <strong>production</strong> هستند. تست <strong>smoke</strong> معمولاً به عنوان بخشی از فعالیت‌های استقرار انجام می‌شود، تست <strong>smoke</strong> تضمین می‌کند که نرم‌افزار مستقر شده به درستی کار می‌کند. این تست‌های <strong>smoke</strong> معمولاً قبل از انتشار نرم‌افزار برای کاربران (بیشتر در این مورد در ادامه) بر روی نرم‌افزار در حال اجرا واقعی انجام می‌شوند.
    </p>
<p>
<strong>Canary releases</strong>، که در فصل 8 پوشش دادیم، همچنین یک مکانیسم است که می‌توان گفت در مورد تست است. ما یک نسخه جدید از نرم‌افزار خود را برای بخش کوچکی از کاربران منتشر می‌کنیم تا "تست" کنیم که آیا به درستی کار می‌کند. اگر اینطور است، می‌توانیم نرم‌افزار را به بخش بزرگتری از کاربران خود، شاید به روشی کاملاً خودکار، منتقل کنیم.
    </p>
<p>
        مثال دیگری از تست در <strong>production</strong>، تزریق رفتار کاربر جعلی به سیستم است تا مطمئن شویم که همانطور که انتظار می‌رود کار می‌کند—به عنوان مثال، ثبت سفارش برای یک مشتری جعلی، یا ثبت نام یک کاربر جدید (جعلی) در سیستم <strong>production</strong> واقعی. این نوع تست گاهی اوقات می‌تواند با مخالفت مواجه شود، زیرا مردم نگران تأثیری هستند که ممکن است بر سیستم <strong>production</strong> داشته باشد. بنابراین اگر تست‌هایی مانند این ایجاد می‌کنید، مطمئن شوید که آنها را ایمن می‌کنید.
    </p>
<h4>Making Testing in Production Safe</h4>
<p>
        اگر تصمیم دارید در <strong>production</strong> تست انجام دهید (و باید انجام دهید!)، مهم است که تست‌ها باعث ایجاد مشکلات <strong>production</strong> نشوند، چه با ایجاد بی‌ثباتی سیستم یا با آلوده کردن داده‌های <strong>production</strong>. چیزی به سادگی <strong>ping</strong> کردن یک نمونه <strong>microservice</strong> برای اطمینان از فعال بودن آن، احتمالاً یک عملیات ایمن است—اگر این باعث بی‌ثباتی سیستم شود، احتمالاً با مشکلات جدی روبه‌رو هستید که باید به آنها رسیدگی شود، مگر اینکه شما به‌طور تصادفی سیستم بررسی سلامت خود را به یک حمله <strong>denial of service</strong> داخلی تبدیل کرده باشید.
    </p>
<p>
        298 | Chapter 9: Testing
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0324</div>
            </div>
        </div>
        <!-- Page 0325 -->
        <div class="chapter" id="page-0325">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        تست‌های <strong>smoke</strong> معمولاً ایمن هستند، زیرا عملیاتی که انجام می‌دهند اغلب بر روی نرم‌افزار قبل از انتشار آن انجام می‌شود. همانطور که در "جدا کردن استقرار از انتشار" در صفحه 270 بررسی کردیم، جدا کردن مفهوم استقرار از انتشار می‌تواند فوق‌العاده مفید باشد. وقتی صحبت از تست در <strong>production</strong> می‌شود، تست‌هایی که بر روی نرم‌افزاری که در <strong>production</strong> مستقر شده است، قبل از انتشار آن انجام می‌شود، باید ایمن باشند.
    </p>
<p>
        مردم تمایل دارند که بیشتر نگران ایمنی چیزهایی مانند تزریق رفتار کاربر جعلی به سیستم باشند. ما واقعاً نمی‌خواهیم سفارش ارسال شود یا پرداخت انجام شود. این چیزی است که نیاز به مراقبت و توجه دارد، و علیرغم چالش‌ها، این نوع تست می‌تواند بسیار مفید باشد. ما در "نظارت معنایی" در صفحه 333 به این موضوع باز خواهیم گشت.
    </p>
<h4>Mean Time to Repair over Mean Time Between Failures?</h4>
<p>
        بنابراین با نگاهی به تکنیک‌هایی مانند <strong>blue-green deployment</strong> یا <strong>canary releasing</strong>، ما راهی برای تست نزدیک‌تر به (یا حتی در) <strong>production</strong> پیدا می‌کنیم، و همچنین ابزارهایی را برای کمک به مدیریت یک شکست در صورت وقوع ایجاد می‌کنیم. استفاده از این رویکردها، اذعان ضمنی به این است که ما نمی‌توانیم همه مشکلات را قبل از اینکه نرم‌افزار خود را واقعاً منتشر کنیم، شناسایی و برطرف کنیم.
    </p>
<p>
        گاهی اوقات صرف تلاش یکسان برای بهتر شدن در رفع مشکلات در هنگام وقوع، می‌تواند به طور قابل توجهی مفیدتر از افزودن تست‌های <strong>functional</strong> خودکار بیشتر باشد. در دنیای عملیات وب، این اغلب به عنوان <strong>trade-off</strong> بین بهینه‌سازی برای میانگین زمان بین شکست‌ها (<strong>MTBF</strong>) و بهینه‌سازی برای میانگین زمان تعمیر (<strong>MTTR</strong>) نامیده می‌شود.
    </p>
<p>
        تکنیک‌هایی برای کاهش زمان بازیابی می‌تواند به سادگی بازگشت‌های بسیار سریع همراه با نظارت خوب باشد (که ما در فصل 10 در مورد آن بحث خواهیم کرد). اگر بتوانیم یک مشکل را در <strong>production</strong> زود شناسایی کنیم و زودتر <strong>roll back</strong> کنیم، تأثیر آن بر مشتریان خود را کاهش می‌دهیم.
    </p>
<p>
        برای سازمان‌های مختلف، <strong>trade-off</strong> بین <strong>MTBF</strong> و <strong>MTTR</strong> متفاوت خواهد بود، و بخش زیادی از این موضوع به درک تأثیر واقعی شکست در یک محیط <strong>production</strong> بستگی دارد. با این حال، اکثر سازمان‌هایی که من می‌بینم وقت خود را صرف ایجاد <strong>test suites functional</strong> می‌کنند، اغلب تلاش کمی برای نظارت بهتر یا بازیابی از شکست انجام می‌دهند. بنابراین در حالی که آنها ممکن است تعداد نقص‌هایی را که در وهله اول رخ می‌دهند کاهش دهند، نمی‌توانند همه آنها را از بین ببرند، و برای مقابله با آنها در صورت ظاهر شدن در <strong>production</strong> آماده نیستند.
    </p>
<p>
<strong>Trade-offs</strong> دیگری غیر از آنهایی که بین <strong>MTBF</strong> و <strong>MTTR</strong> وجود دارد. به عنوان مثال، چه بخواهید بفهمید که آیا کسی واقعاً از نرم‌افزار شما استفاده می‌کند یا خیر، ممکن است منطقی‌تر باشد که در حال حاضر چیزی را منتشر کنید، تا قبل از ساخت نرم‌افزار قوی، ایده یا مدل کسب‌وکار را اثبات کنید. در محیطی که اینطور است، تست ممکن است بیش از حد باشد، زیرا تأثیر ندانستن اینکه آیا ایده شما کار می‌کند یا خیر، بسیار بیشتر از داشتن یک نقص در <strong>production</strong> است. در این شرایط، اجتناب از تست قبل از <strong>production</strong> به طور کلی می‌تواند کاملاً منطقی باشد.
    </p>
<p>
        From Preproduction to In-Production Testing | 299
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0325</div>
            </div>
        </div>
        <!-- Page 0326 -->
        <div class="chapter" id="page-0326">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Cross-Functional Testing</h4>
<p>
        بخش عمده این فصل بر روی تست قطعات خاصی از <strong>functionality</strong> متمرکز شده است، و اینکه این موضوع در هنگام تست یک سیستم مبتنی بر <strong>microservice</strong> چگونه متفاوت است. با این حال، یک دسته دیگر از تست وجود دارد که مهم است در مورد آن بحث شود. الزامات غیر <strong>functional</strong> یک اصطلاح کلی است که برای توصیف آن ویژگی‌هایی استفاده می‌شود که سیستم شما نشان می‌دهد و نمی‌توان آنها را به سادگی مانند یک ویژگی معمولی پیاده‌سازی کرد. آنها شامل جنبه‌هایی مانند تأخیر قابل قبول یک صفحه وب، تعداد کاربرانی که یک سیستم باید پشتیبانی کند، میزان دسترسی رابط کاربری شما برای افراد دارای معلولیت، یا میزان امنیت داده‌های مشتری شما می‌شوند.
    </p>
<p>
        اصطلاح غیر <strong>functional</strong> هرگز با من سازگار نبود. برخی از مواردی که توسط این اصطلاح پوشش داده می‌شوند، در ماهیت خود بسیار <strong>functional</strong> به نظر می‌رسند! یکی از همکاران قبلی من، <strong>Sarah Taraporewalla</strong>، عبارت الزامات <strong>cross-functional (CFR)</strong> را ابداع کرد، که من بسیار ترجیح می‌دهم. این بیشتر به این واقعیت اشاره دارد که این رفتارهای سیستم واقعاً فقط در نتیجه کارهای <strong>cross-cutting</strong> زیادی ظاهر می‌شوند.
    </p>
<p>
        بسیاری اگر نه اکثر <strong>CFRs</strong>ها واقعاً فقط می‌توانند در <strong>production</strong> برآورده شوند. با این حال، ما می‌توانیم استراتژی‌های تستی را تعریف کنیم تا به ما کمک کند ببینیم آیا ما حداقل به سمت تحقق این اهداف حرکت می‌کنیم یا خیر. این نوع تست‌ها در مربع تست ویژگی قرار می‌گیرند. یک مثال عالی از این نوع تست، تست عملکرد است، که ما در ادامه با جزئیات بیشتری در مورد آن بحث خواهیم کرد.
    </p>
<p>
        شما ممکن است بخواهید برخی از <strong>CFRs</strong>ها را در سطح <strong>microservice</strong> فردی پیگیری کنید. به عنوان مثال، ممکن است تصمیم بگیرید که دوام سرویسی که از <strong>service</strong> پرداخت خود می‌خواهید، به طور قابل توجهی بالاتر است، اما شما از زمان خرابی بیشتر برای <strong>service</strong> توصیه‌های موسیقی خود خوشحال هستید، با دانستن اینکه کسب‌وکار اصلی شما می‌تواند زنده بماند اگر نتوانید هنرمندانی مشابه <strong>Metallica</strong> را به مدت 10 دقیقه یا بیشتر توصیه کنید. این <strong>trade-offs</strong>ها در نهایت تأثیر زیادی بر نحوه طراحی و تکامل سیستم شما خواهند داشت، و یک بار دیگر ماهیت ریزدانه یک سیستم مبتنی بر <strong>microservice</strong> به شما فرصت‌های بیشتری برای انجام این <strong>trade-offs</strong> می‌دهد. هنگام نگاه کردن به <strong>CFRs</strong>ها که یک <strong>microservice</strong> یا تیم معین ممکن است مسئولیت آن را بر عهده داشته باشد، معمولاً آنها به عنوان بخشی از اهداف سطح <strong>service</strong> تیم (<strong>SLOs</strong>)، موضوعی که ما بیشتر در "آیا ما خوب هستیم؟" در صفحه 327 بررسی می‌کنیم، ظاهر می‌شوند.
    </p>
<p>
        تست‌ها در اطراف <strong>CFRs</strong> باید از <strong>pyramid</strong> نیز پیروی کنند. برخی از تست‌ها باید <strong>end-to-end</strong> باشند، مانند تست‌های بار، اما بقیه اینطور نیستند. به عنوان مثال، هنگامی که یک گلوگاه عملکردی را در یک تست بار <strong>end-to-end</strong> پیدا کردید، یک تست با <strong>scope</strong> کوچکتر بنویسید تا به شما در شناسایی مشکل در آینده کمک کند. سایر <strong>CFRs</strong>ها به راحتی با تست‌های سریع‌تر مطابقت دارند. من به یاد دارم که روی پروژه‌ای کار می‌کردم که در آن ما اصرار داشتیم که اطمینان حاصل کنیم که نشانه‌گذاری <strong>HTML</strong> ما از ویژگی‌های دسترسی مناسب برای کمک به افراد دارای معلولیت برای استفاده از وب‌سایت ما استفاده می‌کند. بررسی نشانه‌گذاری تولید شده برای اطمینان از وجود کنترل‌های مناسب، می‌تواند بسیار سریع، بدون نیاز به هیچ گونه <strong>networking round trips</strong> انجام شود.
    </p>
<p>
        بسیار زیاد، ملاحظات در مورد <strong>CFRs</strong> خیلی دیر مطرح می‌شود. من قویاً پیشنهاد می‌کنم <strong>CFRs</strong>های خود را در اسرع وقت بررسی کنید و مرتباً آنها را مرور کنید.
    </p>
<p>
        300 | Chapter 9: Testing
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0326</div>
            </div>
        </div>
        <!-- Page 0327 -->
        <div class="chapter" id="page-0327">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Performance Tests</h4>
<p>
        تست‌های عملکرد ارزش این را دارند که صریحاً به عنوان راهی برای اطمینان از برآورده شدن برخی از الزامات <strong>cross-functional</strong> ما ذکر شوند. هنگام تجزیه سیستم‌ها به <strong>microservices</strong>های کوچکتر، ما تعداد تماس‌هایی را که در سراسر مرزهای شبکه انجام می‌شود، افزایش می‌دهیم. جایی که قبلاً یک عملیات ممکن است شامل یک تماس پایگاه داده بوده باشد، اکنون ممکن است شامل سه یا چهار تماس در سراسر مرزهای شبکه با <strong>services</strong>های دیگر باشد، با تعداد تماس‌های پایگاه داده منطبق. همه اینها می‌تواند سرعت عملکرد سیستم‌های ما را کاهش دهد. پیگیری منابع <strong>latency</strong> به ویژه مهم است.
    </p>
<p>
        وقتی شما یک زنجیره تماس از چندین تماس همزمان دارید، اگر هر بخشی از زنجیره شروع به عمل کند، همه چیز تحت تأثیر قرار می‌گیرد، که به طور بالقوه منجر به یک تأثیر قابل توجه می‌شود.
    </p>
<p>
        این باعث می‌شود که داشتن راهی برای تست عملکرد برنامه‌هایتان حتی مهم‌تر از زمانی باشد که با یک سیستم <strong>monolithic</strong> بیشتر سروکار دارید. اغلب دلیل اینکه این نوع تست به تأخیر می‌افتد این است که در ابتدا سیستم به اندازه کافی برای تست وجود ندارد. من این مشکل را درک می‌کنم، اما این اغلب منجر به به تعویق انداختن کار می‌شود، و تست عملکرد اغلب فقط درست قبل از رفتن به حالت <strong>live</strong> برای اولین بار انجام می‌شود، اگر اصلاً انجام شود! در این تله نیفتید.
    </p>
<p>
        مانند تست‌های <strong>functional</strong>، شما ممکن است یک ترکیب را بخواهید. شما ممکن است تصمیم بگیرید که تست‌های عملکردی می‌خواهید که <strong>services</strong>های جداگانه را ایزوله کند، اما با تست‌هایی شروع کنید که سفرهای اصلی را در سیستم شما بررسی می‌کنند. شما ممکن است بتوانید تست‌های سفر <strong>end-to-end</strong> را انجام دهید و به سادگی آنها را با حجم اجرا کنید.
    </p>
<p>
        برای تولید نتایج ارزشمند، شما اغلب باید سناریوهای داده شده را با تعداد فزاینده‌ای از مشتریان شبیه‌سازی شده اجرا کنید. این به شما اجازه می‌دهد تا ببینید چگونه <strong>latency</strong> تماس‌ها با افزایش <strong>load</strong> متفاوت است. این بدان معناست که تست‌های عملکرد می‌توانند مدتی طول بکشند تا اجرا شوند. علاوه بر این، شما می‌خواهید سیستم تا حد امکان با <strong>production</strong> مطابقت داشته باشد، تا اطمینان حاصل شود که نتایجی که مشاهده می‌کنید نشان‌دهنده عملکردی است که می‌توانید در سیستم‌های <strong>production</strong> انتظار داشته باشید. این می‌تواند به این معنی باشد که شما باید حجم بیشتری از داده‌ها شبیه به <strong>production</strong> را جمع‌آوری کنید و ممکن است به ماشین‌های بیشتری برای مطابقت با زیرساخت‌ها نیاز داشته باشید—وظایفی که می‌توانند چالش‌برانگیز باشند. حتی اگر برای تبدیل محیط عملکرد به تولید واقعی تلاش می‌کنید، تست‌ها ممکن است همچنان در پیگیری گلوگاه‌ها ارزش داشته باشند. فقط آگاه باشید که ممکن است <strong>false negatives</strong>—یا، حتی بدتر، <strong>false positives</strong>—داشته باشید.
    </p>
<p>
        با توجه به زمانی که برای اجرای تست‌های عملکرد طول می‌کشد، همیشه اجرای آنها در هر <strong>check-in</strong> امکان‌پذیر نیست. این یک روش رایج است که یک زیرمجموعه را هر روز و یک مجموعه بزرگ‌تر را هر هفته اجرا کنید. هر رویکردی که انتخاب می‌کنید، اطمینان حاصل کنید که تست‌ها را تا حد امکان منظم اجرا می‌کنید. هر چه مدت بیشتری بدون اجرای تست‌های عملکرد سپری کنید، ردیابی مقصر سخت‌تر می‌شود. مشکلات عملکرد به ویژه دشوار هستند، بنابراین اگر بتوانید تعداد <strong>commits</strong>هایی را که باید بررسی کنید تا یک مشکل تازه معرفی شده را ببینید، کاهش دهید، زندگی شما بسیار آسان‌تر خواهد شد.
    </p>
<p>
        و مطمئن شوید که به نتایج نیز نگاه می‌کنید! من از تعداد تیم‌هایی که با آنها روبرو شده‌ام و کارهای زیادی را برای پیاده‌سازی تست‌ها انجام داده‌اند و...
    </p>
<p>
        Cross-Functional Testing | 301
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0327</div>
            </div>
        </div>
        <!-- Page 0328 -->
        <div class="chapter" id="page-0328">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        اجرای آنها را، اما هرگز اعداد را بررسی نمی‌کنند. اغلب این به این دلیل است که مردم نمی‌دانند نتیجه "خوب" چه شکلی است. شما واقعاً نیاز به داشتن اهداف دارید. هنگامی که شما یک <strong>microservice</strong> را ارائه می‌دهید تا به عنوان بخشی از یک معماری گسترده‌تر استفاده شود، داشتن انتظارات خاصی که متعهد به ارائه آنها هستید—<strong>SLOs</strong> که قبلاً ذکر کردم—رایج است.
    </p>
<p>
        اگر به عنوان بخشی از این کار متعهد به ارائه سطح خاصی از عملکرد هستید، پس منطقی است که هر تست خودکاری به شما بازخورد دهد که آیا شما به احتمال زیاد به آن هدف می‌رسید (و امیدوارم از آن فراتر بروید) یا خیر.
    </p>
<p>
        به جای اهداف عملکردی خاص، تست‌های عملکرد خودکار هنوز هم می‌توانند در کمک به شما در دیدن اینکه چگونه عملکرد <strong>microservice</strong> شما با ایجاد تغییرات متفاوت است، بسیار مفید باشند. می‌تواند یک شبکه ایمنی برای شما باشد تا در صورت ایجاد تغییری که باعث تخریب چشمگیر عملکرد می‌شود، شما را بگیرد. بنابراین جایگزینی برای یک هدف خاص ممکن است این باشد که اگر <strong>delta</strong> در عملکرد از یک <strong>build</strong> به <strong>build</strong> بعدی بیش از حد متفاوت باشد، تست با شکست مواجه شود.
    </p>
<p>
        تست عملکرد باید در هماهنگی با درک عملکرد سیستم واقعی (که ما در فصل 10 بیشتر در مورد آن بحث خواهیم کرد) انجام شود، و در حالت ایده‌آل شما باید از همان ابزارها در محیط تست عملکرد خود برای تجسم رفتار سیستم استفاده کنید، همانند ابزارهایی که در <strong>production</strong> استفاده می‌کنید. این رویکرد می‌تواند مقایسه مشابه با مشابه را بسیار آسان‌تر کند.
    </p>
<h4>Robustness Tests</h4>
<p>
        یک معماری <strong>microservice</strong> اغلب فقط به اندازه ضعیف‌ترین حلقه خود قابل اعتماد است، و در نتیجه، این برای <strong>microservices</strong> ما رایج است که مکانیسم‌هایی را در خود ایجاد کنیم تا به آنها اجازه دهیم قابلیت اطمینان خود را برای بهبود قابلیت اطمینان سیستم بهبود بخشند. ما این موضوع را بیشتر در "الگوهای پایداری" در صفحه 395 بررسی خواهیم کرد، اما نمونه‌ها شامل اجرای چندین نمونه از یک <strong>microservice</strong> در پشت یک <strong>load balancer</strong> برای تحمل خرابی یک نمونه، یا استفاده از <strong>circuit breakers</strong> برای مدیریت برنامه‌ریزی شده موقعیت‌هایی است که در آن <strong>microservices downstream</strong> نمی‌توانند تماس بگیرند.
    </p>
<p>
        در چنین شرایطی، داشتن تست‌هایی که به شما امکان می‌دهد تا شکست‌های خاصی را دوباره ایجاد کنید تا اطمینان حاصل شود که <strong>microservice</strong> شما به عنوان یک کل به عملکرد خود ادامه می‌دهد، می‌تواند مفید باشد. به طور طبیعی، پیاده‌سازی این تست‌ها می‌تواند کمی دشوارتر باشد. به عنوان مثال، ممکن است لازم باشد یک <strong>time-out</strong> شبکه مصنوعی بین یک <strong>microservice</strong> تحت تست و یک <strong>stub</strong> خارجی ایجاد کنید. با این حال، آنها می‌توانند ارزشمند باشند، به خصوص اگر شما در حال ایجاد <strong>functionality</strong> مشترکی هستید که در چندین <strong>microservices</strong> استفاده خواهد شد—به عنوان مثال، استفاده از یک پیاده‌سازی <strong>service mesh</strong> پیش‌فرض برای مدیریت <strong>circuit breaking</strong>.
    </p>
<p>
        302 | Chapter 9: Testing
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0328</div>
            </div>
        </div>
        <!-- Page 0329 -->
        <div class="chapter" id="page-0329">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        9 Ham Vocke, “The Practical Test Pyramid,” martinfowler.com, February 26, 2018, https://oreil.ly/J7lc6.
    </p>
<h4>Summary</h4>
<p>
        با کنار هم قرار دادن همه این موارد، آنچه که من در این فصل مشخص کرده‌ام، یک رویکرد جامع برای تست است که امیدوارم به شما راهنمایی کلی در مورد نحوه ادامه کار هنگام تست سیستم‌های خودتان ارائه دهد. برای تکرار اصول اولیه:
    </p>
<ul>
<li>برای بازخورد سریع، بهینه‌سازی کنید و انواع تست‌ها را بر این اساس از هم جدا کنید.</li>
<li>از نیاز به تست‌های <strong>end-to-end</strong> که بیش از یک تیم را در بر می‌گیرند، اجتناب کنید—در عوض، قراردادهای <strong>consumer-driven</strong> را در نظر بگیرید.</li>
<li>از قراردادهای <strong>consumer-driven</strong> برای ارائه نقاط تمرکز برای مکالمات بین تیم‌ها استفاده کنید.</li>
<li>سعی کنید <strong>trade-off</strong> بین صرف تلاش بیشتر برای تست و شناسایی سریع‌تر مشکلات در <strong>production</strong> را درک کنید (بهینه‌سازی برای <strong>MTBF</strong> در مقابل بهینه‌سازی برای <strong>MTTR</strong>).</li>
<li>تست در <strong>production</strong> را امتحان کنید!</li>
</ul>
<p>
        اگر علاقه‌مند به مطالعه بیشتر در مورد تست هستید، من <em>Agile Testing</em> نوشته <strong>Lisa Crispin</strong> و <strong>Janet Gregory</strong> (Addison-Wesley) را توصیه می‌کنم، که در میان چیزهای دیگر، استفاده از <strong>testing quadrant</strong> را با جزئیات بیشتری پوشش می‌دهد. برای بررسی عمیق‌تر <strong>test pyramid</strong>، همراه با برخی از نمونه‌های کد و ارجاعات ابزارهای بیشتر، من همچنین "<strong>The Practical Test Pyramid</strong>" نوشته <strong>Ham Vocke</strong> را توصیه می‌کنم.<sup>9</sup>
</p>
<p>
        این فصل بیشتر بر روی اطمینان از عملکرد کد ما قبل از ورود به <strong>production</strong> متمرکز بود، اما ما همچنین شروع به بررسی تست برنامه خود پس از رسیدن به <strong>production</strong> کردیم. این چیزی است که ما باید با جزئیات بیشتری به آن بپردازیم. معلوم می‌شود که <strong>microservices</strong> باعث ایجاد تعداد زیادی چالش برای درک نحوه رفتار نرم‌افزار ما در <strong>production</strong> می‌شود—موضوعی که ما در ادامه با جزئیات بیشتری به آن خواهیم پرداخت.
    </p>
<p>
        Summary | 303
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0329</div>
            </div>
        </div>
        <!-- Page 0331 -->
        <div class="chapter" id="page-0331">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>CHAPTER 10</h3>
<h4>From Monitoring to Observability</h4>
<p>
        همانطور که تاکنون نشان داده‌ام، امیدوارم، تقسیم سیستم ما به <strong>microservices</strong>های کوچکتر و با <strong>fine-grained</strong> منجر به مزایای متعددی می‌شود. همچنین، همانطور که ما نیز با جزئیات پوشش داده‌ایم، منابع قابل توجهی از پیچیدگی‌های جدید را اضافه می‌کند. در هیچ موقعیتی این پیچیدگی افزایش‌یافته بیشتر از درک رفتار سیستم‌های ما در یک محیط <strong>production</strong> مشهود نیست. در مراحل اولیه، متوجه خواهید شد که ابزارها و تکنیک‌هایی که برای برنامه‌های <strong>monolithic</strong> تک‌فرآیندی نسبتاً ساده‌تر خوب عمل می‌کردند، برای معماری <strong>microservice</strong> شما به خوبی کار نمی‌کنند.
    </p>
<p>
        در این فصل، ما به چالش‌های مرتبط با نظارت بر معماری <strong>microservice</strong> خود نگاهی خواهیم انداخت، و من نشان خواهم داد که اگرچه ابزارهای جدید می‌توانند کمک کنند، اما شما اساساً ممکن است نیاز داشته باشید که کل ذهنیت خود را در مورد اینکه چه اتفاقی در <strong>production</strong> می‌افتد، تغییر دهید. ما همچنین در مورد تمرکز فزاینده بر مفهوم <strong>observability</strong>—درک چگونگی امکان پرسیدن سؤال از سیستم خود صحبت خواهیم کرد، تا بتوانیم بفهمیم چه چیزی اشتباه پیش می‌رود.
    </p>
<h4>Production Pain</h4>
<p>
        شما واقعاً قدر درد بالقوه، رنج و عذاب ناشی از معماری <strong>microservice</strong> را تا زمانی که آن را در <strong>production</strong> اجرا نکرده‌اید و ترافیک واقعی را سرویس نمی‌دهد، درک نخواهید کرد.
    </p>
<h4>Disruption, Panic, and Confusion</h4>
<p>
        این صحنه را تصور کنید: بعدازظهر یک جمعه آرام است، و تیم مشتاق است که زودتر از کار بیرون برود و به سمت کافه برود تا آخر هفته را دور از کار شروع کند. سپس ناگهان ایمیل‌ها می‌رسند. وب‌سایت بد عمل می‌کند! <strong>Twitter</strong> با شکست‌های شرکت شما شعله‌ور است، رئیس شما دارد گوش شما را می‌جود، و چشم‌انداز یک آخر هفته آرام ناپدید می‌شود.
    </p>
<p>
        305
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 331" src="page_0331/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0331</div>
            </div>
        </div>
        <!-- Page 0332 -->
        <div class="chapter" id="page-0332">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        1 Honestly Black Lives Matter (@honest_update), October 7, 2015, 7:10 p.m., https://oreil.ly/Z28BA.
        2 Fire as a cause of system outage isn’t a totally far-fetched idea. I once helped in the aftermath of a production outage caused by a storage area network (SAN) catching fire. That it took several days for us to be told a fire had occurred is a story for another day.
    </p>
<p>
        چند چیز مشکل را به خوبی این توییت خلاصه می‌کند:
    </p>
<p>
        ما <strong>monolith</strong> خود را با <strong>micro services</strong> جایگزین کردیم تا هر <strong>outage</strong> بیشتر شبیه یک رمز و راز قتل باشد.<sup>1</sup>
</p>
<p>
        ردیابی اینکه چه چیزی اشتباه شده است، و چه چیزی باعث آن شده است، اولین قدم ما است. اما اگر لیست طولانی از مظنونین داشته باشیم، این کار دشوار می‌شود.
    </p>
<p>
        در دنیای برنامه <strong>monolithic</strong> تک‌فرآیندی، ما حداقل یک نقطه بسیار آشکار برای شروع تحقیقات خود داریم. وب‌سایت کند است؟ این <strong>monolith</strong> است. وب‌سایت خطاهای عجیبی می‌دهد؟ این <strong>monolith</strong> است. <strong>CPU</strong> در 100%؟ <strong>Monolith</strong>. بوی سوختگی؟ خب، منظور را متوجه می‌شوید.<sup>2</sup> داشتن یک نقطه شکست واحد، تحقیقات در مورد شکست را تا حدودی ساده‌تر می‌کند!
    </p>
<p>
        اکنون بیایید به سیستم مبتنی بر <strong>microservice</strong> خود فکر کنیم. قابلیت‌هایی که ما به کاربران خود ارائه می‌دهیم، از چندین <strong>microservices</strong> ارائه می‌شود، که برخی از آنها برای انجام وظایف خود با <strong>microservices</strong>های بیشتری ارتباط برقرار می‌کنند. مزایای زیادی برای چنین رویکردی وجود دارد (که خوب است، در غیر این صورت این کتاب اتلاف وقت خواهد بود)، اما در دنیای نظارت، ما یک مشکل پیچیده‌تر در دست داریم.
    </p>
<p>
        اکنون ما چندین سرور برای نظارت داریم، چندین فایل <strong>log</strong> برای بررسی، و چندین مکان که <strong>network latency</strong> می‌تواند باعث ایجاد مشکل شود. سطح شکست ما افزایش یافته است، و همچنین چیزهایی که باید بررسی شوند. پس چگونه به این موضوع نزدیک می‌شویم؟ ما باید آنچه را که در غیر این صورت ممکن است یک آشفتگی آشفته و درهم باشد، درک کنیم—آخرین چیزی که هیچ یک از ما می‌خواهد در بعدازظهر جمعه (یا در هر زمانی) با آن سروکار داشته باشد!
    </p>
<p>
        اولاً، ما باید موارد کوچک را نظارت کنیم و تجمیع را ارائه دهیم تا بتوانیم تصویر بزرگ‌تری را ببینیم. سپس، ما باید اطمینان حاصل کنیم که ابزارهایی را برای برش و تقسیم این داده‌ها به عنوان بخشی از تحقیقات خود در اختیار داریم. در نهایت، ما باید با پذیرش مفاهیمی مانند تست در <strong>production</strong>، در مورد نحوه تفکر در مورد سلامت سیستم هوشمندتر شویم. ما در این فصل در مورد هر یک از این ضرورت‌ها بحث خواهیم کرد. بیایید شروع کنیم.
    </p>
<h4>Single Microservice, Single Server</h4>
<p>
        شکل 10-1 یک راه‌اندازی بسیار ساده را ارائه می‌دهد: یک میزبان که یک نمونه از یک <strong>microservice</strong> را اجرا می‌کند. اکنون ما باید آن را نظارت کنیم تا بدانیم چه زمانی مشکلی پیش می‌آید، تا بتوانیم آن را برطرف کنیم. پس باید به دنبال چه چیزی باشیم؟
    </p>
<p>
        306 | Chapter 10: From Monitoring to Observability
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0332</div>
            </div>
        </div>
        <!-- Page 0333 -->
        <div class="chapter" id="page-0333">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<figure>
<img alt="A single microservice instance on a single host" src="https://www.plantuml.com/plantuml/png/VP11QiCm38JpUeT9uJ5H9x8S6U0Oq_f0000"/>
<figcaption>شکل 10-1. یک نمونه <strong>microservice</strong> واحد روی یک میزبان واحد</figcaption>
</figure>
<p>
        ابتدا، ما می‌خواهیم اطلاعاتی را از خود میزبان دریافت کنیم. <strong>CPU</strong>، حافظه—همه این موارد می‌توانند مفید باشند. در مرحله بعد، ما می‌خواهیم به <strong>logs</strong> از خود نمونه <strong>microservice</strong> دسترسی داشته باشیم. اگر یک کاربر خطایی را گزارش دهد، ما باید بتوانیم خطا را در این <strong>logs</strong> مشاهده کنیم، که امیدواریم راهی برای فهمیدن اینکه چه اشتباهی رخ داده است به ما بدهد. در این مرحله، با یک میزبان واحد خود، احتمالاً می‌توانیم با <strong>logging</strong> محلی به میزبان و استفاده از ابزارهای خط فرمان برای نگاه کردن به <strong>log</strong>، کارمان را پیش ببریم.
    </p>
<p>
        در نهایت، ما ممکن است بخواهیم خود برنامه را نظارت کنیم—مشاهده آن از بیرون. حداقل، نظارت بر زمان پاسخگویی <strong>microservice</strong> یک ایده خوب است. اگر شما یک <strong>web server</strong> در جلوی نمونه <strong>microservice</strong> خود دارید، شاید بتوانید فقط به <strong>logs</strong> <strong>web server</strong> نگاه کنید. یا شاید شما بتوانید کمی پیشرفته‌تر شوید، با استفاده از چیزی مانند یک <strong>health check endpoint</strong> برای دیدن اینکه آیا <strong>microservice</strong> فعال و "سالم" است (ما بعداً به این معنی خواهیم پرداخت).
    </p>
<p>
        زمان می‌گذرد، <strong>loads</strong> افزایش می‌یابد، و ما متوجه می‌شویم که نیاز به مقیاس داریم…
    </p>
<h4>Single Microservice, Multiple Servers</h4>
<p>
        اکنون ما چندین نسخه از <strong>service</strong> را که روی میزبان‌های جداگانه اجرا می‌شوند، داریم، همانطور که در شکل 10-2 نشان داده شده است، با درخواست‌هایی به نمونه‌های مختلف که از طریق یک <strong>load balancer</strong> توزیع می‌شوند.
    </p>
<p>
        اکنون اوضاع کمی پیچیده‌تر می‌شود. ما همچنان می‌خواهیم همه چیز را همانطور که قبلاً بود، نظارت کنیم، اما ما باید این کار را به گونه‌ای انجام دهیم که بتوانیم مشکل را ایزوله کنیم. وقتی <strong>CPU</strong> بالا است، آیا این مشکلی است که ما در همه میزبان‌ها می‌بینیم، که به یک مشکل در خود <strong>service</strong> اشاره دارد؟ یا آیا این به یک میزبان واحد محدود می‌شود، که حاکی از آن است که خود میزبان مشکل دارد—شاید یک فرآیند <strong>OS</strong> متقلب؟
    </p>
<p>
        در این مرحله، ما همچنان می‌خواهیم <strong>metrics</strong> سطح میزبان را ردیابی کنیم، و شاید حتی در هنگام عبور از نوعی آستانه، به آنها هشدار دهیم. اما اکنون ما می‌خواهیم آنچه را که در سراسر تمام میزبان‌ها هستند، و همچنین میزبان‌های جداگانه را ببینیم. به عبارت دیگر، ما می‌خواهیم آنها را جمع‌آوری کنیم و همچنان بتوانیم به آنها دسترسی داشته باشیم. بنابراین ما به چیزی نیاز داریم که بتواند همه این <strong>metrics</strong> را از سراسر میزبان‌ها جمع‌آوری کند و به ما اجازه دهد تا آنها را برش و تقسیم کنیم.
    </p>
<p>
        Single Microservice, Multiple Servers | 307
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 333" src="page_0333/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0333</div>
            </div>
        </div>
        <!-- Page 0334 -->
        <div class="chapter" id="page-0334">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<figure>
<img alt="A single service distributed across multiple hosts" src="https://www.plantuml.com/plantuml/png/VP11QiCm38JpUeT9uJ5H9x8S6U0Oq_f0000"/>
<figcaption>شکل 10-2. یک <strong>service</strong> واحد که در چندین میزبان توزیع شده است</figcaption>
</figure>
<p>
        سپس <strong>logs</strong>های ما را داریم. با اجرای <strong>service</strong> ما بر روی بیش از یک سرور، احتمالاً از <strong>logging</strong> در هر جعبه خسته خواهیم شد تا به آن نگاه کنیم. با این حال، با تنها چند میزبان، ما می‌توانیم از ابزارهایی مانند <strong>SSH multiplexers</strong> استفاده کنیم، که به ما امکان می‌دهد دستورات یکسانی را روی چندین میزبان اجرا کنیم. با کمک یک مانیتور بزرگ، و اجرای "خطای <strong>grep</strong>" در <strong>log microservice</strong> ما، می‌توانیم مقصر را پیدا کنیم. منظورم این است که، این عالی نیست، اما می‌تواند برای مدتی خوب باشد. اگرچه خیلی سریع قدیمی می‌شود.
    </p>
<p>
        برای کارهایی مانند ردیابی زمان پاسخگویی، ما می‌توانیم زمان‌های پاسخگویی را در <strong>load balancer</strong> برای تماس‌های <strong>downstream</strong> به <strong>microservices</strong> ثبت کنیم. با این حال، ما همچنین باید در نظر بگیریم که اگر <strong>load balancer</strong> به گلوگاه سیستم ما تبدیل شود، چه اتفاقی می‌افتد—ثبت زمان‌های پاسخگویی هم در <strong>load balancer</strong> و هم در خود <strong>microservices</strong>ها ممکن است مورد نیاز باشد. در این مرحله، ما احتمالاً بیشتر به این اهمیت می‌دهیم که یک <strong>service</strong> سالم چه شکلی است، زیرا ما <strong>load balancer</strong> خود را طوری پیکربندی می‌کنیم که گره‌های ناسالم را از برنامه ما حذف کند. امیدواریم تا زمانی که به اینجا برسیم، حداقل ایده‌ای از آنچه سالم به نظر می‌رسد، داشته باشیم.
    </p>
<h4>Multiple Services, Multiple Servers</h4>
<p>
        در شکل 10-3، اوضاع بسیار جالب‌تر می‌شود. چندین <strong>service</strong> در حال همکاری برای ارائه قابلیت‌ها به کاربران ما هستند، و آن <strong>services</strong>ها بر روی چندین میزبان در حال اجرا هستند، چه فیزیکی و چه مجازی. چگونه می‌توانید خطایی را که به دنبال آن هستید در هزاران خط از <strong>logs</strong> در چندین میزبان پیدا کنید؟ چگونه تعیین می‌کنید که آیا یک سرور رفتار نادرستی دارد، یا اینکه این یک مشکل سیستمی است؟ و چگونه یک خطا را که در اعماق یک زنجیره تماس بین چندین میزبان یافت می‌شود، ردیابی می‌کنید و متوجه می‌شوید که چه چیزی باعث آن شده است؟
    </p>
<p>
        308 | Chapter 10: From Monitoring to Observability
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 334" src="page_0334/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0334</div>
            </div>
        </div>
        <!-- Page 0335 -->
        <div class="chapter" id="page-0335">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<figure>
<img alt="Multiple collaborating services distributed across multiple hosts" src="https://www.plantuml.com/plantuml/png/VP11QiCm38JpUeT9uJ5H9x8S6U0Oq_f0000"/>
<figcaption>شکل 10-3. چندین <strong>service</strong> در حال همکاری که در چندین میزبان توزیع شده‌اند</figcaption>
</figure>
<p>
        تجمیع اطلاعات—<strong>metrics</strong> و <strong>logs</strong>—نقش حیاتی در تحقق این امر دارد. اما این تنها چیزی نیست که ما باید در نظر بگیریم. ما باید راه‌هایی برای بررسی این هجوم عظیم داده‌ها پیدا کنیم و سعی کنیم از همه آنها سر در بیاوریم. بیش از هر چیز، این تا حد زیادی در مورد تغییر ذهنیت است، از یک چشم‌انداز نسبتاً ایستا از نظارت به دنیای فعال‌تر <strong>observability</strong> و تست در <strong>production</strong>.
    </p>
<h4>Observability Versus Monitoring</h4>
<p>
        ما قصد داریم شروع به بررسی چگونگی شروع حل برخی از مشکلاتی که به تازگی مشخص کرده‌ایم، کنیم، اما قبل از انجام این کار، فکر می‌کنم مهم است که اصطلاحی را بررسی کنیم که از زمان نوشتن ویرایش اول این کتاب محبوبیت زیادی پیدا کرده است—<strong>observability</strong>.
    </p>
<p>
        همانطور که اغلب اتفاق می‌افتد، مفهوم <strong>observability</strong> دهه‌ها وجود داشته است، اما اخیراً وارد توسعه نرم‌افزار شده است. <strong>Observability</strong> یک سیستم، میزان درک شما از حالت داخلی سیستم از خروجی‌های خارجی است. این معمولاً به درک جامع‌تری از نرم‌افزار شما نیاز دارد—دیدن آن بیشتر به عنوان یک سیستم تا مجموعه‌ای از موجودیت‌های پراکنده.
    </p>
<p>
        Observability Versus Monitoring | 309
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 335" src="page_0335/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0335</div>
            </div>
        </div>
        <!-- Page 0336 -->
        <div class="chapter" id="page-0336">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        در عمل، هر چه یک سیستم <strong>observable</strong>تر باشد، درک اینکه مشکل چیست، وقتی مشکلی پیش می‌آید، برای ما آسان‌تر خواهد بود. درک ما از خروجی‌های خارجی به ما کمک می‌کند تا مشکل اساسی را سریع‌تر ردیابی کنیم. چالش این است که ما اغلب نیاز به ایجاد این خروجی‌های خارجی خواهیم داشت و از انواع مختلف ابزارها برای درک خروجی‌ها استفاده خواهیم کرد.
    </p>
<p>
        از طرف دیگر، نظارت، چیزی است که ما انجام می‌دهیم. ما سیستم را نظارت می‌کنیم. ما به آن نگاه می‌کنیم. اگر شما فقط بر نظارت—فعالیت—تمرکز کنید، بدون اینکه به آنچه انتظار دارید آن فعالیت به دست آید فکر کنید، اوضاع شروع به اشتباه رفتن می‌کند.
    </p>
<p>
        رویکردهای سنتی‌تر به نظارت، شما را ملزم می‌کنند که از قبل به این فکر کنید که چه چیزی می‌تواند اشتباه پیش برود و مکانیسم‌های هشدار را تعریف کنید تا به شما بگویند چه زمانی این اتفاقات رخ داده است. اما با توزیع فزاینده سیستم، با مشکلاتی مواجه خواهید شد که هرگز به ذهن شما خطور نکرده است. با یک سیستم بسیار <strong>observable</strong>، شما مجموعه‌ای از خروجی‌های خارجی خواهید داشت که می‌توانید به روش‌های مختلف از آنها بازجویی کنید—نتیجه ملموس داشتن یک سیستم <strong>observable</strong> این است که شما می‌توانید از سیستم <strong>production</strong> خود سؤالاتی را بپرسید که قبلاً هرگز به فکر پرسیدن آنها نبوده‌اید.
    </p>
<p>
        بنابراین ما می‌توانیم نظارت را به عنوان یک فعالیت—چیزی که ما انجام می‌دهیم—با <strong>observability</strong> به عنوان یک ویژگی از سیستم در نظر بگیریم.
    </p>
<h4>The Pillars of Observability? Not So Fast</h4>
<p>
        برخی از مردم تلاش کرده‌اند تا ایده <strong>observability</strong> را به چند مفهوم اصلی تقطیر کنند. برخی بر روی "سه ستون" <strong>observability</strong> در قالب <strong>metrics</strong>، <strong>logging</strong> و <strong>distributed tracing</strong> متمرکز شده‌اند. <strong>New Relic</strong> حتی اصطلاح <strong>MELT</strong> (<strong>metrics, event, logs, and traces</strong>) را ابداع کرد، که واقعاً جا نیفتاد، اما حداقل <strong>New Relic</strong> در حال تلاش است. اگرچه این مدل ساده در ابتدا برای من بسیار جذاب بود (و من عاشق یک سرواژه هستم!)، اما با گذشت زمان واقعاً از این طرز فکر دور شده‌ام و آن را بیش از حد تقلیل‌گرا و همچنین بالقوه از دست دادن نکته می‌دانم.
    </p>
<p>
        اولاً، کاهش یک ویژگی از یک سیستم به جزئیات پیاده‌سازی به این روش از نظر من عقب‌مانده است. <strong>Observability</strong> یک ویژگی است، و راه‌های زیادی وجود دارد که من ممکن است بتوانم به آن ویژگی برسم. تمرکز بیش از حد بر جزئیات پیاده‌سازی خاص، خطر تمرکز بر فعالیت در مقابل نتیجه را به همراه دارد. این شبیه به دنیای فعلی <strong>IT</strong> است، جایی که صدها اگر نگوییم هزاران سازمان عاشق ساخت سیستم‌های مبتنی بر <strong>microservice</strong> شده‌اند، بدون اینکه واقعاً درک کنند که چه چیزی را می‌خواهند به دست آورند!
    </p>
<p>
        ثانیاً، آیا همیشه خطوط مشخصی بین این مفاهیم وجود دارد؟ من استدلال خواهم کرد که بسیاری از آنها همپوشانی دارند. اگر بخواهم، می‌توانم <strong>metrics</strong> را در یک <strong>logfile</strong> قرار دهم. به همین ترتیب، می‌توانم یک <strong>distributed trace</strong> را از مجموعه‌ای از خطوط <strong>log</strong> بسازم، کاری که معمولاً انجام می‌شود.
    </p>
<p>
        310 | Chapter 10: From Monitoring to Observability
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0336</div>
            </div>
        </div>
        <!-- Page 0337 -->
        <div class="chapter" id="page-0337">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        3 I didn’t say I was succeeding.
    </p>
<p>
<strong>Observability</strong>، میزان درک شما از آنچه سیستم بر اساس ورودی‌های خارجی انجام می‌دهد. <strong>Logs</strong>، رویدادها، و <strong>metrics</strong> ممکن است به شما در <strong>observable</strong> کردن موارد کمک کنند، اما مطمئن شوید که بر قابل درک کردن سیستم به جای پرتاب کردن ابزارهای زیاد تمرکز کرده‌اید.
    </p>
<p>
        به طور بدبینانه، من می‌توانم پیشنهاد کنم که پیش بردن این روایت ساده‌انگارانه راهی برای فروش ابزارها به شماست. شما به یک ابزار برای <strong>metrics</strong>، یک ابزار متفاوت برای <strong>logs</strong>، و یک ابزار دیگر برای <strong>traces</strong> نیاز دارید! و شما باید تمام آن اطلاعات را متفاوت ارسال کنید! فروش ویژگی‌ها از طریق یک تمرین علامت‌گذاری جعبه هنگام بازاریابی یک محصول بسیار آسان‌تر است، تا صحبت در مورد نتایج. همانطور که گفتم، من می‌توانم این را با یک دیدگاه بدبینانه پیشنهاد کنم، اما سال 2021 است، و من سعی می‌کنم در تفکرم کمی مثبت‌تر باشم.<sup>3</sup>
</p>
<p>
        قابل بحث است که این سه (یا چهار!) مفهوم واقعاً فقط نمونه‌های خاصی از یک مفهوم عمومی‌تر هستند. اساساً، ما می‌توانیم هر قطعه اطلاعاتی را که می‌توانیم از سیستم خود دریافت کنیم—هر یک از این خروجی‌های خارجی—به طور کلی به عنوان یک رویداد ببینیم. یک رویداد داده شده ممکن است مقدار کمی یا زیادی اطلاعات داشته باشد. این می‌تواند شامل نرخ <strong>CPU</strong>، اطلاعات مربوط به یک پرداخت ناموفق، این واقعیت که یک مشتری وارد سیستم شده است، یا هر تعداد موارد دیگر باشد. ما می‌توانیم از این جریان رویداد یک <strong>trace</strong> (با فرض اینکه بتوانیم این رویدادها را همبسته کنیم)، یک شاخص قابل جستجو، یا تجمیعی از اعداد را ایجاد کنیم.
    </p>
<p>
        اگرچه در حال حاضر ما این اطلاعات را به روش‌های مختلف، با استفاده از ابزارهای مختلف و پروتکل‌های مختلف جمع‌آوری می‌کنیم، اما زنجیره‌های ابزار فعلی ما نباید تفکر ما را از نظر بهترین روش برای دریافت اطلاعات مورد نیازمان محدود کند.
    </p>
<p>
        وقتی صحبت از <strong>observable</strong> کردن سیستم شما می‌شود، در مورد خروجی‌هایی که از سیستم خود به صورت رویدادهایی که می‌توانید جمع‌آوری و بازجویی کنید، فکر کنید. شما ممکن است نیاز داشته باشید که از ابزارهای مختلف برای نشان دادن انواع مختلف رویدادها در حال حاضر استفاده کنید، اما این ممکن است در آینده اینطور نباشد.
    </p>
<h4>Building Blocks for Observability</h4>
<p>
        پس به چه چیزی نیاز داریم؟ ما باید بدانیم که کاربران نرم‌افزار ما خوشحال هستند. اگر مشکلی وجود دارد، ما می‌خواهیم از آن مطلع شویم—در حالت ایده‌آل قبل از اینکه کاربران خودمان مشکلی را پیدا کنند. وقتی مشکلی رخ می‌دهد، ما باید راه‌هایی را برای راه‌اندازی و اجرای مجدد سیستم پیدا کنیم، و پس از فروکش کردن گرد و غبار، ما می‌خواهیم اطلاعات کافی در دست داشته باشیم تا بفهمیم چه اتفاقی افتاده است و چه کاری می‌توانیم انجام دهیم تا از تکرار مشکل جلوگیری کنیم.
    </p>
<p>
        در ادامه این فصل ما به بررسی چگونگی تحقق همه این موارد خواهیم پرداخت. ما تعدادی از <strong>building blocks</strong> را پوشش خواهیم داد که می‌توانند به بهبود <strong>observability</strong> معماری سیستم شما کمک کنند:
    </p>
<p>
        Building Blocks for Observability | 311
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 337" src="page_0337/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0337</div>
            </div>
        </div>
        <!-- Page 0338 -->
        <div class="chapter" id="page-0338">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        Log aggregation
        جمع‌آوری اطلاعات در سراسر چندین <strong>microservices</strong>، یک <strong>building block</strong> حیاتی هر راه‌حل نظارت یا <strong>observability</strong>
</p>
<p>
        Metrics aggregation
        ثبت اعداد خام از <strong>microservices</strong> و زیرساخت‌های ما برای کمک به شناسایی مشکلات، هدایت برنامه‌ریزی ظرفیت، و شاید حتی مقیاس‌بندی برنامه‌های ما
    </p>
<p>
        Distributed tracing
        ردیابی جریان تماس‌ها در سراسر مرزهای چند <strong>microservice</strong> برای یافتن آنچه اشتباه شده است و استخراج اطلاعات <strong>latency</strong> دقیق
    </p>
<p>
        Are you doing OK?
        نگاهی به بودجه‌های خطا، <strong>SLAs</strong>، <strong>SLOs</strong>، و غیره برای دیدن چگونگی استفاده از آنها به عنوان بخشی از اطمینان از اینکه <strong>microservice</strong> ما نیازهای مصرف‌کنندگان خود را برآورده می‌کند
    </p>
<p>
        Alerting
        در مورد چه چیزی باید هشدار دهید؟ یک هشدار خوب چه شکلی است؟
    </p>
<p>
        Semantic monitoring
        تفکر متفاوت در مورد سلامت سیستم‌های ما، و در مورد اینکه چه چیزی باید ما را ساعت 3 صبح بیدار کند.
    </p>
<p>
        Testing in production
        خلاصه‌ای از تکنیک‌های مختلف تست در <strong>production</strong>
</p>
<p>
        بیایید با شاید ساده‌ترین چیز برای راه‌اندازی و اجرا شروع کنیم، اما چیزی که چندین برابر ارزشش را دارد: <strong>log aggregation</strong>.
    </p>
<h4>Log Aggregation</h4>
<p>
        با بسیاری از سرورها و نمونه‌های <strong>microservice</strong> در حتی یک معماری <strong>microservice</strong> متوسط، <strong>logging</strong> به ماشین‌ها یا <strong>SSH-multiplexing</strong> برای بازیابی <strong>logs</strong> واقعاً جواب نمی‌دهد. در عوض، ما به دنبال استفاده از زیرسیستم‌های تخصصی برای گرفتن <strong>logs</strong> خود و در دسترس قرار دادن آنها به صورت مرکزی هستیم.
    </p>
<p>
<strong>Logs</strong> به سرعت به یکی از حیاتی‌ترین مکانیسم‌ها برای کمک به شما در درک آنچه در سیستم <strong>production</strong> شما اتفاق می‌افتد، تبدیل می‌شود. با معماری‌های استقرار ساده‌تر، فایل‌های <strong>logfile</strong> ما، آنچه در آنها قرار می‌دهیم، و نحوه برخورد ما با آنها اغلب یک فکر بعدی است. با یک سیستم فزاینده توزیع شده، آنها به یک ابزار حیاتی تبدیل می‌شوند، نه تنها به شما کمک می‌کنند تا تشخیص دهید چه چیزی اشتباه شده است وقتی متوجه می‌شوید که مشکلی دارید، بلکه به شما می‌گویند که در وهله اول مشکلی وجود داشته است که به توجه شما نیاز داشت.
    </p>
<p>
        همانطور که به زودی بحث خواهیم کرد، ابزارهای مختلفی در این فضا وجود دارد، اما همه آنها تا حد زیادی به همان شیوه عمل می‌کنند، همانطور که در شکل 10-4 مشخص شده است. فرآیندها (مانند نمونه‌های <strong>microservice</strong> ما) به سیستم فایل محلی خود <strong>log</strong> می‌شوند. یک فرآیند <strong>daemon</strong> محلی به‌طور دوره‌ای جمع‌آوری می‌کند...
    </p>
<p>
        312 | Chapter 10: From Monitoring to Observability
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0338</div>
            </div>
        </div>
        <!-- Page 0339 -->
        <div class="chapter" id="page-0339">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        و این <strong>log</strong> را به نوعی <strong>store</strong> ارسال می‌کند که می‌تواند توسط اپراتورها مورد پرسش قرار گیرد. یکی از جنبه‌های خوب این سیستم‌ها این است که معماری <strong>microservice</strong> شما می‌تواند تا حد زیادی از آنها بی‌خبر باشد. شما نیازی به تغییر کد خود برای استفاده از نوعی <strong>API</strong> خاص ندارید. شما فقط به یک سیستم فایل محلی <strong>log</strong> می‌کنید. با این حال، شما باید حالت‌های شکست را در اطراف این فرآیند ارسال <strong>log</strong> درک کنید، به‌ویژه اگر می‌خواهید موقعیت‌هایی را که <strong>logs</strong> می‌توانند در آنها گم شوند، درک کنید.
    </p>
<figure>
<img alt="An overview of how logs are collected as part of log aggregation" src="https://www.plantuml.com/plantuml/png/VP11QiCm38JpUeT9uJ5H9x8S6U0Oq_f0000"/>
<figcaption>شکل 10-4. مروری بر نحوه جمع‌آوری <strong>logs</strong> به عنوان بخشی از <strong>log aggregation</strong></figcaption>
</figure>
<p>
        اکنون، امیدوارم متوجه شده باشید که من سعی می‌کنم از جزمی بودن در مورد مسائل اجتناب کنم. من به جای اینکه فقط بگویم شما باید X یا Y را انجام دهید، سعی کرده‌ام به شما زمینه و راهنمایی ارائه دهم و ظرافت‌های تصمیمات خاص را توضیح دهم—یعنی، من سعی کرده‌ام ابزارهایی را در اختیار شما قرار دهم تا انتخاب درستی برای زمینه خود داشته باشید. اما در مورد <strong>log aggregation</strong>، من تا حد ممکن به ارائه یک توصیه <strong>one-size-fits-all</strong> نزدیک می‌شوم: شما باید اجرای یک ابزار <strong>log aggregation</strong> را به عنوان یک پیش نیاز برای پیاده‌سازی یک معماری <strong>microservice</strong> در نظر بگیرید.
    </p>
<p>
        دلایل من برای این دیدگاه دوگانه است. اولاً، <strong>log aggregation</strong> فوق‌العاده مفید است. برای کسانی از شما که با فایل‌های <strong>logfile</strong> خود به‌عنوان یک محل تخلیه برای اطلاعات نادرست رفتار می‌کنید، این موضوع تعجب‌آور خواهد بود. اما به من اعتماد کنید—وقتی این کار درست انجام شود، <strong>log aggregation</strong> می‌تواند فوق‌العاده ارزشمند باشد، به‌ویژه هنگامی که با مفهوم دیگری که به زودی پوشش خواهیم داد، یعنی <strong>correlation IDs</strong> استفاده شود.
    </p>
<p>
        ثانیاً، پیاده‌سازی یک <strong>log aggregation</strong>، در مقایسه با سایر منابع درد و رنجی که یک معماری <strong>microservice</strong> می‌تواند به همراه داشته باشد، آنقدرها هم دشوار نیست. اگر سازمان شما نتواند یک راه‌حل ساده <strong>log aggregation</strong> را با موفقیت پیاده‌سازی کند، احتمالاً جنبه‌های دیگر معماری <strong>microservice</strong> را نیز بیش از حد تحمل خواهد کرد. بنابراین استفاده از پیاده‌سازی چنین راه‌حلی را به‌عنوان راهی برای آزمایش آمادگی سازمان خود برای بقیه وحشتی که در پی خواهد داشت، در نظر بگیرید.
    </p>
<p>
        Building Blocks for Observability | 313
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 339" src="page_0339/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0339</div>
            </div>
        </div>
        <!-- Page 0340 -->
        <div class="chapter" id="page-0340">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Before Anything Else</h4>
<p>
        قبل از اینکه هر کار دیگری برای ساخت معماری <strong>microservice</strong> خود انجام دهید، یک ابزار <strong>log aggregation</strong> را راه‌اندازی کنید. آن را به عنوان یک پیش‌نیاز برای ساختن یک معماری <strong>microservice</strong> در نظر بگیرید. بعداً از من تشکر خواهید کرد.
    </p>
<p>
        اکنون، این نیز درست است که <strong>log aggregation</strong> محدودیت‌هایی دارد، و با گذشت زمان، ممکن است بخواهید به ابزارهای پیچیده‌تری برای افزایش یا حتی جایگزینی برخی از آنچه <strong>log aggregation</strong> ارائه می‌دهد، نگاه کنید. با این حال، با وجود همه اینها، همچنان یک نقطه عالی برای شروع است.
    </p>
<h4>Common format</h4>
<p>
        اگر می‌خواهید <strong>logs</strong> خود را تجمیع کنید، می‌خواهید بتوانید پرس‌وجوهایی را در آنها اجرا کنید تا اطلاعات مفیدی را استخراج کنید. برای اینکه این کار انجام شود، مهم است که یک قالب <strong>log</strong> استاندارد معقول را انتخاب کنید—در غیر این صورت پرس‌وجوهای شما در نهایت دشوار یا شاید غیرممکن خواهند بود. شما تاریخ، زمان، نام <strong>microservice</strong>، <strong>log level</strong>، و غیره را در مکان‌های ثابت در هر <strong>log</strong> می‌خواهید.
    </p>
<p>
        برخی از <strong>log forwarding agents</strong>ها به شما این امکان را می‌دهند که <strong>logs</strong> را قبل از ارسال آنها به <strong>log store</strong> مرکزی خود، دوباره قالب‌بندی کنید. من شخصاً، تا حد امکان از این کار اجتناب می‌کنم. مسئله این است که بازفرمت‌بندی <strong>logs</strong> می‌تواند از نظر محاسباتی فشرده باشد، تا جایی که من مشکلات <strong>production</strong> واقعی را دیده‌ام که ناشی از مشغول بودن <strong>CPU</strong> در انجام این کار بوده است. بسیار بهتر است که <strong>logs</strong> را همانطور که توسط خود <strong>microservice</strong> نوشته شده است، تغییر دهید. من استفاده از <strong>log forwarding agents</strong>ها را برای انجام بازفرمت‌بندی <strong>log</strong> به مکان‌هایی محدود می‌کنم که نمی‌توانم قالب <strong>log</strong> منبع را تغییر دهم—به عنوان مثال، نرم‌افزار قدیمی یا شخص ثالث.
    </p>
<p>
        من فکر می‌کردم که در زمانی که از زمان نوشتن نسخه اول این کتاب گذشته است، یک استاندارد صنعتی رایج برای <strong>logging</strong> رواج پیدا می‌کرد، اما به نظر نمی‌رسد که این اتفاق افتاده باشد. به نظر می‌رسد انواع زیادی وجود دارد. آنها معمولاً شامل گرفتن قالب <strong>log</strong> دسترسی استاندارد است که توسط سرورهای وب مانند <strong>Apache</strong> و <strong>nginx</strong> پشتیبانی می‌شود و با افزودن ستون‌های داده بیشتر، آن را گسترش می‌دهند. نکته کلیدی این است که در معماری <strong>microservice</strong> خود، یک قالب را انتخاب می‌کنید که به صورت داخلی در آن استانداردسازی می‌کنید.
    </p>
<p>
        اگر شما از یک قالب <strong>log</strong> نسبتاً ساده استفاده می‌کنید، شما فقط خطوط ساده‌ای از متن را منتشر می‌کنید که دارای قطعات اطلاعات خاصی در مکان‌های خاص در خط <strong>log</strong> هستند. در مثال 10-1، ما یک قالب مثال را می‌بینیم.
    </p>
<p>
        Example 10-1. Some example logs
    </p>
<p>
        15-02-2020 16:00:58 Order INFO [abc-123] Customer 2112 has placed order 988827
    </p>
<p>
        15-02-2020 16:01:01 Payment INFO [abc-123] Payment $20.99 for 988827 by cust 2112
    </p>
<p>
        314 | Chapter 10: From Monitoring to Observability
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 340" src="page_0340/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0340</div>
            </div>
        </div>
        <!-- Page 0341 -->
        <div class="chapter" id="page-0341">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        ابزار <strong>log aggregation</strong> باید بداند چگونه این رشته را تجزیه کند تا اطلاعاتی را که ممکن است بخواهیم در مورد آنها پرس‌وجو کنیم—به عنوان مثال، <strong>timestamp</strong>، نام <strong>microservice</strong>، یا <strong>log level</strong>—را استخراج کند. در این مثال، این کار امکان‌پذیر است، زیرا این قطعات داده در مکان‌های ثابت در سراسر <strong>logs</strong> ما رخ می‌دهند—تاریخ ستون اول است، زمان ستون دوم است، و به همین ترتیب. با این حال، اگر بخواهیم خطوط <strong>log</strong> مربوط به یک مشتری داده شده را پیدا کنیم، این مشکل‌سازتر است—شناسه مشتری در هر دو خط <strong>log</strong> وجود دارد اما در مکان‌های مختلف نشان داده می‌شود. اینجاست که ما ممکن است به نوشتن خطوط <strong>log</strong> ساختاریافته‌تر، شاید با استفاده از یک قالب <strong>JSON</strong>، فکر کنیم، بنابراین می‌توانیم اطلاعاتی مانند شناسه مشتری یا سفارش را در یک مکان ثابت پیدا کنیم. باز هم، ابزار <strong>log aggregation</strong> باید پیکربندی شود تا اطلاعات مورد نیاز را از <strong>log</strong> تجزیه و استخراج کند. نکته دیگر این است که اگر شما <strong>JSON</strong> را <strong>log</strong> می‌کنید، این ممکن است خواندن مستقیم آن توسط انسان را بدون ابزارهای اضافی برای تجزیه مقادیر مورد نیاز دشوارتر کند—به سادگی خواندن <strong>log</strong> در یک <strong>plain text viewer</strong> ممکن است خیلی مفید نباشد.
    </p>
<h4>Correlating log lines</h4>
<p>
        با تعداد زیادی <strong>service</strong> که برای ارائه هر قابلیت کاربر نهایی با هم تعامل دارند، یک فراخوانی اولیه واحد می‌تواند در نهایت چندین فراخوانی <strong>service downstream</strong> ایجاد کند. به عنوان مثال، بیایید مثالی را در <strong>MusicCorp</strong> در نظر بگیریم، همانطور که در شکل 10-5 نشان داده شده است. ما در حال ثبت نام یک مشتری در سرویس <strong>streaming</strong> جدید خود هستیم. مشتری بسته <strong>streaming</strong> انتخابی خود را انتخاب می‌کند و روی دکمه <strong>submit</strong> کلیک می‌کند. در پشت صحنه، وقتی روی دکمه در <strong>UI</strong> کلیک می‌شود، به <strong>Gateway</strong> می‌رسد که در محیط سیستم ما قرار دارد. این به نوبه خود تماس را به <strong>Streaming microservice</strong> منتقل می‌کند. این <strong>microservice</strong> با <strong>Payment</strong> ارتباط برقرار می‌کند تا اولین پرداخت را انجام دهد، از <strong>Customer microservice</strong> استفاده می‌کند تا این واقعیت را که این مشتری اکنون <strong>streaming</strong> فعال دارد، به‌روزرسانی کند، و با استفاده از <strong>Email microservice</strong> ما ایمیلی را برای مشتری ارسال می‌کند و تأیید می‌کند که اکنون مشترک شده است.
    </p>
<p>
        اگر تماس با <strong>microservice Payment</strong> در نهایت یک خطای عجیب ایجاد کند، چه اتفاقی می‌افتد؟ ما به تفصیل در مورد رسیدگی به شکست‌ها در فصل 12 صحبت خواهیم کرد، اما دشواری تشخیص آنچه رخ داده است را در نظر بگیرید.
    </p>
<p>
        مشکل این است که تنها <strong>microservice</strong> ثبت کننده خطا، <strong>microservice Payment</strong> ما است. اگر خوش شانس باشیم، می‌توانیم بفهمیم کدام درخواست باعث ایجاد مشکل شده است، و ما حتی ممکن است بتوانیم به پارامترهای تماس نگاه کنیم. اما ما نمی‌توانیم این خطا را در زمینه گسترده‌تری که در آن رخ می‌دهد، ببینیم. در این مثال خاص، حتی اگر فرض کنیم که هر تعامل فقط یک خط <strong>log</strong> واحد ایجاد می‌کند، ما پنج خط <strong>log</strong> با اطلاعاتی در مورد این جریان تماس خواهیم داشت. توانایی دیدن این خطوط <strong>log</strong> که با هم گروه‌بندی شده‌اند می‌تواند فوق‌العاده مفید باشد.
    </p>
<p>
        Building Blocks for Observability | 315
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0341</div>
            </div>
        </div>
        <!-- Page 0342 -->
        <div class="chapter" id="page-0342">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<figure>
<img alt="A series of calls across multiple microservices related to registering a customer" src="https://www.plantuml.com/plantuml/png/VP11QiCm38JpUeT9uJ5H9x8S6U0Oq_f0000"/>
<figcaption>شکل 10-5. مجموعه‌ای از تماس‌ها در سراسر چندین <strong>microservices</strong> مرتبط با ثبت نام یک مشتری</figcaption>
</figure>
<p>
        یک رویکرد که می‌تواند در اینجا مفید باشد، استفاده از <strong>correlation IDs</strong> است—چیزی که ما اولین بار در فصل 6 هنگام بحث در مورد <strong>sagas</strong> به آن اشاره کردیم. هنگامی که اولین تماس برقرار می‌شود، شما یک <strong>ID</strong> منحصربه‌فرد ایجاد می‌کنید که برای همبستگی همه تماس‌های بعدی مرتبط با درخواست استفاده می‌شود. در شکل 10-6، ما این <strong>ID</strong> را در <strong>Gateway</strong> ایجاد می‌کنیم، و سپس به عنوان یک پارامتر به همه تماس‌های بعدی منتقل می‌شود.
    </p>
<p>
<strong>Logging</strong> هر فعالیتی توسط یک <strong>microservice</strong> که توسط این تماس ورودی ایجاد می‌شود، همراه با همان <strong>correlation ID</strong> ثبت می‌شود، که ما آن را در یک مکان ثابت در هر خط <strong>log</strong> قرار می‌دهیم، همانطور که در مثال 10-2 نشان داده شده است. این کار استخراج تمام <strong>logs</strong> مرتبط با یک <strong>correlation ID</strong> داده شده را در تاریخ بعدی آسان می‌کند.
    </p>
<p>
        Example 10-2. Using a correlation ID in a fixed location in a log line
    </p>
<p>
        15-02-2020 16:01:01 Gateway INFO [abc-123] Signup for streaming
    </p>
<p>
        15-02-2020 16:01:02 Streaming INFO [abc-123] Cust 773 signs up ...
    </p>
<p>
        15-02-2020 16:01:03 Customer INFO [abc-123] Streaming package added ...
    </p>
<p>
        15-02-2020 16:01:03 Email INFO [abc-123] Send streaming welcome ...
    </p>
<p>
        15-02-2020 16:01:03 Payment ERROR [abc-123] ValidatePayment ...
    </p>
<p>
        316 | Chapter 10: From Monitoring to Observability
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 342" src="page_0342/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0342</div>
            </div>
        </div>
        <!-- Page 0343 -->
        <div class="chapter" id="page-0343">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<figure>
<img alt="Generating a correlation ID for a set of calls" src="https://www.plantuml.com/plantuml/png/VP11QiCm38JpUeT9uJ5H9x8S6U0Oq_f0000"/>
<figcaption>شکل 10-6. ایجاد یک <strong>correlation ID</strong> برای مجموعه‌ای از تماس‌ها</figcaption>
</figure>
<p>
        البته، شما باید اطمینان حاصل کنید که هر <strong>service</strong> می‌داند که چگونه <strong>correlation ID</strong> را منتقل کند. اینجاست که شما باید در سراسر سیستم خود استانداردسازی کنید و در اجرای این مورد قوی‌تر باشید. اما هنگامی که این کار را انجام دادید، می‌توانید ابزارهایی را برای ردیابی انواع تعاملات ایجاد کنید. این نوع ابزارها می‌توانند در ردیابی <strong>event storms</strong> یا موارد گوشه عجیب، یا حتی در شناسایی تراکنش‌های به‌ویژه پرهزینه مفید باشند، زیرا می‌توانید کل آبشاری تماس‌ها را تصور کنید.
    </p>
<p>
<strong>Correlation IDs</strong> در <strong>logs</strong> از آن دسته چیزهایی هستند که در ابتدا چندان مفید به نظر نمی‌رسند، اما به من اعتماد کنید—با گذشت زمان، آنها می‌توانند فوق‌العاده مفید باشند. متأسفانه، <strong>retrofit</strong> کردن آنها به یک سیستم می‌تواند دردسرساز باشد. به همین دلیل من قویاً پیشنهاد می‌کنم که <strong>correlation IDs</strong> را در <strong>logging</strong> در اسرع وقت پیاده‌سازی کنید. البته <strong>logs</strong> فقط می‌توانند شما را در این مورد تا این حد پیش ببرند—برخی از انواع مشکلات با ابزارهای <strong>distributed tracing</strong> بهتر حل می‌شوند، که ما به زودی آنها را بررسی خواهیم کرد. اما یک <strong>correlation ID</strong> ساده در یک <strong>logfile</strong> می‌تواند در ابتدا فوق‌العاده مفید باشد، به این معنی که شما می‌توانید از استفاده از یک ابزار <strong>tracing</strong> اختصاصی تا زمانی که سیستم شما به اندازه کافی پیچیده شود تا آن را توجیه کند، صرف‌نظر کنید.
    </p>
<p>
        هنگامی که <strong>log aggregation</strong> را دارید، <strong>correlation IDs</strong> را در اسرع وقت دریافت کنید. انجام آن در ابتدا آسان است و <strong>retrofit</strong> کردن آن در مراحل بعدی دشوار است، آنها ارزش <strong>logs</strong> شما را به شدت افزایش می‌دهند.
    </p>
<p>
        Building Blocks for Observability | 317
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 343" src="page_0343/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 343" src="page_0343/image_2.png"/></div>
</div>
                <div class="page-number">صفحه 0343</div>
            </div>
        </div>
        <!-- Page 0344 -->
        <div class="chapter" id="page-0344">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        4 Leslie Lamport, “Time, Clocks, and the Ordering of Events in a Distributed System,” Communications of the ACM 21, no. 7 (July 1978): 558–65, https://oreil.ly/qzYmh.
    </p>
<h4>Timing</h4>
<p>
        هنگام نگاه کردن به لیستی از خطوط <strong>log</strong>، ما می‌توانیم فریب بخوریم و فکر کنیم که در حال دیدن یک ترتیب زمانی دقیق هستیم که به ما در درک آنچه اتفاق افتاده است و به چه ترتیبی کمک می‌کند. از این گذشته، هر خط از <strong>logs</strong> ما شامل تاریخ و زمان است—پس چرا ما نمی‌توانیم از این به عنوان راهی برای تعیین ترتیب وقوع رویدادها استفاده کنیم؟ در دنباله‌ای از تماس‌ها در مثال 10-2، ما یک خط <strong>log</strong> از <strong>Gateway</strong>، به دنبال آن <strong>logs</strong> از <strong>Streaming, Customer, Email</strong>، و سپس <strong>microservice Payment</strong> را می‌بینیم. ما ممکن است اینطور نتیجه‌گیری کنیم که این ترتیبی است که در آن تماس‌ها واقعاً اتفاق افتاده‌اند. متأسفانه، ما همیشه نمی‌توانیم روی این حساب کنیم که درست باشد.
    </p>
<p>
        خطوط <strong>log</strong> در ماشین‌هایی ایجاد می‌شوند که این نمونه‌های <strong>microservice</strong> در آنها در حال اجرا هستند. این <strong>logs</strong>ها پس از نوشته شدن به صورت محلی، در نقطه‌ای به جلو فرستاده می‌شوند. این بدان معناست که برچسب‌های تاریخ در خطوط <strong>log</strong> در ماشین‌هایی ایجاد می‌شوند که <strong>microservices</strong> در حال اجرا هستند. متأسفانه، ما نمی‌توانیم تضمین کنیم که ساعت‌های این ماشین‌های مختلف با هم همگام هستند. این بدان معناست که ساعت روی ماشینی که <strong>microservice Email</strong> در آن در حال اجرا است، ممکن است چند ثانیه جلوتر از ساعت ماشینی باشد که <strong>Payment</strong> در آن در حال اجرا است—این می‌تواند منجر به این شود که به نظر برسد چیزی در <strong>microservice Email</strong> قبل از وقوع آن در <strong>microservice Payment</strong> رخ داده است، اما این فقط می‌تواند به دلیل این <strong>clock skew</strong> باشد.
    </p>
<p>
        مشکل <strong>clock skew</strong> باعث ایجاد انواع مسائل در سیستم‌های توزیع‌شده می‌شود. پروتکل‌هایی برای تلاش و کاهش <strong>clock skew</strong> در سیستم‌ها وجود دارد—پروتکل زمان شبکه (<strong>NTP</strong>) که پرکاربردترین نمونه است. با این حال، <strong>NTP</strong> تضمین شده نیست که کار می‌کند، و حتی زمانی که کار می‌کند، تنها کاری که می‌تواند انجام دهد، کاهش <strong>skew</strong> است، نه حذف آن. اگر شما دنباله‌ای از تماس‌ها دارید که بسیار نزدیک به هم اتفاق می‌افتند، ممکن است متوجه شوید که حتی یک ثانیه <strong>skew</strong> در ماشین‌ها برای اینکه درک شما از توالی تماس‌ها کاملاً تغییر کند، کافی است.
    </p>
<p>
        اساساً، این بدان معناست که ما دو محدودیت در مورد زمان در <strong>logs</strong> داریم. ما نمی‌توانیم اطلاعات زمان‌بندی کاملاً دقیقی را برای جریان کلی تماس‌ها دریافت کنیم، و همچنین نمی‌توانیم علیت را درک کنیم.
    </p>
<p>
        از نظر کمک به حل این مشکل تا بتوانیم ترتیب واقعی امور را درک کنیم، <strong>Leslie Lamport</strong><sup>4</sup> یک سیستم ساعت منطقی را پیشنهاد کرده است، که در آن از یک شمارنده برای پیگیری ترتیب تماس‌ها استفاده می‌شود. شما می‌توانید یک طرح مشابه را پیاده‌سازی کنید، اگر می‌خواهید، و تعدادی از تغییرات در این طرح وجود دارد. اما شخصاً، اگر می‌خواستم اطلاعات دقیق‌تری در مورد ترتیب تماس‌ها داشته باشم، و همچنین زمان‌بندی دقیق‌تری می‌خواستم، تمایل بیشتری به استفاده از یک ابزار <strong>distributed tracing</strong> داشتم، که هر دو مشکل را برای من برطرف می‌کند. ما در ادامه این فصل با جزئیات بیشتری به <strong>distributed tracing</strong> خواهیم پرداخت.
    </p>
<p>
        318 | Chapter 10: From Monitoring to Observability
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0344</div>
            </div>
        </div>
        <!-- Page 0345 -->
        <div class="chapter" id="page-0345">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        5 See the analysis Kyle Kingsbury did on Elasticsearch 1.1.0 in “Jepsen: Elasticsearch,” https://oreil.ly/uO9wU
        and on Elasticsearch 1.5.0 in “Jepsen: Elasticsearch 1.5.0,” https://oreil.ly/8fBCt.
        6 Renato Losio, “Elastic Changes Licences for Elasticsearch and Kibana: AWS Forks Both,” InfoQ, January 25, 2021, https://oreil.ly/VdWzD.
    </p>
<h4>Implementations</h4>
<p>
        تعدادی کمی از فضاها در صنعت ما به اندازه <strong>log aggregation</strong> مورد بحث قرار گرفته‌اند، و انواع مختلفی از راه‌حل‌ها در این فضا وجود دارد.
    </p>
<p>
        یک <strong>toolchain open source</strong> محبوب برای <strong>log aggregation</strong> این است که از یک <strong>log forwarding agent</strong> مانند <strong>Fluentd</strong> برای ارسال <strong>logs</strong> به <strong>Elasticsearch</strong> استفاده کنید، با استفاده از <strong>Kibana</strong> به عنوان راهی برای برش و تقسیم جریان <strong>logs</strong> حاصل. بزرگترین چالش با این <strong>stack</strong> تمایل به سربار مدیریت خود <strong>Elasticsearch</strong> است، اما این ممکن است اگر شما نیاز به اجرای <strong>Elasticsearch</strong> برای اهداف دیگر دارید، یا اگر از یک ارائه دهنده مدیریت شده استفاده می‌کنید، مشکل کمتری باشد. من دو نکته احتیاطی اضافی در مورد استفاده از این <strong>toolchain</strong> خواهم داشت.
    </p>
<p>
        اولاً، تلاش زیادی برای بازاریابی <strong>Elasticsearch</strong> به عنوان یک پایگاه داده انجام شده است. شخصاً، این موضوع همیشه برای من ناخوشایند بوده است. گرفتن چیزی که همیشه به عنوان یک شاخص جستجو معرفی می‌شد و تغییر نام آن به عنوان یک پایگاه داده می‌تواند بسیار مشکل‌ساز باشد. ما به‌طور ضمنی فرضیاتی را در مورد نحوه عملکرد و رفتار پایگاه‌های داده در نظر می‌گیریم، و طبق آن با آنها رفتار می‌کنیم، و آنها را به عنوان منبع حقیقت برای داده‌های حیاتی در نظر می‌گیریم. اما از نظر طراحی، یک شاخص جستجو منبع حقیقت نیست. این یک پیش‌بینی از منبع حقیقت است. <strong>Elasticsearch</strong> در گذشته از مشکلاتی رنج برده است که باعث می‌شود من به فکر فرو بروم.<sup>5</sup> در حالی که من مطمئن هستم که بسیاری از این مسائل حل شده‌اند، اما خواندن من از این مشکلات باعث شده است که در مورد استفاده از <strong>Elasticseach</strong> در شرایط خاص، و قطعاً هنگام در نظر گرفتن آن به عنوان یک پایگاه داده، محتاط باشم. داشتن یک شاخص جستجو که ممکن است گاهی داده‌ها را از دست بدهد، اگر شما قبلاً بتوانید دوباره ایندکس کنید، یک مسئله نیست. اما برخورد با آن مانند یک پایگاه داده چیز دیگری است. اگر من از این <strong>stack</strong> استفاده می‌کردم و نمی‌توانستم اطلاعات <strong>log</strong> را از دست بدهم، می‌خواستم اطمینان حاصل کنم که اگر مشکلی پیش آمد، می‌توانم <strong>logs</strong> اصلی را دوباره <strong>index</strong> کنم.
    </p>
<p>
        مجموعه دوم از نگرانی‌ها کمتر در مورد جنبه‌های فنی <strong>Elasticsearch</strong> و <strong>Kibana</strong> است و بیشتر در مورد رفتارهای <strong>Elastic</strong>، شرکتی که پشت این پروژه‌ها قرار دارد. اخیراً، <strong>Elastic</strong> تصمیم گرفت که مجوز کد منبع را برای هر دو پایگاه داده اصلی <strong>Elasticsearch</strong> و <strong>Kibana</strong> از یک مجوز <strong>open source</strong> که به طور گسترده مورد استفاده و پذیرفته شده است (<strong>Apache 2.0</strong>) به یک مجوز <strong>Server Side Public License (SSPL)</strong> غیر <strong>open source</strong> تغییر دهد.<sup>6</sup> به نظر می‌رسد که محرک این تغییر در مجوز این بوده است که <strong>Elastic</strong> از این واقعیت ناامید شده است که سازمان‌هایی مانند <strong>AWS</strong> از این فناوری، که خود محصولات تجاری <strong>Elastic</strong> را تضعیف کرده‌اند، ارائه‌های تجاری موفقی ساخته‌اند. جدا از نگرانی‌هایی که <strong>SSPL</strong> می‌تواند ذاتاً "ویروسی" باشد (به روشی مشابه با <strong>GNU General Public License</strong>)، این تصمیم بسیاری را خشمگین کرده است. بیش از هزار نفر کد را به <strong>Elasticsearch</strong> تحت این انتظار مشارکت کردند که آنها به یک محصول <strong>open source</strong> اهدا می‌کنند. طعنه دیگری وجود دارد که خود <strong>Elasticsearch</strong>، و بنابراین بخش زیادی از شرکت <strong>Elastic</strong> به عنوان یک کل، بر اساس فناوری...
    </p>
<p>
        Building Blocks for Observability | 319
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0345</div>
            </div>
        </div>
        <!-- Page 0346 -->
        <div class="chapter" id="page-0346">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        پروژه <strong>open source Lucene</strong>. در زمان نگارش این مقاله، <strong>AWS</strong>، به طور قابل پیش‌بینی متعهد به ایجاد و نگهداری یک <strong>fork open source</strong> از هر دو <strong>Elasticsearch</strong> و <strong>Kibana</strong> تحت مجوز <strong>Apache 2.0 open source</strong> که قبلاً استفاده می‌شد، شده بود.
    </p>
<p>
        از بسیاری جهات، <strong>Kibana</strong> یک تلاش قابل ستایش برای ایجاد جایگزینی <strong>open source</strong> برای گزینه‌های تجاری گران‌قیمت مانند <strong>Splunk</strong> بود. به همان خوبی که به نظر می‌رسد <strong>Splunk</strong> وجود دارد، هر مشتری <strong>Splunk</strong> که من با او صحبت کرده‌ام نیز به من گفته است که می‌تواند از نظر هزینه‌های مجوز و هزینه‌های سخت‌افزاری، بسیار گران‌قیمت باشد. با این حال، بسیاری از این مشتریان ارزش آن را می‌بینند. با این حال، گزینه‌های تجاری زیادی وجود دارد. من شخصاً طرفدار بزرگ <strong>Humio</strong> هستم، بسیاری از مردم دوست دارند از <strong>Datadog</strong> برای <strong>log aggregation</strong> استفاده کنند، و شما راه‌حل‌های <strong>out-of-the-box</strong> ساده اما قابل‌اجرایی برای <strong>log aggregation</strong> با برخی از ارائه دهندگان <strong>cloud public</strong>، مانند <strong>CloudWatch</strong> برای <strong>AWS</strong> یا <strong>Application Insights</strong> برای <strong>Azure</strong> دارید.
    </p>
<p>
        واقعیت این است که شما مجموعه‌ای عظیم از گزینه‌ها در این فضا دارید، از <strong>open source</strong> تا تجاری، و از خود-میزبانی تا کاملاً میزبانی شده. اگر می‌خواهید یک معماری <strong>microservice</strong> بسازید، این یکی از مواردی نیست که باید در مرتب کردن آن مشکل داشته باشید.
    </p>
<h4>Shortcomings</h4>
<p>
<strong>Logs</strong> یک راه فوق‌العاده و آسان برای دریافت سریع اطلاعات از سیستم‌های در حال اجرا شما هستند. من همچنان متقاعد شده‌ام که برای یک معماری <strong>microservice</strong> در مراحل اولیه، مکان‌های کمی وجود دارد که بازگشت سرمایه بیشتری نسبت به <strong>logs</strong> در بهبود دید برنامه شما در <strong>production</strong> داشته باشد. آنها به منبع حیاتی برای جمع‌آوری اطلاعات و تشخیص تبدیل خواهند شد. با این حال، شما باید از برخی چالش‌های بالقوه مهم با <strong>logs</strong> آگاه باشید.
    </p>
<p>
        اولاً، همانطور که قبلاً به آن اشاره کردیم، به دلیل <strong>clock skew</strong>، آنها همیشه نمی‌توانند برای کمک به شما در درک ترتیب وقوع تماس‌ها به آنها اعتماد کنید. این <strong>clock skew</strong> بین ماشین‌ها همچنین به این معنی است که زمان‌بندی دقیق یک دنباله از تماس‌ها مشکل‌ساز خواهد بود، و به‌طور بالقوه استفاده <strong>logs</strong> را در ردیابی گلوگاه‌های <strong>latency</strong> محدود می‌کند.
    </p>
<p>
        با این حال، مشکل اصلی با <strong>logs</strong> این است که با داشتن <strong>microservices</strong> بیشتر و تماس‌های بیشتر، شما در نهایت مقدار زیادی داده تولید می‌کنید. بارها. مقادیر زیادی. این می‌تواند منجر به هزینه‌های بالاتر از نظر نیاز به سخت‌افزار بیشتر شود، و همچنین می‌تواند هزینه‌ای را که به ارائه دهنده سرویس خود پرداخت می‌کنید، افزایش دهد (برخی از ارائه دهندگان بر اساس استفاده هزینه دریافت می‌کنند). و بسته به نحوه ساخت زنجیره ابزار <strong>log aggregation</strong> شما، این می‌تواند منجر به چالش‌های مقیاس‌پذیری نیز شود. برخی از راه‌حل‌های <strong>log aggregation</strong> سعی می‌کنند هنگام دریافت داده‌های <strong>log</strong> یک شاخص ایجاد کنند تا پرس‌وجوها را سریع‌تر کنند. مشکل این است که نگهداری یک شاخص از نظر محاسباتی پرهزینه است—و هر چه <strong>logs</strong> بیشتری دریافت می‌کنید، و هر چه شاخص بزرگتر می‌شود، این مسئله می‌تواند مشکل‌سازتر شود. این امر منجر به نیاز به سفارشی‌تر شدن در آنچه <strong>log</strong> می‌کنید می‌شود تا این مشکل را کاهش دهید، که به نوبه خود می‌تواند کار بیشتری ایجاد کند و این خطر را به همراه دارد که شما ممکن است اطلاعاتی را که در غیر این صورت ارزشمند خواهد بود، از <strong>logging</strong> دور کنید. من با تیمی صحبت کردم که خوشه <strong>Elasticsearch</strong> را برای ابزارهای توسعه‌دهنده مبتنی بر <strong>SaaS</strong> مدیریت می‌کرد. او دریافت که بزرگترین خوشه <strong>Elasticsearch</strong> که می‌تواند با خوشحالی اجرا کند، فقط قادر خواهد بود که...
    </p>
<p>
        320 | Chapter 10: From Monitoring to Observability
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0346</div>
            </div>
        </div>
        <!-- Page 0347 -->
        <div class="chapter" id="page-0347">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        مدیریت شش هفته <strong>logging</strong> برای یکی از محصولاتش، باعث می‌شد که تیم دائماً مجبور باشد داده‌ها را جابه‌جا کند تا امور را قابل مدیریت نگه دارد. بخشی از دلیل اینکه من <strong>Humio</strong> را دوست دارم این است که این چیزی است که توسعه‌دهندگانش برای آن ساخته‌اند—به جای نگهداری یک شاخص، آنها بر جذب کارآمد و مقیاس‌پذیر داده‌ها با راه‌حل‌های هوشمند برای تلاش و کاهش زمان پرس‌وجو تمرکز می‌کنند.
    </p>
<p>
        حتی اگر راه‌حلی دارید که می‌تواند حجم <strong>logs</strong> مورد نظر شما را ذخیره کند، این <strong>logs</strong> می‌توانند حاوی اطلاعات ارزشمند و حساسی باشند. این بدان معناست که شما ممکن است مجبور شوید دسترسی به <strong>logs</strong> را محدود کنید (که می‌تواند تلاش‌های شما برای داشتن مالکیت جمعی از <strong>microservices</strong> خود در <strong>production</strong> را پیچیده‌تر کند)، و <strong>logs</strong> می‌تواند هدف احزاب مخرب باشد. بنابراین ممکن است لازم باشد که در نظر بگیرید که انواع خاصی از اطلاعات را <strong>logging</strong> نکنید (همانطور که در "صرفه جو باشید" در صفحه 373 به آن اشاره خواهیم کرد، اگر داده‌ای را ذخیره نکنید، نمی‌توان آن را سرقت کرد) تا تأثیر دسترسی توسط افراد غیرمجاز را کاهش دهید.
    </p>
<h4>Metrics Aggregation</h4>
<p>
        همانطور که در مورد چالش نگاه کردن به <strong>logs</strong> برای میزبان‌های مختلف، ما باید راه‌های بهتری برای جمع‌آوری و مشاهده داده‌ها در مورد سیستم‌های خود در نظر بگیریم. دانستن اینکه "خوب" چه شکلی دارد، هنگامی که ما به <strong>metrics</strong> برای یک سیستم پیچیده‌تر نگاه می‌کنیم، دشوار است. وب‌سایت ما تقریباً 50 کد خطای <strong>HTTP</strong> <strong>4XX</strong> در ثانیه را مشاهده می‌کند. آیا این بد است؟ <strong>CPU load</strong> در <strong>service</strong> کاتالوگ از زمان ناهار 20% افزایش یافته است؛ آیا مشکلی پیش آمده است؟ راز دانستن اینکه چه زمانی باید وحشت کرد و چه زمانی باید آرامش داشت، جمع‌آوری <strong>metrics</strong> در مورد نحوه رفتار سیستم شما در یک دوره زمانی به اندازه کافی طولانی است که الگوهای روشنی ظاهر شوند.
    </p>
<p>
        در یک محیط پیچیده‌تر، ما اغلب نمونه‌های جدیدی از <strong>microservices</strong> خود را ارائه خواهیم کرد، بنابراین ما می‌خواهیم سیستمی را انتخاب کنیم که جمع‌آوری <strong>metrics</strong> از میزبان‌های جدید را بسیار آسان کند. ما می‌خواهیم بتوانیم به یک <strong>metric</strong> جمع‌آوری شده برای کل سیستم نگاه کنیم—به عنوان مثال، میانگین <strong>CPU load</strong>—اما همچنین می‌خواهیم آن <strong>metric</strong> را برای تمام نمونه‌های یک <strong>service</strong> داده شده، یا حتی برای یک نمونه واحد از آن <strong>service</strong> جمع‌آوری کنیم. این بدان معناست که ما باید بتوانیم <strong>metadata</strong> را با <strong>metric</strong> مرتبط کنیم تا به ما اجازه دهد این ساختار را استنباط کنیم.
    </p>
<p>
        یکی دیگر از مزایای کلیدی درک روندها، در زمان برنامه‌ریزی ظرفیت است. آیا ما به حد خود می‌رسیم؟ چقدر طول می‌کشد تا به میزبان‌های بیشتری نیاز داشته باشیم؟ در گذشته، وقتی ما میزبان‌های فیزیکی خریداری می‌کردیم، این اغلب یک کار سالانه بود. در عصر جدید محاسبات درخواستی که توسط فروشندگان <strong>infrastructure as a service (IaaS)</strong> ارائه می‌شود، ما می‌توانیم در عرض چند دقیقه، اگر نه چند ثانیه، مقیاس را افزایش یا کاهش دهیم. این بدان معناست که اگر الگوهای استفاده خود را درک کنیم، می‌توانیم اطمینان حاصل کنیم که زیرساخت‌های کافی برای پاسخگویی به نیازهای خود داریم. هر چه در ردیابی روندها و دانستن اینکه با آنها چه کنیم، هوشمندتر باشیم، سیستم‌های ما مقرون به صرفه‌تر و پاسخگوتر خواهند بود.
    </p>
<p>
        Building Blocks for Observability | 321
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0347</div>
            </div>
        </div>
        <!-- Page 0348 -->
        <div class="chapter" id="page-0348">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        7 Charity Majors, “Metrics: Not the Observability Droids You’re Looking For,” Honeycomb (blog), October 24, 2017, https://oreil.ly/TEETp.
    </p>
<p>
        با توجه به ماهیت این نوع داده‌ها، ما ممکن است بخواهیم این <strong>metrics</strong> را با وضوح‌های مختلف ذخیره و گزارش کنیم. به عنوان مثال، من ممکن است بخواهم یک نمونه <strong>CPU</strong> برای سرورهای خود با وضوح یک نمونه در هر 10 ثانیه برای 30 دقیقه گذشته داشته باشم، تا بهتر به یک موقعیت که در حال حاضر در حال وقوع است، واکنش نشان دهم. از طرف دیگر، نمونه‌های <strong>CPU</strong> از سرورهای من از ماه گذشته احتمالاً فقط برای تجزیه و تحلیل روند کلی مورد نیاز هستند، بنابراین من ممکن است از محاسبه یک نمونه <strong>CPU</strong> متوسط بر اساس یک ساعت خوشحال باشم. این اغلب در پلتفرم‌های <strong>metrics</strong> استاندارد انجام می‌شود تا به کاهش زمان پرس‌وجو کمک کند و همچنین فضای ذخیره‌سازی داده‌ها را کاهش دهد. برای چیزی به سادگی نرخ <strong>CPU</strong>، این ممکن است خوب باشد، اما فرآیند تجمیع داده‌های قدیمی باعث می‌شود که ما اطلاعات را از دست بدهیم. مشکل با نیاز به تجمیع این داده‌ها این است که شما اغلب باید از قبل تصمیم بگیرید که چه چیزی را تجمیع کنید—شما باید از قبل حدس بزنید که چه اطلاعاتی را می‌توان از دست داد.
    </p>
<p>
        ابزارهای <strong>metrics</strong> استاندارد می‌توانند برای درک روندها یا حالت‌های شکست ساده کاملاً مناسب باشند. در واقع، آنها می‌توانند حیاتی باشند. اما آنها اغلب به ما کمک نمی‌کنند تا سیستم‌هایمان را <strong>observable</strong>تر کنیم، زیرا آنها انواع سؤالاتی را که می‌خواهیم بپرسیم محدود می‌کنند. زمانی که ما از قطعات ساده اطلاعاتی مانند زمان پاسخگویی، <strong>CPU</strong>، یا استفاده از فضای دیسک به تفکر گسترده‌تر در مورد انواع اطلاعاتی که می‌خواهیم ثبت کنیم، می‌رویم، اوضاع جالب می‌شود.
    </p>
<h4>Low versus high cardinality</h4>
<p>
        بسیاری از ابزارها، به‌ویژه ابزارهای جدیدتر، برای پذیرش ذخیره‌سازی و بازیابی داده‌های با <strong>high-cardinality</strong> ساخته شده‌اند. راه‌هایی برای توصیف <strong>cardinality</strong> وجود دارد، اما می‌توانید آن را به‌عنوان تعداد فیلدهایی در نظر بگیرید که می‌توان به راحتی در یک نقطه داده داده شده پرس‌وجو کرد. هرچه فیلدهای بالقوه بیشتری داشته باشیم که ممکن است بخواهیم از داده‌های خود پرس‌وجو کنیم، <strong>cardinality</strong> بالاتری را باید پشتیبانی کنیم. اساساً، این امر به دلایلی که من در اینجا در مورد آنها توضیح نمی‌دهم، اما مربوط به نحوه ساخت بسیاری از این سیستم‌ها است، در پایگاه‌های داده سری زمانی مشکل‌سازتر می‌شود.
    </p>
<p>
        به عنوان مثال، من ممکن است بخواهم نام <strong>microservice</strong>، <strong>customer ID</strong>، <strong>request ID</strong>، شماره ساخت نرم‌افزار، و <strong>product ID</strong> را در طول زمان ثبت و پرس‌وجو کنم. سپس من تصمیم می‌گیرم که اطلاعاتی را در مورد دستگاه در آن مرحله—سیستم عامل، معماری سیستم، ارائه‌دهنده <strong>cloud</strong>، و غیره—ثبت کنم. من ممکن است نیاز داشته باشم که تمام آن اطلاعات را برای هر نقطه داده‌ای که جمع‌آوری می‌کنم، ثبت کنم. با افزایش تعداد مواردی که ممکن است بخواهم در مورد آنها پرس‌وجو کنم، <strong>cardinality</strong> افزایش می‌یابد، و سیستم‌ها مشکلات بیشتری خواهند داشت که با در نظر گرفتن این مورد ساخته نشده‌اند. همانطور که <strong>Charity Majors</strong>،<sup>7</sup> بنیانگذار <strong>Honeycomb</strong>، توضیح می‌دهد:
    </p>
<p>
        322 | Chapter 10: From Monitoring to Observability
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0348</div>
            </div>
        </div>
        <!-- Page 0349 -->
        <div class="chapter" id="page-0349">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
        این موضوع اساساً به <strong>metric</strong> برمی‌گردد. <strong>Metric</strong> یک نقطه از داده است، یک عدد واحد با یک نام و برخی از برچسب‌های شناسایی‌کننده. تمام زمینه‌ای که می‌توانید دریافت کنید باید در آن برچسب‌ها وارد شود. اما انفجار نوشتن همه آن برچسب‌ها به دلیل نحوه ذخیره <strong>metrics</strong> در دیسک، پرهزینه است. ذخیره یک <strong>metric</strong> بسیار ارزان است، اما ذخیره یک برچسب گران است. و ذخیره تعداد زیادی از برچسب‌ها در هر <strong>metric</strong> باعث توقف سریع موتور ذخیره‌سازی شما می‌شود.
    </p>
<p>
        از نظر عملی، سیستم‌هایی که با در نظر گرفتن <strong>low cardinality</strong> ساخته شده‌اند، اگر سعی کنید داده‌های <strong>high-cardinality</strong> بیشتری را در آنها قرار دهید، با مشکل زیادی مواجه خواهند شد. به عنوان مثال، سیستم‌هایی مانند <strong>Prometheus</strong>، برای ذخیره قطعات نسبتاً ساده‌ای از اطلاعات، مانند نرخ <strong>CPU</strong> برای یک دستگاه داده شده، ساخته شده‌اند. از بسیاری جهات، ما می‌توانیم <strong>Prometheus</strong> و ابزارهای مشابه را به عنوان یک پیاده‌سازی عالی از ذخیره‌سازی و پرس‌وجوی <strong>metrics</strong> سنتی ببینیم. اما عدم توانایی در پشتیبانی از داده‌های با <strong>high-cardinality</strong> می‌تواند یک عامل محدودکننده باشد. توسعه‌دهندگان <strong>Prometheus</strong> در مورد این محدودیت کاملاً باز هستند:
    </p>
<p>
        به یاد داشته باشید که هر ترکیب منحصربه‌فرد از جفت‌های برچسب کلید-مقدار نشان‌دهنده یک سری زمانی جدید است، که می‌تواند مقدار داده ذخیره‌شده را به طرز چشمگیری افزایش دهد. از برچسب‌ها برای ذخیره ابعاد با <strong>high cardinality</strong> (بسیاری از مقادیر برچسب مختلف)، مانند <strong>user ID</strong>ها، آدرس‌های ایمیل، یا سایر مجموعه‌های نامحدود از مقادیر استفاده نکنید.
    </p>
<p>
        سیستم‌هایی که قادر به رسیدگی به <strong>high cardinality</strong> هستند، بیشتر می‌توانند به شما اجازه دهند که تعداد زیادی سؤال مختلف را از سیستم‌های خود بپرسید—اغلب سؤالاتی که قبلاً نمی‌دانستید که باید بپرسید. اکنون، این ممکن است یک مفهوم دشوار برای درک باشد، به‌ویژه اگر شما سیستم <strong>monolithic</strong> تک‌فرآیندی خود را با ابزارهای "متعارف‌تر" کاملاً مدیریت می‌کنید. حتی افرادی که سیستم‌های بزرگ‌تری دارند با سیستم‌های با <strong>low-cardinality</strong> کنار آمده‌اند، اغلب به این دلیل که چاره‌ای نداشتند. اما با افزایش پیچیدگی سیستم شما، شما نیاز خواهید داشت که کیفیت خروجی‌هایی را که سیستم شما ارائه می‌دهد، برای بهبود <strong>observability</strong> آن بهبود بخشید. این به معنای جمع‌آوری اطلاعات بیشتر و داشتن ابزارهایی است که به شما اجازه می‌دهد این داده‌ها را برش و تقسیم کنید.
    </p>
<h4>Implementations</h4>
<p>
        از زمان چاپ اول این کتاب، <strong>Prometheus</strong> به یک ابزار <strong>open source</strong> محبوب برای استفاده از جمع‌آوری و تجمیع <strong>metrics</strong> تبدیل شده است، و در مواردی که من قبلاً ممکن بود استفاده از <strong>Graphite</strong> را توصیه کنم (که در چاپ اول توصیه‌ام را دریافت کرد)، <strong>Prometheus</strong> می‌تواند جایگزینی معقول باشد. فضای تجاری نیز در این زمینه بسیار گسترش یافته است، و فروشندگان جدید و فروشندگان قدیمی به طور یکسان در حال ساخت یا بازسازی راه‌حل‌های موجود برای هدف قرار دادن کاربران <strong>microservice</strong> هستند.
    </p>
<p>
        با این حال، نگرانی‌های من در مورد داده‌های با <strong>low-</strong> در مقابل <strong>high-cardinality</strong> را در نظر داشته باشید. سیستم‌هایی که برای مدیریت داده‌های با <strong>low-cardinality</strong> ساخته شده‌اند، بازسازی آنها برای پشتیبانی از ذخیره‌سازی و پردازش <strong>high-cardinality</strong> بسیار دشوار خواهد بود. اگر شما به دنبال سیستم‌هایی هستید که قادر به ذخیره و مدیریت داده‌های با <strong>high cardinality</strong> هستند، که امکان مشاهده (و پرسش) بسیار پیچیده‌تری از رفتار سیستم شما را فراهم می‌کنند، من قویاً پیشنهاد می‌کنم به <strong>Honeycomb</strong> یا <strong>Lightstep</strong> نگاه کنید. اگرچه این ابزارها اغلب به عنوان راه‌حل‌هایی برای...
    </p>
<p>
        Building Blocks for Observability | 323
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0349</div>
            </div>
        </div>
        <!-- Page 0350 -->
        <div class="chapter" id="page-0350">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
<strong>distributed tracing</strong> (که ما در ادامه بیشتر به آن خواهیم پرداخت)، در ذخیره‌سازی، فیلتر کردن، و پرس‌وجو از داده‌های با <strong>high-cardinality</strong> بسیار توانمند هستند.
    </p>
<h4>Monitoring and Observability Systems Are Production Systems</h4>
<p>
        با مجموعه رو به رشدی از ابزارها برای کمک به ما در مدیریت معماری <strong>microservice</strong> خود، ما باید به یاد داشته باشیم که این ابزارها خودشان سیستم‌های <strong>production</strong> هستند. پلتفرم‌های <strong>log aggregation</strong>، ابزارهای <strong>distributed tracing</strong>، سیستم‌های هشدار—همه آنها برنامه‌هایی با مأموریت حیاتی هستند که اگر نه بیشتر، به اندازه نرم‌افزار خودمان حیاتی هستند. همان درجه دقت باید از نظر حفظ ابزارهای نظارت بر <strong>production</strong> ما اعمال شود، همانطور که ما برای نرم‌افزاری که می‌نویسیم و نگهداری می‌کنیم، اعمال می‌کنیم.
    </p>
<p>
        ما همچنین باید تشخیص دهیم که این ابزارها می‌توانند به ابزارهای بالقوه حمله از طرف اشخاص خارجی تبدیل شوند. در زمان نگارش این مقاله، دولت ایالات متحده و سایر سازمان‌های سراسر جهان در حال رسیدگی به کشف یک <strong>breach</strong> در نرم‌افزار مدیریت شبکه از <strong>SolarWinds</strong> هستند. اگرچه ماهیت دقیق این <strong>breach</strong> هنوز در حال بررسی است، اما اعتقاد بر این است که این همان چیزی است که به عنوان یک حمله زنجیره تأمین شناخته می‌شود. این نرم‌افزار که یک بار در سایت‌های مشتری نصب شد (و <strong>SolarWinds</strong> توسط 425 شرکت از 500 شرکت برتر <strong>US Fortune</strong> استفاده می‌شود)، به طرف‌های مخرب اجازه داد تا به شبکه‌های مشتریان، از جمله شبکه <strong>US Treasury</strong>، دسترسی خارجی پیدا کنند.
    </p>
<h4>Distributed Tracing</h4>
<p>
        تاکنون، من در درجه اول در مورد جمع‌آوری اطلاعات به صورت ایزوله صحبت کرده‌ام. بله، ما آن اطلاعات را تجمیع می‌کنیم، اما درک زمینه گسترده‌تری که در آن این اطلاعات ثبت شده‌اند، می‌تواند کلیدی باشد. اساساً، یک معماری <strong>microservice</strong> مجموعه‌ای از فرآیندها است که با هم کار می‌کنند تا نوعی کار را انجام دهند—ما راه‌های مختلفی را که می‌توانیم این فعالیت‌ها را در فصل 6 هماهنگ کنیم، بررسی کردیم.
    </p>
<p>
        بنابراین منطقی است که، هنگام تمایل به درک نحوه رفتار سیستم ما در یک محیط <strong>production</strong>، بتوانیم روابط بین <strong>microservices</strong>های خود را ببینیم. این می‌تواند به ما کمک کند تا نحوه رفتار سیستم خود را بهتر درک کنیم، تأثیر یک مشکل را ارزیابی کنیم، یا در تعیین اینکه دقیقاً چه چیزی آنطور که انتظار داریم کار نمی‌کند، بهتر شویم.
    </p>
<p>
        بنابراین، با پیچیده‌تر شدن سیستم‌های ما، مهم می‌شود که راهی برای دیدن این <strong>traces</strong> در سراسر سیستم‌های خود داشته باشیم. ما باید بتوانیم این داده‌های پراکنده را بیرون بکشیم تا یک نمای ترکیبی از مجموعه‌ای از تماس‌های مرتبط را به ما ارائه دهد. همانطور که قبلاً دیده‌ایم، انجام کاری ساده مانند قرار دادن <strong>correlation IDs</strong> در فایل‌های <strong>logfile</strong> ما یک شروع خوب است، اما این یک راه‌حل نسبتاً ساده است، به‌ویژه از آنجایی که ما در نهایت مجبور خواهیم شد ابزارهای سفارشی خودمان را برای کمک به تجسم، برش و تقسیم این داده‌ها ایجاد کنیم. اینجاست که <strong>distributed tracing</strong> وارد عمل می‌شود.
    </p>
<p>
        324 | Chapter 10: From Monitoring to Observability
    </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0350</div>
            </div>
        </div>
        <!-- Page 0351 -->
        <div class="chapter" id="page-0351">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>How it works</h4>
<p>
        اگرچه پیاده‌سازی‌های دقیق متفاوت است، به طور کلی، ابزارهای <strong>distributed tracing</strong> همگی به روشی مشابه کار می‌کنند. فعالیت محلی در داخل یک <strong>thread</strong> در یک <strong>span</strong> ثبت می‌شود. این <strong>spans</strong>های فردی با استفاده از یک شناسه منحصربه‌فرد همبسته می‌شوند. سپس <strong>spans</strong>ها به یک جمع‌کننده مرکزی ارسال می‌شوند، که قادر به ساخت این <strong>spans</strong>های مرتبط در یک <strong>trace</strong> واحد است.
    </p>
<figure>
<img alt="A distributed trace shown in Honeycomb, allowing you to identify where time is being spent for operations that can span multiple microservices" src="https://www.plantuml.com/plantuml/png/VP11QiCm38JpUeT9uJ5H9x8S6U0Oq_f0000"/>
<figcaption>شکل 10-7. یک <strong>trace distributed</strong> که در <strong>Honeycomb</strong> نشان داده شده است، به شما امکان می‌دهد مکان صرف زمان برای عملیاتی را که می‌تواند چندین <strong>microservices</strong> را شامل شود، شناسایی کنید</figcaption>
</figure>
<p>
        این <strong>spans</strong> به شما اجازه می‌دهد تا مجموعه‌ای از اطلاعات را جمع‌آوری کنید. دقیقاً چه داده‌هایی را جمع‌آوری می‌کنید به <strong>protocol</strong>ی که استفاده می‌کنید بستگی دارد، اما در مورد <strong>OpenTracing API</strong>، هر <strong>span</strong> شامل زمان شروع و پایان، مجموعه‌ای از <strong>logs</strong> مرتبط با <strong>span</strong>، و مجموعه‌ای دلخواه از جفت‌های کلید-مقدار برای کمک به پرس‌وجوی بعدی (اینها می‌توانند برای ارسال مواردی مانند <strong>customer ID</strong>، یک <strong>order ID</strong>، یک <strong>hostname</strong>، یک شماره ساخت، و مانند آن استفاده شوند).
    </p>
<p>
        جمع‌آوری اطلاعات کافی برای اینکه به ما اجازه دهد تماس‌ها را در سیستم خود ردیابی کنیم، می‌تواند تأثیر مستقیمی بر خود سیستم داشته باشد. این منجر به نیاز به نوعی نمونه‌برداری می‌شود، که در آن برخی از اطلاعات صریحاً از جمع‌آوری <strong>trace</strong> ما حذف می‌شود تا اطمینان حاصل شود که سیستم هنوز می‌تواند کار کند. چالش این است که اطمینان حاصل شود که اطلاعات صحیح حذف می‌شود، و ما هنوز نمونه‌های کافی را جمع‌آوری می‌کنیم تا به ما اجازه دهد مشاهدات را به درستی برون‌یابی کنیم.
    </p>
<p>
        Building Blocks for Observability | 325
    </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 351" src="page_0351/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0351</div>
            </div>
        </div>
        <!-- Page 0352 -->
        <div class="chapter" id="page-0352">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>راهبردهای نمونه‌برداری</h3>
<p>
    راهبردهای نمونه‌برداری می‌توانند بسیار <strong>basic</strong> باشند. سیستم <strong>Google’s Dapper</strong> که الهام‌بخش بسیاری از ابزارهای <strong>distributed tracing</strong> بعدی شد، یک نمونه‌برداری <strong>highly aggressive random</strong> را انجام می‌داد. درصد مشخصی از تماس‌ها نمونه‌برداری می‌شدند و تمام. برای مثال، <strong>Jaeger</strong>، تنها ۱ تماس از ۱۰۰۰ تماس را در تنظیمات پیش‌فرض خود ثبت می‌کند. ایده این است که اطلاعات کافی را برای درک آنچه سیستم ما انجام می‌دهد، ثبت کنیم، اما آن‌قدر اطلاعات ثبت نکنیم که خود سیستم نتواند پاسخگو باشد. ابزارهایی مانند <strong>Honeycomb</strong> و <strong>Lightstep</strong> می‌توانند نمونه‌برداری پویا و ظریف‌تری را نسبت به این نمونه‌برداری تصادفی ساده ارائه دهند. یک مثال از نمونه‌برداری <strong>dynamic</strong> می‌تواند این باشد که شما می‌خواهید نمونه‌های بیشتری را برای انواع خاصی از رویدادها داشته باشید—برای مثال، ممکن است بخواهید از هر چیزی که یک <strong>error</strong> تولید می‌کند نمونه‌برداری کنید، اما از نمونه‌برداری تنها ۱ در ۱۰۰ عملیات موفق در صورتی که همگی بسیار شبیه به هم باشند، خوشحال خواهید شد.
  </p>
<h3>پیاده‌سازی <strong>distributing tracing</strong></h3>
<p>
    راه‌اندازی و اجرای <strong>distributed tracing</strong> برای سیستم شما به چند چیز نیاز دارد.
  </p>
<ol>
<li>
      ابتدا، شما نیاز دارید که اطلاعات <strong>span</strong> را در داخل <strong>microservices</strong> خود ثبت کنید. اگر از یک <strong>API</strong> استاندارد مانند <strong>OpenTracing</strong> یا <strong>OpenTelemetry API</strong> جدیدتر استفاده می‌کنید، ممکن است متوجه شوید که برخی از کتابخانه‌ها و <strong>frameworks</strong> شخص ثالث، از این <strong>APIs</strong> پشتیبانی داخلی دارند و در حال حاضر اطلاعات مفیدی را ارسال می‌کنند (به عنوان مثال، به طور خودکار اطلاعاتی درباره تماس‌های <strong>HTTP</strong> ثبت می‌کنند). اما حتی اگر این کار را انجام دهند، احتمالاً همچنان می‌خواهید کد خود را <strong>instrument</strong> کنید، و اطلاعات مفیدی درباره آنچه <strong>microservice</strong> شما در هر لحظه انجام می‌دهد، ارائه دهید.
    </li>
<li>
      در مرحله بعد، شما به روشی برای ارسال این اطلاعات <strong>span</strong> به <strong>collector</strong> خود نیاز دارید—ممکن است این باشد که این داده‌ها را مستقیماً از نمونه <strong>microservice</strong> خود به <strong>collector</strong> مرکزی ارسال کنید، اما استفاده از یک <strong>local forwarding agent</strong> بسیار رایج‌تر است. بنابراین، مانند تجمیع لاگ‌ها، شما یک <strong>agent</strong> را به صورت محلی در نمونه <strong>microservice</strong> خود اجرا می‌کنید، که به طور دوره‌ای اطلاعات <strong>span</strong> را به یک <strong>collector</strong> مرکزی ارسال می‌کند. استفاده از یک <strong>local agent</strong> معمولاً امکانات پیشرفته‌تری را فراهم می‌کند، مانند تغییر نمونه‌برداری یا اضافه کردن <strong>tags</strong> اضافی، و همچنین می‌تواند اطلاعات در حال ارسال را به طور موثرتری بافر کند.
    </li>
<li>
      در نهایت، البته، شما به یک <strong>collector</strong> نیاز دارید که قادر به دریافت این اطلاعات و درک همه آن‌ها باشد.
    </li>
</ol>
<p>
    در فضای <strong>open source</strong>، <strong>Jaeger</strong> به عنوان یک انتخاب محبوب برای <strong>distributed tracing</strong> ظاهر شده است. برای ابزارهای تجاری، من با نگاهی به <strong>Lightstep</strong> و <strong>Honeycomb</strong> که قبلاً ذکر شد، شروع می‌کنم. با این حال، از شما می‌خواهم چیزی را انتخاب کنید که متعهد به پشتیبانی از <strong>OpenTelemetry API</strong> باشد. <strong>OpenTelemetry</strong> یک مشخصات <strong>API open</strong> است که باعث می‌شود کد مانند <strong>database drivers</strong> یا <strong>web frameworks</strong> با پشتیبانی از <strong>tracing</strong>، از ابتدا ساده‌تر شود و همچنین می‌تواند قابلیت حمل آسان‌تری را در میان فروشندگان مختلف در سمت جمع‌آوری به شما ارائه دهد. بر اساس کار انجام شده توسط <strong>OpenTracing</strong> و <strong>OpenConsensus APIs</strong> قبلی، این <strong>API</strong> اکنون از پشتیبانی گسترده صنعت برخوردار است.
  </p>
<p>
    326
    |
    Chapter 10: From Monitoring to Observability
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0352</div>
            </div>
        </div>
        <!-- Page 0353 -->
        <div class="chapter" id="page-0353">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>آیا ما خوب پیش می‌رویم؟</h3>
<p>
    ما زیاد درباره چیزهایی صحبت کردیم که شما می‌توانید به عنوان <strong>operator</strong> یک سیستم انجام دهید—<strong>mindset</strong> مورد نیاز شما، اطلاعاتی که ممکن است نیاز به جمع‌آوری آن‌ها داشته باشید. اما چگونه می‌دانید که آیا بیش از حد انجام می‌دهید—یا به اندازه کافی نه؟ چگونه می‌دانید که آیا به اندازه کافی خوب کار می‌کنید، یا اینکه سیستم شما به اندازه کافی خوب کار می‌کند؟
  </p>
<p>
    مفاهیم <strong>binary</strong> یک سیستم که "<strong>up</strong>" یا "<strong>down</strong>" است، با پیچیده‌تر شدن سیستم، معنای کمتری پیدا می‌کنند. با یک سیستم <strong>monolithic</strong> تک‌فرآیندی، دیدن سلامت سیستم به عنوان یک کیفیت سیاه و سفید آسان‌تر است. اما در مورد یک سیستم <strong>distributed</strong> چطور؟ اگر یک نمونه از یک <strong>microservice</strong> غیرقابل دسترس باشد، آیا این یک مشکل است؟ آیا یک <strong>microservice</strong> "<strong>healthy</strong>" است اگر قابل دسترس باشد؟ در مورد موقعیتی که <strong>Returns microservice</strong> ما در دسترس است، اما نیمی از عملکردی که ارائه می‌دهد به استفاده از <strong>Inventory microservice</strong> <strong>downstream</strong> نیاز دارد، که در حال حاضر با مشکل مواجه است، چطور؟ آیا این بدان معناست که ما <strong>Returns microservice</strong> را سالم یا ناسالم در نظر می‌گیریم؟
  </p>
<p>
    با پیچیده‌تر شدن مسائل، مهم‌تر می‌شود که یک گام به عقب بردارید و از یک نقطه نظر متفاوت به مسائل فکر کنید. به یک کندوی زنبور عسل فکر کنید. شما می‌توانید به یک زنبور منفرد نگاه کنید و تعیین کنید که خوشحال نیست. شاید یکی از بال‌هایش را از دست داده باشد و بنابراین دیگر نمی‌تواند پرواز کند. این قطعاً یک مشکل برای آن زنبور منفرد است، اما آیا می‌توانید از آن هر مشاهده‌ای در مورد سلامت خود کندو را استخراج کنید؟ نه—شما باید به سلامت کندو به روشی جامع‌تر نگاه کنید.
    یک زنبور بیمار بودن به این معنی نیست که کل کندو بیمار است.
  </p>
<p>
    ما می‌توانیم سعی کنیم بفهمیم آیا یک <strong>service</strong> سالم است یا نه، به عنوان مثال، با تصمیم‌گیری در مورد اینکه سطح <strong>CPU</strong> خوب چیست، یا چه چیزی زمان پاسخ‌گویی قابل قبولی را ایجاد می‌کند. اگر سیستم <strong>monitoring</strong> ما تشخیص دهد که مقادیر واقعی خارج از این سطح ایمن هستند، می‌توانیم یک <strong>alert</strong> را فعال کنیم. با این حال، از بسیاری جهات، این مقادیر یک قدم از آنچه ما واقعاً می‌خواهیم ردیابی کنیم فاصله دارند—یعنی، آیا سیستم در حال کار است؟ هرچه تعاملات بین <strong>services</strong> پیچیده‌تر باشد، از پاسخ دادن به این سوال با نگاه کردن به یک <strong>metric</strong> به صورت جداگانه دورتر می‌شویم.
  </p>
<p>
    بنابراین ما می‌توانیم اطلاعات زیادی جمع‌آوری کنیم، اما به خودی خود این به ما کمک نمی‌کند تا به این سوال پاسخ دهیم که آیا سیستم به درستی کار می‌کند یا خیر. برای این کار، ما باید کمی بیشتر از نظر تعریف آنچه رفتار قابل قبول به نظر می‌رسد، شروع به فکر کنیم. کارهای زیادی در زمینه <strong>site reliability engineering (SRE)</strong> انجام شده است، که تمرکز آن بر این است که چگونه می‌توانیم اطمینان حاصل کنیم که سیستم‌های ما می‌توانند قابل اعتماد باشند و در عین حال امکان تغییر را نیز فراهم کنند.
    از این فضا، ما چند مفهوم مفید برای بررسی داریم.
    آماده شوید—ما در حال ورود به شهر <strong>acronym</strong>ها هستیم.
  </p>
<h4>توافقنامه سطح سرویس</h4>
<p>
    یک <strong>service-level agreement (SLA)</strong> یک توافق است که بین افرادی که سیستم را می‌سازند و افرادی که از سیستم استفاده می‌کنند، حاصل می‌شود. این نه تنها آنچه را که کاربران می‌توانند انتظار داشته باشند توصیف می‌کند، بلکه آنچه را که در صورت عدم رسیدن سیستم به این سطح قابل قبول اتفاق می‌افتد نیز شرح می‌دهد.
    Building Blocks for Observability
    |
    327
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0353</div>
            </div>
        </div>
        <!-- Page 0354 -->
        <div class="chapter" id="page-0354">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
    8 Mostly. <strong>AWS</strong> در حال حاضر نمونه‌های <strong>bare metal</strong> را ارائه می‌دهد، که کمی مغزم را به هم می‌ریزد.
  </p>
<p>
    رفتار. <strong>SLAs</strong> تمایل دارند بسیار در سطح "حداقل" باشند، اغلب تا جایی که اگر سیستم فقط به اهداف خود برسد، کاربر نهایی همچنان ناراضی خواهد بود. به عنوان مثال، <strong>AWS</strong> یک <strong>SLA</strong> برای سرویس محاسباتی خود دارد. این موضوع روشن می‌کند که هیچ تضمین موثری برای <strong>uptime</strong> برای یک نمونه <strong>EC2</strong> واحد (یک ماشین مجازی مدیریت شده8) وجود ندارد. <strong>AWS</strong> بیان می‌کند که تمام تلاش خود را می‌کند تا <strong>uptime</strong> 90% را برای یک نمونه معین تضمین کند، اما اگر این کار محقق نشد، فقط برای ساعتی که نمونه در دسترس نبوده است، از شما هزینه‌ای دریافت نمی‌کند. حال، اگر نمونه‌های <strong>EC2</strong> شما دائماً در یک ساعت معین به در دسترس بودن 90٪ نرسند و باعث بی‌ثباتی قابل توجه سیستم شوند، ممکن است هزینه‌ای از شما دریافت نشود، اما همچنین خیلی خوشحال نخواهید بود. طبق تجربه من، <strong>AWS</strong> در عمل بسیار بیش از آنچه <strong>SLA</strong> مشخص می‌کند به دست می‌آورد، همانطور که اغلب در مورد <strong>SLAs</strong> صدق می‌کند.
  </p>
<h4>اهداف سطح سرویس</h4>
<p>
    نقشه‌برداری از یک <strong>SLA</strong> برای یک تیم مشکل‌ساز است، به‌خصوص اگر <strong>SLA</strong> تا حدودی گسترده و <strong>cross-cutting</strong> باشد. در سطح تیم، ما به جای آن در مورد اهداف سطح سرویس (<strong>SLOs</strong>) صحبت می‌کنیم. <strong>SLOs</strong> تعریف می‌کنند که تیم برای ارائه چه چیزی ثبت‌نام می‌کند. دستیابی به <strong>SLOs</strong> هر تیم در سراسر سازمان، الزامات <strong>SLAs</strong> سازمان را برآورده می‌کند (و احتمالاً بسیار فراتر می‌رود). <strong>SLOs</strong> نمونه می‌تواند شامل مواردی مانند <strong>uptime</strong> مورد انتظار یا زمان پاسخ‌گویی قابل قبول برای یک عملیات معین باشد.
  </p>
<p>
    خیلی ساده‌لوحانه است که فکر کنیم <strong>SLOs</strong> چیزی است که یک تیم برای دستیابی سازمان به <strong>SLAs</strong> خود باید انجام دهد. بله، اگر کل سازمان به تمام <strong>SLOs</strong> خود برسد، ما فرض می‌کنیم که همه <strong>SLAs</strong> نیز محقق شده‌اند، اما <strong>SLOs</strong> می‌توانند با اهداف دیگری که در <strong>SLA</strong> مشخص نشده‌اند صحبت کنند—یا ممکن است آرمان‌گرا باشند، می‌توانند <strong>inward facing</strong> باشند (تلاش برای انجام برخی از تغییرات داخلی). <strong>SLOs</strong> اغلب می‌تواند چیزی را منعکس کند که خود تیم می‌خواهد به آن دست یابد که ممکن است هیچ ارتباطی با یک <strong>SLA</strong> نداشته باشد.
  </p>
<h4>شاخص‌های سطح سرویس</h4>
<p>
    برای تعیین اینکه آیا ما <strong>SLOs</strong> خود را برآورده می‌کنیم، باید داده‌های واقعی را جمع‌آوری کنیم. این چیزی است که شاخص‌های سطح سرویس (<strong>SLI</strong>) ما هستند. یک <strong>SLI</strong> اندازه‌گیری چیزی است که نرم‌افزار ما انجام می‌دهد. به عنوان مثال، می‌تواند زمان پاسخ‌گویی از یک فرآیند، ثبت نام مشتری، <strong>error</strong> ایجاد شده برای مشتری یا ثبت سفارش باشد. ما باید این <strong>SLIs</strong> را جمع‌آوری و <strong>surface</strong> کنیم تا مطمئن شویم که <strong>SLOs</strong> خود را برآورده می‌کنیم.
  </p>
<h4>بودجه‌های خطا</h4>
<p>
    وقتی چیزهای جدید را امتحان می‌کنیم، بی‌ثباتی بیشتری را به سیستم‌های خود تزریق می‌کنیم. بر این اساس، تمایل به حفظ (یا بهبود) پایداری سیستم می‌تواند منجر به دلسرد شدن تغییر شود. بودجه‌های خطا تلاشی برای جلوگیری از این مشکل با روشن بودن میزان خطای قابل قبول در یک سیستم است.
  </p>
<p>
    328
    |
    Chapter 10: From Monitoring to Observability
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0354</div>
            </div>
        </div>
        <!-- Page 0355 -->
        <div class="chapter" id="page-0355">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
    اگر از قبل در مورد یک <strong>SLO</strong> تصمیم گرفته‌اید، پس محاسبه بودجه خطای شما باید کاملاً واضح باشد. به عنوان مثال، ممکن است بگویید که <strong>microservice</strong> شما باید 99.9٪ از زمان در هر فصل، به صورت 24/7 در دسترس باشد. این بدان معناست که شما در واقع مجاز هستید که برای 2 ساعت و 11 دقیقه در هر فصل <strong>down</strong> باشید. از نظر آن <strong>SLO</strong>، این بودجه خطای شما است.
  </p>
<p>
    بودجه‌های خطا به شما کمک می‌کنند تا درک روشنی از این داشته باشید که چقدر خوب به یک <strong>SLO</strong> دست می‌یابید (یا نه)، که به شما امکان می‌دهد تصمیمات بهتری در مورد ریسک‌هایی که باید بپذیرید، بگیرید. اگر برای فصل جاری، خیلی کمتر از بودجه خطای خود هستید، شاید با راه‌اندازی آن <strong>microservice</strong> که به یک زبان برنامه‌نویسی جدید نوشته شده است، مشکلی نداشته باشید. اگر قبلاً از بودجه خطای خود فراتر رفته‌اید، شاید آن راه‌اندازی را به تعویق بیندازید و در عوض، بیشتر زمان تیم را بر بهبود قابلیت اطمینان سیستم خود متمرکز کنید.
  </p>
<p>
    بودجه‌های خطا به همان اندازه که درباره دادن فضای تنفس به تیم‌ها برای امتحان چیزهای جدید است، اهمیت دارد.
  </p>
<h4>هشدار دادن</h4>
<p>
    گاهی اوقات (امیدوارم به ندرت، اما احتمالاً بیشتر از آنچه دوست داریم)، اتفاقی در سیستم‌های ما رخ می‌دهد که نیاز به این دارد که یک <strong>human operator</strong> مطلع شود تا اقدام کند. ممکن است یک <strong>microservice</strong> به طور غیرمنتظره‌ای غیرقابل دسترس شده باشد، ممکن است تعداد خطاهای بیشتری از آنچه انتظار داریم را ببینیم، یا شاید کل سیستم برای کاربران ما غیرقابل دسترس شده باشد. در این شرایط، ما نیاز داریم که مردم از آنچه در حال رخ دادن است آگاه شوند تا بتوانند سعی کنند و اوضاع را درست کنند.
  </p>
<p>
    مشکل این است که با معماری <strong>microservice</strong>، با توجه به تعداد تماس‌های بیشتر، تعداد فرآیندهای بیشتر، و زیرساخت پیچیده‌تر، اغلب چیزهایی اشتباه پیش می‌رود. چالش در یک محیط <strong>microservice</strong> این است که دقیقاً مشخص کنیم چه نوع مشکلاتی باید باعث شود یک انسان مطلع شود و دقیقاً چگونه باید به او گفته شود.
  </p>
<h4>برخی مشکلات بدتر از بقیه هستند</h4>
<p>
    وقتی مشکلی پیش می‌آید، ما می‌خواهیم از آن مطلع شویم. یا واقعاً می‌خواهیم؟ آیا همه مشکلات یکسان هستند؟ با افزایش منابع مشکلات، ممکن است مهم‌تر شود که بتوانیم این مسائل را اولویت‌بندی کنیم تا تصمیم بگیریم که آیا و چگونه یک <strong>human operator</strong> باید درگیر شود. اغلب بزرگترین سؤالی که من در مورد هشدار دادن از خودم می‌پرسم این است که، "آیا این مشکل باید باعث شود کسی ساعت 3 صبح بیدار شود؟"
  </p>
<p>
    من یک مثال از این تفکر را در حالی که سال‌ها پیش مدتی را در محوطه <strong>Google</strong> سپری می‌کردم دیدم. در قسمت پذیرش یکی از ساختمان‌ها در <strong>Mountain View</strong> یک قفسه قدیمی از ماشین‌ها وجود داشت، که به نوعی نمایشگاه بود. من متوجه چند چیز شدم. اول، این سرورها در محفظه‌های سرور نبودند. آن‌ها فقط <strong>motherboard</strong>های خالی بودند که در قفسه قرار داشتند. اما نکته اصلی که متوجه شدم این بود که هارد دیسک‌ها توسط <strong>Velcro</strong> متصل شده بودند. من از یکی از <strong>Googler</strong>ها پرسیدم چرا اینطور است. او گفت: "اوه،"
  </p>
<p>
    Building Blocks for Observability
    |
    329
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0355</div>
            </div>
        </div>
        <!-- Page 0356 -->
        <div class="chapter" id="page-0356">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
    9 United States President’s Commission on the Accident at Three Mile Island, The Need for Change, the Legacy
    of TMI: Report of the President’s Commission on the Accident at Three Mile Island (Washington, DC: The
    Commission, 1979).
  </p>
<p>
    10 National Transportation Safety Board, Safety Recommendation Report: Assumptions Used in the Safety Assess‐
    ment Process and the Effects of Multiple Alerts and Indications on Pilot Performance (Washington, DC: NTSB,
    2019).
  </p>
<p>
    هارد دیسک‌ها خیلی خراب می‌شوند، ما نمی‌خواهیم آن‌ها را پیچ کنیم. ما فقط آن‌ها را بیرون می‌کشیم، در سطل زباله می‌اندازیم و یک هارد دیسک جدید را با <strong>Velcro</strong> می‌چسبانیم.»
  </p>
<p>
    سیستم‌هایی که <strong>Google</strong> ساخت، فرض می‌کردند که هارد دیسک‌ها خراب می‌شوند. این طراحی این سرورها را بهینه کرد تا اطمینان حاصل شود که تعویض هارد دیسک تا حد امکان آسان است. از آنجایی که سیستم برای تحمل خرابی یک هارد دیسک ساخته شده بود، در حالی که مهم بود که در نهایت درایو جایگزین شود، احتمالاً خرابی یک هارد دیسک واحد باعث هیچ مشکل قابل توجهی نخواهد شد که برای کاربر قابل مشاهده باشد. با هزاران سرور در یک <strong>data center Google</strong>، این کار روزانه کسی خواهد بود که فقط در امتداد یک ردیف از رک‌ها راه برود و هارد دیسک‌ها را در حین کار جایگزین کند. مطمئناً، خرابی درایو یک مسئله بود، اما مسئله‌ای بود که می‌توانست به روشی معمول با آن برخورد کرد. خرابی هارد دیسک <strong>routine</strong> در نظر گرفته می‌شد—ارزش تماس با کسی خارج از ساعات کاری منظم را نداشت، اما شاید فقط چیزی بود که آن‌ها باید در طول روز کاری عادی خود در مورد آن مطلع می‌شدند.
  </p>
<p>
    با افزایش منابع مشکلات احتمالی خود، باید در اولویت‌بندی اینکه چه چیزهایی باعث ایجاد چه نوع <strong>alerts</strong> می‌شوند، بهتر شوید. در غیر این صورت، ممکن است خود را در تلاش برای جدا کردن چیزهای بی‌اهمیت از چیزهای فوری بیابید.
  </p>
<h4>خستگی هشدار</h4>
<p>
    اغلب، هشدارهای زیاد می‌تواند باعث ایجاد مشکلات قابل توجهی شود. در سال 1979، یک <strong>partial meltdown</strong> از یک راکتور در نیروگاه هسته‌ای <strong>Three Mile Island</strong> در ایالات متحده رخ داد. تحقیقات در مورد این حادثه این واقعیت را برجسته کرد که <strong>operators</strong> این تأسیسات آنقدر از هشدارهایی که می‌دیدند غرق شده بودند که تعیین اینکه چه اقدامی باید انجام شود، غیرممکن بود. یک هشدار وجود داشت که مشکل اساسی را نشان می‌داد که باید به آن رسیدگی می‌شد، اما این چیزی نبود که برای <strong>operators</strong> آشکار باشد، زیرا هشدارهای بسیار دیگری همزمان فعال بودند. در طول جلسه استماع عمومی در مورد این حادثه، یکی از <strong>operators</strong>، <strong>Craig Faust</strong>، به یاد آورد که "من دوست داشتم تابلوی هشدار را دور بیندازم. این هیچ اطلاعات مفیدی به ما نمی‌داد." گزارش این حادثه نتیجه گرفت که اتاق کنترل "برای مدیریت یک حادثه بسیار ناکافی بود."9
  </p>
<p>
    اخیراً، ما این مشکل را دیده‌ایم که هشدارهای زیادی در زمینه یک سری حوادث با هواپیمای 737 <strong>Max</strong> مطرح شده است که شامل دو سانحه هوایی جداگانه بود که در مجموع 346 نفر را کشت. گزارش اولیه10 در مورد مسائل توسط <strong>US National Transportation Safety Board (NTSB)</strong> توجه را به هشدارهای گیج‌کننده جلب کرد
  </p>
<p>
    330
    |
    Chapter 10: From Monitoring to Observability
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0356</div>
            </div>
        </div>
        <!-- Page 0357 -->
        <div class="chapter" id="page-0357">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
    که در شرایط دنیای واقعی فعال شده بودند و به عنوان عوامل مؤثر در سقوط در نظر گرفته می‌شدند. از گزارش:
  </p>
<p>
    تحقیقات در مورد عوامل انسانی نشان داده است که برای شرایط غیرعادی، مانند موارد شامل <strong>system failure</strong> با هشدارهای متعدد، که ممکن است به اقدامات متعدد خدمه پرواز نیاز داشته باشد، ارائه درک به خلبانان در مورد اینکه کدام اقدامات باید اولویت داشته باشند، یک نیاز حیاتی است. این امر به‌ویژه در مورد عملکردهای پیاده‌سازی شده در سیستم‌های متعدد هواپیما صادق است، زیرا خرابی در یک سیستم در معماری‌های سیستم بسیار یکپارچه می‌تواند هشدارهای متعدد و نشانه‌هایی را برای خدمه پرواز ارائه دهد، زیرا هر سیستم رابط، <strong>failure</strong> را ثبت می‌کند... بنابراین، مهم است که تعاملات سیستم و <strong>interface</strong> کابین خلبان به گونه‌ای طراحی شوند که به هدایت خلبانان به اقدام(های) با بالاترین اولویت کمک کند.
  </p>
<p>
    بنابراین ما در اینجا در مورد راه‌اندازی یک راکتور هسته‌ای و پرواز با هواپیما صحبت می‌کنیم. من مشکوکم که بسیاری از شما در حال حاضر از خود می‌پرسید که این چه ربطی به سیستمی دارد که در حال ساخت آن هستید. اکنون این امکان وجود دارد (اگر نه محتمل) که شما سیستم‌های حساس به ایمنی مانند این را نمی‌سازید، اما ما می‌توانیم از این مثال‌ها چیزهای زیادی یاد بگیریم. هر دو شامل سیستم‌های بسیار پیچیده و مرتبط با هم هستند که در آن یک مشکل در یک ناحیه می‌تواند باعث ایجاد مشکل در ناحیه دیگر شود. و هنگامی که ما هشدارهای زیادی تولید می‌کنیم، یا به <strong>operators</strong> این توانایی را نمی‌دهیم که اولویت‌بندی کنند که روی کدام هشدارها باید تمرکز شود، فاجعه می‌تواند به دنبال داشته باشد. غلبه بر یک <strong>operator</strong> با هشدارها می‌تواند باعث ایجاد مشکلات واقعی شود. دوباره از گزارش:
  </p>
<p>
    علاوه بر این، تحقیقات در مورد پاسخ‌های خلبان به موقعیت‌های ناهنجار متعدد/همزمان، همراه با داده‌های حاصل از سوانح، نشان می‌دهد که هشدارهای متعدد رقابتی ممکن است از منابع ذهنی موجود فراتر رفته و تمرکز توجه را محدود کند که منجر به پاسخ‌های تأخیری یا ناکافی اولویت‌بندی شده می‌شود.
  </p>
<p>
    بنابراین دو بار فکر کنید قبل از اینکه به سادگی هشدارهای بیشتری را برای یک <strong>operator</strong> مطرح کنید—ممکن است آنچه را که می‌خواهید به دست نیاورید.
  </p>
<h4>هشدار در مقابل <strong>Alert</strong></h4>
<p>
    هنگامی که به طور گسترده‌تری به موضوع هشدار نگاه می‌کنیم، تحقیقات و رویه‌های بسیار مفیدی را از تعدادی از زمینه‌ها یافتم، که بسیاری از آن‌ها به‌طور خاص در مورد هشدار در سیستم‌های <strong>IT</strong> صحبت نمی‌کردند. اصطلاح <strong>alarm</strong> معمولاً هنگام بررسی این موضوع در مهندسی و فراتر از آن مواجه می‌شود، در حالی که ما تمایل داریم از اصطلاح <strong>alert</strong> در <strong>IT</strong> بیشتر استفاده کنیم. من با چند نفر صحبت کردم که تمایزی بین این دو اصطلاح قائل بودند، اما به اندازه کافی عجیب، تمایزاتی که مردم بین این دو اصطلاح قائل بودند، به نظر نمی‌رسید که سازگار باشد. بر اساس این واقعیت که به نظر می‌رسد اکثر مردم اصطلاحات <strong>alert</strong> و <strong>alarm</strong> را تقریباً یکسان می‌دانند، و بر این واقعیت که در جایی که تمایزی بین این دو وجود داشت، سازگار نبود، من تصمیم گرفته‌ام که اصطلاح <strong>alert</strong> را برای این کتاب استاندارد کنم.
  </p>
<p>
    Building Blocks for Observability
    |
    331
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0357</div>
            </div>
        </div>
        <!-- Page 0358 -->
        <div class="chapter" id="page-0358">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>
    11 <strong>Steven Shorrock</strong>, “Alarm Design: From Nuclear Power to <strong>WebOps</strong>,” <strong>Humanistic Systems</strong> (blog), October 16,
    2015, https://oreil.ly/RCHDL.
  </p>
<h4>به سوی هشدارهای بهتر</h4>
<p>
    بنابراین ما می‌خواهیم از داشتن هشدارهای زیاد و همچنین داشتن هشدارهایی که مفید نیستند اجتناب کنیم. چه دستورالعمل‌هایی را می‌توانیم برای کمک به ایجاد هشدارهای بهتر در نظر بگیریم؟
  </p>
<p>
<strong>Steven Shorrock</strong> در مقاله خود "<strong>Alarm Design: From Nuclear Power to WebOps</strong>،"11 به این موضوع می‌پردازد، که یک مقاله عالی است و یک نقطه شروع خوب برای مطالعه بیشتر در این زمینه است. از این مقاله:
  </p>
<p>
    هدف از [هشدارها] این است که توجه کاربر را به جنبه‌های مهم عملیات یا تجهیزاتی که نیاز به توجه به موقع دارند، جلب کند.
  </p>
<p>
    با بهره‌گیری از کار خارج از توسعه نرم‌افزار، ما مجموعه‌ای مفید از قوانین را از، از همه جا، <strong>Engineering Equipment and Materials Users Association (EEMUA)</strong> داریم، که به خوبی توصیف کرده است که چه چیزی یک هشدار خوب را می‌سازد، همانطور که من دیده‌ام:
  </p>
<ul>
<li>
      مرتبط
      <p>مطمئن شوید که هشدار ارزشمند است.</p>
</li>
<li>
      منحصر به فرد
      <p>اطمینان حاصل کنید که هشدار، هشدار دیگری را تکرار نمی‌کند.</p>
</li>
<li>
      به موقع
      <p>ما باید هشدار را به اندازه کافی سریع دریافت کنیم تا از آن استفاده کنیم.</p>
</li>
<li>
      اولویت‌بندی شده
      <p>به <strong>operator</strong> اطلاعات کافی برای تصمیم‌گیری در مورد اینکه هشدارها به چه ترتیبی باید رسیدگی شوند، بدهید.</p>
</li>
<li>
      قابل فهم
      <p>اطلاعات موجود در هشدار باید واضح و خوانا باشد.</p>
</li>
<li>
      تشخیصی
      <p>باید مشخص شود که چه چیزی اشتباه است.</p>
</li>
<li>
      مشاوره‌ای
      <p>به <strong>operator</strong> کمک کنید تا اقدامات مورد نیاز را درک کند.</p>
</li>
<li>
      متمرکز
      <p>توجه را به مهمترین مسائل جلب کنید.</p>
</li>
</ul>
<p>
    با نگاهی به سابقه کارم در زمان‌هایی که در پشتیبانی تولید کار کرده‌ام، ناراحت‌کننده است که فکر کنم هشدارهایی که با آن‌ها سروکار داشته‌ام به ندرت از هیچ یک از این قوانین پیروی می‌کنند.
  </p>
<p>
    332
    |
    Chapter 10: From Monitoring to Observability
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0358</div>
            </div>
        </div>
        <!-- Page 0359 -->
        <div class="chapter" id="page-0359">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>Semantic Monitoring</h3>
<p>متاسفانه، اغلب اوقات، افرادی که اطلاعات را به سیستم‌های هشداردهنده ما می‌دهند و افرادی که در واقع هشدارهای ما را دریافت می‌کنند، افراد متفاوتی هستند. از Shorrock دوباره:</p>
<p><em>درک ماهیت مدیریت هشدارها و مسائل طراحی مرتبط، می‌تواند به شما—متخصص در کارتان—کمک کند تا یک کاربر آگاه‌تر باشید و به ایجاد بهترین سیستم‌های هشدار برای پشتیبانی از کارتان کمک کنید.</em></p>
<p>یک تکنیک که می‌تواند به کاهش تعداد هشدارها که برای جلب توجه ما رقابت می‌کنند کمک کند، شامل تغییر نحوه تفکر ما در مورد اینکه کدام مسائل نیاز دارند تا آنها را در وهله اول به توجه اپراتورها برسانیم. بیایید این موضوع را در ادامه بررسی کنیم.</p>
<h4>Semantic Monitoring (پایش معنایی)</h4>
<p>با <strong>Semantic Monitoring</strong>، ما در حال تعریف یک مدل برای آنچه <em>semantics</em> (معناشناسی) قابل قبول سیستممان است، هستیم. چه ویژگی‌هایی را سیستم باید داشته باشد تا ما فکر کنیم که در محدوده قابل قبول کار می‌کند؟ تا حد زیادی، <strong>Semantic Monitoring</strong> نیازمند تغییری در رفتار ما است. به جای جستجوی وجود خطاها، ما باید دائماً یک سوال را بپرسیم: آیا سیستم به روشی که ما انتظار داریم رفتار می‌کند؟ اگر به درستی رفتار می‌کند، این به ما کمک می‌کند تا درک کنیم که چگونه به اولویت‌بندی رسیدگی به خطاهایی که می‌بینیم بپردازیم.</p>
<p>مرحله بعدی این است که بفهمیم چگونه می‌توانید یک مدل برای یک سیستم که به درستی رفتار می‌کند، تعریف کنید. شما می‌توانید با این رویکرد بسیار رسمی برخورد کنید (به معنای واقعی کلمه، با برخی سازمان‌ها که از <em>formal methods</em> استفاده می‌کنند)، اما بیان برخی از <em>value statements</em> (عبارات ارزشی) ساده می‌تواند شما را به یک مسیر طولانی برساند. به عنوان مثال، در مورد <em>MusicCorp</em>، برای اینکه ما مطمئن باشیم سیستم به درستی کار می‌کند، چه چیزی باید درست باشد؟ خوب، شاید ما بگوییم که:</p>
<ul>
<li>مشتریان جدید می‌توانند برای پیوستن ثبت‌نام کنند.</li>
<li>ما در زمان اوج خود حداقل 20000 دلار محصول در ساعت می‌فروشیم.</li>
<li>ما سفارشات را با نرخ نرمالی ارسال می‌کنیم.</li>
</ul>
<p>اگر این سه عبارت بتوانند درست بودن خود را اثبات کنند، در کل ما احساس می‌کنیم که سیستم به اندازه کافی خوب کار می‌کند. با بازگشت به بحث‌های قبلی ما در مورد <strong>SLAs</strong> و <strong>SLOs</strong>، انتظار می‌رود که مدل ما برای درستی <strong>Semantic</strong> بسیار بیشتر از تعهدات ما در یک <strong>SLA</strong> باشد و ما انتظار داریم <strong>SLOs</strong> (اهداف سطح سرویس) مشخصی داشته باشیم که به ما امکان می‌دهند تا در برابر این مدل ردیابی کنیم. به عبارت دیگر، بیان این عبارات در مورد چگونگی عملکرد نرم‌افزارمان، راه درازی را برای شناسایی <strong>SLOs</strong> طی خواهد کرد.</p>
<p>یکی از بزرگترین چالش‌ها، رسیدن به توافق در مورد این مدل است. همانطور که می‌بینید، ما در مورد مسائل سطح پایین مانند “استفاده از دیسک نباید از 95٪ تجاوز کند” صحبت نمی‌کنیم؛ ما در حال بیان عبارات سطح بالاتری در مورد سیستم خود هستیم. به عنوان اپراتور سیستم، یا شخصی که <em>microservice</em> را نوشته و آزمایش کرده‌اید، ممکن است در موقعیتی نباشید که تصمیم بگیرید این <em>value statements</em> چه باید باشند. در یک محصول محور</p>
<p><em>Building Blocks for Observability | 333</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0359</div>
            </div>
        </div>
        <!-- Page 0360 -->
        <div class="chapter" id="page-0360">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>در سازمان تحویل، اینجاست که <em>product owner</em> (مالک محصول) باید وارد عمل شود—اما ممکن است وظیفه شما به عنوان اپراتور باشد که اطمینان حاصل کنید که بحث با <em>product owner</em> واقعاً انجام می‌شود.</p>
<p>هنگامی که در مورد مدل خود تصمیم گرفتید، سپس نوبت به این می‌رسد که بررسی کنید آیا رفتار سیستم فعلی با این مدل مطابقت دارد یا خیر. به طور کلی، ما دو روش اصلی برای انجام این کار داریم—<em>real user monitoring</em> (پایش کاربران واقعی) و <em>synthetic transactions</em> (تراکنش‌های مصنوعی). ما در لحظاتی به <em>synthetic transactions</em> نگاه خواهیم کرد، زیرا آنها تحت پوشش <em>testing in production</em> (تست در تولید) قرار می‌گیرند، اما بیایید ابتدا به <em>real user monitoring</em> نگاهی بیندازیم.</p>
<h4>Real user monitoring (پایش کاربران واقعی)</h4>
<p>با <em>real user monitoring</em>، ما به آنچه در سیستم تولیدی ما در حال وقوع است نگاه می‌کنیم و آن را با مدل معنایی خود مقایسه می‌کنیم. در <em>MusicCorp</em>، به تعداد مشتریانی که ثبت‌نام کرده‌اند، تعداد سفارشاتی که ارسال کرده‌ایم و غیره نگاه خواهیم کرد</p>
<p>چالش <em>real user monitoring</em> این است که اغلب اطلاعات مورد نیاز ما به موقع در دسترس ما نیست. انتظارات <em>MusicCorp</em> را در نظر بگیرید که باید حداقل 20000 دلار محصول در ساعت بفروشد. اگر این اطلاعات در جایی در یک <em>database</em> (پایگاه داده) قفل شده باشد، ممکن است نتوانیم این اطلاعات را جمع‌آوری کرده و بر اساس آن عمل کنیم. به همین دلیل است که ممکن است نیاز داشته باشید در معرض قرار دادن دسترسی به اطلاعاتی که قبلاً آنها را به عنوان معیارهای "تجاری" برای <em>tooling</em> (ابزارسازی) تولید خود در نظر می‌گرفتید، بهتر شوید. اگر می‌توانید یک نرخ <em>CPU</em> را به <em>metrics store</em> (مخزن معیارها) خود ارسال کنید، و این <em>metric store</em> می‌تواند برای هشدار در مورد این شرایط استفاده شود، پس چرا نمی‌توانید یک فروش و یک مقدار دلاری را در همین <em>store</em> ثبت کنید؟</p>
<p>یکی از معایب اصلی <em>real user monitoring</em> این است که اساساً پر سر و صدا است. شما مقدار زیادی اطلاعات دریافت می‌کنید—غربال کردن آنها برای فهمیدن اینکه آیا مشکلی وجود دارد یا خیر می‌تواند دشوار باشد. همچنین ارزش دارد بدانید که <em>real user monitoring</em> به شما می‌گوید که قبلاً چه اتفاقی افتاده است، و در نتیجه ممکن است یک مشکل را تا بعد از وقوع آن متوجه نشوید. اگر یک مشتری نتوانست ثبت‌نام کند، این یک مشتری ناراضی است. با <em>synthetic transactions</em>، نوع دیگری از <em>testing in production</em> که در لحظاتی به آن نگاه خواهیم کرد، ما این فرصت را داریم که نه تنها نویز را کاهش دهیم، بلکه مشکلات را قبل از اینکه کاربران ما از آنها آگاه شوند، شناسایی کنیم.</p>
<p><em>334 | Chapter 10: From Monitoring to Observability</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0360</div>
            </div>
        </div>
        <!-- Page 0361 -->
        <div class="chapter" id="page-0361">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>12 <em>Charity Majors</em> (@mipsytipsy), <em>Twitter</em>, July 7, 2019, 9:48 a.m., https://oreil.ly/4VUAX.</p>
<h4>Testing in Production (تست در تولید)</h4>
<p><em>Not testing in prod is like not practicing with the full orchestra because your solo sounded fine at home.</em>12</p>
<p>—<em>Charity Majors</em></p>
<p>همانطور که بارها در طول کتاب پوشش داده‌ایم، از بحث ما در مورد مفاهیمی مانند <em>canary deployments</em> (استقرارهای قناری) در "Canary Release" در صفحه 271 تا نگاه ما به عمل متعادل‌سازی در رابطه با تست‌های پیش و پس از تولید، انجام نوعی تست در تولید می‌تواند یک فعالیت فوق‌العاده مفید—و ایمن—باشد. ما به تعدادی از انواع مختلف تست در تولید در این کتاب نگاه کرده‌ایم و فرم‌های بیشتری نیز وجود دارد، بنابراین احساس کردم که خلاصه کردن برخی از انواع مختلف تست در تولید که قبلاً به آنها نگاه کرده‌ایم و همچنین به اشتراک گذاشتن برخی دیگر از نمونه‌های تست در تولید که معمولاً استفاده می‌شوند، مفید خواهد بود. تعجب می‌کنم که چه تعداد از افرادی که از مفهوم تست در تولید می‌ترسند، در حال حاضر بدون اینکه واقعاً متوجه شوند، در حال انجام آن هستند.</p>
<p>تمام اشکال تست در تولید، به طور استدلالی، نوعی فعالیت "<em>monitoring</em>" (پایش) هستند. ما این اشکال تست در تولید را انجام می‌دهیم تا اطمینان حاصل کنیم که سیستم تولیدی ما همانطور که انتظار داریم اجرا می‌شود، و بسیاری از اشکال تست در تولید می‌توانند در شناسایی مشکلات قبل از اینکه کاربران ما متوجه شوند، بسیار مؤثر باشند.</p>
<h5>Synthetic transactions (تراکنش‌های مصنوعی)</h5>
<p>با <em>synthetic transactions</em>، ما رفتار کاربری جعلی را به سیستم تولیدی خود تزریق می‌کنیم. این رفتار کاربری جعلی ورودی‌های شناخته شده و خروجی‌های مورد انتظار دارد. به عنوان مثال، برای <em>MusicCorp</em>، می‌توانیم به طور مصنوعی یک مشتری جدید ایجاد کنیم و سپس بررسی کنیم که آیا مشتری با موفقیت ایجاد شده است یا خیر. این تراکنش‌ها به طور منظم اجرا می‌شوند و به ما این شانس را می‌دهند که مشکلات را در اسرع وقت شناسایی کنیم.</p>
<p>من اولین بار این کار را در سال 2005 انجام دادم. من بخشی از یک تیم کوچک <em>Thoughtworks</em> بودم که در حال ساخت سیستمی برای یک بانک سرمایه‌گذاری بودیم. در طول روز معاملاتی، رویدادهای زیادی وارد می‌شدند که نشان‌دهنده تغییرات در بازار بودند. وظیفه ما این بود که به این تغییرات واکنش نشان دهیم و تأثیر آن را بر سبد سهام بانک بررسی کنیم. ما تحت مهلت‌های نسبتاً فشرده کار می‌کردیم، یک هدف ناخوشایند این بود که تمام محاسبات خود را کمتر از 10 ثانیه پس از رسیدن رویداد تکمیل کنیم. خود سیستم شامل حدود پنج <em>service</em> (سرویس) مجزا بود که حداقل یکی از آنها بر روی یک <em>computing grid</em> (شبکه محاسباتی) اجرا می‌شد که، در میان چیزهای دیگر، چرخه‌های <em>CPU</em> استفاده‌نشده را روی حدود 250 میزبان دسکتاپ در مرکز بازیابی فاجعه بانک جمع‌آوری می‌کرد.</p>
<p>تعداد قطعات متحرک در سیستم به معنای ایجاد نویز زیاد از بسیاری از <em>metrics</em> (معیارهای) سطح پایین‌تری بود که جمع‌آوری می‌کردیم. ما همچنین نداشتیم</p>
<p><em>Building Blocks for Observability | 335</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0361</div>
            </div>
        </div>
        <!-- Page 0362 -->
        <div class="chapter" id="page-0362">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>مزیت مقیاس‌بندی تدریجی یا اجرای سیستم برای چند ماه برای درک اینکه "خوب" از نظر معیارهای سطح پایین مانند نرخ <em>CPU</em> (پردازنده) یا زمان پاسخ، چگونه به نظر می‌رسید.</p>
<p>رویکرد ما این بود که رویدادهای جعلی تولید کنیم تا بخشی از سبد سهام را که در سیستم‌های پایین‌دستی ثبت نشده بود، قیمت‌گذاری کنیم. تقریباً هر دقیقه، ما از ابزاری به نام <em>Nagios</em> برای اجرای یک <em>command-line job</em> (شغل خط فرمان) استفاده می‌کردیم که یک رویداد جعلی را به یکی از <em>queues</em> (صف)های ما وارد می‌کرد. سیستم ما آن را دریافت و تمام محاسبات مختلف را درست مانند هر شغل دیگری اجرا می‌کرد، با این تفاوت که نتایج در دفتر "<em>junk</em>" ظاهر می‌شد، که فقط برای تست استفاده می‌شد. اگر یک <em>repricing</em> (قیمت‌گذاری مجدد) در یک زمان معین مشاهده نمی‌شد، <em>Nagios</em> این را به عنوان یک مشکل گزارش می‌داد.</p>
<p>در عمل، من استفاده از <em>synthetic transactions</em> (تراکنش‌های مصنوعی) برای انجام <em>semantic monitoring</em> (پایش معنایی) مانند این را یک شاخص بسیار بهتر از مشکلات در سیستم‌ها نسبت به هشدار دادن در مورد معیارهای سطح پایین‌تر، یافته‌ام. با این حال، آنها جایگزین نیاز به جزئیات سطح پایین‌تر نمی‌شوند—ما هنوز هم زمانی که نیاز به یافتن دلیل شکست یک <em>synthetic transaction</em> داریم، به آن اطلاعات نیاز خواهیم داشت.</p>
<p><em>Implementing synthetic transactions</em> (پیاده‌سازی تراکنش‌های مصنوعی). در گذشته، پیاده‌سازی <em>synthetic transactions</em> یک کار نسبتاً دلهره‌آوری بود. اما جهان به جلو رفته است و ابزارهای پیاده‌سازی آنها در دسترس ماست! شما در حال انجام تست برای سیستم‌های خود هستید، درست است؟ اگر نه، فصل 9 را بخوانید و برگردید. همه کارها انجام شد؟ خوب!</p>
<p>اگر به تست‌هایی نگاه کنیم که یک <em>service</em> (سرویس) معین را سرتاسر یا حتی کل سیستم خود را سرتاسر تست می‌کنند، ما بسیاری از آنچه برای پیاده‌سازی <em>semantic monitoring</em> نیاز داریم، در اختیار داریم. سیستم ما در حال حاضر <em>hooks</em> (قلاب‌هایی) را که برای راه‌اندازی تست و بررسی نتیجه مورد نیاز است، در معرض نمایش قرار می‌دهد. پس چرا فقط زیرمجموعه‌ای از این تست‌ها را، به طور مداوم، به عنوان راهی برای پایش سیستم خود اجرا نکنیم؟</p>
<p>البته، کارهایی وجود دارد که باید انجام دهیم. اول، باید در مورد الزامات داده‌های تست‌هایمان محتاط باشیم. ممکن است لازم باشد راهی برای انطباق تست‌هایمان با داده‌های زنده مختلف، در صورت تغییر آنها در طول زمان، پیدا کنیم، یا منبع داده متفاوتی را تنظیم کنیم. به عنوان مثال، می‌توانیم مجموعه‌ای از کاربران جعلی داشته باشیم که در تولید با مجموعه داده‌های شناخته شده از آنها استفاده می‌کنیم.</p>
<p>به همین ترتیب، ما باید اطمینان حاصل کنیم که به طور تصادفی، اثرات جانبی پیش‌بینی نشده را فعال نمی‌کنیم. یک دوست برای من داستانی در مورد یک شرکت <em>ecommerce</em> (تجارت الکترونیک) تعریف کرد که به طور تصادفی تست‌های خود را در برابر سیستم‌های سفارش‌دهی تولید خود اجرا کرد. آنها اشتباه خود را متوجه نشدند تا زمانی که تعداد زیادی ماشین لباسشویی به دفتر مرکزی رسید.</p>
<h5>A/B testing (تست A/B)</h5>
<p>با یک تست <em>A/B</em>، شما دو نسخه مختلف از یک عملکرد را مستقر می‌کنید، به طوری که کاربران یا عملکرد "A" یا "B" را می‌بینند. سپس می‌توانید ببینید کدام نسخه از عملکرد بهترین عملکرد را دارد. این معمولاً هنگام تلاش برای تصمیم‌گیری بین دو رویکرد مختلف برای چگونگی انجام یک کار استفاده می‌شود—به عنوان مثال، ممکن است دو فرم ثبت‌نام مشتری مختلف را امتحان کنید تا ببینید کدام یک در جذب ثبت‌نام‌ها مؤثرتر است.</p>
<p><em>336 | Chapter 10: From Monitoring to Observability</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0362</div>
            </div>
        </div>
        <!-- Page 0363 -->
        <div class="chapter" id="page-0363">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>Canary release (انتشار قناری)</h4>
<p>بخش کوچکی از پایگاه کاربری شما، نسخه جدیدی از عملکرد را می‌بیند. اگر این عملکرد جدید به خوبی کار کند، می‌توانید بخش از پایگاه کاربری خود را که عملکرد جدید را می‌بیند افزایش دهید تا جایی که نسخه جدید عملکرد اکنون توسط همه کاربران استفاده می‌شود. از طرف دیگر، اگر عملکرد جدید آنطور که در نظر گرفته شده کار نکند، شما فقط بر بخش کوچکی از پایگاه کاربری خود تأثیر گذاشته‌اید و می‌توانید تغییر را بازگردانید یا سعی کنید هر مشکلی را که شناسایی کرده‌اید برطرف کنید.</p>
<h4>Parallel run (اجرای موازی)</h4>
<p>با یک <em>parallel run</em> (اجرای موازی)، شما دو پیاده‌سازی معادل مختلف از یک عملکرد یکسان را در کنار هم اجرا می‌کنید. هر درخواست کاربر به هر دو نسخه هدایت می‌شود و نتایج آنها را می‌توان مقایسه کرد. بنابراین، به جای هدایت یک کاربر به نسخه قدیمی یا جدید، همانطور که در یک <em>canary release</em> (انتشار قناری) انجام می‌شود، ما هر دو نسخه را اجرا می‌کنیم—اما کاربر فقط یکی را می‌بیند. این امکان مقایسه کامل بین دو نسخه مختلف را فراهم می‌کند، که وقتی می‌خواهیم درک بهتری از جنبه‌هایی مانند ویژگی‌های بارگذاری یک پیاده‌سازی جدید از برخی عملکردهای کلیدی داشته باشیم، فوق‌العاده مفید است.</p>
<h4>Smoke tests (تست‌های دود)</h4>
<p><em>Smoke tests</em> (تست‌های دود) که پس از استقرار نرم‌افزار در تولید اما قبل از انتشار آن استفاده می‌شوند، در برابر نرم‌افزار اجرا می‌شوند تا اطمینان حاصل شود که به درستی کار می‌کند. این تست‌ها معمولاً کاملاً خودکار هستند و می‌توانند از فعالیت‌های بسیار ساده مانند اطمینان از اینکه یک <em>microservice</em> (ریز سرویس) معین در حال اجرا است تا اجرای <em>synthetic transactions</em> (تراکنش‌های مصنوعی) کامل را شامل شوند.</p>
<h4>Synthetic transactions (تراکنش‌های مصنوعی)</h4>
<p>یک تعامل کامل و جعلی کاربر به سیستم تزریق می‌شود. این اغلب بسیار نزدیک به نوع تست سرتاسری است که ممکن است بنویسید.</p>
<h4>Chaos engineering (مهندسی آشوب)</h4>
<p>موضوعی که در فصل 12 بیشتر در مورد آن بحث خواهیم کرد، <em>chaos engineering</em> (مهندسی آشوب) می‌تواند شامل تزریق خطاها به یک سیستم تولیدی باشد تا اطمینان حاصل شود که می‌تواند این مشکلات مورد انتظار را مدیریت کند. شناخته‌شده‌ترین نمونه این تکنیک احتمالاً <em>Chaos Monkey</em> نتفلیکس است، که قادر است ماشین‌های مجازی را در تولید خاموش کند، با این انتظار که سیستم به اندازه‌ای قوی باشد که این خاموش شدن‌ها عملکرد کاربر نهایی را مختل نکنند.</p>
<h5>Standardization (استانداردسازی)</h5>
<p>همانطور که قبلاً پوشش دادیم، یکی از اقدامات متعادل‌سازی مستمر که باید انجام دهید این است که کجا اجازه دهید تصمیمات برای یک <em>microservice</em> واحد به طور محدود گرفته شود و کجا نیاز به استانداردسازی در سراسر سیستم خود دارید. به نظر من، پایش و</p>
<p><em>Standardization | 337</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0363</div>
            </div>
        </div>
        <!-- Page 0364 -->
        <div class="chapter" id="page-0364">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>observability</em> (قابلیت مشاهده‌پذیری) یک حوزه‌ای است که در آن استانداردسازی می‌تواند فوق‌العاده مهم باشد. با <em>microservices</em> (ریز سرویس‌ها) که به روش‌های مختلفی برای ارائه قابلیت‌ها به کاربران با استفاده از چندین <em>interface</em> (رابط) همکاری می‌کنند، شما باید سیستم را به صورت <em>holistic</em> (کل‌نگرانه) مشاهده کنید.</p>
<p>شما باید سعی کنید <em>logs</em> (لاگ‌ها)ی خود را در یک قالب استاندارد بنویسید. شما قطعاً می‌خواهید تمام <em>metrics</em> (معیارهای) خود را در یک مکان داشته باشید، و ممکن است بخواهید یک لیست از نام‌های استاندارد برای <em>metrics</em> خود نیز داشته باشید؛ بسیار آزاردهنده خواهد بود اگر یک <em>service</em> (سرویس) یک <em>metric</em> (معیار) به نام <em>ResponseTime</em> (زمان پاسخ) داشته باشد، و دیگری یک <em>metric</em> (معیار) به نام <em>RspTimeSecs</em> (زمان پاسخ بر حسب ثانیه) داشته باشد، در حالی که هر دو به یک معنا هستند.</p>
<p>مانند همیشه با استانداردسازی، ابزارها می‌توانند کمک کنند. همانطور که قبلاً گفتم، نکته کلیدی این است که انجام کار درست را آسان کنید—بنابراین داشتن یک پلتفرم با بسیاری از <em>building blocks</em> (بلوک‌های سازنده) اساسی در جای خود، مانند تجمیع <em>log</em> (لاگ)، بسیار منطقی است. به طور فزاینده‌ای، بسیاری از این موارد به تیم پلتفرم مربوط می‌شود، که نقش آن را در فصل 15 بیشتر بررسی می‌کنیم.</p>
<h4>Selecting Tools (انتخاب ابزارها)</h4>
<p>همانطور که قبلاً پوشش دادیم، به طور بالقوه مجموعه‌ای از ابزارهای مختلف وجود دارد که ممکن است برای کمک به بهبود <em>observability</em> (قابلیت مشاهده‌پذیری) سیستم خود نیاز داشته باشید. اما همانطور که قبلاً اشاره کردم، این یک فضای در حال ظهور سریع است، و بسیار محتمل است که ابزارهایی که در آینده استفاده خواهیم کرد، بسیار متفاوت از آنچه اکنون داریم، به نظر برسند. با پلتفرم‌هایی مانند <em>Honeycomb</em> و <em>Lightstep</em> که در زمینه <em>tooling</em> (ابزارسازی) <em>observability</em> (قابلیت مشاهده‌پذیری) برای <em>microservices</em> (ریز سرویس‌ها) پیشرو هستند، و با بقیه بازار که تا حدی در حال جبران هستند، من کاملاً انتظار دارم که این فضا در آینده شاهد تغییرات زیادی باشد.</p>
<p>بنابراین کاملاً ممکن است شما به ابزارهای متفاوتی نسبت به آنچه در حال حاضر دارید نیاز داشته باشید، اگر تازه شروع به پذیرش <em>microservices</em> (ریز سرویس‌ها) کرده‌اید، و ممکن است در آینده نیز به <em>tooling</em> (ابزارسازی) متفاوتی نیاز داشته باشید، زیرا راه‌حل‌ها در این فضا همچنان در حال بهبود هستند. با توجه به این موضوع، می‌خواهم چند فکر را در مورد معیارهایی که فکر می‌کنم برای هر <em>tooling</em> (ابزارسازی) در این زمینه مهم هستند، به اشتراک بگذارم.</p>
<h5>Democratic (دموکراتیک)</h5>
<p>اگر ابزارهایی دارید که کار با آنها بسیار دشوار است به طوری که فقط اپراتورهای باتجربه می‌توانند از آنها استفاده کنند، در این صورت شما تعداد افرادی را که می‌توانند در فعالیت‌های تولید شرکت کنند، محدود می‌کنید. به همین ترتیب، اگر ابزارهایی را انتخاب کنید که آنقدر گران هستند که استفاده از آنها را در هر موقعیتی به جز محیط‌های تولیدی بحرانی ممنوع می‌کند، توسعه‌دهندگان تا زمانی که دیر نشده است، در معرض این ابزارها قرار نخواهند گرفت.</p>
<p>ابزارهایی را انتخاب کنید که نیازهای همه افرادی را که می‌خواهید از آنها استفاده کنند، در نظر بگیرند. اگر واقعاً می‌خواهید به یک مدل از مالکیت جمعی‌تر نرم‌افزار خود بروید، پس نرم‌افزار باید توسط همه افراد تیم قابل استفاده باشد. اطمینان از اینکه هر <em>tooling</em> (ابزارسازی) که انتخاب می‌کنید در محیط‌های توسعه و تست نیز استفاده خواهد شد، راه درازی را برای تحقق این هدف طی خواهد کرد.</p>
<p><em>338 | Chapter 10: From Monitoring to Observability</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0364</div>
            </div>
        </div>
        <!-- Page 0365 -->
        <div class="chapter" id="page-0365">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>13 “<em>Observability: A Complete Overview for 2021</em>,” <em>Lightstep</em>, accessed June 16, 2021, https://oreil.ly/a1ERu.</p>
<h4>Easy to Integrate (ادغام آسان)</h4>
<p>به دست آوردن اطلاعات صحیح از معماری <em>application</em> (برنامه) و سیستم‌هایی که بر روی آنها اجرا می‌کنید، حیاتی است، و همانطور که قبلاً پوشش دادیم، ممکن است لازم باشد اطلاعات بیشتری نسبت به قبل، و در قالب‌های مختلف، استخراج کنید. آسان کردن این فرآیند تا حد امکان بسیار مهم است. ابتکاراتی مانند <em>OpenTracing</em> از نظر ارائه <em>APIs</em> (رابط‌های برنامه‌نویسی) استانداردی که کتابخانه‌های <em>client</em> (مشتری) و پلتفرم‌ها می‌توانند از آنها پشتیبانی کنند، به ادغام و قابلیت حمل در سراسر <em>toolchains</em> (زنجیره ابزارها) کمک کرده‌اند. از جمله موارد مورد توجه ویژه، همانطور که بحث کردم، ابتکار جدید <em>OpenTelemetry</em> است که توسط تعداد زیادی از طرفین هدایت می‌شود.</p>
<p>انتخاب ابزارهایی که از این استانداردهای باز پشتیبانی می‌کنند، تلاش‌های ادغام را آسان‌تر می‌کند و همچنین شاید به آسان‌تر شدن تغییر <em>vendors</em> (فروشندگان) در آینده کمک کند.</p>
<h5>Provide Context (ارائه زمینه)</h5>
<p>هنگام نگاه کردن به یک قطعه اطلاعات، من به ابزار نیاز دارم تا تا حد امکان زمینه را برای من فراهم کند تا به من کمک کند بفهمم چه اتفاقی باید بیفتد. من واقعاً سیستم طبقه‌بندی زیر را برای انواع مختلف زمینه که از طریق یک پست وبلاگ <em>Lightstep</em> پیدا کردم، دوست دارم:13</p>
<ul>
<li><em>Temporal context</em> (زمینه زمانی)</li>
<p>این با یک دقیقه، ساعت، روز یا ماه پیش چگونه به نظر می‌رسد؟</p>
<li><em>Relative context</em> (زمینه نسبی)</li>
<p>این در رابطه با سایر موارد در سیستم چگونه تغییر کرده است؟</p>
<li><em>Relational context</em> (زمینه رابطه‌ای)</li>
<p>آیا چیزی به این وابسته است؟ آیا این به چیز دیگری وابسته است؟</p>
<li><em>Proportional context</em> (زمینه متناسب)</li>
<p>این چقدر بد است؟ آیا بزرگ یا کوچک است؟ چه کسی تحت تأثیر قرار گرفته است؟</p>
</ul>
<h5>Real-Time (بلادرنگ)</h5>
<p>شما نمی‌توانید برای این اطلاعات منتظر زمان زیادی باشید. شما به آن اکنون نیاز دارید. البته تعریف شما از "اکنون" می‌تواند تا حدودی متفاوت باشد، اما در زمینه سیستم‌های شما، شما به اندازه‌ای سریع به اطلاعات نیاز دارید که این شانس را داشته باشید که قبل از اینکه یک کاربر متوجه شود، یک مشکل را شناسایی کنید، یا حداقل اطلاعات را در دست داشته باشید. وقتی کسی شکایت می‌کند.</p>
<p>در عمل، ما در مورد ثانیه‌ها صحبت می‌کنیم، نه دقیقه یا ساعت.</p>
<p><em>Selecting Tools | 339</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0365</div>
            </div>
        </div>
        <!-- Page 0366 -->
        <div class="chapter" id="page-0366">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>14 <em>Ben Sigelman</em>, “<em>Three Pillars with Zero Answers—Towards a New Scorecard for Observability</em>,” <em>Lightstep</em> (<em>blog post</em>), December 5, 2018, https://oreil.ly/R3LwC.</p>
<h5>Suitable for Your Scale (مناسب برای مقیاس شما)</h5>
<p>بسیاری از کارها در زمینه <em>observability</em> (قابلیت مشاهده‌پذیری) سیستم‌های توزیع‌شده، از کارهایی که در سیستم‌های توزیع‌شده در مقیاس بزرگ انجام شده است، الهام گرفته شده است. متأسفانه این می‌تواند ما را به سمت تلاش برای ایجاد مجدد راه‌حل‌هایی برای سیستم‌هایی با مقیاس بسیار بزرگتر از خودمان، بدون درک <em>trade-offs</em> (تبعات) سوق دهد.</p>
<p>سیستم‌های با مقیاس عظیم اغلب مجبور خواهند بود <em>trade-offs</em> (تبعات) خاصی را برای کاهش عملکرد سیستم‌های خود به منظور رسیدگی به مقیاسی که در آن فعالیت می‌کنند، انجام دهند. به عنوان مثال، <em>Dapper</em>، مجبور بود از نمونه‌برداری تصادفی بسیار تهاجمی از داده‌ها (در واقع "<em>dropping</em>" (دور انداختن) مقدار زیادی از اطلاعات) استفاده کند تا بتواند با مقیاس <em>Google</em> مقابله کند. همانطور که <em>Ben Sigelman</em>، بنیانگذار <em>LightStep</em> و خالق <em>Dapper</em>، می‌گوید:14</p>
<p><em>microservices</em> (ریز سرویس‌های) گوگل حدود 5 میلیارد <em>RPCs</em> در ثانیه تولید می‌کنند. بنابراین، ساخت ابزارهای <em>observability</em> (قابلیت مشاهده‌پذیری) که تا 5 میلیارد <em>RPCs</em> در ثانیه مقیاس‌پذیر باشند، در واقع به ساخت ابزارهای <em>observability</em> (قابلیت مشاهده‌پذیری) که به شدت فاقد ویژگی هستند، خلاصه می‌شود. اگر سازمان شما حدود 5 میلیون <em>RPCs</em> در ثانیه انجام می‌دهد، این هنوز هم بسیار چشمگیر است، اما تقریباً مطمئناً نباید از آنچه گوگل استفاده می‌کند، استفاده کنید: در 1/1000th مقیاس، شما می‌توانید ویژگی‌های بسیار قدرتمندتری را داشته باشید.</p>
<p>همچنین در حالت ایده‌آل شما به ابزاری نیاز دارید که بتواند با مقیاس شما، مقیاس‌پذیر باشد. باز هم، <em>cost effectiveness</em> (مقرون به صرفه بودن) می‌تواند در اینجا وارد عمل شود. حتی اگر ابزار مورد نظر شما از نظر فنی بتواند از رشد مورد انتظار سیستم شما پشتیبانی کند، آیا می‌توانید هزینه آن را پرداخت کنید؟</p>
<h5>The Expert in the Machine (متخصص در ماشین)</h5>
<p>من در این فصل، شاید بیشتر از هر فصل دیگری در کتاب، در مورد ابزارها صحبت کرده‌ام. این تا حدی به دلیل تغییر اساسی از مشاهده جهان صرفاً از نظر <em>monitoring</em> (پایش) به جای آن، تفکر در مورد چگونگی <em>observable</em> (قابل مشاهده)تر کردن سیستم‌هایمان است؛ این تغییر در رفتار نیازمند <em>tooling</em> (ابزارسازی) برای کمک به پشتیبانی از آن است. با این حال، این اشتباه خواهد بود که این تغییر را صرفاً به عنوان مربوط به ابزارهای جدید ببینیم، همانطور که امیدوارم قبلاً توضیح داده باشم. با این وجود، با وجود تعداد زیادی از <em>vendors</em> (فروشندگان) مختلف که برای جلب توجه ما رقابت می‌کنند، ما نیز باید محتاط باشیم.</p>
<p>در حال حاضر، بیش از یک دهه است که من دیده‌ام که چندین <em>vendors</em> (فروشندگان) ادعا می‌کنند که درجه‌ای از هوشمندی را در مورد چگونگی عملکرد سیستم خود دارند، و این تنها سیستمی است که به طور جادویی مشکلات را شناسایی کرده و دقیقاً به ما می‌گوید که برای رفع مشکلات چه کاری باید انجام دهیم. به نظر می‌رسد این موضوع در امواج می‌آید، اما با توجه به هیاهوی اخیر پیرامون <em>machine learning</em> (یادگیری ماشینی) (<em>ML</em>) و <em>artificial intelligence</em> (هوش مصنوعی) (<em>AI</em>) که تنها در حال افزایش است، من ادعاهای بیشتری را در مورد تشخیص ناهنجاری خودکار می‌بینم.</p>
<p>من در مورد میزان اثربخشی این موضوع به صورت کاملاً خودکار تردید دارم، و حتی در این صورت فرض بر این است که تمام تخصص مورد نیاز شما می‌تواند به صورت خودکار حذف شود، مشکل‌ساز خواهد بود.</p>
<p><em>340 | Chapter 10: From Monitoring to Observability</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0366</div>
            </div>
        </div>
        <!-- Page 0367 -->
        <div class="chapter" id="page-0367">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>بسیاری از تلاش‌ها در اطراف <em>AI</em> (هوش مصنوعی) همیشه برای تلاش و رمزگذاری دانش متخصص در یک سیستم خودکار بوده است. ایده اینکه ما می‌توانیم تخصص را خودکار کنیم ممکن است برای برخی جذاب باشد، اما همچنین یک ایده بالقوه خطرناک در این فضا است، حداقل با درک فعلی ما. چرا باید تخصص را خودکار کرد؟ بنابراین شما مجبور نیستید در داشتن اپراتورهای متخصص برای اجرای سیستم خود سرمایه‌گذاری کنید. من در اینجا سعی نمی‌کنم به نکاتی در مورد دگرگونی نیروی کار ناشی از پیشرفت‌های تکنولوژیکی اشاره کنم—بیشتر این است که مردم این ایده را اکنون می‌فروشند، و شرکت‌ها اکنون این ایده را می‌خرند، به این امید که اینها مشکلات کاملاً قابل حل (و خودکار) هستند. واقعیت این است که در حال حاضر، آنها اینطور نیستند.</p>
<p>من اخیراً با یک <em>startup</em> (استارتاپ) متمرکز بر علوم داده در اروپا کار کردم. این <em>startup</em> (استارتاپ) با شرکتی کار می‌کرد که سخت‌افزار نظارت بر تخت را ارائه می‌کرد، که می‌توانست قطعات مختلفی از داده‌ها را در مورد یک بیمار جمع‌آوری کند. دانشمندان داده توانستند الگوهایی را در داده‌ها مشاهده کنند، که خوشه‌های عجیبی از بیماران را نشان می‌داد که می‌توانستند با همبستگی جنبه‌های مختلف داده‌ها تعیین شوند. دانشمندان داده می‌توانستند بگویند "این بیماران مرتبط به نظر می‌رسند" اما هیچ آگاهی از معنای آن رابطه نداشتند. </p>
<p>این کار یک پزشک متخصص را طلب می‌کرد تا توضیح دهد که برخی از این خوشه‌ها به بیمارانی اشاره دارد که به طور کلی، نسبت به دیگران بیمارتر بوده‌اند. این کار به تخصص نیاز داشت تا خوشه را شناسایی کند، و تخصص متفاوتی برای درک معنای این خوشه و به کار بستن آن دانش لازم بود. با بازگشت به ابزارهای ما برای <em>monitoring</em> (پایش) و <em>observability</em> (قابلیت مشاهده‌پذیری)، من می‌توانستم چنین ابزاری را ببینم که به کسی در مورد این واقعیت هشدار می‌دهد که "به نظر می‌رسد چیزی عجیب است"، اما دانستن اینکه با آن اطلاعات چه باید کرد هنوز به درجه‌ای از تخصص نیاز دارد.</p>
<p>در حالی که من مطمئن هستم که ویژگی‌هایی مانند "تشخیص ناهنجاری خودکار" ممکن است به خوبی به بهبود خود ادامه دهند، ما باید تشخیص دهیم که در حال حاضر، متخصص در سیستم، یک انسان است و برای مدتی باقی خواهد ماند. ما می‌توانیم ابزارهایی ایجاد کنیم که می‌توانند اپراتور را بهتر در مورد آنچه باید انجام شود مطلع کنند، و می‌توانیم <em>automation</em> (خودکارسازی) را برای کمک به اپراتور در اجرای تصمیمات خود به روشی مؤثرتر ارائه دهیم. اما محیط اساساً متنوع و پیچیده یک سیستم توزیع شده به این معنی است که ما به اپراتورهای انسانی ماهر و پشتیبانی شده نیاز داریم. ما می‌خواهیم متخصصان ما از تخصص خود در طرح سوالات صحیح و اتخاذ بهترین تصمیماتی که می‌توانند، استفاده کنند. ما نباید از آنها بخواهیم که از تخصص خود برای مقابله با کاستی‌های ابزارهای ضعیف استفاده کنند. همچنین نباید تسلیم این تصور راحت شویم که یک ابزار جدید فانتزی تمام مشکلات ما را حل خواهد کرد.</p>
<h4>Getting Started (شروع کار)</h4>
<p>همانطور که من توضیح دادم، در اینجا چیزهای زیادی برای فکر کردن وجود دارد. اما من می‌خواهم یک نقطه شروع اساسی برای یک معماری <em>microservice</em> (ریز سرویس) ساده از نظر آنچه و چگونه باید چیزها را ثبت کنید، ارائه دهم.</p>
<p>برای شروع، شما می‌خواهید بتوانید اطلاعات اساسی در مورد میزبان‌هایی که <em>microservices</em> (ریز سرویس‌های) شما روی آنها اجرا می‌شوند—نرخ <em>CPU</em> (پردازنده)، <em>I/O</em> (ورودی/خروجی) و غیره—ثبت کنید و مطمئن شوید که می‌توانید یک نمونه <em>microservice</em> (ریز سرویس) را به میزبان آن که روی آن اجرا می‌شود، مرتبط کنید. برای هر نمونه <em>microservice</em> (ریز سرویس)، شما می‌خواهید زمان پاسخگویی برای <em>service interfaces</em> (رابط‌های سرویس) آن را ثبت کنید و</p>
<p><em>Getting Started | 341</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0367</div>
            </div>
        </div>
        <!-- Page 0368 -->
        <div class="chapter" id="page-0368">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>ثبت تمام فراخوانی‌های پایین‌دستی در <em>logs</em> (لاگ‌ها) را ثبت کنید. از همان ابتدا، <em>correlation IDs</em> (شناسه‌های همبستگی) را وارد <em>logs</em> (لاگ‌ها)ی خود کنید.</p>
<p>سایر مراحل اصلی در فرآیندهای کسب‌وکار خود را ثبت کنید. این امر مستلزم آن است که شما حداقل یک <em>toolchain</em> (زنجیره ابزار) جمع‌آوری <em>metric</em> (معیار) و <em>log</em> (لاگ) اساسی داشته باشید.</p>
<p>من در تردید هستم که بگویم شما نیاز دارید با یک ابزار ردیابی توزیع‌شده اختصاصی شروع کنید. اگر شما مجبورید ابزار را خودتان اجرا و میزبانی کنید، این می‌تواند پیچیدگی قابل توجهی را اضافه کند. از طرف دیگر، اگر می‌توانید به راحتی از یک سرویس کاملاً مدیریت شده استفاده کنید، از همان ابتدا <em>instrumenting</em> (ابزاربندی) <em>microservices</em> (ریز سرویس‌های) خود می‌تواند بسیار منطقی باشد.</p>
<p>برای عملیات‌های کلیدی، به شدت ایجاد <em>synthetic transactions</em> (تراکنش‌های مصنوعی) را به عنوان راهی برای درک بهتر اینکه آیا جنبه‌های حیاتی سیستم شما به درستی کار می‌کنند یا خیر، در نظر بگیرید. سیستم خود را با در نظر گرفتن این قابلیت بسازید.</p>
<p>همه اینها فقط جمع‌آوری اطلاعات اساسی است. مهمتر از آن، شما باید اطمینان حاصل کنید که می‌توانید این اطلاعات را غربال کنید تا از سیستم در حال اجرا سوالاتی بپرسید. آیا شما می‌توانید با اطمینان بگویید که سیستم به درستی برای کاربران شما کار می‌کند؟</p>
<p>با گذشت زمان، شما نیاز خواهید داشت که اطلاعات بیشتری جمع‌آوری کنید و <em>tooling</em> (ابزارسازی) خود را (و نحوه استفاده از آن را) بهبود بخشید تا <em>observability</em> (قابلیت مشاهده‌پذیری) پلتفرم خود را بهتر کنید.</p>
<h4>Summary (خلاصه)</h4>
<p>درک سیستم‌های توزیع‌شده می‌تواند پیچیده باشد، و هرچه بیشتر توزیع‌شده باشند، کار عیب‌یابی تولید دشوارتر می‌شود. وقتی فشار وارد می‌شود، هشدارها در حال انفجار هستند، و مشتریان در حال فریاد زدن هستند، مهم است که شما اطلاعات صحیحی را در اختیار داشته باشید تا بفهمید چه اتفاقی می‌افتد و چه کاری باید انجام دهید تا آن را برطرف کنید.</p>
<p>با پیچیده‌تر شدن معماری <em>microservice</em> (ریز سرویس) شما، دانستن اینکه چه مشکلاتی ممکن است رخ دهد، از قبل آسان‌تر نمی‌شود. در عوض، شما اغلب از انواع مشکلاتی که با آنها روبرو خواهید شد، شگفت‌زده خواهید شد. بنابراین، ضروری است که تفکر خود را از فعالیت (منفعل) <em>monitoring</em> (پایش) به سمت فعالانه <em>observable</em> (قابل مشاهده) کردن سیستم خود تغییر دهید. این امر نه تنها شامل تغییر احتمالی مجموعه ابزارهای شما می‌شود، بلکه همچنین تغییر از داشبوردهای استاتیک به فعالیت‌های <em>slicing and dicing</em> (برش و قالب‌بندی) پویاتر را نیز شامل می‌شود.</p>
<p>با یک سیستم ساده، اصول اولیه شما را به یک مسیر طولانی می‌رساند. جمع‌آوری <em>log</em> (لاگ) را از ابتدا دریافت کنید، و همچنین <em>correlation IDs</em> (شناسه‌های همبستگی) را در خطوط <em>log</em> (لاگ) خود دریافت کنید. ردیابی توزیع‌شده می‌تواند بعداً دنبال شود، اما مراقب باشید که زمان آن فرا می‌رسد که آن را در جای خود قرار دهید.</p>
<p>درک خود را از سلامت سیستم یا <em>microservice</em> (ریز سرویس) را از یک حالت باینری "خوشحال" یا "ناراحت" دور کنید؛ در عوض، متوجه شوید که حقیقت همیشه ظریف‌تر از این است. از داشتن هر مشکل کوچکی که یک هشدار ایجاد می‌کند، به تفکر جامع‌تر در مورد آنچه قابل قبول است، تغییر دهید. به شدت در نظر بگیرید که <em>SLOs</em> (اهداف سطح سرویس) را بپذیرید و بر اساس این اصول هشدار دهید تا خستگی هشدار را کاهش دهید و توجه را به درستی متمرکز کنید.</p>
<p><em>342 | Chapter 10: From Monitoring to Observability</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0368</div>
            </div>
        </div>
        <!-- Page 0369 -->
        <div class="chapter" id="page-0369">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>15 <em>Charity Majors</em>, <em>Liz Fong-Jones</em>, and <em>George Miranda</em>, <em>Observability Engineering</em> (<em>Sebastopol</em>: <em>O’Reilly</em>, 2022).</p>
<p>در زمان نگارش این کتاب، این کتاب در حال انتشار اولیه است.</p>
<p>16 <em>Betsy Beyer</em> et al., eds., <em>Site Reliability Engineering: How Google Runs Production Systems</em> (<em>Sebastopol</em>: <em>O’Reilly</em>, 2016).</p>
<p>17 <em>Betsy Beyer</em> et al., eds., <em>The Site Reliability Workbook</em> (<em>Sebastopol</em>: <em>O’Reilly</em>, 2018).</p>
<p>بیش از هر چیز، این در مورد پذیرش این است که قبل از رسیدن به <em>production</em> (تولید)، همه چیز قابل دانستن نیست. در مدیریت ناشناخته‌ها خوب باشید.</p>
<p>ما مطالب زیادی را پوشش داده‌ایم، اما در اینجا موارد بیشتری برای بررسی وجود دارد. اگر می‌خواهید مفاهیم <em>observability</em> (قابلیت مشاهده‌پذیری) را با جزئیات بیشتری بررسی کنید، پس من <em>Observability Engineering</em> by <em>Charity Majors</em>, <em>Liz Fong-Jones</em>, and <em>George Miranda</em> را توصیه می‌کنم.15 من همچنین هر دو <em>Site Reliability Engineering</em>16 و <em>The Site Reliability Workbook</em>17 را به عنوان نقاط شروع خوب برای بحث گسترده‌تر در مورد <em>SLOs</em> (اهداف سطح سرویس)، <em>SLIs</em> (شاخص‌های سطح سرویس) و موارد مشابه توصیه می‌کنم. شایان ذکر است که این دو کتاب آخر، تا حد زیادی از دیدگاهی نوشته شده‌اند که چگونه کارها در گوگل انجام می‌شود (یا می‌شد)، و این بدان معناست که این مفاهیم همیشه ترجمه نمی‌شوند. شما احتمالاً گوگل نیستید و احتمالاً مشکلات گوگل را ندارید. با این حال، هنوز هم موارد زیادی برای توصیه در این کتاب‌ها وجود دارد.</p>
<p>در فصل بعد، ما دیدگاهی متفاوت، اگرچه هنوز هم کل‌نگرانه، از سیستم‌های خود خواهیم داشت و برخی از مزایای منحصربه‌فرد—و چالش‌هایی—را که معماری‌های دقیق می‌توانند در زمینه امنیت ارائه دهند، در نظر خواهیم گرفت.</p>
<p><em>Summary | 343</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0369</div>
            </div>
        </div>
        <!-- Page 0371 -->
        <div class="chapter" id="page-0371">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>CHAPTER 11 (فصل 11)</h3>
<h4>Security (امنیت)</h4>
<p>من می‌خواهم این فصل را با گفتن این موضوع آغاز کنم که من خودم را یک متخصص در زمینه <em>application security</em> (امنیت نرم‌افزار) نمی‌دانم. من صرفاً قصد دارم یک فرد آگاه باشم—به عبارت دیگر، می‌خواهم بفهمم که چه چیزی را نمی‌دانم و از محدودیت‌های خود آگاه باشم. حتی در حالی که در مورد این فضا بیشتر می‌آموزم، متوجه می‌شوم که هنوز چیزهای بیشتری برای دانستن وجود دارد. این به این معنا نیست که آموزش خود در مورد موضوعاتی مانند این بی‌فایده است—من احساس می‌کنم که هر آنچه در ده سال گذشته در مورد این فضا آموخته‌ام، من را به یک توسعه‌دهنده و معمار مؤثرتر تبدیل کرده است.</p>
<p>در این فصل، من جنبه‌هایی از <em>security</em> (امنیت) را برجسته می‌کنم که برای یک توسعه‌دهنده، معمار، یا فرد عملیاتی که روی یک معماری <em>microservice</em> (ریز سرویس) کار می‌کند، ارزشمند می‌دانم. هنوز هم نیاز به حمایت متخصصان در زمینه <em>application security</em> (امنیت نرم‌افزار) وجود دارد—اما حتی اگر به چنین افرادی دسترسی داشته باشید، همچنان مهم است که شما در این موضوعات، زمینه‌ای داشته باشید. به همان روشی که توسعه‌دهندگان در مورد تست یا مدیریت داده‌ها، موضوعاتی که قبلاً به متخصصان محدود می‌شد، بیشتر آموخته‌اند، داشتن آگاهی عمومی از موضوعات <em>security</em> (امنیت) می‌تواند از نظر ایجاد <em>security</em> (امنیت) در نرم‌افزار ما از ابتدا، حیاتی باشد.</p>
<p>هنگام مقایسه <em>microservices</em> (ریز سرویس‌ها) با معماری‌های کمتر توزیع‌شده، مشخص می‌شود که ما با یک دوگانگی جالب مواجه هستیم. از یک طرف، ما اکنون داده‌های بیشتری را داریم که از طریق شبکه‌هایی جریان دارند که قبلاً در یک ماشین واحد باقی می‌ماندند، و ما زیرساخت‌های پیچیده‌تری را برای اجرای معماری خود داریم—سطح حمله ما بسیار بیشتر است. از طرف دیگر، <em>microservices</em> (ریز سرویس‌ها) به ما فرصت‌های بیشتری برای دفاع در عمق و محدود کردن دامنه دسترسی می‌دهند، که به‌طور بالقوه می‌تواند پروژه‌ سیستم ما را افزایش دهد و در عین حال تأثیر حمله را در صورت وقوع کاهش دهد. این پارادوکس ظاهری—که <em>microservices</em> (ریز سرویس‌ها) می‌توانند سیستم‌های ما را هم کمتر ایمن و هم ایمن‌تر کنند—در واقع فقط یک عمل متعادل‌سازی ظریف است. امید من این است که تا پایان این فصل، شما در سمت راست این معادله قرار بگیرید.</p>
<p><em>345</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0371</div>
            </div>
        </div>
        <!-- Page 0372 -->
        <div class="chapter" id="page-0372">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>برای کمک به شما در یافتن تعادل مناسب در مورد <em>security</em> (امنیت) معماری <em>microservice</em> (ریز سرویس) خود، ما موضوعات زیر را پوشش خواهیم داد:</p>
<ul>
<li>Core principles (اصول اصلی)</li>
<p>مفاهیم اساسی که در هنگام تلاش برای ساخت نرم‌افزار ایمن‌تر، مفید هستند</p>
<li>The five functions of cybersecurity (پنج عملکرد امنیت سایبری)</li>
<p>شناسایی، محافظت، تشخیص، پاسخگویی و بازیابی—مروری بر پنج حوزه عملکردی کلیدی برای <em>application security</em> (امنیت نرم‌افزار)</p>
<li>Foundations of application security (بنیادهای امنیت نرم‌افزار)</li>
<p>برخی از مفاهیم اساسی <em>application security</em> (امنیت نرم‌افزار) و نحوه اعمال آنها در <em>microservices</em> (ریز سرویس‌ها)، از جمله <em>credentials</em> (اعتبارنامه‌ها) و <em>secrets</em> (رازها)، <em>patching</em> (وصله‌کردن)، <em>backups</em> (پشتیبان‌گیری) و <em>rebuild</em> (بازسازی)</p>
<li>Implicit trust versus zero trust (اعتماد ضمنی در مقابل اعتماد صفر)</li>
<p>رویکردهای مختلف برای اعتماد در محیط <em>microservice</em> (ریز سرویس) ما و چگونگی تأثیر این امر بر فعالیت‌های مرتبط با <em>security</em> (امنیت)</p>
<li>Securing data (ایمن‌سازی داده‌ها)</li>
<p>چگونه داده‌ها را در حین انتقال در شبکه‌ها و در حین ذخیره‌سازی در دیسک محافظت می‌کنیم</p>
<li>Authentication and authorization (احراز هویت و مجوز)</li>
<p>نحوه عملکرد <em>single sign-on</em> (SSO) (ورود به سیستم یکپارچه) در یک معماری <em>microservice</em> (ریز سرویس)، مدل‌های مجوزدهی متمرکز در مقابل غیرمتمرکز، و نقش توکن‌های <em>JWT</em> به عنوان بخشی از این موارد</p>
</ul>
<h4>Core Principles (اصول اصلی)</h4>
<p>اغلب، وقتی موضوع <em>microservice security</em> (امنیت ریز سرویس) مطرح می‌شود، مردم می‌خواهند در مورد مسائل تکنولوژیکی نسبتاً پیچیده‌ای مانند استفاده از توکن‌های <em>JWT</em> یا نیاز به <em>mutual TLS</em> (موضوعاتی که در ادامه این فصل بررسی خواهیم کرد) صحبت کنند. با این حال، مشکل <em>security</em> (امنیت) این است که شما فقط به اندازه کمترین جنبه ایمن خود ایمن هستید. برای استفاده از یک تشبیه، اگر به دنبال ایمن‌سازی خانه خود هستید، تمرکز تمام تلاش‌های خود بر داشتن یک درب ورودی مقاوم در برابر انتخاب، با چراغ‌ها و دوربین‌ها برای جلوگیری از افراد مخرب، اشتباه است، اگر درب پشتی خود را باز بگذارید.</p>
<p>بنابراین، برخی جنبه‌های اساسی <em>application security</em> (امنیت نرم‌افزار) وجود دارد که ما باید به آنها نگاهی بیندازیم، هرچند به اختصار، تا انبوهی از مسائلی را که باید از آنها آگاه باشید، برجسته کنیم. ما بررسی خواهیم کرد که چگونه این مسائل اصلی در زمینه <em>microservices</em> (ریز سرویس‌ها) پیچیده‌تر (یا کمتر) می‌شوند، اما آنها همچنین باید به طور کلی برای توسعه نرم‌افزار به عنوان یک کل قابل اجرا باشند. برای کسانی از شما که می‌خواهید به همه آن "مطالب خوب" بپردازید، لطفاً فقط اطمینان حاصل کنید که بیش از حد روی ایمن‌سازی درب ورودی خود تمرکز نمی‌کنید در حالی که درب پشتی را باز می‌گذارید.</p>
<p><em>346 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0372</div>
            </div>
        </div>
        <!-- Page 0373 -->
        <div class="chapter" id="page-0373">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>1 لطفاً، بیایید همه چیز را به برگزیت (Brexit) مربوط نکنیم.</p>
<h4>Principle of Least Privilege (اصل کمترین امتیاز)</h4>
<p>هنگام اعطای دسترسی برنامه به افراد، سیستم‌های خارجی یا داخلی، یا حتی <em>microservices</em> (ریز سرویس‌های) خودمان، باید به دقت به میزان دسترسی که اعطا می‌کنیم، توجه کنیم. <em>principle of least privilege</em> (اصل کمترین امتیاز) ایده را توصیف می‌کند که هنگام اعطای دسترسی، باید حداقل دسترسی مورد نیاز یک طرف را برای انجام عملکرد مورد نیاز، و فقط برای بازه زمانی مورد نیاز آنها، اعطا کنیم. مزیت اصلی این امر این است که اطمینان حاصل شود که اگر <em>credentials</em> (اعتبارنامه‌ها) توسط یک مهاجم به خطر بیفتند، آن <em>credentials</em> (اعتبارنامه‌ها) دسترسی محدودی را در اختیار طرف مخرب قرار می‌دهند.</p>
<p>اگر یک <em>microservice</em> (ریز سرویس) فقط دسترسی <em>read-only</em> (فقط خواندنی) به یک <em>database</em> (پایگاه داده) داشته باشد، در این صورت یک مهاجم که به آن <em>database credentials</em> (اعتبارنامه‌های پایگاه داده) دسترسی پیدا می‌کند، فقط دسترسی <em>read-only</em> (فقط خواندنی) را به دست می‌آورد، و فقط به آن <em>database</em> (پایگاه داده). اگر <em>credential</em> (اعتبارنامه) به <em>database</em> (پایگاه داده) قبل از به خطر افتادن منقضی شود، آنگاه <em>credential</em> (اعتبارنامه) بی‌فایده می‌شود. این مفهوم را می‌توان برای محدود کردن اینکه کدام <em>microservices</em> (ریز سرویس‌ها) را می‌توان توسط طرف‌های خاصی ارتباط برقرار کرد، گسترش داد.</p>
<p>همانطور که در ادامه این فصل خواهیم دید، <em>principle of least privilege</em> (اصل کمترین امتیاز) می‌تواند به اطمینان از اینکه کنترل‌های دسترسی فقط برای بازه‌های زمانی محدود اعطا می‌شوند، گسترش یابد، که بیشتر نتایج بدی را که ممکن است در صورت به خطر افتادن رخ دهد، محدود می‌کند.</p>
<h4>Defense in Depth (دفاع در عمق)</h4>
<p>بریتانیا، جایی که من زندگی می‌کنم، پر از قلعه است. این قلعه‌ها تا حدی یادآور تاریخ کشور ما هستند (مخصوصاً یادآور زمانی قبل از اینکه بریتانیا، تا حدی متحد شود). آنها ما را به یاد زمانی می‌اندازند که مردم احساس نیاز به دفاع از اموال خود در برابر دشمنان می‌کردند. گاهی اوقات دشمنان ادراک‌شده متفاوت بودند—بسیاری از قلعه‌های نزدیک جایی که من در کنت زندگی می‌کنم، برای دفاع در برابر تهاجمات ساحلی از فرانسه طراحی شده بودند.1 به هر دلیلی، قلعه‌ها می‌توانند نمونه‌ای عالی از <em>principle of defense in depth</em> (اصل دفاع در عمق) باشند.</p>
<p>داشتن فقط یک مکانیسم حفاظت، در صورتی که یک مهاجم راهی برای نقض آن دفاع پیدا کند، یا اگر مکانیسم حفاظت فقط از انواع خاصی از مهاجمان دفاع کند، یک مشکل است. به یک قلعه دفاع ساحلی فکر کنید که تنها دیوار آن رو به دریا است، و آن را کاملاً در برابر حمله زمینی بی‌دفاع می‌گذارد. اگر به قلعه <em>Dover</em>، که بسیار نزدیک به جایی است که من زندگی می‌کنم، نگاه کنید، حفاظت‌های متعددی وجود دارد که به راحتی قابل مشاهده هستند. اولاً، در یک تپه بزرگ قرار دارد که نزدیک شدن به قلعه را از طریق خشکی دشوار می‌کند. این یک دیوار نیست، بلکه دو دیوار دارد—نقض دیوار اول هنوز مستلزم آن است که یک مهاجم با دیوار دوم مقابله کند. و هنگامی که شما از آخرین دیوار عبور کردید، یک برج (برج) بزرگ و باشکوه برای مقابله دارید.</p>
<p>همین اصل باید هنگام ایجاد محافظت در <em>application security</em> (امنیت نرم‌افزار) ما اعمال شود. داشتن چندین حفاظت در جای خود برای دفاع در برابر مهاجمان حیاتی است. با</p>
<p><em>Core Principles | 347</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0373</div>
            </div>
        </div>
        <!-- Page 0374 -->
        <div class="chapter" id="page-0374">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>2 هر چقدر هم تلاش کنم، نمی‌توانم منبع اصلی این طرح طبقه‌بندی را پیدا کنم.</p>
<p>معماری‌های <em>microservice</em> (ریز سرویس)، ما مکان‌های بیشتری داریم که در آنها می‌توانیم از سیستم‌های خود محافظت کنیم. با جدا کردن عملکرد خود به <em>microservices</em> (ریز سرویس‌های) مختلف و محدود کردن دامنه کاری آن <em>microservices</em> (ریز سرویس‌ها)، ما در حال حاضر <em>defense in depth</em> (دفاع در عمق) را اعمال می‌کنیم. ما همچنین می‌توانیم <em>microservices</em> (ریز سرویس‌ها) را در بخش‌های مختلف شبکه اجرا کنیم، حفاظت‌های مبتنی بر شبکه را در مکان‌های بیشتری اعمال کنیم، و حتی از ترکیبی از فناوری برای ساخت و اجرای این <em>microservices</em> (ریز سرویس‌ها) استفاده کنیم به طوری که یک <em>zero-day exploit</em> (آسیب‌پذیری روز صفر) واحد ممکن است بر همه چیزهایی که داریم تأثیر نگذارد.</p>
<p><em>Microservices</em> (ریز سرویس‌ها) توانایی بیشتری برای دفاع در عمق نسبت به برنامه‌های <em>monolithic</em> (یکپارچه) تک فرآیندی معادل فراهم می‌کنند، و در نتیجه، آنها می‌توانند به سازمان‌ها در ساخت سیستم‌های امن‌تر کمک کنند.</p>
<h4>Types of Security Controls (انواع کنترل‌های امنیتی)</h4>
<p>هنگام در نظر گرفتن کنترل‌های امنیتی که ممکن است برای ایمن‌سازی سیستم خود قرار دهیم، می‌توانیم آنها را به عنوان موارد زیر طبقه‌بندی کنیم:2</p>
<ul>
<li>Preventative (پیشگیرانه)</li>
<p>متوقف کردن یک حمله از وقوع. این شامل ذخیره <em>secrets</em> (رازها) به طور ایمن، رمزگذاری داده‌ها در حالت <em>rest</em> (بیکاری) و در حال انتقال، و پیاده‌سازی مکانیسم‌های مناسب <em>authentication</em> (احراز هویت) و <em>authorization</em> (مجوز) است.</p>
<li>Detective (تشخیصی)</li>
<p>هشدار دادن به شما در مورد این واقعیت که یک حمله در حال وقوع است/رخ داده است. <em>firewalls</em> (فایروال‌ها) برنامه و خدمات تشخیص نفوذ نمونه‌های خوبی هستند.</p>
<li>Responsive (واکنشی)</li>
<p>کمک به شما در پاسخگویی در حین/بعد از یک حمله. داشتن یک مکانیسم خودکار برای بازسازی سیستم خود، پشتیبان‌گیری‌های کارآمد برای بازیابی داده‌ها، و یک برنامه ارتباطی مناسب در پی یک حادثه می‌تواند حیاتی باشد.</p>
</ul>
<p>ترکیبی از هر سه برای ایمن‌سازی صحیح یک سیستم مورد نیاز است، و شما ممکن است چندین مورد از هر نوع داشته باشید. با بازگشت به مثال قلعه ما، ممکن است چندین دیوار داشته باشیم، که نشان‌دهنده چندین کنترل پیشگیرانه است. ما می‌توانیم برج‌های دیده‌بانی و یک سیستم <em>beacon</em> (فانوس دریایی) داشته باشیم تا بتوانیم ببینیم آیا حمله‌ای در حال وقوع است یا خیر. در نهایت، ممکن است تعدادی نجار و سنگ‌تراش در حالت آماده‌باش داشته باشیم، در صورتی که نیاز به تقویت درها یا دیوارها در پی یک حمله داشته باشیم. بدیهی است که بعید است که شما برای امرار معاش قلعه بسازید، بنابراین ما به مثال‌هایی از این کنترل‌ها برای یک معماری <em>microservice</em> (ریز سرویس) در ادامه این فصل نگاه خواهیم کرد.</p>
<p><em>348 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0374</div>
            </div>
        </div>
        <!-- Page 0375 -->
        <div class="chapter" id="page-0375">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>3 برای کسب اطلاعات بیشتر در مورد بینش‌های او، من <em>Understanding Design Thinking</em>، <em>Lean</em> و <em>Agile</em> جونی را (<em>O’Reilly</em>) توصیه می‌کنم.</p>
<h4>Automation (خودکارسازی)</h4>
<p>یک موضوع تکراری این کتاب، <em>automation</em> (خودکارسازی) است. از آنجایی که ما قطعات متحرک بسیار بیشتری با معماری‌های <em>microservice</em> (ریز سرویس) داریم، <em>automation</em> (خودکارسازی) برای کمک به ما در مدیریت پیچیدگی فزاینده سیستممان، کلیدی می‌شود. در عین حال، ما به سمت افزایش سرعت تحویل حرکت می‌کنیم، و <em>automation</em> (خودکارسازی) در اینجا ضروری است. کامپیوترها در انجام یک کار یکسان بارها و بارها بهتر از انسان‌ها هستند—آنها این کار را سریع‌تر و کارآمدتر از ما انجام می‌دهند (و همچنین با نوسانات کمتری). آنها همچنین می‌توانند خطاهای انسانی را کاهش دهند و پیاده‌سازی <em>principle of least privilege</em> (اصل کمترین امتیاز) را آسان‌تر کنند—به عنوان مثال، می‌توانیم امتیازات خاصی را به اسکریپت‌های خاصی اختصاص دهیم.</p>
<p>همانطور که در این فصل خواهیم دید، <em>automation</em> (خودکارسازی) می‌تواند به ما کمک کند تا در پی یک حادثه، بازیابی کنیم. ما می‌توانیم از آن برای لغو و چرخاندن کلیدهای <em>security</em> (امنیت) استفاده کنیم و همچنین از <em>tooling</em> (ابزارسازی) برای کمک به تشخیص آسان‌تر مسائل <em>security</em> (امنیت) بالقوه استفاده کنیم. همانند سایر جنبه‌های معماری <em>microservice</em> (ریز سرویس)، پذیرش فرهنگ <em>automation</em> (خودکارسازی) به شما در زمینه <em>security</em> (امنیت) بسیار کمک خواهد کرد.</p>
<h4>Build Security into the Delivery Process (ایجاد امنیت در فرآیند تحویل)</h4>
<p>مانند بسیاری از جنبه‌های دیگر تحویل نرم‌افزار، <em>security</em> (امنیت) اغلب به عنوان یک <em>afterthought</em> (چیز بی‌اهمیت) در نظر گرفته می‌شود. حداقل از نظر تاریخی، رسیدگی به جنبه‌های <em>security</em> (امنیت) یک سیستم، کاری است که پس از نوشته شدن کد انجام می‌شود، که به طور بالقوه منجر به بازسازی قابل توجهی در مراحل بعدی می‌شود. <em>Security</em> (امنیت) اغلب به عنوان یک مانع برای خارج کردن نرم‌افزار در نظر گرفته می‌شود.</p>
<p>در 20 سال گذشته، ما مشکلات مشابهی را با تست، قابلیت استفاده و عملیات مشاهده کرده‌ایم. این جنبه‌های تحویل نرم‌افزار اغلب به صورت مجزا ارائه می‌شدند، اغلب پس از اتمام بخش عمده‌ای از کد. یکی از همکاران قدیمی من، جانی اشنایدر، زمانی رویکردی را نسبت به قابلیت استفاده از نرم‌افزار از نظر ذهنیت "آیا سیب‌زمینی سرخ کرده همراهش می‌خواهید؟" تشبیه کرد. به عبارت دیگر، قابلیت استفاده یک <em>afterthought</em> (چیز بی‌اهمیت) است—چیزی که شما روی "غذای اصلی" می‌پاشید.3</p>
<p>البته واقعیت این است که نرم‌افزاری که قابل استفاده نیست، ایمن نیست، نمی‌تواند به درستی در تولید عمل کند و مملو از اشکالات است، به هیچ وجه یک "غذای اصلی" نیست—در بهترین حالت یک ارائه معیوب است. ما در پیشبرد تست‌ها به فرآیند تحویل اصلی، همانطور که در مورد جنبه‌های عملیاتی (<em>DevOps</em>، هرکسی؟) و قابلیت استفاده انجام دادیم—<em>security</em> (امنیت) نباید متفاوت باشد. ما باید اطمینان حاصل کنیم که توسعه‌دهندگان از آگاهی عمومی‌تری از نگرانی‌های مرتبط با <em>security</em> (امنیت) برخوردارند، متخصصان راهی برای ادغام خود در تیم‌های تحویل در صورت نیاز پیدا می‌کنند، و <em>tooling</em> (ابزارسازی) برای ایجاد تفکر مرتبط با <em>security</em> (امنیت) در نرم‌افزار ما، بهبود می‌یابد.</p>
<p><em>Core Principles | 349</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0375</div>
            </div>
        </div>
        <!-- Page 0376 -->
        <div class="chapter" id="page-0376">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>این می‌تواند چالش‌هایی را در سازمان‌هایی که تیم‌های همراستا با جریان را با درجات افزایشی استقلال در مورد مالکیت <em>microservices</em> (ریز سرویس‌های) خود اتخاذ می‌کنند، ایجاد کند. نقش متخصصان <em>security</em> (امنیت) چیست؟ در "Enabling Teams" (فعال‌سازی تیم‌ها) در صفحه 503، ما به این خواهیم پرداخت که چگونه متخصصانی مانند متخصصان <em>security</em> (امنیت) می‌توانند برای پشتیبانی از تیم‌های همراستا با جریان و کمک به مالکان <em>microservice</em> (ریز سرویس‌ها) در ایجاد تفکر بیشتر <em>security</em> (امنیت) در نرم‌افزار خود کار کنند، و همچنین اطمینان حاصل کنند که شما تخصص عمیق مناسبی را در دست دارید، زمانی که به آن نیاز دارید.</p>
<p>ابزارهای خودکاری وجود دارند که می‌توانند سیستم‌های ما را از نظر آسیب‌پذیری‌ها بررسی کنند، مانند جستجوی حملات <em>cross-site scripting</em> (XSS). <em>Zed Attack Proxy</em> (همچنین ZAP نامیده می‌شود) نمونه خوبی است. <em>ZAP</em> که توسط کار <em>OWASP</em> اطلاع‌رسانی شده است، تلاش می‌کند حملات مخرب را در وب‌سایت شما بازسازی کند. ابزارهای دیگری وجود دارند که از <em>static analysis</em> (تحلیل ایستا) برای جستجوی اشتباهات رایج کدنویسی که می‌تواند سوراخ‌های <em>security</em> (امنیت) را باز کند، استفاده می‌کنند، مانند <em>Brakeman</em> برای <em>Ruby</em>؛ همچنین ابزارهایی مانند <em>Snyk</em> وجود دارد، که در میان موارد دیگر می‌تواند وابستگی‌ها به کتابخانه‌های شخص ثالث را که دارای آسیب‌پذیری‌های شناخته شده هستند، شناسایی کند. جایی که این ابزارها را می‌توان به راحتی در ساخت‌های <em>CI</em> معمولی ادغام کرد، ادغام آنها در <em>check-ins</em> استاندارد شما، مکان بسیار خوبی برای شروع است. البته، شایان ذکر است که بسیاری از این نوع ابزارها فقط می‌توانند به مسائل محلی رسیدگی کنند—به عنوان مثال، یک آسیب‌پذیری در یک قطعه کد خاص. آنها جایگزین نیاز به درک <em>security</em> (امنیت) سیستم شما در یک سطح گسترده‌تر و سیستمی نمی‌شوند.</p>
<h4>The Five Functions of Cybersecurity (پنج عملکرد امنیت سایبری)</h4>
<p>با در نظر گرفتن آن اصول اصلی، بیایید اکنون فعالیت‌های گسترده مرتبط با <em>security</em> (امنیت) را که باید انجام دهیم، در نظر بگیریم. سپس به درک چگونگی متفاوت بودن این فعالیت‌ها در زمینه معماری <em>microservice</em> (ریز سرویس) خواهیم پرداخت.</p>
<p>مدلی که من برای توصیف جهان <em>application security</em> (امنیت نرم‌افزار) ترجیح می‌دهم، از مؤسسه ملی استانداردها و فناوری ایالات متحده (<em>NIST</em>) می‌آید، که یک مدل پنج قسمتی مفید برای فعالیت‌های مختلف مرتبط با <em>cybersecurity</em> (امنیت سایبری) را شرح می‌دهد:</p>
<ul>
<li>شناسایی اینکه مهاجمان بالقوه شما چه کسانی هستند، چه اهدافی را در تلاش برای به دست آوردن هستند، و در کجا آسیب‌پذیرتر هستید.</li>
<li>محافظت از دارایی‌های کلیدی خود در برابر هکرها.</li>
<li>تشخیص اینکه آیا حمله‌ای رخ داده است، علیرغم بهترین تلاش‌های شما.</li>
<li>پاسخ دادن وقتی فهمیدید که اتفاق بدی رخ داده است.</li>
<li>بازیابی در پی یک حادثه.</li>
</ul>
<p>من این مدل را به دلیل ماهیت جامع آن، به ویژه مفید می‌دانم. بسیار آسان است که تمام تلاش خود را صرف محافظت از برنامه خود کنید، بدون اینکه ابتدا تهدیداتی را که ممکن است واقعاً با آن روبرو شوید، در نظر بگیرید، چه رسد به اینکه بفهمید اگر یک مهاجم باهوش از دفاعیات شما عبور کند، چه کاری می‌توانید انجام دهید.</p>
<p><em>350 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0376</div>
            </div>
        </div>
        <!-- Page 0377 -->
        <div class="chapter" id="page-0377">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>4 این بیشتر یک بحث منفعل-پرخاشگرانه بود، که اغلب بدون بخش "منفعل" بود.</p>
<p>بیایید هر یک از این عملکردها را با کمی عمق بیشتر بررسی کنیم و به این موضوع بپردازیم که چگونه یک معماری <em>microservice</em> (ریز سرویس) ممکن است نحوه برخورد شما با این ایده‌ها را در مقایسه با یک معماری سنتی‌تر <em>monolithic</em> (یکپارچه) تغییر دهد.</p>
<h5>Identify (شناسایی)</h5>
<p>قبل از اینکه بتوانیم بفهمیم چه چیزی را باید محافظت کنیم، باید بفهمیم چه کسی ممکن است به دنبال چیزهای ما باشد و دقیقاً به دنبال چه چیزی هستند. قرار دادن خودمان در ذهنیت یک مهاجم اغلب دشوار است، اما این دقیقاً همان کاری است که ما باید انجام دهیم تا اطمینان حاصل کنیم که تلاش‌های خود را در جای مناسب متمرکز می‌کنیم. <em>Threat modeling</em> (مدل‌سازی تهدید) اولین چیزی است که باید هنگام پرداختن به این جنبه از <em>application security</em> (امنیت نرم‌افزار) به آن نگاه کنید.</p>
<p>به عنوان انسان، ما در درک ریسک کاملاً ضعیف هستیم. ما اغلب روی چیزهای اشتباه تمرکز می‌کنیم در حالی که مشکلات بزرگ‌تری را که می‌توانند از دید پنهان باشند، نادیده می‌گیریم. این البته به حوزه <em>security</em> (امنیت) نیز گسترش می‌یابد. درک ما در مورد خطرات امنیتی که ممکن است در معرض آن قرار بگیریم، اغلب تا حد زیادی توسط دید محدود ما از سیستم، مهارت‌ها و تجربیات ما رنگ می‌گیرد.</p>
<p>وقتی با توسعه‌دهندگان در مورد خطرات <em>security</em> (امنیت) در زمینه معماری <em>microservice</em> (ریز سرویس) گپ می‌زنم، آنها بلافاصله شروع به صحبت در مورد <em>JWTs</em> (توکن‌های <em>JWT</em>) و <em>mutual TLS</em> می‌کنند. آنها به دنبال راه‌حل‌های فنی برای مشکلات فنی هستند که تا حدی در آنها دید دارند. منظورم این نیست که فقط انگشت را به سمت توسعه‌دهندگان نشانه بگیرم—همه ما دید محدودی از جهان داریم. با بازگشت به تشبیهی که قبلاً استفاده کردیم، اینگونه است که ما می‌توانیم با یک درب ورودی فوق‌العاده ایمن و یک درب پشتی کاملاً باز، به پایان برسیم.</p>
<p>در یک شرکتی که من در آن کار می‌کردم، بحث‌های متعددی در مورد نیاز به نصب دوربین‌های مداربسته (<em>CCTV</em>) در مناطق پذیرش دفاتر شرکت در سراسر جهان وجود داشت. این به دلیل حادثه‌ای بود که در آن یک فرد غیرمجاز به منطقه دفتر جلویی و سپس شبکه شرکتی دسترسی پیدا کرده بود. این اعتقاد وجود داشت که یک سیستم دوربین مداربسته نه تنها دیگران را از تلاش مجدد برای انجام همان کار منصرف می‌کند، بلکه به شناسایی افراد درگیر پس از این واقعه نیز کمک می‌کند.</p>
<p>شبح نظارت شرکتی، موجی از رنج را در شرکت در مورد نگرانی‌های نوع "برادر بزرگ" به راه انداخت. بسته به اینکه در کدام طرف بحث بودید، این یا در مورد جاسوسی از کارمندان بود (اگر شما طرفدار دوربین‌ها بودید) یا در مورد خوشحال بودن از اینکه مزاحمان به ساختمان‌ها دسترسی پیدا کنند (اگر شما مخالف دوربین‌ها بودید). با کنار گذاشتن ماهیت مشکل‌ساز چنین بحث قطبی‌شده‌ای،4 یکی از کارمندان به روشی نسبتاً خجالت‌آور صحبت کرد تا پیشنهاد کند که شاید بحث کمی گمراه‌کننده باشد زیرا ما برخی از مسائل بزرگ‌تر را از دست داده بودیم—یعنی این واقعیت که مردم ظاهراً نگران نبودند که درب جلوی یکی از دفاتر اصلی قفل معیوب داشت، و سال‌ها مردم صبح‌ها می‌آمدند و درب را باز می‌دیدند.</p>
<p><em>The Five Functions of Cybersecurity | 351</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0377</div>
            </div>
        </div>
        <!-- Page 0378 -->
        <div class="chapter" id="page-0378">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>5 <em>Adam Shostack</em>, <em>Threat Modeling: Designing for Security</em> (<em>Indianapolis</em>: <em>Wiley</em>, 2014).</p>
<p>این داستان افراطی (اما واقعی) نمونه‌ای عالی از یک مشکل رایج است که ما هنگام تلاش برای ایمن‌سازی سیستم‌هایمان با آن روبرو هستیم. بدون اینکه زمان کافی برای در نظر گرفتن همه عوامل و درک اینکه دقیقاً بزرگترین خطرات شما در کجا قرار دارند، داشته باشید، ممکن است در نهایت مکان‌هایی را که زمان شما در آنها بهتر صرف می‌شود، از دست بدهید. هدف از <em>threat modeling</em> (مدل‌سازی تهدید) کمک به شما در درک این است که یک مهاجم ممکن است از سیستم شما چه بخواهد. آنها به دنبال چه چیزی هستند؟ آیا انواع مختلف بازیگران مخرب می‌خواهند به دارایی‌های مختلف دسترسی پیدا کنند؟ <em>Threat modeling</em> (مدل‌سازی تهدید)، در صورت انجام صحیح، تا حد زیادی در مورد قرار دادن خود در ذهن مهاجم، تفکر از بیرون به داخل است. این دیدگاه بیرونی مهم است، و یکی از دلایلی است که کمک گرفتن از یک طرف خارجی برای هدایت یک تمرین <em>threat modeling</em> (مدل‌سازی تهدید) می‌تواند بسیار مفید باشد.</p>
<p>ایده اصلی <em>threat modeling</em> (مدل‌سازی تهدید) وقتی به معماری‌های <em>microservice</em> (ریز سرویس) نگاه می‌کنیم، تغییر چندانی نمی‌کند، جدا از این واقعیت که هر معماری که تجزیه و تحلیل می‌شود، ممکن است اکنون پیچیده‌تر باشد. آنچه تغییر می‌کند این است که چگونه نتیجه یک مدل تهدید را می‌گیریم و آن را به کار می‌بندیم. یکی از خروجی‌های یک تمرین <em>threat modeling</em> (مدل‌سازی تهدید)، فهرستی از توصیه‌ها برای کنترل‌های <em>security</em> (امنیت) است که باید اجرا شوند—این کنترل‌ها می‌توانند شامل مواردی مانند تغییر در فرآیند، تغییر در فناوری، یا شاید تغییری در معماری سیستم باشند. برخی از این تغییرات ممکن است متقابل باشند و می‌تواند بر چندین تیم و <em>microservices</em> (ریز سرویس‌های) مرتبط با آنها تأثیر بگذارد. موارد دیگر ممکن است منجر به کار هدفمندتر شوند. اما اساساً، هنگام انجام <em>threat modeling</em> (مدل‌سازی تهدید)، شما باید به طور <em>holistic</em> (کل‌نگرانه) نگاه کنید—متمرکز کردن این تجزیه و تحلیل بر روی زیرمجموعه‌ای بیش از حد کوچک از سیستم شما، مانند یک یا دو <em>microservices</em> (ریز سرویس)، ممکن است منجر به احساس امنیت کاذب شود. ممکن است زمان خود را صرف ساخت یک درب ورودی فوق‌العاده ایمن کنید، فقط برای اینکه پنجره را باز بگذارید.</p>
<p>برای یک غواصی عمیق‌تر در این موضوع، من می‌توانم <em>Threat Modeling: Designing for Security</em>5 by <em>Adam Shostack</em> را توصیه کنم.</p>
<h5>Protect (محافظت)</h5>
<p>هنگامی که ما باارزش‌ترین—و آسیب‌پذیرترین—دارایی‌های خود را شناسایی کردیم، باید اطمینان حاصل کنیم که آنها به درستی محافظت می‌شوند. همانطور که اشاره کردم، معماری‌های <em>microservice</em> (ریز سرویس) احتمالاً سطح حمله بسیار وسیع‌تری را به ما می‌دهند، و بنابراین ما چیزهای بیشتری داریم که ممکن است نیاز به محافظت داشته باشند، اما آنها همچنین گزینه‌های بیشتری را برای دفاع در عمق به ما می‌دهند. ما بیشتر این فصل را صرف تمرکز بر جنبه‌های مختلف حفاظت خواهیم کرد، در درجه اول به این دلیل که این حوزه‌ای است که معماری‌های <em>microservice</em> (ریز سرویس) بیشترین چالش‌ها را ایجاد می‌کنند.</p>
<p><em>352 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0378</div>
            </div>
        </div>
        <!-- Page 0379 -->
        <div class="chapter" id="page-0379">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h5>Detect (تشخیص)</h5>
<p>با یک معماری <em>microservice</em> (ریز سرویس)، تشخیص یک حادثه می‌تواند پیچیده‌تر باشد. ما شبکه‌های بیشتری برای نظارت و ماشین‌های بیشتری برای زیر نظر گرفتن داریم. منابع اطلاعات به شدت افزایش یافته‌اند، که می‌تواند تشخیص مشکلات را دشوارتر کند. بسیاری از تکنیک‌هایی که در فصل 10 بررسی کردیم، مانند تجمیع <em>log</em> (لاگ)، می‌تواند به ما کمک کند تا اطلاعاتی را جمع‌آوری کنیم که به ما کمک می‌کند تا تشخیص دهیم که ممکن است اتفاق بدی در حال رخ دادن باشد. علاوه بر این موارد، ابزارهای ویژه‌ای مانند سیستم‌های تشخیص نفوذ وجود دارند که ممکن است برای شناسایی رفتار بد، اجرا کنید. نرم‌افزار برای مقابله با پیچیدگی فزاینده سیستم‌های ما در حال بهبود است، به‌ویژه در فضای <em>container</em> (کانتینر) با ابزارهایی مانند <em>Aqua</em>.</p>
<h5>Respond (پاسخگویی)</h5>
<p>اگر بدترین اتفاق افتاده باشد و شما از آن مطلع شده‌اید، چه باید بکنید؟ اتخاذ یک رویکرد پاسخگویی مؤثر به حادثه برای محدود کردن آسیب‌های ناشی از یک نقض، حیاتی است. این معمولاً با درک دامنه نقض و اینکه چه داده‌هایی در معرض دید قرار گرفته است، شروع می‌شود. اگر داده‌های در معرض دید، شامل اطلاعات شناسایی شخصی (<em>PII</em>) باشد، در این صورت شما باید از فرآیندهای پاسخگویی و اعلان حادثه <em>security</em> (امنیت) و حریم خصوصی پیروی کنید. این ممکن است به این معنی باشد که شما باید با بخش‌های مختلف سازمان خود صحبت کنید، و در برخی شرایط ممکن است از نظر قانونی ملزم به اطلاع به یک افسر حفاظت از داده‌ها در صورت وقوع انواع خاصی از نقض باشید.</p>
<p>بسیاری از سازمان‌ها، تأثیر یک نقض را از طریق سوء مدیریت پیامدها، اغلب منجر به مجازات‌های مالی بیشتر، جدا از آسیب‌های وارد شده به نام تجاری و رابطه آن با مشتریان خود، ترکیب کرده‌اند. بنابراین، مهم است که نه تنها درک کنید که به دلیل دلایل قانونی یا انطباق چه کاری باید انجام دهید، بلکه در مورد نحوه مراقبت از کاربران نرم‌افزار خود نیز باید بدانید. به عنوان مثال، <em>GDPR</em> (قانون حریم خصوصی داده‌ها) مستلزم آن است که نقض داده‌های شخصی ظرف 72 ساعت به مقامات مربوطه گزارش شود—یک جدول زمانی که چندان سنگین به نظر نمی‌رسد. این به این معنی نیست که شما نمی‌توانید تلاش کنید تا در صورت وقوع نقض داده‌هایشان، زودتر به مردم اطلاع دهید.</p>
<p>جدا از جنبه‌های ارتباطی خارجی پاسخ، نحوه رسیدگی شما به امور داخلی نیز بسیار مهم است. سازمان‌هایی که دارای فرهنگ سرزنش و ترس هستند، احتمالاً در پی یک حادثه بزرگ، عملکرد ضعیفی خواهند داشت. درس‌ها آموخته نخواهد شد، و عوامل مؤثر آشکار نخواهند شد. از طرف دیگر، سازمانی که بر گشودگی و ایمنی تمرکز دارد، بهترین موقعیت را برای یادگیری درس‌هایی خواهد داشت که اطمینان حاصل می‌کند که حوادث مشابه احتمال کمتری دارد که رخ دهند. ما به این موضوع در "Blame" (سرزنش) در صفحه 415 باز خواهیم گشت.</p>
<p><em>The Five Functions of Cybersecurity | 353</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0379</div>
            </div>
        </div>
        <!-- Page 0380 -->
        <div class="chapter" id="page-0380">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h5>Recover (بازیابی)</h5>
<p>بازیابی به توانایی ما در راه‌اندازی مجدد سیستم در پی یک حمله، و همچنین توانایی ما در اجرای آنچه آموخته‌ایم برای اطمینان از اینکه مشکلات احتمال کمتری برای دوباره رخ دادن دارند، اشاره دارد. با یک معماری <em>microservice</em> (ریز سرویس)، ما قطعات متحرک بسیار بیشتری داریم، که اگر یک مشکل تأثیر گسترده‌ای داشته باشد، می‌تواند بازیابی را پیچیده‌تر کند. بنابراین در ادامه این فصل به این خواهیم پرداخت که چگونه چیزهای ساده‌ای مانند <em>automation</em> (خودکارسازی) و <em>backups</em> (پشتیبان‌گیری) می‌توانند به شما در بازسازی یک سیستم <em>microservice</em> (ریز سرویس) در صورت تقاضا کمک کنند و سیستم خود را در اسرع وقت راه‌اندازی و اجرا کنید.</p>
<h4>Foundations of Application Security (بنیادهای امنیت نرم‌افزار)</h4>
<p>خوب، اکنون که ما برخی از اصول اصلی را در جای خود داریم و تا حدودی از دنیای گسترده‌ای که فعالیت‌های <em>security</em> (امنیت) می‌توانند پوشش دهند، آگاهی داریم، بیایید به چند موضوع اساسی <em>security</em> (امنیت) در زمینه معماری <em>microservice</em> (ریز سرویس) نگاهی بیندازیم، اگر می‌خواهید یک سیستم امن‌تر بسازید—<em>credentials</em> (اعتبارنامه‌ها)، <em>patching</em> (وصله‌کردن)، <em>backups</em> (پشتیبان‌گیری) و <em>rebuild</em> (بازسازی).</p>
<h5>Credentials (اعتبارنامه‌ها)</h5>
<p>به طور کلی، <em>credentials</em> (اعتبارنامه‌ها) به یک فرد (یا رایانه) دسترسی به نوعی منبع محدود شده می‌دهند. این می‌تواند یک <em>database</em> (پایگاه داده)، یک کامپیوتر، یک حساب کاربری، یا چیز دیگری باشد. با یک معماری <em>microservice</em> (ریز سرویس)، از نظر مقایسه آن با یک معماری <em>monolithic</em> (یکپارچه) معادل، ما احتمالاً تعداد یکسانی از انسان‌ها را درگیر داریم، اما ما <em>credentials</em> (اعتبارنامه‌های) بیشتری در این ترکیب داریم که نشان‌دهنده <em>microservices</em> (ریز سرویس‌های) مختلف، ماشین‌های (مجازی)، <em>databases</em> (پایگاه‌های داده) و موارد مشابه هستند. این می‌تواند منجر به درجه‌ای از سردرگمی در مورد چگونگی محدود کردن (یا عدم محدود کردن) دسترسی شود، و در بسیاری از موارد می‌تواند منجر به یک رویکرد "تنبلی" شود که در آن از تعداد کمی <em>credentials</em> (اعتبارنامه) با امتیازات گسترده در تلاش برای ساده‌سازی امور استفاده می‌شود. این می‌تواند به نوبه خود منجر به مشکلات بیشتر شود، اگر <em>credentials</em> (اعتبارنامه‌ها) به خطر بیفتند.</p>
<p>ما می‌توانیم موضوع <em>credentials</em> (اعتبارنامه‌ها) را به دو حوزه اصلی تقسیم کنیم. اول، ما <em>credentials</em> (اعتبارنامه‌های) کاربران (و اپراتورهای) سیستم خود را داریم. اینها اغلب ضعیف‌ترین نقطه سیستم ما هستند و معمولاً به عنوان یک <em>attack vector</em> (بردار حمله) توسط افراد مخرب استفاده می‌شوند، همانطور که در یک لحظه خواهیم دید. ثانیاً، ما می‌توانیم <em>secrets</em> (رازها) را در نظر بگیریم—قطعاتی از اطلاعات که برای اجرای <em>microservices</em> (ریز سرویس‌های) ما حیاتی هستند. در هر دو مجموعه <em>credentials</em> (اعتبارنامه‌ها)، ما باید مسائل مربوط به چرخش، لغو و محدود کردن دامنه را در نظر بگیریم.</p>
<p><em>354 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0380</div>
            </div>
        </div>
        <!-- Page 0381 -->
        <div class="chapter" id="page-0381">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>6 <em>Troy Hunt</em>, “<em>Passwords Evolved: Authentication Guidance for the Modern Era</em>,” July 26, 2017, https://oreil.ly/T7PYM.</p>
<p>7 <em>Neil McAllister</em>, “<em>Code Spaces Goes Titsup FOREVER After Attacker NUKES Its Amazon-Hosted Data</em>,” <em>The Register</em>, June 18, 2014, https://oreil.ly/mw7PC.</p>
<h5>User credentials (اعتبارنامه‌های کاربر)</h5>
<p><em>User credentials</em> (اعتبارنامه‌های کاربر)، مانند ترکیبی از ایمیل و رمز عبور، برای نحوه کار بسیاری از ما با نرم‌افزارمان ضروری باقی می‌مانند، اما آنها همچنین یک نقطه ضعف بالقوه هستند که به دسترسی سیستم‌های ما توسط افراد مخرب مربوط می‌شود. گزارش تحقیقات نقض داده‌های ورایزون در سال 2020 نشان داد که نوعی از سرقت <em>credential</em> (اعتبارنامه) در 80٪ از موارد ناشی از هک استفاده شده است. این شامل موقعیت‌هایی است که در آنها <em>credentials</em> (اعتبارنامه‌ها) از طریق مکانیسم‌هایی مانند حملات فیشینگ یا جایی که رمزهای عبور به صورت <em>brute-forced</em> (زورگیرانه) به دست آمده‌اند، به سرقت رفته‌اند.</p>
<p>توصیه‌های عالی در مورد نحوه رسیدگی صحیح به مواردی مانند رمزهای عبور وجود دارد—توصیه‌هایی که با وجود سادگی و وضوح در پیروی، هنوز به اندازه کافی به‌طور گسترده اتخاذ نمی‌شوند. <em>Troy Hunt</em> یک نمای کلی عالی از آخرین توصیه‌ها از هر دو <em>NIST</em> و مرکز ملی <em>Cyber Security</em> بریتانیا دارد.6 این توصیه‌ها شامل توصیه‌هایی برای استفاده از <em>password managers</em> (مدیریت‌کننده‌های رمز عبور) و رمزهای عبور طولانی، اجتناب از استفاده از قوانین پیچیده رمز عبور، و—تا حدودی تعجب‌آور—اجتناب از تغییرات منظم رمز عبور است. پست کامل <em>Troy</em> ارزش خواندن دقیق را دارد.</p>
<p>در عصر کنونی سیستم‌های مبتنی بر <em>API</em>، <em>credentials</em> (اعتبارنامه‌های) ما همچنین به مدیریت مواردی مانند کلیدهای <em>API</em> برای سیستم‌های شخص ثالث، مانند حساب‌هایی برای ارائه دهنده <em>cloud</em> (ابری) شما، گسترش می‌یابد. به عنوان مثال، اگر یک فرد مخرب به حساب ریشه <em>AWS</em> شما دسترسی پیدا کند، می‌تواند تصمیم بگیرد همه چیز را که در آن حساب در حال اجرا است، از بین ببرد. در یک نمونه افراطی، چنین حمله‌ای منجر به ورشکستگی شرکتی به نام <em>Code Spaces</em> شد7—تمام منابع آنها در یک حساب واحد اجرا می‌شدند، همه‌چیز از جمله <em>backups</em> (پشتیبان‌گیری). طعنه <em>Code Spaces</em> که "<em>Rock Solid, Secure and Affordable Svn Hosting, Git Hosting and Project Management</em>" را ارائه می‌داد، از نظر من پنهان نیست.</p>
<p>حتی اگر کسی کلیدهای <em>API</em> شما را برای ارائه‌دهنده <em>cloud</em> (ابری) شما به دست آورد و تصمیم به از بین بردن همه چیزهایی که ساخته‌اید نگیرد، ممکن است تصمیم بگیرد که برخی از ماشین‌های مجازی گران‌قیمت را راه‌اندازی کند تا مقداری <em>bitcoin mining</em> (استخراج بیت‌کوین) را اجرا کند به این امید که شما متوجه نشوید. این اتفاق برای یکی از مشتریان من افتاد، که متوجه شد کسی قبل از خاموش شدن حساب، بیش از 10 هزار دلار برای انجام این کار هزینه کرده است. معلوم شد که مهاجمان نیز می‌دانند چگونه <em>automation</em> (خودکارسازی) کنند—<em>bots</em> (ربات‌هایی) وجود دارند که فقط <em>credentials</em> (اعتبارنامه‌ها) را اسکن می‌کنند و سعی می‌کنند از آنها برای راه‌اندازی ماشین‌ها برای استخراج ارزهای رمزنگاری شده استفاده کنند.</p>
<p><em>Foundations of Application Security | 355</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0381</div>
            </div>
        </div>
        <!-- Page 0382 -->
        <div class="chapter" id="page-0382">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>8 برخی از افراد نگران این واقعیت هستند که <em>secrets</em> (رازها) به صورت متن ساده ذخیره می‌شوند. اینکه آیا این یک مسئله برای شما است یا خیر، تا حد زیادی به مدل تهدید شما بستگی دارد. برای اینکه <em>secrets</em> (رازها) خوانده شوند، یک مهاجم باید به سیستم‌های اصلی که <em>cluster</em> (خوشه) شما را اجرا می‌کنند، دسترسی مستقیم داشته باشد، که در این مرحله می‌توان گفت که <em>cluster</em> (خوشه) شما قبلاً به‌طور ناامیدکننده‌ای به خطر افتاده است.</p>
<h5>Secrets (رازها)</h5>
<p>به طور کلی، <em>secrets</em> (رازها) قطعات مهمی از اطلاعات هستند که یک <em>microservice</em> (ریز سرویس) برای عملکرد به آنها نیاز دارد و همچنین آنقدر حساس هستند که نیاز به محافظت از آنها در برابر افراد مخرب وجود دارد. نمونه‌هایی از <em>secrets</em> (رازهایی) که یک <em>microservice</em> (ریز سرویس) ممکن است به آنها نیاز داشته باشد عبارتند از:</p>
<ul>
<li>گواهی‌نامه‌ها برای <em>TLS</em> (امنیت لایه انتقال)</li>
<li>کلیدهای <em>SSH</em></li>
<li>جفت کلیدهای <em>API</em> عمومی/خصوصی</li>
<li><em>Credentials</em> (اعتبارنامه‌ها) برای دسترسی به <em>databases</em> (پایگاه‌های داده)</li>
</ul>
<p>اگر چرخه عمر یک <em>secret</em> (راز) را در نظر بگیریم، می‌توانیم جنبه‌های مختلف مدیریت <em>secrets</em> (رازها) را که ممکن است به نیازهای امنیتی متفاوتی نیاز داشته باشند، از هم جدا کنیم:</p>
<ul>
<li>Creation (ایجاد)</li>
<p>چگونه <em>secret</em> (راز) را در وهله اول ایجاد می‌کنیم؟</p>
<li>Distribution (توزیع)</li>
<p>پس از ایجاد <em>secret</em> (راز)، چگونه اطمینان حاصل می‌کنیم که به مکان صحیح (و فقط مکان صحیح) می‌رسد؟</p>
<li>Storage (ذخیره‌سازی)</li>
<p>آیا <em>secret</em> (راز) به گونه‌ای ذخیره می‌شود که اطمینان حاصل شود فقط افراد مجاز می‌توانند به آن دسترسی داشته باشند؟</p>
<li>Monitoring (نظارت)</li>
<p>آیا می‌دانیم که چگونه از این <em>secret</em> (راز) استفاده می‌شود؟</p>
<li>Rotation (چرخش)</li>
<p>آیا می‌توانیم <em>secret</em> (راز) را بدون ایجاد مشکل، تغییر دهیم؟</p>
</ul>
<p>اگر تعدادی <em>microservices</em> (ریز سرویس) داشته باشیم، که هر یک ممکن است مجموعه‌های مختلفی از <em>secrets</em> (رازها) را بخواهند، ما نیاز خواهیم داشت از <em>tooling</em> (ابزارسازی) برای کمک به مدیریت همه این موارد استفاده کنیم.</p>
<p><em>Kubernetes</em> (کوبه‌رنتیس) یک راه‌حل <em>secrets</em> (رازها) داخلی ارائه می‌دهد. از نظر عملکرد تا حدودی محدود است اما به عنوان بخشی از یک نصب <em>Kubernetes</em> (کوبه‌رنتیس) اساسی ارائه می‌شود، بنابراین می‌تواند برای بسیاری از موارد استفاده کافی باشد.8</p>
<p>اگر به دنبال یک ابزار پیچیده‌تر در این فضا بودید، <em>Vault</em> <em>Hashicorp</em> ارزش دیدن دارد. یک ابزار متن‌باز با گزینه‌های تجاری موجود، این یک چاقوی ارتش سوئیسی واقعی مدیریت <em>secrets</em> (رازها) است، که همه چیز را از جنبه‌های اساسی توزیع <em>secrets</em> (رازها) تا تولید <em>credentials</em> (اعتبارنامه‌های) محدود به زمان برای <em>databases</em> (پایگاه‌های داده) و <em>cloud</em> (ابری)</p>
<p><em>356 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0382</div>
            </div>
        </div>
        <!-- Page 0383 -->
        <div class="chapter" id="page-0383">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>platforms</em> (پلتفرم‌ها). <em>Vault</em> این مزیت را دارد که ابزار <em>consul-template</em> پشتیبان‌کننده می‌تواند به صورت پویا <em>secrets</em> (رازها) را در یک فایل پیکربندی معمولی به‌روزرسانی کند. این بدان معناست که بخش‌هایی از سیستم شما که می‌خواهند <em>secrets</em> (رازها) را از یک فایل سیستم محلی بخوانند، نیازی به تغییر برای پشتیبانی از ابزار مدیریت <em>secrets</em> (رازها) ندارند. هنگامی که یک <em>secret</em> (راز) در <em>Vault</em> تغییر می‌کند، <em>consul-template</em> می‌تواند این ورودی را در فایل پیکربندی به‌روزرسانی کند، و به <em>microservices</em> (ریز سرویس‌های) شما اجازه می‌دهد <em>secrets</em> (رازهایی) را که استفاده می‌کنند، به‌طور پویا تغییر دهند. این برای مدیریت <em>credentials</em> (اعتبارنامه‌ها) در مقیاس عالی است.</p>
<p>برخی از ارائه دهندگان <em>cloud</em> (ابری) عمومی نیز راه‌حل‌هایی را در این فضا ارائه می‌دهند؛ به عنوان مثال، <em>AWS Secrets Manager</em> یا <em>Azure’s Key Vault</em> به ذهن می‌رسد. با این حال، برخی از افراد از ایده ذخیره اطلاعات <em>secret</em> (راز) حیاتی در یک سرویس <em>cloud</em> (ابری) عمومی مانند این متنفرند. باز هم، این به مدل تهدید شما بستگی دارد. اگر این یک نگرانی جدی است، هیچ چیز شما را از اجرای <em>Vault</em> در ارائه‌دهنده <em>cloud</em> (ابری) مورد نظر خود و رسیدگی به آن سیستم به تنهایی متوقف نمی‌کند. حتی اگر داده‌ها در حالت <em>rest</em> (بیکاری) در ارائه‌دهنده <em>cloud</em> (ابری) ذخیره شوند، با <em>backend</em> (بک‌اند) ذخیره‌سازی مناسب، می‌توانید اطمینان حاصل کنید که داده‌ها به گونه‌ای رمزگذاری شده‌اند که حتی اگر یک شخص خارجی به داده‌ها دسترسی پیدا کند، نمی‌تواند با آن کاری انجام دهد.</p>
<h5>Rotation (چرخش)</h5>
<p>در حالت ایده‌آل، ما می‌خواهیم <em>credentials</em> (اعتبارنامه‌ها) را به طور مکرر بچرخانیم تا آسیب‌هایی را که کسی می‌تواند در صورت دسترسی به <em>credentials</em> (اعتبارنامه‌ها) وارد کند، محدود کنیم. اگر یک فرد مخرب به جفت کلید عمومی/خصوصی <em>API</em> شما در <em>AWS</em> دسترسی پیدا کند، اما آن <em>credential</em> (اعتبارنامه) یک بار در هفته تغییر کند، آنها فقط یک هفته فرصت دارند تا از <em>credentials</em> (اعتبارنامه‌ها) استفاده کنند. البته، آنها هنوز هم می‌توانند در یک هفته کارهای زیادی را انجام دهند، اما شما ایده را دریافت می‌کنید. برخی از انواع مهاجمان دوست دارند به سیستم‌ها دسترسی پیدا کنند و سپس شناسایی نشوند، و به آنها اجازه می‌دهند تا داده‌های باارزش‌تری را در طول زمان جمع‌آوری کنند و راه‌هایی برای ورود به سایر قسمت‌های سیستم شما پیدا کنند. اگر آنها از <em>credentials</em> (اعتبارنامه‌های) دزدیده شده برای دسترسی استفاده کردند، اگر <em>credentials</em> (اعتبارنامه‌هایی) که استفاده می‌کنند قبل از اینکه بتوانند از آنها استفاده زیادی بکنند، منقضی شوند، ممکن است بتوانید آنها را متوقف کنید.</p>
<p>یک مثال عالی از چرخش برای <em>operator credentials</em> (اعتبارنامه‌های اپراتور) ایجاد کلیدهای <em>API</em> محدود به زمان برای استفاده از <em>AWS</em> است. بسیاری از سازمان‌ها اکنون کلیدهای <em>API</em> را برای کارکنان خود به صورت آنی تولید می‌کنند، با این حال جفت کلید عمومی و خصوصی فقط برای مدت زمان کوتاهی—معمولاً کمتر از یک ساعت—معتبر است. این به شما امکان می‌دهد کلیدهای <em>API</em> مورد نیاز برای انجام هر عملیاتی که لازم است، را تولید کنید، با این اطمینان که حتی اگر یک فرد مخرب متعاقباً به این کلیدها دسترسی پیدا کند، نمی‌تواند از آنها استفاده کند. حتی اگر شما به‌طور تصادفی آن جفت کلید را در <em>GitHub</em> عمومی <em>check</em> (چک) کردید، پس از انقضا برای هیچ‌کس فایده‌ای نخواهد داشت.</p>
<p>استفاده از <em>credentials</em> (اعتبارنامه‌های) محدود به زمان می‌تواند برای سیستم‌ها نیز مفید باشد. <em>Vault Hashicorp’s</em> می‌تواند <em>credentials</em> (اعتبارنامه‌های) محدود به زمان را برای <em>databases</em> (پایگاه‌های داده) تولید کند. به‌جای اینکه نمونه <em>microservice</em> (ریز سرویس) شما جزئیات اتصال <em>database</em> (پایگاه داده) را از یک انبار پیکربندی یا یک فایل متنی بخواند، در عوض می‌توانند در حال پرواز برای یک نمونه خاص از <em>microservice</em> (ریز سرویس) شما ایجاد شوند.</p>
<p>حرکت به سمت فرآیند چرخش مکرر <em>credentials</em> (اعتبارنامه‌ها) مانند کلیدها می‌تواند دردناک باشد. من با شرکت‌هایی صحبت کرده‌ام که در نتیجه چرخش کلید، حوادثی را تجربه کرده‌اند،</p>
<p><em>Foundations of Application Security | 357</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0383</div>
            </div>
        </div>
        <!-- Page 0384 -->
        <div class="chapter" id="page-0384">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>جایی که سیستم‌ها با تغییر کلیدها از کار می‌افتند. این اغلب به این دلیل است که مشخص نیست چه چیزی از یک <em>credential</em> (اعتبارنامه) خاص استفاده می‌کند. اگر دامنه <em>credential</em> (اعتبارنامه) محدود باشد، تأثیر بالقوه چرخش به میزان قابل توجهی کاهش می‌یابد. اما اگر <em>credential</em> (اعتبارنامه) استفاده گسترده‌ای داشته باشد، فهمیدن تأثیر یک تغییر می‌تواند دشوار باشد. این به این دلیل نیست که شما را از چرخش منصرف کنم، بلکه فقط به این دلیل است که شما را از خطرات احتمالی آگاه کنم، و من همچنان متقاعد شده‌ام که این کار درستی است. معقول‌ترین راه پیش رو احتمالاً اتخاذ <em>tooling</em> (ابزارسازی) برای کمک به خودکارسازی این فرآیند و در عین حال محدود کردن دامنه هر مجموعه از <em>credentials</em> (اعتبارنامه‌ها) در همان زمان خواهد بود.</p>
<h5>Revocation (لغو)</h5>
<p>داشتن یک سیاست برای اطمینان از اینکه <em>key credentials</em> (اعتبارنامه‌های کلیدی) به طور منظم چرخیده می‌شوند، می‌تواند راهی منطقی برای محدود کردن تأثیر نشت <em>credential</em> (اعتبارنامه) باشد، اما اگر می‌دانید که یک <em>credential</em> (اعتبارنامه) معین به دست افراد اشتباه افتاده است، چه اتفاقی می‌افتد؟ آیا شما باید منتظر بمانید تا چرخش برنامه‌ریزی‌شده برای آن <em>credential</em> (اعتبارنامه) اجرا شود تا دیگر معتبر نباشد؟ این ممکن است عملی یا منطقی نباشد. در عوض، در حالت ایده‌آل، شما می‌خواهید بتوانید <em>credentials</em> (اعتبارنامه‌ها) را به طور خودکار لغو و احتمالاً بازسازی کنید، هنگامی که چیزی مانند این اتفاق می‌افتد.</p>
<p>استفاده از ابزارهایی که امکان مدیریت متمرکز <em>secrets</em> (رازها) را فراهم می‌کنند، می‌تواند در اینجا کمک کند، اما این ممکن است مستلزم آن باشد که <em>microservices</em> (ریز سرویس‌های) شما قادر به خواندن مقادیر تازه تولید شده باشند. اگر <em>microservice</em> (ریز سرویس) شما مستقیماً <em>secrets</em> (رازها) را از چیزی مانند انبار <em>Kubernetes secrets</em> (رازهای کوبرنتیس) یا <em>Vault</em> می‌خواند، می‌تواند زمانی که این مقادیر تغییر کرده‌اند، مطلع شود، و به <em>microservice</em> (ریز سرویس) شما اجازه می‌دهد تا از مقادیر تغییر یافته استفاده کند. از طرف دیگر، اگر <em>microservice</em> (ریز سرویس) شما این <em>secrets</em> (رازها) را فقط در هنگام راه‌اندازی می‌خواند، در این صورت ممکن است نیاز داشته باشید که یک راه‌اندازی مجدد چرخشی از سیستم خود انجام دهید تا این <em>credentials</em> (اعتبارنامه‌ها) را دوباره بارگذاری کنید. اگر شما به طور منظم <em>credentials</em> (اعتبارنامه‌ها) را می‌چرخانید، احتمالاً قبلاً مجبور شده‌اید مشکل اینکه <em>microservices</em> (ریز سرویس‌های) شما بتوانند این اطلاعات را دوباره بخوانند را حل کنید. اگر شما با چرخش منظم <em>credentials</em> (اعتبارنامه‌ها) راحت هستید، احتمالاً از قبل برای رسیدگی به لغو اضطراری نیز تنظیم شده‌اید.</p>
<h5>Scanning for Keys (اسکن برای کلیدها)</h5>
<p><em>Accidentally checking in private keys</em> (به‌طور تصادفی وارد کردن کلیدهای خصوصی) به <em>source code repositories</em> (مخازن کد منبع) یک راه رایج برای نشت <em>credentials</em> (اعتبارنامه‌ها) به افراد غیرمجاز است—این اتفاق به طرز شگفت‌انگیزی رخ می‌دهد. <em>GitHub</em> به طور خودکار مخازن را برای برخی از انواع <em>secrets</em> (رازها) اسکن می‌کند، اما شما همچنین می‌توانید اسکن خود را نیز اجرا کنید. اگر بتوانید <em>secrets</em> (رازها) را قبل از <em>check in</em> (چک این) شناسایی کنید، عالی خواهد بود، و <em>git-secrets</em> به شما این امکان را می‌دهد. این می‌تواند <em>commits</em> (کامیت‌های) موجود را برای <em>secrets</em> (رازهای) احتمالی اسکن کند، اما با تنظیم آن به عنوان یک <em>commit hook</em> (هوک کامیت)، می‌تواند حتی از انجام <em>commits</em> (کامیت‌ها) جلوگیری کند. همچنین <em>gitleaks</em> مشابه وجود دارد، که علاوه بر پشتیبانی از <em>pre-commit hooks</em> (هوک‌های قبل از کامیت) و اسکن عمومی <em>commits</em> (کامیت‌ها)، دارای چند ویژگی است که آن را به طور بالقوه به عنوان یک ابزار عمومی‌تر برای اسکن فایل‌های محلی، مفیدتر می‌کند.</p>
<p><em>358 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0384</div>
            </div>
        </div>
        <!-- Page 0385 -->
        <div class="chapter" id="page-0385">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h5>Limiting scope (محدود کردن دامنه)</h5>
<p>محدود کردن دامنه <em>credentials</em> (اعتبارنامه‌ها) هسته اصلی ایده پذیرش <em>principle of least privilege</em> (اصل کمترین امتیاز) است. این می‌تواند در تمام اشکال <em>credentials</em> (اعتبارنامه‌ها) اعمال شود، اما محدود کردن دامنه آنچه یک مجموعه از <em>credentials</em> (اعتبارنامه‌ها) به شما امکان دسترسی به آن را می‌دهد، می‌تواند فوق‌العاده مفید باشد. به عنوان مثال، در شکل 11-1، به هر نمونه از <em>microservice Inventory</em> (ریز سرویس انبار) نام کاربری و رمز عبور یکسانی برای <em>database</em> (پایگاه داده) پشتیبان داده می‌شود. ما همچنین دسترسی <em>read-only</em> (فقط خواندنی) به فرآیند <em>Debezium</em> پشتیبان را ارائه می‌کنیم که برای خواندن داده‌ها و ارسال آن از طریق <em>Kafka</em> به عنوان بخشی از فرآیند <em>ETL</em> موجود استفاده خواهد شد. اگر نام کاربری و رمز عبور برای <em>microservices</em> (ریز سرویس‌ها) به خطر بیفتد، یک شخص خارجی از نظر تئوری می‌تواند به دسترسی خواندن و نوشتن به <em>database</em> (پایگاه داده) دست یابد. اگر آنها به <em>Debezium credentials</em> (اعتبارنامه‌های Debezium) دسترسی پیدا می‌کردند، فقط دسترسی <em>read-only</em> (فقط خواندنی) خواهند داشت.</p>
<p>شکل 11-1. محدود کردن دامنه <em>credentials</em> (اعتبارنامه‌ها) برای محدود کردن تأثیر سوء استفاده</p>
<p>محدود کردن دامنه می‌تواند هم از نظر آنچه مجموعه <em>credentials</em> (اعتبارنامه‌ها) می‌تواند به آن دسترسی داشته باشد و هم از نظر اینکه چه کسی به آن مجموعه از <em>credentials</em> (اعتبارنامه‌ها) دسترسی دارد، اعمال شود. در شکل 11-2، ما چیزها را به گونه‌ای تغییر داده‌ایم که هر نمونه از <em>Inventory</em> (انبار) یک مجموعه <em>credentials</em> (اعتبارنامه) متفاوت دریافت می‌کند. این بدان معناست که ما می‌توانیم هر <em>credential</em> (اعتبارنامه) را به طور مستقل بچرخانیم، یا فقط <em>credential</em> (اعتبارنامه) را برای</p>
<p><em>Foundations of Application Security | 359</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 385" src="page_0385/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0385</div>
            </div>
        </div>
        <!-- Page 0386 -->
        <div class="chapter" id="page-0386">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>یکی از نمونه‌ها اگر این همان چیزی است که به خطر می‌افتد. علاوه بر این، با <em>credentials</em> (اعتبارنامه‌های) خاص‌تر، می‌توان راحت‌تر فهمید که <em>credential</em> (اعتبارنامه) از کجا و چگونه به دست آمده است. بدیهی است مزایای دیگری از داشتن یک نام کاربری منحصربه‌فرد برای یک نمونه <em>microservice</em> (ریز سرویس) در اینجا وجود دارد؛ به عنوان مثال، ردیابی اینکه کدام نمونه باعث یک <em>query</em> (پرس و جو) پرهزینه شد، ممکن است آسان‌تر باشد.</p>
<p>شکل 11-2. هر نمونه از <em>Inventory</em> (انبار) <em>credentials</em> (اعتبارنامه‌های) دسترسی خود را برای <em>database</em> (پایگاه داده) دارد، که دسترسی را بیشتر محدود می‌کند</p>
<p>همانطور که قبلاً پوشش دادیم، مدیریت <em>credentials</em> (اعتبارنامه‌های) با <em>fine-grained</em> (دانه ریز) در مقیاس می‌تواند پیچیده باشد، و اگر می‌خواهید رویکردی مانند این را اتخاذ کنید، نوعی <em>automation</em> (خودکارسازی) ضروری خواهد بود—انبار <em>secret</em> (راز) مانند <em>Vault</em> به عنوان راه‌هایی عالی برای پیاده‌سازی طرح‌هایی مانند این به ذهن می‌رسند.</p>
<h5>Patching (وصله‌کردن)</h5>
<p>نقض داده‌های <em>Equifax</em> در سال 2017 نمونه‌ای عالی از اهمیت <em>patching</em> (وصله‌کردن) است. از یک آسیب‌پذیری شناخته شده در <em>Apache Struts</em> برای به دست آوردن دسترسی غیرمجاز به داده‌های <em>Equifax</em> استفاده شد. از آنجایی که <em>Equifax</em> یک دفتر اعتباری است، این اطلاعات به ویژه حساس بود. در نهایت مشخص شد که داده‌های بیش از 160 میلیون نفر در این نقض به خطر افتاده است. <em>Equifax</em> در نهایت مجبور شد 700 میلیون دلار توافق پرداخت کند.</p>
<p><em>360 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 386" src="page_0386/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0386</div>
            </div>
        </div>
        <!-- Page 0387 -->
        <div class="chapter" id="page-0387">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>ماه‌ها قبل از این نقض، آسیب‌پذیری در <em>Apache Struts</em> شناسایی شده بود، و یک <em>release</em> (نسخه) جدید توسط <em>maintainers</em> (نگهدارندگان) که مشکل را برطرف می‌کردند، ایجاد شده بود. متأسفانه، <em>Equifax</em>، با وجود اینکه ماه‌ها قبل از حمله در دسترس بود، به نسخه جدید نرم‌افزار به‌روزرسانی نکرده بود. اگر <em>Equifax</em> این نرم‌افزار را به موقع به‌روزرسانی کرده بود، به نظر می‌رسد که حمله امکان‌پذیر نمی‌بود.</p>
<p>مسئله در راس قرار دادن <em>patching</em> (وصله‌کردن) با استقرار سیستم‌های پیچیده‌تر، پیچیده‌تر می‌شود. ما باید در نحوه برخورد با این مفهوم نسبتاً اساسی، پیشرفته‌تر شویم.</p>
<p>شکل 11-3 نمونه‌ای از لایه‌های زیرساخت و نرم‌افزاری را نشان می‌دهد که زیر یک <em>Kubernetes cluster</em> (خوشه کوبرنتیس) معمولی وجود دارد. اگر شما تمام آن زیرساخت را خودتان اجرا می‌کنید، شما مسئول مدیریت و <em>patching</em> (وصله‌کردن) تمام آن لایه‌ها هستید. چقدر مطمئن هستید که شما با <em>patching</em> (وصله‌کردن) خود به‌روز هستید؟ بدیهی است، اگر شما می‌توانید مقداری از این کار را به یک ارائه‌دهنده <em>cloud</em> (ابری) عمومی واگذار کنید، شما می‌توانید بخشی از این بار را نیز واگذار کنید.</p>
<p>شکل 11-3. لایه‌های مختلف در یک زیرساخت مدرن که همگی نیاز به نگهداری و <em>patching</em> (وصله‌کردن) دارند</p>
<p><em>Foundations of Application Security | 361</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 387" src="page_0387/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0387</div>
            </div>
        </div>
        <!-- Page 0388 -->
        <div class="chapter" id="page-0388">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>اگر شما از یک <em>Kubernetes cluster</em> (خوشه کوبرنتیس) مدیریت‌شده در یکی از فروشندگان اصلی <em>cloud</em> (ابری) عمومی استفاده کنید، به عنوان مثال، دامنه مالکیت خود را به شدت کاهش می‌دهید، همانطور که در شکل 11-4 می‌بینیم.</p>
<p>شکل 11-4. واگذاری مسئولیت برای برخی از لایه‌های این پشته می‌تواند پیچیدگی را کاهش دهد</p>
<p><em>Containers</em> (کانتینرها) یک مشکل جالب را در اینجا برای ما ایجاد می‌کنند. ما با یک نمونه <em>container</em> (کانتینر) معین به عنوان <em>immutable</em> (تغییرناپذیر) رفتار می‌کنیم. اما یک <em>container</em> (کانتینر) نه تنها شامل نرم‌افزار ما می‌شود بلکه شامل یک سیستم عامل نیز می‌شود. و آیا می‌دانید که آن <em>container</em> (کانتینر) از کجا آمده است؟ <em>Containers</em> (کانتینرها) بر اساس یک <em>image</em> (تصویر) هستند، که به نوبه خود می‌تواند <em>images</em> (تصاویر) دیگری را گسترش دهد—آیا مطمئن هستید که <em>base images</em> (تصاویر پایه) که استفاده می‌کنید، قبلاً در آنها <em>backdoors</em> (در پشتی) ندارند؟ اگر شما یک نمونه <em>container</em> (کانتینر) را در شش ماه گذشته تغییر نداده‌اید، این به اندازه شش ماه <em>patches</em> (وصله‌های) سیستم عامل است که اعمال نشده‌اند. قرار گرفتن در صدر این موضوع مشکل‌ساز است، به همین دلیل است که شرکت‌هایی مانند <em>Aqua</em> ابزارهایی را برای کمک به شما در تجزیه و تحلیل <em>production containers</em> (کانتینرهای تولیدی) در حال اجرا ارائه می‌دهند، بنابراین شما می‌توانید بفهمید که چه مسائلی باید برطرف شوند.</p>
<p><em>362 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 388" src="page_0388/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0388</div>
            </div>
        </div>
        <!-- Page 0389 -->
        <div class="chapter" id="page-0389">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>البته، در بالای این مجموعه از لایه‌ها، کد <em>application</em> (برنامه) ما قرار دارد. آیا این به‌روز است؟ این فقط کدی نیست که ما می‌نویسیم؛ در مورد کد شخص ثالثی که استفاده می‌کنیم چطور؟ یک <em>bug</em> (اشکال) در یک کتابخانه شخص ثالث می‌تواند برنامه ما را در برابر حمله آسیب‌پذیر کند. در مورد نقض <em>Equifax</em>، آسیب‌پذیری <em>unpatched</em> (وصله‌نشده) در واقع در <em>Struts</em>—یک <em>framework</em> (چارچوب) وب <em>Java</em>—بود.</p>
<p>در مقیاس، فهمیدن اینکه کدام <em>microservices</em> (ریز سرویس‌ها) به کتابخانه‌هایی با آسیب‌پذیری‌های شناخته شده لینک می‌شوند، می‌تواند فوق‌العاده دشوار باشد. این حوزه‌ای است که من اکیداً استفاده از ابزارهایی مانند <em>Snyk</em> یا اسکن کد <em>GitHub</em> را توصیه می‌کنم، که قادر است به طور خودکار وابستگی‌های شخص ثالث شما را اسکن کند و در صورت پیوند به کتابخانه‌هایی با آسیب‌پذیری‌های شناخته شده، به شما هشدار دهد. اگر هر کدام را پیدا کرد، می‌تواند یک <em>pull request</em> (درخواست ادغام) برای کمک به به‌روزرسانی به آخرین نسخه‌های وصله‌شده، برای شما ارسال کند. شما حتی می‌توانید این را در فرآیند <em>CI</em> (ادغام مداوم) خود بسازید و اگر به کتابخانه‌هایی با مشکلات پیوند دارد، یک <em>microservice</em> (ریز سرویس) را با شکست مواجه کنید.</p>
<h5>Backups (پشتیبان‌گیری)</h5>
<p>بنابراین من گاهی اوقات فکر می‌کنم که گرفتن <em>backups</em> (پشتیبان‌گیری) مانند نخ دندان کشیدن است، به این معنا که افراد بیشتری می‌گویند که این کار را انجام می‌دهند تا واقعاً انجام دهند. من احساس نمی‌کنم که نیازی به تکرار بیش از حد بحث برای <em>backups</em> (پشتیبان‌گیری) در اینجا داشته باشم، به جز اینکه بگویم: شما باید <em>backups</em> (پشتیبان‌گیری) کنید، زیرا داده‌ها ارزشمند هستند، و شما نمی‌خواهید آنها را از دست بدهید.</p>
<p>داده‌ها بیش از هر زمان دیگری ارزشمند هستند، و با این حال من گاهی اوقات تعجب می‌کنم که آیا پیشرفت‌های فناوری باعث شده‌اند که ما <em>backups</em> (پشتیبان‌گیری) را از اولویت خارج کنیم. دیسک‌ها نسبت به قبل قابل اطمینان‌تر هستند. پایگاه‌های داده احتمال بیشتری دارند که تکثیر داخلی داشته باشند تا از از دست رفتن داده‌ها جلوگیری کنند. با چنین سیستم‌هایی، ممکن است خودمان را متقاعد کنیم که نیازی به <em>backups</em> (پشتیبان‌گیری) نداریم. اما اگر یک خطای فاجعه‌بار رخ دهد و کل <em>Cassandra cluster</em> (خوشه کاساندرا) شما پاک شود، چه؟ یا اگر یک <em>bug</em> (اشکال) کدنویسی به این معنی باشد که برنامه شما در واقع داده‌های ارزشمندی را حذف می‌کند، چه؟ <em>Backups</em> (پشتیبان‌گیری) به همان اندازه مهم است. پس لطفاً، از داده‌های حیاتی خود <em>backup</em> (پشتیبان) بگیرید.</p>
<p>با استقرار <em>microservices</em> (ریز سرویس‌های) ما که خودکار شده است، ما نیازی به گرفتن <em>backups</em> (پشتیبان‌گیری) کامل از ماشین نداریم، زیرا می‌توانیم زیرساخت‌های خود را از کد منبع بازسازی کنیم. بنابراین ما سعی نمی‌کنیم از حالت کل ماشین‌ها کپی‌برداری کنیم؛ ما در عوض <em>backups</em> (پشتیبان‌گیری) خود را برای حالتی که بیشترین ارزش را دارد، هدف قرار می‌دهیم. این بدان معناست که تمرکز ما برای <em>backups</em> (پشتیبان‌گیری) به مواردی مانند داده‌ها در <em>databases</em> (پایگاه‌های داده) ما، یا شاید <em>logs</em> (لاگ‌های) برنامه ما محدود می‌شود. با فناوری <em>filesystem</em> (سیستم فایل) مناسب، امکان ایجاد کلون‌های سطح بلوک تقریباً فوری از داده‌های یک <em>database</em> (پایگاه داده) بدون ایجاد اختلال قابل توجه در سرویس وجود دارد.</p>
<p><em>Foundations of Application Security | 363</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0389</div>
            </div>
        </div>
        <!-- Page 0390 -->
        <div class="chapter" id="page-0390">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>9 من قطعاً این اصطلاح را ابداع کردم، اما همچنین فکر می‌کنم بسیار محتمل است که من تنها فردی نباشم.</p>
<p>10 درست همانطور که <em>Niels Bohr</em> استدلال می‌کرد که گربه <em>Schrödinger</em> (شرودینگر) هم زنده و هم مرده بود تا زمانی که شما در واقع جعبه را برای بررسی باز کنید.</p>
<h5>Avoid the Schrödinger Backup (اجتناب از پشتیبان‌گیری شرودینگر)</h5>
<p>هنگام ایجاد <em>backups</em> (پشتیبان‌گیری)، شما می‌خواهید از آنچه من <em>Schrödinger backup</em> (پشتیبان‌گیری شرودینگر) می‌نامم، اجتناب کنید.9 این یک <em>backup</em> (پشتیبان‌گیری) است که ممکن است واقعاً یک <em>backup</em> (پشتیبان‌گیری) باشد یا نباشد. تا زمانی که شما در واقع آن را بازیابی نکنید، شما واقعاً نمی‌دانید که آیا این واقعاً یک استفاده از <em>backup</em> (پشتیبان‌گیری) است،10 یا فقط مجموعه‌ای از 1 و 0 است که روی دیسک نوشته شده است. بهترین راه برای اجتناب از این مشکل این است که اطمینان حاصل کنید که <em>backup</em> (پشتیبان‌گیری) واقعی است، با بازیابی آن. راه‌هایی برای ایجاد بازیابی منظم <em>backups</em> (پشتیبان‌گیری) در فرآیند توسعه نرم‌افزار خود بیابید—به عنوان مثال، با استفاده از <em>production backups</em> (پشتیبان‌های تولید) برای ساخت داده‌های تست عملکرد خود.</p>
<p>راهنمایی "قدیمی" در مورد <em>backups</em> (پشتیبان‌گیری) این است که آنها باید خارج از سایت نگهداری شوند، این ایده این است که یک حادثه در دفاتر یا <em>data center</em> (مرکز داده) شما، بر <em>backups</em> (پشتیبان‌گیری) شما تأثیر نخواهد گذاشت اگر در جای دیگری بودند. اما "خارج از سایت" به چه معناست، اگر <em>application</em> (برنامه) شما در یک <em>public cloud</em> (ابر عمومی) مستقر شده باشد؟ آنچه اهمیت دارد این است که <em>backups</em> (پشتیبان‌گیری) شما به گونه‌ای ذخیره می‌شوند که تا حد امکان از سیستم‌های اصلی شما جدا شده‌اند، بنابراین سازش در سیستم اصلی، <em>backups</em> (پشتیبان‌گیری) شما را نیز به خطر نمی‌اندازد. <em>Code Spaces</em>، که قبلاً به آن اشاره کردیم، <em>backups</em> (پشتیبان‌گیری) داشت—اما آنها در <em>AWS</em> در همان حسابی ذخیره می‌شدند که به خطر افتاده بود.</p>
<p>اگر <em>application</em> (برنامه) شما در <em>AWS</em> اجرا می‌شود، شما همچنان می‌توانید <em>backups</em> (پشتیبان‌گیری) خود را نیز در آنجا ذخیره کنید، اما شما باید این کار را در یک حساب جداگانه در منابع ابری جداگانه انجام دهید—شما حتی ممکن است بخواهید قرار دادن آنها را در یک منطقه ابری متفاوت در نظر بگیرید تا خطر یک مشکل در سراسر منطقه را کاهش دهید، یا حتی می‌توانید آنها را با یک ارائه دهنده دیگر ذخیره کنید.</p>
<p>بنابراین اطمینان حاصل کنید که از داده‌های حیاتی <em>backup</em> (پشتیبان) می‌گیرید، آن <em>backups</em> (پشتیبان‌ها) را در یک سیستم جدا از محیط تولید اصلی خود نگه دارید، و اطمینان حاصل کنید که <em>backups</em> (پشتیبان‌گیری‌ها) با بازیابی منظم آنها واقعاً کار می‌کنند.</p>
<h5>Rebuild (بازسازی)</h5>
<p>ما می‌توانیم تمام تلاش خود را انجام دهیم تا اطمینان حاصل کنیم که یک فرد مخرب به سیستم‌های ما دسترسی پیدا نمی‌کند، اما اگر این اتفاق بیفتد چه؟ خوب، اغلب مهمترین کاری که شما می‌توانید در پی آن انجام دهید، این است که سیستم را دوباره راه‌اندازی و اجرا کنید، اما به گونه‌ای که دسترسی را از فرد غیرمجاز حذف کرده باشید. این همیشه سرراست نیست، اگرچه. من به یاد دارم که یکی از ماشین‌های ما سال‌ها پیش توسط یک <em>rootkit</em> هک شد. یک <em>rootkit</em> مجموعه‌ای از نرم‌افزار است که برای پنهان کردن فعالیت‌های یک فرد غیرمجاز طراحی شده است، و این یک تکنیک است که معمولاً توسط مهاجمانی استفاده می‌شود که می‌خواهند شناسایی نشوند، و به آنها زمان می‌دهند تا سیستم را بررسی کنند. در مورد ما، متوجه شدیم که <em>rootkit</em> دستورات اصلی سیستم مانند <em>ls</em> (فهرست کردن فایل‌ها) یا <em>ps</em> (برای نشان دادن</p>
<p><em>364 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 390" src="page_0390/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0390</div>
            </div>
        </div>
        <!-- Page 0391 -->
        <div class="chapter" id="page-0391">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>فهرست‌های پردازش) را تغییر داده بود تا آثار مهاجم خارجی را پنهان کند. ما این را تنها زمانی متوجه شدیم که توانستیم هش‌های برنامه‌هایی را که روی دستگاه اجرا می‌شدند، با بسته‌های رسمی مقایسه کنیم. در پایان، ما اساساً مجبور شدیم کل سرور را از ابتدا دوباره نصب کنیم.</p>
<p>توانایی پاک کردن یک سرور و بازسازی کامل آن می‌تواند نه تنها در پی یک حمله شناخته شده، بلکه از نظر کاهش تأثیر مهاجمان مداوم، فوق‌العاده مؤثر باشد. شما ممکن است از وجود یک فرد مخرب در سیستم خود آگاه نباشید، اما اگر مرتباً سرورهای خود را بازسازی می‌کنید و <em>credentials</em> (اعتبارنامه‌ها) را می‌چرخانید، ممکن است تأثیر آنچه آنها می‌توانند انجام دهند را بدون اینکه متوجه شوید، به‌طور چشمگیری محدود کنید.</p>
<p>توانایی شما در بازسازی یک <em>microservice</em> (ریز سرویس) معین، یا حتی یک سیستم کامل، به کیفیت <em>automation</em> (خودکارسازی) و <em>backups</em> (پشتیبان‌گیری) شما بستگی دارد. اگر شما می‌توانید هر <em>microservice</em> (ریز سرویس) را از ابتدا بر اساس اطلاعات ذخیره شده در <em>source control</em> (کنترل منبع) مستقر و پیکربندی کنید، شما شروع خوبی دارید. البته، شما باید این را با یک فرآیند بازیابی <em>backup</em> (پشتیبان‌گیری) استوار برای داده‌ها ترکیب کنید. مانند <em>backups</em> (پشتیبان‌گیری)، بهترین راه برای اطمینان از اینکه استقرار و پیکربندی خودکار <em>microservices</em> (ریز سرویس‌های) شما کار می‌کند، این است که این کار را زیاد انجام دهید—و آسان‌ترین راه برای دستیابی به این هدف، استفاده از همان فرآیند برای بازسازی یک <em>microservice</em> (ریز سرویس) است که شما برای هر استقراری انجام می‌دهید. این البته نحوه عملکرد بیشتر فرآیندهای استقرار مبتنی بر <em>container</em> (کانتینر) است. شما یک مجموعه جدید از <em>containers</em> (کانتینرها) را که نسخه جدید <em>microservice</em> (ریز سرویس) شما را اجرا می‌کنند، مستقر می‌کنید و مجموعه قدیمی را خاموش می‌کنید. تبدیل این به رویه عملیاتی عادی، بازسازی را تقریباً به یک اتفاق بی‌اهمیت تبدیل می‌کند.</p>
<p>یک هشدار در اینجا وجود دارد، به خصوص اگر شما در یک پلتفرم <em>container</em> (کانتینر) مانند <em>Kubernetes</em> استقرار می‌دهید. شما ممکن است اغلب نمونه‌های <em>container</em> (کانتینر) را از بین ببرید و دوباره مستقر کنید، اما در مورد خود پلتفرم <em>container</em> (کانتینر) زیربنایی چطور؟ آیا شما توانایی بازسازی آن را از ابتدا دارید؟ اگر شما از یک ارائه دهنده <em>Kubernetes</em> (کوبه‌رنتیس) کاملاً مدیریت شده استفاده می‌کنید، راه‌اندازی یک <em>cluster</em> (خوشه) جدید ممکن است خیلی دشوار نباشد، اما اگر شما <em>cluster</em> (خوشه) را خودتان نصب و مدیریت کرده‌اید، در این صورت این ممکن است مقدار قابل توجهی کار باشد.</p>
<p>توانایی بازسازی <em>microservice</em> (ریز سرویس) خود و بازیابی داده‌های آن به صورت خودکار، به شما کمک می‌کند تا در پی یک حمله بازیابی کنید و همچنین این مزیت را دارد که استقرار شما را در سراسر هیئت مدیره آسان‌تر می‌کند، و مزایای مثبتی برای فعالیت‌های توسعه، تست و عملیات تولید دارد.</p>
<h5>Implicit Trust Versus Zero Trust (اعتماد ضمنی در مقابل اعتماد صفر)</h5>
<p>معماری <em>microservice</em> (ریز سرویس) ما شامل ارتباطات زیادی بین چیزها است. کاربران انسانی از طریق <em>user interfaces</em> (رابط‌های کاربری) با سیستم ما تعامل دارند. این <em>user interfaces</em> (رابط‌های کاربری) به نوبه خود به <em>microservices</em> (ریز سرویس‌ها) فراخوانی می‌کنند، و <em>microservices</em> (ریز سرویس‌ها) در نهایت <em>microservices</em> (ریز سرویس‌های) بیشتری را فراخوانی می‌کنند. وقتی نوبت به <em>application security</em> (امنیت نرم‌افزار) می‌رسد، ما باید مسئله اعتماد را در میان تمام آن نقاط تماس در نظر بگیریم. چگونه یک سطح قابل قبول از اعتماد را ایجاد می‌کنیم؟</p>
<p><em>Implicit Trust Versus Zero Trust | 365</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 391" src="page_0391/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0391</div>
            </div>
        </div>
        <!-- Page 0392 -->
        <div class="chapter" id="page-0392">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>ما این موضوع را به زودی از نظر <em>authentication</em> (احراز هویت) و <em>authorization</em> (مجوز) هر دو انسان و <em>microservices</em> (ریز سرویس‌ها) بررسی خواهیم کرد، اما قبل از آن باید برخی از مدل‌های اساسی پیرامون اعتماد را در نظر بگیریم.</p>
<p>آیا ما به هر چیزی که در شبکه‌مان در حال اجراست، اعتماد داریم؟ یا به همه چیز با سوء ظن نگاه می‌کنیم؟ در اینجا، ما می‌توانیم دو ذهنیت را در نظر بگیریم—<em>implicit trust</em> (اعتماد ضمنی) و <em>zero trust</em> (اعتماد صفر).</p>
<h5>Implicit Trust (اعتماد ضمنی)</h5>
<p>اولین گزینه ما می‌تواند این باشد که فرض کنیم هر فراخوانی به یک <em>service</em> (سرویس) که از داخل محدوده ما انجام می‌شود، به طور ضمنی مورد اعتماد است.</p>
<p>بسته به حساسیت داده‌ها، این ممکن است خوب باشد. برخی از سازمان‌ها تلاش می‌کنند تا <em>security</em> (امنیت) را در محیط شبکه‌های خود تضمین کنند، و بنابراین فرض می‌کنند که وقتی دو <em>service</em> (سرویس) با هم صحبت می‌کنند، نیازی به انجام کار دیگری ندارند. با این حال، اگر یک مهاجم به شبکه شما نفوذ کند، ممکن است همه چیز خراب شود. اگر مهاجم تصمیم بگیرد داده‌های ارسالی را رهگیری و خواندن کند، داده‌ها را بدون اطلاع شما تغییر دهد، یا حتی در برخی شرایط وانمود کند که همان چیزی است که شما با آن صحبت می‌کنید، ممکن است چیز زیادی در مورد آن ندانید.</p>
<p>این، تاکنون، رایج‌ترین شکل اعتماد داخلی-محدوده است که من در سازمان‌ها می‌بینم. من نمی‌گویم که این چیز خوبی است! برای اکثر سازمان‌هایی که من از این مدل استفاده می‌کنند، نگران هستم که مدل <em>implicit trust</em> (اعتماد ضمنی) یک تصمیم آگاهانه نیست؛ بلکه، مردم در وهله اول از خطرات بی‌اطلاع هستند.</p>
<h5>Zero Trust (اعتماد صفر)</h5>
<p>"<em>Jill</em>، ما تماس را ردیابی کردیم—از داخل خانه می‌آید!"</p>
<p>—<em>When a Stranger Calls</em></p>
<p>هنگام کار در یک محیط <em>zero-trust</em> (اعتماد صفر)، شما باید فرض کنید که در محیطی کار می‌کنید که قبلاً به خطر افتاده است—رایانه‌هایی که با آنها صحبت می‌کنید ممکن است به خطر افتاده باشند، اتصالات ورودی می‌تواند از طرف‌های متخاصم باشد، داده‌هایی که شما می‌نویسید ممکن است توسط افراد بد خوانده شود. بدبین؟ بله! به <em>zero trust</em> (اعتماد صفر) خوش آمدید.</p>
<p><em>Zero trust</em> (اعتماد صفر)، اساساً یک ذهنیت است. این چیزی نیست که شما بتوانید به طور جادویی با استفاده از یک محصول یا ابزار پیاده‌سازی کنید؛ این یک ایده است و این ایده این است که اگر شما با این فرض عمل می‌کنید که در یک محیط خصمانه عمل می‌کنید که در آن بازیگران بد می‌توانند از قبل حضور داشته باشند، در این صورت شما باید اقدامات احتیاطی را انجام دهید تا مطمئن شوید که هنوز هم می‌توانید ایمن عمل کنید. در واقع، مفهوم "محدوده" با <em>zero trust</em> (اعتماد صفر) بی‌معنی است (به همین دلیل، <em>zero trust</em> (اعتماد صفر) اغلب به عنوان "<em>perimeterless computing</em>" (محاسبات بدون مرز) نیز شناخته می‌شود).</p>
<p>از آنجایی که شما فرض می‌کنید سیستم شما به خطر افتاده است، تمام فراخوانی‌های ورودی از سایر <em>microservices</em> (ریز سرویس‌ها) باید به درستی ارزیابی شوند. آیا این واقعاً یک کلاینت است که باید به آن اعتماد کنم؟</p>
<p><em>366 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0392</div>
            </div>
        </div>
        <!-- Page 0393 -->
        <div class="chapter" id="page-0393">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>11 <em>Jan Schaumann</em> (@jschauma), <em>Twitter</em>, November 5, 2020, 4:22 p.m., https://oreil.ly/QaCm2.</p>
<p>به همین ترتیب، همه داده‌ها باید با خیال راحت ذخیره شوند و تمام کلیدهای رمزنگاری شده به‌طور ایمن نگهداری شوند، و از آنجایی که ما باید فرض کنیم که کسی در حال گوش دادن است، همه داده‌های حساس در حال انتقال در سیستم ما باید رمزگذاری شوند.</p>
<p>جالب اینجاست که اگر شما یک ذهنیت <em>zero-trust</em> (اعتماد صفر) را به درستی پیاده‌سازی کرده باشید، می‌توانید کارهایی را شروع کنید که کاملاً عجیب به نظر می‌رسند:</p>
<p>[با <em>zero trust</em> (اعتماد صفر)] شما در واقع می‌توانید تصمیمات دسترسی برخلاف شهود بگیرید و به عنوان مثال، اتصالات به <em>services</em> (سرویس‌های) داخلی را از اینترنت مجاز کنید زیرا شما با شبکه "داخلی" خود به همان اندازه قابل اعتماد با اینترنت رفتار می‌کنید (یعنی، اصلاً).
    —<em>Jan Schaumann</em>11</p>
<p>استدلال <em>Jan</em> در اینجا این است که اگر شما فرض کنید که هیچ چیزی در داخل شبکه شما قابل اعتماد نیست، و آن اعتماد باید دوباره برقرار شود، شما می‌توانید در مورد محیطی که <em>microservice</em> (ریز سرویس) شما در آن زندگی می‌کند، بسیار انعطاف‌پذیرتر باشید—شما انتظار ندارید که محیط گسترده‌تر ایمن باشد. اما به یاد داشته باشید، <em>zero trust</em> (اعتماد صفر) چیزی نیست که شما با یک کلید روشن کنید. این یک اصل اساسی برای نحوه تصمیم‌گیری شما برای انجام کارها است. این باید تصمیم‌گیری شما را در مورد چگونگی ساخت و تکامل سیستم شما هدایت کند—این چیزی است که شما باید به‌طور مداوم در آن سرمایه‌گذاری کنید تا پاداش‌ها را دریافت کنید.</p>
<h5>It’s a Spectrum (یک طیف است)</h5>
<p>من قصد ندارم این را القا کنم که شما یک انتخاب سخت بین <em>implicit</em> (ضمنی) و <em>zero trust</em> (اعتماد صفر) دارید. میزان اعتمادی که شما به طرف‌های دیگر در سیستم خود دارید (یا ندارید) می‌تواند بر اساس حساسیت اطلاعاتی که به آن دسترسی دارید، تغییر کند. شما ممکن است، به عنوان مثال، تصمیم بگیرید که یک مفهوم <em>zero trust</em> (اعتماد صفر) را برای هر <em>microservices</em> (ریز سرویس) که <em>PII</em> را مدیریت می‌کند، اتخاذ کنید، اما در زمینه‌های دیگر راحت‌تر باشید. باز هم، هزینه هر پیاده‌سازی <em>security</em> (امنیت) باید توسط مدل تهدید شما توجیه (و هدایت) شود. بگذارید درک شما از تهدیدات و تأثیرات مرتبط با آنها، تصمیم‌گیری شما را در مورد اینکه آیا <em>zero trust</em> (اعتماد صفر) برای شما ارزش دارد یا خیر، هدایت کند.</p>
<p>به عنوان مثال، بیایید به <em>MedicalCo</em>، شرکتی که من با آن کار می‌کردم و داده‌های حساس مراقبت‌های بهداشتی مربوط به افراد را مدیریت می‌کرد، نگاهی بیندازیم. تمام اطلاعاتی که آنها در اختیار داشتند بر اساس یک رویکرد نسبتاً معقول و سرراست طبقه‌بندی شده بود:</p>
<ul>
<li>Public (عمومی)</li>
<p>داده‌هایی که می‌توانستند آزادانه با هر شخص خارجی به اشتراک گذاشته شوند. این اطلاعات در واقع در حوزه عمومی است.</p>
<li>Private (خصوصی)</li>
<p>اطلاعاتی که فقط باید برای کاربران وارد شده در دسترس باشد. دسترسی به این اطلاعات می‌تواند به دلیل محدودیت‌های <em>authorization</em> (مجوز) بیشتر محدود شود. این ممکن است شامل مواردی مانند طرح بیمه‌ای که یک مشتری در آن حضور داشت باشد.</p>
</ul>
<p><em>Implicit Trust Versus Zero Trust | 367</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0393</div>
            </div>
        </div>
        <!-- Page 0394 -->
        <div class="chapter" id="page-0394">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<ul>
<li>Secret (محرمانه)</li>
<p>اطلاعات فوق‌العاده حساسی در مورد افراد که فقط در موقعیت‌های بسیار خاص می‌توانند توسط افراد دیگری غیر از فرد مورد نظر، مورد دسترسی قرار گیرند. این شامل اطلاعات مربوط به داده‌های سلامت فرد می‌شود.</p>
</ul>
<p><em>Microservices</em> (ریز سرویس‌ها) سپس بر اساس حساس‌ترین داده‌هایی که استفاده می‌کردند طبقه‌بندی شدند و باید در یک محیط (منطقه) منطبق با کنترل‌های منطبق، اجرا می‌شدند، همانطور که در شکل 11-5 می‌بینیم. یک <em>microservice</em> (ریز سرویس) باید در منطقه‌ای اجرا می‌شد که با حساس‌ترین داده‌هایی که از آن استفاده می‌کرد، مطابقت داشته باشد. به عنوان مثال، یک <em>microservice</em> (ریز سرویس) در حال اجرا در منطقه عمومی، فقط می‌توانست از داده‌های عمومی استفاده کند. از طرف دیگر، یک <em>microservice</em> (ریز سرویس) که از داده‌های عمومی و خصوصی استفاده می‌کرد، باید در منطقه خصوصی اجرا می‌شد، و یک <em>microservice</em> (ریز سرویس) که به اطلاعات محرمانه دسترسی داشت، همیشه باید در منطقه محرمانه اجرا می‌شد.</p>
<p>شکل 11-5. استقرار <em>microservices</em> (ریز سرویس‌ها) در مناطق مختلف بر اساس حساسیت داده‌هایی که مدیریت می‌کنند</p>
<p><em>Microservices</em> (ریز سرویس‌ها) در هر منطقه می‌توانستند با یکدیگر ارتباط برقرار کنند اما قادر به دسترسی مستقیم برای دسترسی به داده‌ها یا عملکرد در مناطق پایین‌تر و امن‌تر نبودند. اگرچه <em>Microservices</em> (ریز سرویس‌ها) در مناطق امن‌تر می‌توانستند برای دسترسی به عملکرد در حال اجرا در مناطق کمتر امن، بالا بروند.</p>
<p><em>368 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 394" src="page_0394/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0394</div>
            </div>
        </div>
        <!-- Page 0395 -->
        <div class="chapter" id="page-0395">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>در اینجا، <em>MedicalCo</em> به خود این انعطاف‌پذیری را داده است که رویکرد خود را در هر منطقه متفاوت کند. منطقه عمومی کمتر ایمن می‌تواند در چیزی نزدیک‌تر به یک محیط <em>implicit trust</em> (اعتماد ضمنی) عمل کند، در حالی که منطقه محرمانه، <em>zero-trust</em> (اعتماد صفر) را فرض می‌کند. استدلال این است که، اگر <em>MedicalCo</em> یک رویکرد <em>zero-trust</em> (اعتماد صفر) را در سراسر سیستم خود اتخاذ کند، نیازی به استقرار <em>microservices</em> (ریز سرویس‌ها) در مناطق جداگانه نخواهد بود، زیرا همه فراخوانی‌های بین <em>microservice</em> (ریز سرویس) به <em>authentication</em> (احراز هویت) و <em>authorization</em> (مجوز) اضافی نیاز دارند. با این حال، با تفکر در مورد <em>defense in depth</em> (دفاع در عمق) یک بار دیگر، من نمی‌توانم این فکر را متوقف کنم که با توجه به حساسیت داده‌ها، من همچنان این رویکرد منطقه‌ای را در نظر می‌گیرم!</p>
<h5>Securing Data (ایمن‌سازی داده‌ها)</h5>
<p>همانطور که ما نرم‌افزار <em>monolithic</em> (یکپارچه) خود را به <em>microservices</em> (ریز سرویس‌ها) تقسیم می‌کنیم، داده‌های ما بیشتر از قبل در سیستم‌های ما جابه‌جا می‌شوند. این فقط در شبکه‌ها جریان نمی‌یابد؛ بلکه روی دیسک نیز قرار دارد. داشتن داده‌های ارزشمندتر که در مکان‌های بیشتری پخش شده است، اگر مراقب نباشیم، می‌تواند یک کابوس در مورد ایمن‌سازی برنامه ما باشد. بیایید با جزئیات بیشتری به این موضوع بپردازیم که چگونه می‌توانیم از داده‌های خود در حین حرکت در شبکه‌ها و در حالت بیکاری، محافظت کنیم.</p>
<h5>Data in Transit (داده‌ها در حال انتقال)</h5>
<p>ماهیت حفاظت‌هایی که شما دارید، تا حد زیادی به ماهیت پروتکل‌های ارتباطی که انتخاب کرده‌اید، بستگی دارد. اگر شما از <em>HTTP</em> استفاده می‌کنید، به عنوان مثال، طبیعی است که به استفاده از <em>HTTP</em> با <em>Transport Layer Security</em> (<em>TLS</em>) (امنیت لایه انتقال) نگاه کنید، موضوعی که در بخش بعدی بیشتر به آن خواهیم پرداخت؛ اما اگر شما از پروتکل‌های جایگزین مانند برقراری ارتباط از طریق یک <em>message broker</em> (کارگزار پیام) استفاده می‌کنید، ممکن است مجبور شوید به پشتیبانی آن فناوری خاص برای محافظت از داده‌ها در حال انتقال نگاه کنید. به جای نگاهی به جزئیات طیف وسیعی از فناوری‌ها در این فضا، من فکر می‌کنم که مهم است که به طور کلی‌تر، چهار حوزه اصلی مورد علاقه را در هنگام ایمن‌سازی داده‌ها در حال انتقال در نظر بگیریم، و به این موضوع بپردازیم که چگونه این نگرانی‌ها را می‌توان با <em>HTTP</em> به عنوان یک مثال برطرف کرد. امیدوارم که برای شما دشوار نباشد که این ایده‌ها را به هر پروتکل ارتباطی که انتخاب می‌کنید، نگاشت کنید.</p>
<p>در شکل 11-6 ما می‌توانیم چهار نگرانی اصلی داده‌ها در حال انتقال را ببینیم.</p>
<p><em>Securing Data | 369</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0395</div>
            </div>
        </div>
        <!-- Page 0396 -->
        <div class="chapter" id="page-0396">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>12 "<em>S</em>" در "<em>HTTPS</em>" به <em>Secure Socket Layer</em> (<em>SSL</em>) قدیمی اشاره دارد، که به دلایلی با <em>TLS</em> جایگزین شده است. گیج‌کننده است که، اصطلاح <em>SSL</em> همچنان باقی مانده است، حتی زمانی که در واقع از <em>TLS</em> استفاده می‌شود. به عنوان مثال، کتابخانه <em>OpenSSL</em> در واقع به طور گسترده برای پیاده‌سازی <em>TLS</em> استفاده می‌شود، و هنگامی که یک گواهی <em>SSL</em> برای شما صادر می‌شود، در واقع برای <em>TLS</em> خواهد بود. ما کارها را برای خودمان آسان نمی‌کنیم، درست است؟</p>
<p>شکل 11-6. چهار نگرانی اصلی در مورد داده‌ها در حال انتقال</p>
<p>بیایید با جزئیات بیشتری به هر نگرانی نگاه کنیم.</p>
<h5>Server identity (هویت سرور)</h5>
<p>یکی از ساده‌ترین چیزهایی که باید بررسی کنید این است که سروری که با آن صحبت می‌کنید دقیقاً همان کسی است که ادعا می‌کند. این مهم است زیرا یک فرد مخرب می‌تواند از نظر تئوری، یک <em>endpoint</em> (نقطه پایانی) را جعل کند—و هر داده مفیدی را که شما برای آن ارسال می‌کنید، جمع‌آوری کند. اعتبارسنجی هویت سرور از دیرباز مورد توجه در اینترنت عمومی بوده است، که منجر به فشار برای استفاده گسترده‌تر از <em>HTTPS</em> شده است—و تا حدی، ما می‌توانیم از کارهایی که برای کمک به ایمن‌سازی اینترنت عمومی انجام شده است، در مورد مدیریت <em>HTTP endpoints</em> (نقاط پایانی HTTP) داخلی، بهره‌مند شویم.</p>
<p>وقتی مردم در مورد "<em>HTTPS</em>" صحبت می‌کنند، آنها معمولاً به استفاده از <em>HTTP</em> با <em>TLS</em> اشاره می‌کنند.12 با اکثر ارتباطات از طریق اینترنت عمومی، به دلیل <em>attack vectors</em> (بردار حمله)های بالقوه مختلفی که وجود دارد (<em>WiFi</em> ناامن، مسمومیت <em>DNS</em> و موارد مشابه)، اطمینان از اینکه وقتی به یک وب‌سایت می‌رویم، واقعاً همان وب‌سایتی است که ادعا می‌کند، حیاتی است. با <em>HTTPS</em>، مرورگر ما می‌تواند به گواهی‌نامه آن وب‌سایت نگاه کند و مطمئن شود که معتبر است. این یک مکانیسم ایمنی بسیار منطقی است—"<em>HTTPS Everywhere</em>" به یک شعار برای اینترنت عمومی تبدیل شده است، و به دلایل خوبی.</p>
<p><em>370 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 396" src="page_0396/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0396</div>
            </div>
        </div>
        <!-- Page 0397 -->
        <div class="chapter" id="page-0397">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>شایان ذکر است که برخی از پروتکل‌های ارتباطی که از <em>HTTP</em> در زیرساخت خود استفاده می‌کنند، می‌توانند از <em>HTTPS</em> بهره‌مند شوند—بنابراین ما می‌توانیم به راحتی <em>SOAP</em> یا <em>gRPC</em> را بدون مشکل روی <em>HTTPS</em> اجرا کنیم. <em>HTTPS</em> همچنین حفاظت‌های اضافی را علاوه بر تأیید اینکه با چه کسی انتظار داریم صحبت کنیم، به ما می‌دهد. ما به زودی به آن خواهیم رسید.</p>
<h5>Client identity (هویت کلاینت)</h5>
<p>وقتی در این زمینه به <em>client identity</em> (هویت کلاینت) اشاره می‌کنیم، منظور ما <em>microservice</em> (ریز سرویس) است که یک فراخوانی را انجام می‌دهد—بنابراین ما در تلاشیم تا هویت <em>microservice</em> (ریز سرویس) بالادستی را تأیید و احراز هویت کنیم. ما کمی بعدتر به این موضوع خواهیم پرداخت که چگونه انسان‌ها (کاربران!) را احراز هویت می‌کنیم.</p>
<p>ما می‌توانیم هویت یک <em>client</em> (کلاینت) را به چندین روش تأیید کنیم. ما می‌توانیم از <em>client</em> (کلاینت) بخواهیم که اطلاعاتی را در <em>request</em> (درخواست) برای ما ارسال کند که به ما بگوید آنها چه کسی هستند. یک مثال ممکن است استفاده از نوعی <em>shared secret</em> (راز مشترک) یا یک گواهی <em>client-side</em> (سمت کلاینت) برای امضای <em>request</em> (درخواست) باشد. هنگامی که سرور باید هویت <em>client</em> (کلاینت) را تأیید کند، ما می‌خواهیم این کار تا حد امکان کارآمد باشد—من برخی از راه‌حل‌ها (از جمله راه‌حل‌هایی که توسط فروشندگان <em>API gateway</em> (دروازه <em>API</em>) ارائه می‌شوند) را دیده‌ام که شامل این است که سرور باید با سرویس‌های مرکزی تماس بگیرد تا هویت <em>client</em> (کلاینت) را بررسی کند، که وقتی پیامدهای تأخیر را در نظر می‌گیرید، بسیار احمقانه است.</p>
<p>من در تلاش هستم که به یک موقعیت فکر کنم که در آن هویت <em>client</em> (کلاینت) را بدون تأیید هویت سرور تأیید کنم—برای تأیید هر دو، شما معمولاً در نهایت یک نوع احراز هویت متقابل را پیاده‌سازی می‌کنید. با احراز هویت متقابل، هر دو طرف یکدیگر را احراز هویت می‌کنند. بنابراین در شکل 11-6، <em>Order Processor</em> (پردازشگر سفارش) <em>Payment microservice</em> (ریز سرویس پرداخت) را احراز هویت می‌کند، و <em>Payment microservice</em> (ریز سرویس پرداخت)، <em>Order Processor</em> (پردازشگر سفارش) را احراز هویت می‌کند.</p>
<p>ما می‌توانیم این کار را از طریق استفاده از <em>mutual TLS</em> (امنیت لایه انتقال متقابل) انجام دهیم، که در این صورت هم <em>client</em> (کلاینت) و هم سرور از گواهی‌نامه‌ها استفاده می‌کنند. در اینترنت عمومی، تأیید هویت یک دستگاه <em>client</em> (کلاینت) معمولاً کمتر از تأیید هویت انسانی است که از آن دستگاه استفاده می‌کند. به همین دلیل، <em>mutual TLS</em> (امنیت لایه انتقال متقابل) به ندرت استفاده می‌شود. اما در معماری <em>microservice</em> (ریز سرویس) ما، به خصوص جایی که ممکن است در یک محیط <em>zero-trust</em> (اعتماد صفر) عمل کنیم، این بسیار رایج‌تر است.</p>
<p>چالش پیاده‌سازی طرح‌هایی مانند <em>mutual TLS</em> (امنیت لایه انتقال متقابل) از نظر تاریخی، <em>tooling</em> (ابزارسازی) بوده است. امروزه این یک مسئله کمتری است. ابزارهایی مانند <em>Vault</em> می‌توانند توزیع گواهی‌نامه‌ها را بسیار آسان‌تر کنند، و تمایل به ساده‌سازی استفاده از <em>mutual TLS</em> (امنیت لایه انتقال متقابل) یکی از دلایل اصلی برای پیاده‌سازی <em>service meshes</em> (مش‌های سرویس) توسط افراد است، که ما در "<em>Service Meshes and API Gateways</em>" در صفحه 162 بررسی کردیم.</p>
<h5>Visibility of data (دید داده‌ها)</h5>
<p>وقتی داده‌ها را از یک <em>microservice</em> (ریز سرویس) به دیگری ارسال می‌کنیم، آیا کسی می‌تواند داده‌ها را مشاهده کند؟ برای برخی از اطلاعات، مانند قیمت آلبوم‌های <em>Peter Andre</em>، ممکن است ما زیاد اهمیت ندهیم زیرا داده‌ها در حال حاضر در حوزه عمومی هستند. از طرف دیگر، برخی از داده‌ها ممکن است شامل <em>PII</em> (اطلاعات شناسایی شخصی) باشند، که ما باید مطمئن شویم که محافظت می‌شوند.</p>
<p><em>Securing Data | 371</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0397</div>
            </div>
        </div>
        <!-- Page 0398 -->
        <div class="chapter" id="page-0398">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>هنگامی که شما از <em>HTTPS</em> ساده قدیمی یا <em>mutual TLS</em> استفاده می‌کنید، داده‌ها برای طرف‌های واسطه قابل مشاهده نخواهند بود—این به این دلیل است که <em>TLS</em> داده‌های ارسالی را رمزگذاری می‌کند. این می‌تواند مشکل‌ساز باشد اگر شما صریحاً داده‌ها را در معرض دید قرار دهید—به عنوان مثال، <em>reverse proxies</em> (پراکسی‌های معکوس) مانند <em>Squid</em> یا <em>Varnish</em> قادر به <em>cache</em> (کش) کردن پاسخ‌های <em>HTTP</em> هستند، اما این با <em>HTTPS</em> امکان‌پذیر نیست.</p>
<h5>Manipulation of data (دستکاری داده‌ها)</h5>
<p>ما می‌توانیم تعدادی از موقعیت‌هایی را تصور کنیم که در آن دستکاری داده‌های ارسالی می‌تواند بد باشد—به عنوان مثال، تغییر میزان پولی که ارسال می‌شود. بنابراین در شکل 11-6، ما باید اطمینان حاصل کنیم که مهاجم بالقوه قادر به تغییر <em>request</em> (درخواست) ارسالی به <em>Payment</em> (پرداخت) از <em>Order Processor</em> (پردازشگر سفارش) نیست.</p>
<p>به طور معمول، انواع حفاظت‌هایی که داده‌ها را نامرئی می‌کنند، همچنین اطمینان حاصل می‌کنند که داده‌ها نمی‌توانند دستکاری شوند (<em>HTTPS</em> این کار را انجام می‌دهد، به عنوان مثال). با این حال، ما می‌توانیم تصمیم بگیریم که داده‌ها را در معرض دید قرار دهیم اما همچنان می‌خواهیم اطمینان حاصل کنیم که نمی‌توان آنها را دستکاری کرد. برای <em>HTTP</em>، یک رویکرد این است که از یک <em>hash-based message authentication code</em> (<em>HMAC</em>) (کد احراز هویت پیام مبتنی بر هش) برای امضای داده‌های ارسالی استفاده کنیم. با <em>HMAC</em>، یک هش تولید می‌شود و همراه با داده‌ها ارسال می‌شود، و گیرنده می‌تواند هش را در برابر داده‌ها بررسی کند تا تأیید کند که داده‌ها تغییر نکرده‌اند.</p>
<h5>Data at Rest (داده‌ها در حالت سکون)</h5>
<p>داده‌های بی‌تحرک، یک مسئولیت است، به‌خصوص اگر حساس باشد. امیدواریم که ما هر کاری که می‌توانستیم انجام داده‌ایم تا اطمینان حاصل کنیم که مهاجمان نمی‌توانند به شبکه ما نفوذ کنند، و همچنین نمی‌توانند به برنامه‌ها یا سیستم‌های عامل ما نفوذ کنند تا به داده‌های اساسی دسترسی پیدا کنند. با این حال، ما باید آماده باشیم در صورت انجام این کار—<em>defense in depth</em> (دفاع در عمق) کلیدی است.</p>
<p>بسیاری از نقض‌های امنیتی با مشخصات بالا که ما می‌شنویم، شامل داده‌های در حالت <em>rest</em> (سکون) است که توسط یک مهاجم به دست آمده، و آن داده‌ها توسط مهاجم قابل خواندن است. این اتفاق یا به این دلیل می‌افتد که داده‌ها در یک فرم غیر رمزگذاری شده ذخیره شده‌اند یا به این دلیل که مکانیسم مورد استفاده برای محافظت از داده‌ها، یک نقص اساسی داشته است.</p>
<p>مکانیسم‌هایی که داده‌ها را در حالت <em>rest</em> (سکون) می‌توانند محافظت کنند، زیاد و متنوع هستند، اما چند مورد کلی وجود دارد که باید در نظر داشت.</p>
<ul>
<li>Go with the well known (با شناخته‌شده‌ها بروید)</li>
<p>در برخی موارد، شما می‌توانید کار رمزگذاری داده‌ها را به نرم‌افزار موجود واگذار کنید—به عنوان مثال، با استفاده از پشتیبانی داخلی <em>database</em> (پایگاه داده) خود برای رمزگذاری. با این حال، اگر نیاز به رمزگذاری و رمزگشایی داده‌ها در سیستم خود پیدا کردید، اطمینان حاصل کنید که از پیاده‌سازی‌های شناخته‌شده و آزمایش شده استفاده می‌کنید. آسان‌ترین راهی که می‌توانید در رمزگذاری داده‌ها خرابکاری کنید، این است که سعی کنید الگوریتم‌های رمزگذاری خود را پیاده‌سازی کنید، یا حتی سعی کنید الگوریتم شخص دیگری را پیاده‌سازی کنید. هر زبان برنامه‌نویسی که استفاده می‌کنید، شما به پیاده‌سازی‌های بررسی‌شده و به‌روزرسانی‌شده مرتب رمزگذاری با اعتبار دسترسی خواهید داشت.</p>
</ul>
<p><em>372 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0398</div>
            </div>
        </div>
        <!-- Page 0399 -->
        <div class="chapter" id="page-0399">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>13 ما رمزهای عبور را در حالت <em>rest</em> (بیکاری) رمزگذاری نمی‌کنیم، زیرا رمزگذاری به این معنی است که هر کسی که کلید مناسب را داشته باشد می‌تواند رمز عبور را دوباره بخواند.</p>
<p><em>algorithms</em> (الگوریتم‌ها) از آنها استفاده کنید! و در لیست‌های پستی/لیست‌های مشاوره‌ای برای فناوری‌ای که انتخاب می‌کنید مشترک شوید تا اطمینان حاصل کنید که از آسیب‌پذیری‌ها همانطور که یافت می‌شوند آگاه هستید، بنابراین می‌توانید آنها را وصله‌شده و به‌روز نگه دارید.</p>
<p>برای ایمن‌سازی رمزهای عبور، شما باید مطلقاً از تکنیکی به نام <em>salted password hashing</em> (هش کردن رمز عبور با نمک) استفاده کنید. این اطمینان می‌دهد که رمزهای عبور هرگز به صورت متن ساده نگهداری نمی‌شوند، و حتی اگر یک مهاجم یک رمز عبور هش شده را به صورت <em>brute-force</em> (زورگیرانه) انجام دهد، نمی‌تواند به طور خودکار سایر رمزهای عبور را بخواند.13</p>
<p>رمزگذاری که به‌خوبی پیاده‌سازی نشده باشد، می‌تواند بدتر از این باشد که اصلاً وجود نداشته باشد، زیرا حس کاذب <em>security</em> (امنیت) (به دلیل شوخی) می‌تواند شما را از توجه به موضوع دور کند.</p>
<h5>Pick your targets (اهداف خود را انتخاب کنید)</h5>
<p>فرض کنید همه چیز باید رمزگذاری شود می‌تواند تا حدودی کارها را ساده کند. هیچ حدسی در مورد اینکه چه چیزی باید محافظت شود یا نشود وجود ندارد. با این حال، شما همچنان باید در مورد اینکه چه داده‌هایی را می‌توان در فایل‌های <em>logfile</em> (فایل‌های لاگ) قرار داد تا به شناسایی مشکل کمک کند، فکر کنید، و سربار محاسباتی رمزگذاری همه چیز می‌تواند کاملاً سنگین شود و در نتیجه به سخت‌افزار قدرتمندتری نیاز داشته باشد. این حتی زمانی که شما در حال اعمال <em>database migrations</em> (مهاجرت‌های پایگاه داده) به عنوان بخشی از <em>refactoring schemas</em> (بازسازی طرحواره‌ها) هستید، چالش‌برانگیزتر است. بسته به تغییراتی که ایجاد می‌شود، داده‌ها ممکن است نیاز به رمزگشایی، مهاجرت و رمزگذاری مجدد داشته باشند.</p>
<p>با تقسیم سیستم خود به <em>services</em> (سرویس‌های) دقیق‌تر، شما ممکن است یک انبار داده کامل را شناسایی کنید که می‌توان آن را به‌طور عمده رمزگذاری کرد، اما این بعید است. محدود کردن این رمزگذاری به مجموعه‌ای شناخته‌شده از جداول یک رویکرد منطقی است.</p>
<h5>Be frugal (اقتصادمند باشید)</h5>
<p>همانطور که فضای دیسک ارزان‌تر می‌شود و قابلیت‌های <em>databases</em> (پایگاه‌های داده) بهبود می‌یابد، سهولت ثبت و ذخیره مقادیر زیادی از اطلاعات به‌سرعت در حال بهبود است. این داده‌ها ارزشمند هستند—نه تنها برای خود کسب‌وکارها، که به‌طور فزاینده‌ای داده‌ها را به عنوان یک دارایی باارزش می‌بینند، بلکه به همان اندازه برای کاربرانی که به حریم خصوصی خود اهمیت می‌دهند. داده‌هایی که به یک فرد مربوط می‌شود یا می‌تواند برای استخراج اطلاعات در مورد یک فرد استفاده شود، باید داده‌هایی باشند که ما در مورد آنها بسیار مراقب هستیم.</p>
<p>با این حال، اگر زندگی خود را کمی آسان‌تر کنیم چه؟ چرا تا حد امکان اطلاعاتی که می‌توانند شناسایی شخصی داشته باشند را حذف نکنیم، و این کار را در اسرع وقت انجام ندهیم؟ هنگام ثبت یک <em>request</em> (درخواست) از یک کاربر، آیا ما نیاز داریم که کل آدرس <em>IP</em> را برای همیشه ذخیره کنیم، یا می‌توانیم چند رقم آخر را با <em>x</em> جایگزین کنیم؟ آیا ما نیاز داریم که نام، سن، جنسیت، و تاریخ تولد شخصی را ذخیره کنیم تا پیشنهادات محصول را به آنها ارائه دهیم، یا آیا محدوده سنی و کد پستی آنها اطلاعات کافی است؟</p>
<p><em>Securing Data | 373</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0399</div>
            </div>
        </div>
        <!-- Page 0400 -->
        <div class="chapter" id="page-0400">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>مزایای صرفه‌جویی در جمع‌آوری داده‌ها، متعدد است. اول، اگر شما آن را ذخیره نکنید، هیچ‌کس نمی‌تواند آن را بدزدد. دوم، اگر شما آن را ذخیره نکنید، هیچ‌کس (به عنوان مثال، یک آژانس دولتی) نمی‌تواند آن را درخواست کند!</p>
<p>عبارت آلمانی <em>Datensparsamkeit</em> این مفهوم را نشان می‌دهد. منشأ گرفته از قوانین حفظ حریم خصوصی آلمان، این مفهوم را در بر می‌گیرد که فقط به اندازه‌ای اطلاعات ذخیره شود که برای انجام عملیات تجاری یا برآورده کردن قوانین محلی کاملاً ضروری است.
    این بدیهی است که در تضاد مستقیم با حرکت به سمت ذخیره اطلاعات بیشتر و بیشتر است، اما درک اینکه این تنش حتی وجود دارد، شروع خوبی است!</p>
<h5>It’s all about the keys (همه چیز مربوط به کلیدها است)</h5>
<p>بیشتر اشکال رمزگذاری شامل استفاده از برخی کلیدها در ارتباط با یک <em>algorithm</em> (الگوریتم) مناسب برای ایجاد داده‌های رمزگذاری شده است. برای رمزگشایی داده‌ها به‌طوری که بتوان آنها را خواند، طرف‌های مجاز به کلید—یا همان کلید یا یک کلید متفاوت (در مورد رمزگذاری کلید عمومی) نیاز دارند. بنابراین کلیدهای شما کجا ذخیره می‌شوند؟ اکنون، اگر من داده‌های خود را رمزگذاری می‌کنم زیرا نگران هستم که کسی کل <em>database</em> (پایگاه داده) من را بدزدد، و کلیدی را که استفاده می‌کنم در همان <em>database</em> (پایگاه داده) ذخیره می‌کنم، پس من واقعاً به دستاوردی نرسیده‌ام!</p>
<p>بنابراین، ما باید کلیدها را در جای دیگری ذخیره کنیم. اما کجا؟</p>
<p>یک راه‌حل استفاده از یک <em>security appliance</em> (ابزار امنیتی) جداگانه برای رمزگذاری و رمزگشایی داده‌ها است. راه‌حل دیگر استفاده از یک <em>key vault</em> (خزانه کلید) جداگانه است که <em>service</em> (سرویس) شما می‌تواند هنگام نیاز به یک کلید به آن دسترسی داشته باشد. مدیریت چرخه عمر کلیدها (و دسترسی به تغییر آنها) می‌تواند یک عملیات حیاتی باشد، و این سیستم‌ها می‌توانند این کار را برای شما انجام دهند. اینجاست که <em>Vault HashiCorp’s</em> (ولت هشیکورپ) نیز می‌تواند بسیار مفید باشد.</p>
<p>حتی برخی از <em>databases</em> (پایگاه‌های داده) پشتیبانی داخلی از رمزگذاری را شامل می‌شوند، مانند رمزگذاری داده‌های شفاف <em>SQL Server</em>، که هدف آن رسیدگی به این موضوع به روشی شفاف است.
    حتی اگر <em>database</em> (پایگاه داده) مورد نظر شما چنین پشتیبانی را شامل می‌شود، تحقیق کنید که چگونه کلیدها مدیریت می‌شوند و درک کنید که آیا تهدیدی که شما از آن محافظت می‌کنید، در واقع در حال کاهش است.</p>
<p>باز هم، این موارد پیچیده است. از پیاده‌سازی رمزگذاری خودتان خودداری کنید، و کمی تحقیق خوب انجام دهید!</p>
<p>داده‌ها را هنگامی که برای اولین بار مشاهده کردید، رمزگذاری کنید. فقط در صورت تقاضا رمزگشایی کنید، و اطمینان حاصل کنید که داده‌ها هرگز در جایی ذخیره نمی‌شوند.</p>
<p><em>374 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 400" src="page_0400/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0400</div>
            </div>
        </div>
        <!-- Page 0401 -->
        <div class="chapter" id="page-0401">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h5>Encrypt backups (رمزگذاری پشتیبان‌گیری)</h5>
<p><em>Backups</em> (پشتیبان‌گیری) خوب هستند. ما می‌خواهیم از داده‌های مهم خود <em>backup</em> (پشتیبان‌گیری) کنیم. و ممکن است یک نکته واضح به نظر برسد، اما اگر داده‌ها به اندازه‌ای حساس هستند که ما می‌خواهیم در سیستم تولید در حال اجرا، رمزگذاری شوند، پس احتمالاً ما نیز می‌خواهیم مطمئن شویم که هر <em>backups</em> (پشتیبان‌گیری) از همان داده‌ها نیز رمزگذاری شده‌اند!</p>
<h5>Authentication and Authorization (احراز هویت و مجوز)</h5>
<p><em>Authentication</em> (احراز هویت) و <em>authorization</em> (مجوز) مفاهیم اصلی هستند وقتی صحبت از افراد و چیزهایی می‌شود که با سیستم ما تعامل دارند. در زمینه <em>security</em> (امنیت)، <em>authentication</em> (احراز هویت) فرآیندی است که ما از طریق آن تأیید می‌کنیم که یک طرف همان چیزی است که می‌گوید. ما معمولاً یک کاربر انسانی را با تایپ نام کاربری و رمز عبور احراز هویت می‌کنیم. ما فرض می‌کنیم که فقط کاربر واقعی به این اطلاعات دسترسی دارد، و بنابراین شخصی که این اطلاعات را وارد می‌کند باید خودشان باشند. البته، سیستم‌های پیچیده‌تری نیز وجود دارد. تلفن‌های ما اکنون به ما اجازه می‌دهند از اثر انگشت یا چهره خود برای تأیید اینکه ما همان کسی هستیم که ادعا می‌کنیم، استفاده کنیم. به‌طور کلی، وقتی ما به‌طور انتزاعی در مورد اینکه چه کسی یا چه چیزی احراز هویت می‌شود، صحبت می‌کنیم، به آن طرف <em>principal</em> (اصلی) اشاره می‌کنیم.</p>
<p><em>Authorization</em> (مجوز) مکانیسمی است که ما از طریق آن از یک <em>principal</em> (اصلی) به عملی که به آنها اجازه می‌دهیم انجام دهند، ترسیم می‌کنیم. اغلب، هنگامی که یک <em>principal</em> (اصلی) احراز هویت می‌شود، ما اطلاعاتی در مورد آنها دریافت می‌کنیم که به ما کمک می‌کند تصمیم بگیریم که چه کاری باید به آنها اجازه دهیم انجام دهند. به عنوان مثال، ممکن است به ما گفته شود که آنها در کدام بخش یا اداره کار می‌کنند—یک تکه اطلاعات که سیستم ما می‌تواند برای تصمیم‌گیری در مورد اینکه <em>principal</em> (اصلی) چه کاری می‌تواند و نمی‌تواند انجام دهد، استفاده کند.</p>
<p>سهولت استفاده مهم است—ما می‌خواهیم دسترسی به سیستم خود را برای کاربرانمان آسان کنیم. ما نمی‌خواهیم که همه مجبور باشند جداگانه وارد سیستم شوند تا به <em>microservices</em> (ریز سرویس‌های) مختلف دسترسی داشته باشند، و از نام کاربری و رمز عبور متفاوتی برای هر کدام استفاده کنند. بنابراین ما همچنین باید به این موضوع بپردازیم که چگونه می‌توانیم <em>single sign-on</em> (SSO) (ورود به سیستم یکپارچه) را در یک محیط <em>microservices</em> (ریز سرویس‌ها) پیاده‌سازی کنیم.</p>
<h5>Service-to-Service Authentication (احراز هویت سرویس به سرویس)</h5>
<p>قبلاً ما در مورد <em>mutual TLS</em> (امنیت لایه انتقال متقابل) بحث کردیم، که جدا از محافظت از داده‌ها در حال انتقال، همچنین به ما اجازه می‌دهد تا نوعی <em>authentication</em> (احراز هویت) را پیاده‌سازی کنیم. هنگامی که یک <em>client</em> (کلاینت) با استفاده از <em>mutual TLS</em> (امنیت لایه انتقال متقابل) با یک سرور صحبت می‌کند، سرور قادر به احراز هویت <em>client</em> (کلاینت) است، و <em>client</em> (کلاینت) قادر به احراز هویت سرور است—این یک نوع احراز هویت سرویس به سرویس است. علاوه بر <em>mutual TLS</em> (امنیت لایه انتقال متقابل) می‌توان از طرح‌های احراز هویت دیگری استفاده کرد. یک مثال رایج استفاده از کلیدهای <em>API</em> است، که در آن <em>client</em> (کلاینت) باید از کلید برای هش کردن یک درخواست به گونه‌ای استفاده کند که سرور قادر به تأیید این باشد که <em>client</em> (کلاینت) از یک کلید معتبر استفاده کرده است.</p>
<p><em>Authentication and Authorization | 375</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0401</div>
            </div>
        </div>
        <!-- Page 0402 -->
        <div class="chapter" id="page-0402">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>14 قبلاً ما در مورد <em>two-factor authentication</em> (2FA) (احراز هویت دو عاملی) صحبت می‌کردیم. <em>MFA</em> (احراز هویت چند عاملی) مفهوم یکسانی است اما این ایده را معرفی می‌کند که ما اغلب اکنون به کاربران خود اجازه می‌دهیم تا یک عامل اضافی از انواع مختلف دستگاه‌ها، مانند یک توکن امن، یک برنامه احراز هویت تلفن همراه، یا شاید بیومتریک، ارائه دهند. شما می‌توانید <em>2FA</em> (احراز هویت دو عاملی) را زیرمجموعه‌ای از <em>MFA</em> (احراز هویت چند عاملی) در نظر بگیرید.</p>
<h5>Human Authentication (احراز هویت انسانی)</h5>
<p>ما به احراز هویت انسان‌ها با ترکیب نام کاربری و رمز عبور آشنا هستیم. با این حال، به طور فزاینده‌ای، این به عنوان بخشی از یک رویکرد <em>multi-factor authentication</em> (MFA) (احراز هویت چند عاملی) استفاده می‌شود، که در آن کاربر ممکن است به بیش از یک قطعه از دانش (یک عامل) برای احراز هویت خود نیاز داشته باشد. رایج‌ترین حالت، این است که از <em>multifactor authentication</em> (MFA) (احراز هویت چند عاملی)14 استفاده می‌شود، که در آن به بیش از یک عامل نیاز است. <em>MFA</em> (احراز هویت چند عاملی) معمولاً شامل استفاده از یک ترکیب نام کاربری و رمز عبور معمولی، علاوه بر ارائه حداقل یک عامل اضافی، می‌شود.</p>
<p>انواع مختلف عوامل <em>authentication</em> (احراز هویت) در سال‌های اخیر افزایش یافته است—از کدهای ارسال شده از طریق <em>SMS</em> و لینک‌های جادویی ارسال شده از طریق ایمیل تا برنامه‌های تلفن همراه اختصاصی مانند <em>Authy</em> و دستگاه‌های سخت‌افزاری <em>USB</em> و <em>NFC</em> مانند <em>YubiKey</em>. عوامل بیومتریک نیز اکنون بیشتر مورد استفاده قرار می‌گیرند، زیرا کاربران به سخت‌افزاری که از چیزهایی مانند اثر انگشت یا تشخیص چهره پشتیبانی می‌کند، دسترسی بیشتری دارند. در حالی که <em>MFA</em> (احراز هویت چند عاملی) خود را به عنوان یک رویکرد کلی بسیار امن‌تر نشان داده است، و بسیاری از خدمات عمومی از آن پشتیبانی می‌کنند، اما به عنوان یک طرح احراز هویت در بازار انبوه رواج پیدا نکرده است، اگرچه من انتظار دارم که این تغییر کند. برای مدیریت <em>authentication</em> (احراز هویت) سرویس‌های کلیدی که برای اجرای نرم‌افزار شما حیاتی هستند یا به اطلاعات به‌ویژه حساس (به عنوان مثال، دسترسی به کد منبع) اجازه دسترسی می‌دهند، من استفاده از <em>MFA</em> (احراز هویت چند عاملی) را ضروری می‌دانم.</p>
<h5>Common Single Sign-On Implementations (پیاده‌سازی‌های رایج ورود به سیستم یکپارچه)</h5>
<p>یک رویکرد رایج برای <em>authentication</em> (احراز هویت) استفاده از نوعی راه‌حل <em>single sign-on</em> (SSO) (ورود به سیستم یکپارچه) است تا اطمینان حاصل شود که کاربر فقط یک بار در هر جلسه، خود را احراز هویت می‌کند، حتی اگر در طول آن جلسه ممکن است با چندین <em>service</em> (سرویس) یا <em>application</em> (برنامه) بالادستی تعامل داشته باشد. به عنوان مثال، هنگامی که شما با حساب <em>Google</em> خود وارد می‌شوید، در <em>Google Calendar</em>، <em>Gmail</em> و <em>Google Docs</em> وارد می‌شوید، حتی اگر اینها سیستم‌های جداگانه‌ای باشند.</p>
<p>هنگامی که یک <em>principal</em> (اصلی) سعی می‌کند به یک منبع (مانند یک رابط مبتنی بر وب) دسترسی پیدا کند، آنها به سمت احراز هویت با یک <em>identity provider</em> (ارائه‌دهنده هویت) هدایت می‌شوند. <em>identity provider</em> (ارائه‌دهنده هویت) ممکن است از آنها بخواهد که نام کاربری و رمز عبور خود را ارائه دهند یا ممکن است نیاز به استفاده از چیزی پیشرفته‌تر مانند <em>MFA</em> (احراز هویت چند عاملی) داشته باشد. هنگامی که <em>identity provider</em> (ارائه‌دهنده هویت) از احراز هویت <em>principal</em> (اصلی) راضی شد، اطلاعاتی را به <em>service provider</em> (ارائه‌دهنده سرویس) می‌دهد و به آن اجازه می‌دهد تصمیم بگیرد که آیا به آنها اجازه دسترسی به منبع را بدهد یا خیر.</p>
<p><em>Authentication and Authorization | 376</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0402</div>
            </div>
        </div>
        <!-- Page 0403 -->
        <div class="chapter" id="page-0403">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>15 من نمی‌توانم اعتبار آن را از آن خود کنم!</p>
<p>این <em>identity provider</em> (ارائه‌دهنده هویت) می‌تواند یک سیستم میزبانی شده خارجی یا چیزی در داخل سازمان شما باشد. به عنوان مثال، <em>Google</em> یک <em>identity provider</em> (ارائه‌دهنده هویت) <em>OpenID Connect</em> ارائه می‌دهد. اما برای شرکت‌ها، داشتن <em>identity provider</em> (ارائه‌دهنده هویت) خود، که ممکن است به سرویس دایرکتوری شرکت شما پیوند داده شود، رایج است. یک سرویس دایرکتوری می‌تواند چیزی شبیه <em>Lightweight Directory Access Protocol</em> (<em>LDAP</em>) یا <em>Active Directory</em> باشد. این سیستم‌ها به شما اجازه می‌دهند تا اطلاعاتی در مورد <em>principals</em> (اصلی‌ها)، مانند نقش‌هایی که آنها در سازمان ایفا می‌کنند، ذخیره کنید. اغلب سرویس دایرکتوری و <em>identity provider</em> (ارائه‌دهنده هویت) یکی هستند، در حالی که در زمان‌های دیگر آنها جدا اما مرتبط هستند.</p>
<p>به عنوان مثال، <em>Okta</em> یک <em>identity provider</em> (ارائه‌دهنده هویت) <em>SAML</em> میزبانی شده است که وظایفی مانند احراز هویت دو عاملی را انجام می‌دهد اما می‌تواند به سرویس‌های دایرکتوری شرکت شما به عنوان منبع حقیقت، پیوند داشته باشد.</p>
<p>بنابراین <em>identity provider</em> (ارائه‌دهنده هویت) اطلاعاتی در مورد اینکه <em>principal</em> (اصلی) کیست، به سیستم می‌دهد، اما سیستم تصمیم می‌گیرد که به آن <em>principal</em> (اصلی) چه اجازه‌ای داده شود.
    <em>SAML</em> یک استاندارد مبتنی بر <em>SOAP</em> است و علیرغم کتابخانه‌ها و ابزارهای موجود برای پشتیبانی از آن، به دلیل پیچیدگی نسبتاً خود شناخته شده است، و از زمان انتشار اولین نسخه این کتاب، به سرعت از محبوبیت افتاده است.15 <em>OpenID Connect</em> استانداردی است که به عنوان یک پیاده‌سازی خاص از <em>OAuth 2.0</em>، بر اساس روشی که <em>Google</em> و دیگران <em>SSO</em> را مدیریت می‌کنند، پدید آمده است. این از فراخوانی‌های <em>REST</em> ساده‌تر استفاده می‌کند، و تا حدی به دلیل سادگی نسبی و پشتیبانی گسترده آن، مکانیسم غالب برای <em>SSO</em> (ورود به سیستم یکپارچه) کاربر نهایی است، و به موفقیت‌های چشمگیری در شرکت‌ها دست یافته است.</p>
<h5>Single Sign-On Gateway (دروازه ورود به سیستم یکپارچه)</h5>
<p>ما می‌توانیم تصمیم بگیریم که هدایت مجدد به، و ارتباط با <em>identity provider</em> (ارائه‌دهنده هویت)، را در هر <em>microservice</em> (ریز سرویس) مدیریت کنیم، به طوری که هر <em>request</em> (درخواست) تأیید نشده از یک طرف خارجی، به درستی رسیدگی شود. بدیهی است، این می‌تواند به معنای مقدار زیادی از عملکرد تکراری در <em>microservices</em> (ریز سرویس‌های) ما باشد. یک کتابخانه مشترک می‌تواند کمک کند، اما ما باید مراقب باشیم تا از اتصالاتی که می‌تواند از کد مشترک ناشی شود، اجتناب کنیم (به "<em>DRY</em> and the Perils of Code Reuse in a Microservice World" در صفحه 154 مراجعه کنید). یک کتابخانه مشترک نیز کمک نمی‌کند اگر ما <em>microservices</em> (ریز سرویس‌هایی) داشته باشیم که در پشته‌های فناوری مختلف نوشته شده‌اند.</p>
<p>به جای اینکه هر سرویس، ارتباط با <em>identity provider</em> (ارائه‌دهنده هویت) ما را مدیریت کند، یک رویکرد رایج‌تر استفاده از یک <em>gateway</em> (دروازه) برای عمل به عنوان یک <em>proxy</em> (پراکسی) است که بین سرویس‌های شما و دنیای بیرون قرار دارد (همانطور که در شکل 11-7 نشان داده شده است). ایده این است که ما می‌توانیم رفتار را برای هدایت مجدد کاربر متمرکز کنیم و دست دادن را فقط در یک مکان انجام دهیم.</p>
<p><em>Authentication and Authorization | 377</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0403</div>
            </div>
        </div>
        <!-- Page 0404 -->
        <div class="chapter" id="page-0404">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>شکل 11-7. استفاده از یک <em>gateway</em> (دروازه) برای مدیریت <em>SSO</em> (ورود به سیستم یکپارچه)</p>
<p>با این حال، ما هنوز هم باید مشکل چگونگی دریافت اطلاعات <em>service</em> (سرویس) بالادستی در مورد <em>principals</em> (اصلی‌ها)، مانند نام کاربری آنها یا نقش‌هایی که ایفا می‌کنند، را حل کنیم. اگر شما از <em>HTTP</em> استفاده می‌کنید، می‌توانید <em>gateway</em> (دروازه) خود را طوری پیکربندی کنید که هدرها را با این اطلاعات پر کند. <em>Shibboleth</em> یک ابزار است که می‌تواند این کار را برای شما انجام دهد، و من دیده‌ام که از آن با سرور وب <em>Apache</em> برای مدیریت ادغام با <em>SAML-based identity providers</em> (ارائه‌دهندگان هویت مبتنی بر <em>SAML</em>) استفاده می‌شود، که بسیار مؤثر است. یک جایگزین، که ما به زودی با جزئیات بیشتری به آن خواهیم پرداخت، ایجاد یک <em>JSON Web Token</em> (<em>JWT</em>) (توکن وب <em>JSON</em>) است که حاوی تمام اطلاعات مربوط به <em>principal</em> (اصلی) است؛ این مزایای متعددی دارد، از جمله اینکه چیزی است که ما می‌توانیم به راحتی از یک <em>microservice</em> (ریز سرویس) به <em>microservice</em> (ریز سرویس) دیگر منتقل کنیم.</p>
<p>یک ملاحظه دیگر در استفاده از یک <em>single sign-on gateway</em> (دروازه ورود به سیستم یکپارچه) این است که اگر ما تصمیم گرفته‌ایم مسئولیت <em>authentication</em> (احراز هویت) را به یک <em>gateway</em> (دروازه) واگذار کنیم، استدلال در مورد نحوه رفتار یک <em>microservice</em> (ریز سرویس) هنگام نگاه کردن به آن به‌صورت مجزا می‌تواند دشوارتر باشد. آیا در فصل 9 به یاد دارید که ما برخی از چالش‌های بازتولید محیط‌های تولیدی را بررسی کردیم؟ اگر شما تصمیم دارید از یک <em>gateway</em> (دروازه) استفاده کنید، اطمینان حاصل کنید که توسعه‌دهندگان شما می‌توانند <em>services</em> (سرویس‌های) خود را بدون زحمت زیاد پشت یک <em>gateway</em> (دروازه) راه‌اندازی کنند.</p>
<p><em>378 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 404" src="page_0404/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0404</div>
            </div>
        </div>
        <!-- Page 0405 -->
        <div class="chapter" id="page-0405">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>یک مشکل نهایی در این رویکرد این است که می‌تواند شما را به یک حس کاذب <em>security</em> (امنیت) سوق دهد. باز هم، من دوست دارم به ایده <em>defense in depth</em> (دفاع در عمق) بازگردم—از مرز شبکه تا زیرشبکه، فایروال، ماشین، سیستم عامل، و سخت‌افزار اساسی. شما این توانایی را دارید که اقدامات <em>security</em> (امنیت) را در همه این نقاط پیاده‌سازی کنید. من دیده‌ام که برخی از افراد همه تخم‌مرغ‌های خود را در یک سبد قرار می‌دهند و به دروازه برای رسیدگی به هر مرحله برای آنها متکی هستند. و همه ما می‌دانیم که وقتی یک نقطه شکست داشته باشیم چه اتفاقی می‌افتد...</p>
<p>بدیهی است که شما می‌توانید از این دروازه برای انجام کارهای دیگر استفاده کنید. به عنوان مثال، شما همچنین می‌توانید تصمیم بگیرید که <em>HTTPS</em> را در این سطح خاتمه دهید، تشخیص نفوذ را اجرا کنید، و غیره. اما مراقب باشید. لایه‌های دروازه تمایل دارند که عملکرد بیشتری را در نظر بگیرند، که خود می‌تواند به یک نقطه اتصال بزرگ تبدیل شود. و هرچه چیزی عملکرد بیشتری داشته باشد، سطح حمله بیشتر خواهد بود.</p>
<h5>Fine-Grained Authorization (مجوزهای دقیق)</h5>
<p>یک <em>gateway</em> (دروازه) ممکن است بتواند <em>authentication</em> (احراز هویت) درشت‌دانه (coarse-grained) نسبتاً مؤثری را ارائه دهد. به عنوان مثال، می‌تواند از دسترسی هر کاربر غیر وارد شده به <em>application</em> (برنامه) میز راهنما جلوگیری کند. با فرض اینکه <em>gateway</em> (دروازه) ما می‌تواند ویژگی‌هایی را در مورد <em>principal</em> (اصلی) در نتیجه <em>authentication</em> (احراز هویت) استخراج کند، ممکن است بتواند تصمیمات ظریف‌تری بگیرد. به عنوان مثال، قرار دادن افراد در گروه‌ها یا اختصاص آنها به نقش‌ها رایج است. ما می‌توانیم از این اطلاعات برای درک آنچه آنها می‌توانند انجام دهند، استفاده کنیم. بنابراین برای <em>application</em> (برنامه) میز راهنما، ما ممکن است فقط به <em>principals</em> (اصلی‌ها) با یک نقش خاص (به عنوان مثال، <em>STAFF</em>) دسترسی بدهیم. با این حال، فراتر از اجازه (یا عدم اجازه) دسترسی به منابع یا <em>endpoints</em> (نقاط پایانی) خاص، ما باید بقیه را به خود <em>microservice</em> (ریز سرویس) واگذار کنیم؛ این نیاز خواهد داشت که تصمیمات بیشتری در مورد عملیاتی که باید اجازه داده شوند، اتخاذ کند.</p>
<p>برگردیم به <em>application</em> (برنامه) میز راهنمای ما: آیا ما به هر یک از اعضای کارکنان اجازه می‌دهیم تمام جزئیات را ببینند؟ به احتمال زیاد، ما نقش‌های متفاوتی در کار خواهیم داشت. به عنوان مثال، یک <em>principal</em> (اصلی) در گروه <em>CALL_CENTER</em> ممکن است مجاز به مشاهده هر قطعه اطلاعاتی در مورد یک مشتری، به جز جزئیات پرداخت آنها باشد. این <em>principal</em> (اصلی) ممکن است بتواند بازپرداخت نیز صادر کند، اما آن مبلغ ممکن است محدود شود. با این حال، کسی که نقش <em>CALL_CENTER_TEAM_LEADER</em> را دارد، ممکن است بتواند بازپرداخت‌های بزرگ‌تری صادر کند.</p>
<p>این تصمیمات باید در <em>microservice</em> (ریز سرویس) مورد نظر، محلی باشد. من دیده‌ام که مردم از ویژگی‌های مختلف ارائه شده توسط <em>identity providers</em> (ارائه‌دهندگان هویت) به روش‌های وحشتناکی استفاده می‌کنند، و از نقش‌های واقعاً <em>fine-grained</em> (دانه ریز) مانند <em>CALL_CENTER_50_DOLLAR_REFUND</em> استفاده می‌کنند، که در آن در نهایت اطلاعاتی را که مختص یک قطعه از عملکرد <em>microservice</em> (ریز سرویس) است، در سرویس‌های دایرکتوری خود قرار می‌دهند. این یک کابوس برای نگهداری است و فضای بسیار کمی را برای این ارائه می‌دهد که خدمات ما چرخه عمر مستقل خود را داشته باشند، زیرا ناگهان تکه‌ای از اطلاعات در مورد نحوه عملکرد یک سرویس در جای دیگری، شاید در سیستمی که توسط بخش دیگری از سازمان مدیریت می‌شود، قرار دارد.</p>
<p><em>Authentication and Authorization | 379</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0405</div>
            </div>
        </div>
        <!-- Page 0406 -->
        <div class="chapter" id="page-0406">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>اطمینان از اینکه <em>microservice</em> (ریز سرویس) اطلاعات مورد نیاز برای ارزیابی درخواست‌های مجوز دقیق‌تر را دارد، شایسته بحث بیشتر است—ما این موضوع را زمانی که به <em>JWTs</em> (توکن‌های <em>JWT</em>) نگاه می‌کنیم، دوباره بررسی خواهیم کرد.</p>
<p>در عوض، نقش‌های درشت‌دانه را که بر اساس نحوه عملکرد سازمان شما مدل‌سازی شده‌اند، ترجیح دهید. با بازگشت به فصل‌های اولیه، به یاد داشته باشید که ما در حال ساخت نرم‌افزاری هستیم تا با نحوه عملکرد سازمانمان مطابقت داشته باشد. بنابراین از نقش‌های خود نیز به این روش استفاده کنید.</p>
<h5>The Confused Deputy Problem (مشکل معاون گیج)</h5>
<p>احراز هویت یک <em>principal</em> (اصلی) با سیستم به عنوان یک کل با استفاده از چیزی مانند یک <em>SSO gateway</em> (دروازه ورود به سیستم یکپارچه) به اندازه کافی ساده است، و این می‌تواند برای کنترل دسترسی به یک <em>microservice</em> (ریز سرویس) معین کافی باشد. اما اگر آن <em>microservice</em> (ریز سرویس) سپس نیاز به برقراری تماس‌های اضافی برای تکمیل یک عملیات داشته باشد، چه اتفاقی می‌افتد؟ این می‌تواند ما را در معرض نوعی آسیب‌پذیری قرار دهد که به عنوان <em>the confused deputy problem</em> (مشکل معاون گیج) شناخته می‌شود. این زمانی رخ می‌دهد که یک طرف بالادستی، یک طرف واسطه را فریب می‌دهد تا کارهایی را انجام دهد که نباید انجام دهد. بیایید به یک مثال مشخص در شکل 11-8 نگاه کنیم، که سایت خرید آنلاین <em>MusicCorp</em> را نشان می‌دهد. رابط کاربری <em>JavaScript</em> مبتنی بر مرورگر ما با <em>Web Shop microservice</em> (ریز سرویس فروشگاه وب) سمت سرور صحبت می‌کند، که نوعی <em>backend for frontend</em> (بک‌اند برای فرانت‌اند) است. ما این موضوع را با جزئیات بیشتری در "Pattern: Backend for Frontend (BFF)" در صفحه 480 بررسی خواهیم کرد، اما در حال حاضر، آن را به عنوان یک مؤلفه سمت سرور در نظر بگیرید که تجمیع و فیلتر فراخوانی را برای یک رابط خارجی خاص (در مورد ما، رابط کاربری <em>JavaScript</em> مبتنی بر مرورگر ما) انجام می‌دهد. تماس‌های برقرار شده بین مرورگر و <em>Web Shop</em> (فروشگاه وب) را می‌توان با استفاده از <em>OpenID Connect</em> احراز هویت کرد. تاکنون، خوب پیش رفته‌ایم.</p>
<p>شکل 11-8. نمونه‌ای که در آن یک معاون گیج می‌تواند وارد عمل شود</p>
<p><em>380 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 406" src="page_0406/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0406</div>
            </div>
        </div>
        <!-- Page 0407 -->
        <div class="chapter" id="page-0407">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>هنگامی که یک کاربر وارد سیستم می‌شود، می‌تواند روی یک لینک کلیک کند تا جزئیات یک سفارش را مشاهده کند. برای نمایش اطلاعات، ما باید سفارش اصلی را از <em>Order service</em> (سرویس سفارش) برگردانیم، اما همچنین می‌خواهیم اطلاعات حمل‌ونقل سفارش را جستجو کنیم. بنابراین وقتی یک مشتری وارد سیستم شده روی یک لینک برای <em>/orderStatus/12345</em> کلیک می‌کند، این <em>request</em> (درخواست) به <em>Web Shop</em> (فروشگاه وب) هدایت می‌شود، که سپس نیاز دارد که تماس‌هایی را با <em>microservices</em> (ریز سرویس‌های) <em>Order</em> و <em>Shipping</em> (حمل و نقل) بالادستی برقرار کند و از آنها درخواست جزئیات سفارش 12345 را داشته باشد.</p>
<p>اما آیا این سرویس‌های بالادستی باید فراخوانی‌ها را از <em>Web Shop</em> (فروشگاه وب) بپذیرند؟ ما می‌توانیم یک موضع از اعتماد ضمنی را اتخاذ کنیم: از آنجا که تماس از داخل محیط ما آمده است، مشکلی ندارد. ما حتی می‌توانیم از گواهی‌نامه‌ها یا کلیدهای <em>API</em> برای تأیید اینکه واقعاً این <em>Web Shop</em> (فروشگاه وب) است که این اطلاعات را درخواست می‌کند، استفاده کنیم. اما آیا این کافی است؟ به عنوان مثال، یک مشتری که وارد سیستم خرید آنلاین شده است، می‌تواند جزئیات حساب شخصی خود را مشاهده کند. اگر مشتری بتواند رابط کاربری <em>Web Shop</em> (فروشگاه وب) را فریب دهد تا درخواستی برای اطلاعات شخص دیگری ایجاد کند، چه می‌شود، شاید با برقراری تماس با <em>credentials</em> (اعتبارنامه‌های) وارد شده خود؟</p>
<p>در این مثال، چه چیزی قرار است مشتری را از درخواست سفارشاتی که متعلق به آنها نیست، باز دارد؟ هنگامی که آنها وارد سیستم شدند، می‌توانند درخواست‌هایی را برای سفارشات دیگری که متعلق به آنها نیست ارسال کنند تا ببینند آیا می‌توانند اطلاعات مفیدی را استخراج کنند یا خیر. آنها می‌توانند حدس زدن <em>order IDs</em> (شناسه‌های سفارش) را شروع کنند تا ببینند آیا می‌توانند اطلاعات افراد دیگر را استخراج کنند. اساساً، آنچه در اینجا اتفاق افتاده است این است که در حالی که ما کاربر مورد نظر را احراز هویت کرده‌ایم، ما <em>authorization</em> (مجوز) کافی ارائه نمی‌دهیم. آنچه ما می‌خواهیم این است که بخشی از سیستم ما بتواند قضاوت کند که یک <em>request</em> (درخواست) برای مشاهده جزئیات کاربر <em>A</em> فقط در صورتی می‌تواند اعطا شود که کاربر <em>A</em> درخواست مشاهده آن را داشته باشد. با این حال، این منطق کجا وجود دارد؟</p>
<h5>Centralized, Upstream Authorization (مجوزدهی مرکزی و بالادستی)</h5>
<p>یک گزینه برای جلوگیری از مشکل <em>confused deputy</em> (معاون گیج)، انجام تمام <em>authorization</em> (مجوز)های مورد نیاز به محض دریافت <em>request</em> (درخواست) در سیستم ما است. در شکل 11-8، این به این معنی است که ما قصد داریم <em>request</em> (درخواست) را یا در خود <em>SSO gateway</em> (دروازه ورود به سیستم یکپارچه) یا در <em>Web Shop</em> (فروشگاه وب) مجوز دهیم. ایده این است که تا زمانی که تماس‌ها به <em>Order</em> یا <em>Shipping microservice</em> (ریز سرویس سفارش یا حمل و نقل) ارسال می‌شوند، ما فرض می‌کنیم که به <em>requests</em> (درخواست‌ها) اجازه داده شده است.</p>
<p>این شکل از <em>upstream authorization</em> (مجوزدهی بالادستی) عملاً به این معنی است که ما نوعی اعتماد ضمنی را می‌پذیریم (برخلاف اعتماد صفر)—<em>Shipping</em> و <em>Order microservices</em> (ریز سرویس‌های حمل و نقل و سفارش) باید فرض کنند که فقط به آنها <em>requests</em> (درخواست‌هایی) ارسال می‌شود که اجازه انجام آنها را دارند.
    مسئله دیگر این است که یک نهاد بالادستی—به عنوان مثال، یک <em>gateway</em> (دروازه) یا چیزی مشابه—باید از عملکردی که <em>microservices</em> (ریز سرویس‌های) بالادستی ارائه می‌دهند، اطلاع داشته باشد، و باید بداند چگونه دسترسی به آن عملکرد را محدود کند.</p>
<p>در حالت ایده‌آل، ما می‌خواهیم <em>microservices</em> (ریز سرویس‌های) ما تا حد امکان خودکفا باشند، تا تغییرات و راه‌اندازی عملکرد جدید را تا حد امکان آسان کنیم. ما می‌خواهیم <em>releases</em> (انتشارها)ی ما تا حد امکان ساده باشد—ما قابلیت استقرار مستقل را می‌خواهیم. اگر عمل استقرار اکنون شامل استقرار یک <em>microservice</em> (ریز سرویس) جدید و اعمال برخی از</p>
<p><em>Authentication and Authorization | 377</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0407</div>
            </div>
        </div>
        <!-- Page 0408 -->
        <div class="chapter" id="page-0408">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>اگر ما تصمیم گرفتیم که پیکربندی مرتبط با <em>authorization</em> (مجوز) را به یک <em>gateway</em> (دروازه) بالادستی واگذار کنیم، پس به نظر من این خیلی "مستقل" به نظر نمی‌رسد.</p>
<p>بنابراین، ما می‌خواهیم تصمیم در مورد اینکه آیا <em>call</em> (فراخوانی) باید مجوز داده شود یا خیر، را به همان <em>microservice</em> (ریز سرویس) که عملکرد درخواستی در آن قرار دارد، منتقل کنیم.
    این باعث می‌شود که <em>microservice</em> (ریز سرویس) خودکفا‌تر شود و همچنین در صورت تمایل، به ما این امکان را می‌دهد که <em>zero trust</em> (اعتماد صفر) را پیاده‌سازی کنیم.</p>
<h5>Decentralizing Authorization (مجوزدهی غیرمتمرکز)</h5>
<p>با توجه به چالش‌های <em>centralized authorization</em> (مجوزدهی متمرکز) در یک محیط <em>microservices</em> (ریز سرویس‌ها)، ما می‌خواهیم این منطق را به <em>microservice</em> (ریز سرویس) پایین‌دستی منتقل کنیم. <em>Order microservice</em> (ریز سرویس سفارش) جایی است که عملکرد دسترسی به جزئیات سفارش در آن قرار دارد، بنابراین منطقی است که آن سرویس تصمیم بگیرد که آیا <em>call</em> (فراخوانی) معتبر است یا خیر. با این حال، در این مورد خاص، <em>Order microservice</em> (ریز سرویس سفارش) به اطلاعاتی در مورد اینکه چه کسی درخواست را انجام می‌دهد، نیاز دارد. بنابراین چگونه این اطلاعات را به <em>Order microservice</em> (ریز سرویس سفارش) می‌رسانیم؟</p>
<p>در ساده‌ترین سطح، ما می‌توانیم فقط نیاز داشته باشیم که شناسه فردی که درخواست را انجام می‌دهد، به <em>Order microservice</em> (ریز سرویس سفارش) ارسال شود. به عنوان مثال، اگر از <em>HTTP</em> استفاده می‌کنیم، می‌توانیم فقط نام کاربری را در یک هدر قرار دهیم. اما در چنین حالتی، چه چیزی قرار است یک فرد مخرب را از قرار دادن هر نام قدیمی در <em>request</em> (درخواست) برای دریافت اطلاعات مورد نیاز خود، باز دارد؟ در حالت ایده‌آل، ما می‌خواهیم راهی داشته باشیم تا مطمئن شویم که <em>request</em> (درخواست) واقعاً از طرف یک کاربر احراز هویت شده انجام می‌شود و می‌توانیم اطلاعات اضافی در مورد آن کاربر را منتقل کنیم—به عنوان مثال، گروه‌هایی که آن کاربر ممکن است در آن قرار گیرد.</p>
<p>از نظر تاریخی، راه‌های مختلفی برای رسیدگی به این موضوع وجود داشته است (از جمله تکنیک‌هایی مانند <em>nested SAML assertions</em> (ادعاهای <em>SAML</em> تو در تو)، که بله، به همان اندازه که به نظر می‌رسند دردناک هستند)، اما اخیراً رایج‌ترین راه‌حل برای این مشکل خاص استفاده از <em>JSON Web Tokens</em> (توکن‌های وب <em>JSON</em>) بوده است.</p>
<h5>JSON Web Tokens (توکن‌های وب JSON)</h5>
<p><em>JWTs</em> (توکن‌های <em>JWT</em>) به شما اجازه می‌دهند ادعاهای متعددی را در مورد یک فرد در یک رشته ذخیره کنید که می‌توان آن را منتقل کرد. این توکن را می‌توان امضا کرد تا اطمینان حاصل شود که ساختار توکن دستکاری نشده است، و همچنین می‌توان آن را به‌طور اختیاری رمزگذاری کرد تا تضمین‌های رمزنگاری در مورد اینکه چه کسی می‌تواند داده‌ها را بخواند، ارائه شود. اگرچه <em>JWTs</em> (توکن‌های <em>JWT</em>) می‌توانند برای تبادل اطلاعات عمومی استفاده شوند که در آن اطمینان از اینکه داده‌ها دستکاری نشده‌اند، مهم است، اما آنها معمولاً برای کمک به انتقال اطلاعات برای کمک به <em>authorization</em> (مجوز) استفاده می‌شوند.</p>
<p>هنگامی که امضا شد، <em>JWTs</em> (توکن‌های <em>JWT</em>) می‌توانند به راحتی از طریق انواع مختلفی از پروتکل‌ها منتقل شوند، و توکن‌ها را می‌توان به طور اختیاری طوری پیکربندی کرد که پس از یک دوره زمانی مشخص منقضی شوند. آنها به طور گسترده پشتیبانی می‌شوند، با تعدادی از <em>identity providers</em> (ارائه‌دهندگان هویت) که از تولید <em>JWTs</em> (توکن‌های <em>JWT</em>) پشتیبانی می‌کنند، و تعداد زیادی کتابخانه برای استفاده از <em>JWTs</em> (توکن‌های <em>JWT</em>) در داخل کد خود دارید.</p>
<p><em>382 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0408</div>
            </div>
        </div>
        <!-- Page 0409 -->
        <div class="chapter" id="page-0409">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>16 وب‌سایت <em>JWT</em> یک نمای کلی عالی از اینکه کدام کتابخانه‌ها از کدام <em>public claims</em> (ادعاهای عمومی) پشتیبانی می‌کنند، دارد—به طور کلی یک منبع عالی برای همه چیز <em>JWT</em> است.</p>
<h5>Format (قالب)</h5>
<p><em>payload</em> (بار) اصلی یک <em>JWT</em>، یک ساختار <em>JSON</em> است، که به طور کلی می‌تواند شامل هر چیزی باشد که شما می‌خواهید. ما می‌توانیم یک نمونه از توکن را در مثال 11-1 مشاهده کنیم. استاندارد <em>JWT</em> (توکن وب <em>JSON</em>) برخی از فیلدهای خاص نامگذاری شده ("<em>public claims</em>" (ادعاهای عمومی)) را توصیف می‌کند که شما باید در صورت مرتبط بودن از آنها استفاده کنید. به عنوان مثال، <em>exp</em> تاریخ انقضای یک توکن را تعریف می‌کند. اگر شما از این فیلدهای <em>public claim</em> (ادعای عمومی) به درستی استفاده کنید، احتمال زیادی وجود دارد که کتابخانه‌هایی که استفاده می‌کنید بتوانند به درستی از آنها استفاده کنند—به عنوان مثال، رد کردن یک توکن اگر فیلد <em>exp</em> (انقضا) نشان می‌دهد که توکن قبلاً منقضی شده است.16 حتی اگر شما از همه این <em>public claims</em> (ادعاهای عمومی) استفاده نکنید، آگاهی از اینکه آنها چه هستند ارزش دارد تا اطمینان حاصل کنید که در نهایت از آنها برای استفاده‌های خاص برنامه خود استفاده نمی‌کنید، زیرا این می‌تواند باعث ایجاد رفتارهای عجیبی در کتابخانه‌های پشتیبانی شود.</p>
<p>مثال 11-1. نمونه‌ای از <em>payload</em> (بار) <em>JSON</em> یک <em>JWT</em></p>
<p>{
    "sub": "123",
    "name": "Sam Newman",
    "exp": 1606741736,
    "groups": "admin, beta"
    }</p>
<p>در مثال 11-2، ما توکن را از مثال 11-1 رمزگذاری شده می‌بینیم. این توکن واقعاً فقط یک رشته واحد است، اما به سه قسمت تقسیم می‌شود که با "." مشخص شده‌اند—هدر، <em>payload</em> (بار)، و امضا.</p>
<p>مثال 11-2. نتیجه رمزگذاری یک <em>JWT payload</em> (بار JWT)</p>
<p>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
    eyJzdWIiOiIxMjMiLCJuYW1lIjoiU2FtIE5ld21hbiIsImV4cCI6MTYwNjc0MTczNiwiZ3J... .
    Z9HMH0DGs60I0P5bVVSFixeDxJjGovQEtlNUi__iE_0</p>
<p>هدر
    <em>payload</em> (بار) (کوتاه شده)
    امضا</p>
<p>برای استفاده از این مثال، من خط را در هر قسمت تقسیم کرده‌ام، اما در واقعیت این یک رشته واحد بدون شکستگی خط خواهد بود. هدر شامل اطلاعاتی در مورد <em>signing algorithm</em> (الگوریتم امضا) مورد استفاده است. این به برنامه‌ای که توکن را رمزگشایی می‌کند اجازه می‌دهد تا از طرح‌های امضای مختلف پشتیبانی کند. <em>payload</em> (بار) جایی است که ما اطلاعاتی در مورد</p>
<p><em>Authentication and Authorization | 383</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0409</div>
            </div>
        </div>
        <!-- Page 0410 -->
        <div class="chapter" id="page-0410">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>ادعاهایی که توکن ایجاد می‌کند—این فقط نتیجه رمزگذاری ساختار <em>JSON</em> در مثال 11-1 است. از امضا برای اطمینان از اینکه <em>payload</em> (بار) دستکاری نشده است استفاده می‌شود، و همچنین می‌توان از آن برای اطمینان از اینکه توکن توسط کسی که شما فکر می‌کنید، تولید شده است (با فرض اینکه توکن با یک کلید خصوصی امضا شده باشد) استفاده کرد.</p>
<p>به عنوان یک رشته ساده، این توکن را می‌توان به راحتی از طریق پروتکل‌های ارتباطی مختلف—به عنوان یک هدر در <em>HTTP</em> (در هدر <em>Authorization</em> (مجوز))، به عنوان مثال، یا شاید به عنوان یک قطعه <em>metadata</em> (فراداده) در یک پیام—منتقل کرد. البته این رشته رمزگذاری شده می‌تواند از طریق پروتکل انتقال رمزگذاری شده—به عنوان مثال <em>TLS</em> از طریق <em>HTTP</em>—ارسال شود، که در این صورت توکن برای افرادی که در حال مشاهده ارتباط هستند، قابل مشاهده نخواهد بود.</p>
<h5>Using tokens (استفاده از توکن‌ها)</h5>
<p>بیایید به یک روش رایج برای استفاده از توکن‌های <em>JWT</em> در یک معماری <em>microservice</em> (ریز سرویس) نگاهی بیندازیم.
    در شکل 11-9، مشتری ما به‌طور معمول وارد سیستم می‌شود، و پس از احراز هویت، ما نوعی توکن برای نشان دادن جلسه وارد شده آنها (احتمالاً یک توکن <em>OAuth</em>) تولید می‌کنیم، که در دستگاه <em>client</em> (کلاینت) ذخیره می‌شود. درخواست‌های بعدی از آن دستگاه <em>client</em> (کلاینت) به <em>gateway</em> (دروازه) ما می‌رسند، که یک توکن <em>JWT</em> تولید می‌کند که برای مدت زمان آن <em>request</em> (درخواست) معتبر خواهد بود. این توکن <em>JWT</em> است که سپس به <em>microservices</em> (ریز سرویس‌های) پایین‌دستی منتقل می‌شود.
    آنها قادر به تأیید توکن و استخراج ادعاها از <em>payload</em> (بار) هستند تا تعیین کنند که چه نوع <em>authorization</em> (مجوزی) مناسب است.</p>
<p>شکل 11-9. یک توکن <em>JWT</em> برای یک <em>request</em> (درخواست) خاص تولید می‌شود و به <em>microservices</em> (ریز سرویس‌های) پایین‌دستی منتقل می‌شود</p>
<p><em>384 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 410" src="page_0410/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0410</div>
            </div>
        </div>
        <!-- Page 0411 -->
        <div class="chapter" id="page-0411">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>یک تغییری در این رویکرد این است که یک توکن <em>JWT</em> را زمانی که کاربر در ابتدا خود را با سیستم احراز هویت می‌کند، ایجاد کنید و سپس آن توکن <em>JWT</em> را روی دستگاه <em>client</em> (کلاینت) ذخیره کنید. اما شایسته توجه است که چنین توکنی باید برای مدت زمان جلسه وارد شده معتبر باشد؛ همانطور که قبلاً بحث کردیم، ما می‌خواهیم مدت اعتبار <em>credentials</em> (اعتبارنامه‌های) تولید شده توسط سیستم را محدود کنیم تا شانس سوءاستفاده از آنها را کاهش دهیم، و تأثیر را در صورتی که ما نیاز به تغییر کلیدهایی داشته باشیم که برای تولید توکن رمزگذاری شده استفاده می‌شوند، کاهش دهیم. تولید یک توکن <em>JWT</em> بر اساس هر <em>request</em> (درخواست) به نظر می‌رسد رایج‌ترین راه‌حل برای این مشکل است، همانطور که در شکل 11-9 نشان می‌دهیم.</p>
<p>داشتن نوعی تبادل توکن که در <em>gateway</em> (دروازه) انجام می‌شود، همچنین می‌تواند اتخاذ استفاده از توکن‌های <em>JWT</em> را بدون نیاز به تغییر هیچ بخشی از جریان <em>authentication</em> (احراز هویت) که شامل ارتباط با دستگاه <em>client</em> (کلاینت) است، بسیار آسان‌تر کند—اگر شما قبلاً یک راه‌حل <em>SSO</em> (ورود به سیستم یکپارچه) در جای خود دارید، پنهان کردن این واقعیت که حتی از توکن‌های <em>JWT</em> استفاده می‌شود، از جریان احراز هویت اصلی کاربر، چنین تغییری را کم‌اثر می‌کند.</p>
<p>بنابراین با تولید توکن‌های <em>JWT</em> مناسب، <em>microservices</em> (ریز سرویس‌های) پایین‌دستی ما قادر هستند تمام اطلاعات مورد نیاز خود را برای تأیید هویت کاربری که <em>request</em> (درخواست) را انجام می‌دهد، و همچنین اطلاعات اضافی مانند گروه‌ها یا نقش‌هایی که آن کاربر در آن قرار دارد، دریافت کنند. اعتبار این توکن نیز می‌تواند توسط <em>microservice</em> (ریز سرویس) به سادگی با بررسی امضای توکن <em>JWT</em> تأیید شود. در مقایسه با راه‌حل‌های قبلی در این فضا (مانند ادعاهای <em>SAML</em> تو در تو)، توکن‌های <em>JWT</em> فرآیند <em>decentralizing authorization</em> (مجوزدهی غیرمتمرکز) در یک معماری <em>microservice</em> (ریز سرویس) را بسیار ساده‌تر کرده‌اند.</p>
<h5>Challenges (چالش‌ها)</h5>
<p>چندین مسئله در مورد توکن‌های <em>JWT</em> وجود دارد که ارزش توجه را دارد. اولین مورد مسئله کلیدها است. در مورد توکن‌های <em>JWT</em> امضا شده، برای تأیید یک امضا، دریافت‌کننده یک توکن <em>JWT</em> به مقداری اطلاعات نیاز دارد که باید خارج از <em>band</em> (باند) منتقل شود—معمولاً یک کلید عمومی. تمام مسائل مربوط به مدیریت کلید در این مورد اعمال می‌شود. <em>microservice</em> (ریز سرویس) چگونه کلید عمومی را دریافت می‌کند؟ اگر کلید عمومی نیاز به تغییر داشته باشد، چه اتفاقی می‌افتد؟ <em>Vault</em> نمونه‌ای از ابزاری است که می‌تواند توسط یک <em>microservice</em> (ریز سرویس) برای بازیابی (و مدیریت چرخش) کلیدهای عمومی استفاده شود، و قبلاً برای کار در یک محیط بسیار توزیع‌شده طراحی شده است. البته شما می‌توانید فقط یک کلید عمومی را در یک فایل پیکربندی برای <em>microservice</em> (ریز سرویس) دریافت‌کننده <em>hardcode</em> (کدنویسی) کنید، اما سپس شما با مشکل تغییر کلید عمومی مواجه خواهید شد.</p>
<p>ثانیاً، درست کردن انقضا برای یک توکن می‌تواند دشوار باشد اگر زمان پردازش طولانی درگیر باشد. موقعیتی را در نظر بگیرید که در آن یک مشتری سفارشی را ثبت کرده است.
    این یک سری از فرآیندهای ناهمزمان را آغاز می‌کند که می‌تواند ساعت‌ها اگر نه روزها طول بکشد، بدون هیچ‌گونه مشارکت بعدی از طرف مشتری (پرداخت، ارسال ایمیل‌های اطلاع‌رسانی، بسته‌بندی و ارسال کالا، و غیره). آیا شما باید یک توکن با مدت اعتبار منطبق تولید کنید؟ سؤال اینجاست که، در چه مرحله‌ای داشتن یک توکن با عمر طولانی‌تر، مشکل‌سازتر از نداشتن هیچ توکنی است؟ من با چند تیم صحبت کرده‌ام که با این مسئله سروکار داشته‌اند. برخی یک توکن ویژه با عمر طولانی‌تر تولید کرده‌اند که فقط در این زمینه خاص کار می‌کند؛ بقیه</p>
<p><em>Authentication and Authorization | 377</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0411</div>
            </div>
        </div>
        <!-- Page 0412 -->
        <div class="chapter" id="page-0412">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>17 <em>Laura Bell</em> et al., <em>Agile Application Security</em> (<em>Sebastopol</em>: <em>O’Reilly</em>, 2017).</p>
<p><em>have just stopped using the token at a certain point in the flow</em> (فقط استفاده از توکن را در یک نقطه خاص در جریان متوقف کنید). من هنوز به مثال‌های کافی از این مشکل نگاه نکرده‌ام تا راه‌حل درست را در اینجا مشخص کنم، اما این یک مسئله است که باید از آن آگاه بود.</p>
<p>در نهایت، در برخی از موقعیت‌ها شما می‌توانید به اطلاعات زیادی در توکن <em>JWT</em> نیاز داشته باشید، که اندازه توکن خود به یک مشکل تبدیل می‌شود. اگرچه این وضعیت نادر است، اما اتفاق می‌افتد. چند سال پیش من با یک تیم در مورد استفاده از یک توکن برای مدیریت <em>authorization</em> (مجوز) برای یک جنبه خاص از سیستم آنها که مدیریت حقوق را برای موسیقی انجام می‌داد، صحبت می‌کردم. منطق پیرامون این موضوع بسیار پیچیده بود—مشتری من مشخص کرد که برای هر آهنگ معین، ممکن است به 10000 ورودی در یک توکن برای مقابله با سناریوهای مختلف نیاز داشته باشد. اما ما متوجه شدیم که، حداقل در آن دامنه، فقط یک مورد استفاده خاص بود که به این مقدار زیاد اطلاعات نیاز داشت، در حالی که بخش عمده سیستم می‌توانست با یک توکن ساده با فیلدهای کمتر، کار کند.</p>
<p>در چنین شرایطی، منطقی بود که با فرآیند <em>authorization</em> (مجوز) مدیریت حقوق پیچیده‌تر به روشی متفاوت برخورد کنیم—اساساً با استفاده از توکن <em>JWT</em> برای <em>authorization</em> (مجوز) "ساده" اولیه، و سپس انجام یک جستجوی بعدی در یک انبار داده برای بازیابی فیلدهای اضافی در صورت نیاز. این بدان معنا بود که بخش عمده سیستم می‌توانست فقط بر اساس توکن‌ها کار کند.</p>
<h5>Summary (خلاصه)</h5>
<p>همانطور که امیدوارم در این فصل بیان کرده باشم، ساختن یک سیستم امن، به معنای انجام یک کار نیست. این مستلزم یک دیدگاه کل‌نگرانه از سیستم شما است، با استفاده از نوعی تمرین <em>threat modeling</em> (مدل‌سازی تهدید)، برای درک اینکه چه نوع کنترل‌های <em>security</em> (امنیت) باید در جای خود قرار گیرند.</p>
<p>هنگام فکر کردن به این کنترل‌ها، یک ترکیب برای ساختن یک سیستم امن ضروری است. <em>Defense in depth</em> (دفاع در عمق) فقط به معنای داشتن حفاظت‌های متعدد نیست؛ بلکه به این معنی است که شما یک رویکرد چند وجهی برای ساختن یک سیستم امن‌تر دارید.
    ما همچنین دوباره به یک موضوع اصلی کتاب باز می‌گردیم: داشتن یک سیستم تجزیه‌شده به سرویس‌های دقیق‌تر، گزینه‌های بیشتری را برای حل مشکلات به ما می‌دهد. نه تنها داشتن <em>microservices</em> (ریز سرویس‌ها) به‌طور بالقوه می‌تواند تأثیر هر نقض داده شده را کاهش دهد، بلکه به ما این امکان را می‌دهد که <em>trade-offs</em> (تبعات) بین سربار رویکردهای پیچیده‌تر و امن‌تر، که در آن داده‌ها حساس هستند، و یک رویکرد سبک‌تر، زمانی که خطرات کمتر است، را در نظر بگیریم.</p>
<p>برای نگاهی گسترده‌تر به <em>application security</em> (امنیت نرم‌افزار) به طور کلی، من <em>Agile Application Security</em> by <em>Laura Bell</em> و همکاران را توصیه می‌کنم.17</p>
<p>در مرحله بعد، ما به این موضوع خواهیم پرداخت که چگونه می‌توانیم سیستم‌های خود را قابل اطمینان‌تر کنیم، زیرا به موضوع <em>resilience</em> (مقاومت) می‌پردازیم.</p>
<p><em>386 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0412</div>
            </div>
        </div>
        <!-- Page 0413 -->
        <div class="chapter" id="page-0413">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>CHAPTER 12 (فصل 12)</h3>
<h4>Resiliency (مقاومت)</h4>
<p>از آنجایی که نرم‌افزار به طور فزاینده‌ای به بخش حیاتی از زندگی کاربران ما تبدیل می‌شود، ما باید به‌طور مداوم کیفیت خدماتی را که ارائه می‌دهیم، بهبود بخشیم. از کار افتادن نرم‌افزار می‌تواند تأثیر بسزایی در زندگی مردم داشته باشد، حتی اگر نرم‌افزار در دسته‌بندی "ایمنی حیاتی" به گونه‌ای که سیستم‌های کنترل هواپیما انجام می‌دهند، قرار نگیرد. در طول همه‌گیری <em>COVID-19</em>، که در زمان نگارش در حال انجام بود، خدماتی مانند خرید آنلاین مواد غذایی از یک آسایش به یک ضرورت برای بسیاری از افرادی تبدیل شد که قادر به ترک خانه‌های خود نبودند.</p>
<p>در برابر این پیش‌زمینه، ما اغلب با ایجاد نرم‌افزاری که بیشتر و بیشتر قابل اعتماد است، مواجه هستیم. انتظارات کاربران ما از نظر کاری که نرم‌افزار می‌تواند انجام دهد و زمانی که باید در دسترس باشد، تغییر کرده است. روزهایی که فقط نیاز به پشتیبانی از نرم‌افزار در ساعات اداری وجود داشت، به طور فزاینده‌ای نادر است، و تحمل خرابی به دلیل تعمیر و نگهداری، در حال کاهش است.</p>
<p>همانطور که در ابتدای این کتاب پوشش دادیم، دلایل زیادی وجود دارد که چرا معماری‌های <em>microservice</em> (ریز سرویس) توسط سازمان‌های سراسر جهان انتخاب می‌شوند. اما برای بسیاری از آنها، چشم‌انداز بهبود مقاومت ارائه‌های <em>service</em> (سرویس) آنها به عنوان یک دلیل اصلی ذکر می‌شود.</p>
<p>قبل از اینکه وارد جزئیات چگونگی فعال کردن <em>resiliency</em> (مقاومت) توسط یک معماری <em>microservice</em> (ریز سرویس) شویم، مهم است که به عقب برگردیم و در نظر بگیریم که <em>resiliency</em> (مقاومت) در واقع چیست. مشخص می‌شود که وقتی نوبت به بهبود <em>resiliency</em> (مقاومت) نرم‌افزار ما می‌رسد، اتخاذ یک معماری <em>microservice</em> (ریز سرویس) تنها بخشی از پازل است.</p>
<h5>What Is Resiliency? (مقاومت چیست؟)</h5>
<p>ما از اصطلاح <em>resiliency</em> (مقاومت) در زمینه‌های مختلف و به روش‌های مختلف استفاده می‌کنیم.
    این می‌تواند منجر به سردرگمی در مورد معنای این اصطلاح شود و همچنین می‌تواند منجر به این شود که ما در مورد این زمینه بیش از حد محدود فکر کنیم. در خارج از محدوده‌های <em>IT</em>، یک</p>
<p><em>387 | Chapter 11: Security</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0413</div>
            </div>
        </div>
        <!-- Page 0414 -->
        <div class="chapter" id="page-0414">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>1 <em>David D. Woods</em>, “<em>Four Concepts for Resilience and the Implications for the Future of Resilience Engineer</em>،<em>ing</em>,” <em>Reliability Engineering &amp; System Safety</em> 141 (<em>September</em> 2015): 5–9, doi.org/10.1016/j.ress.2015.03.018.</p>
<p>وسعت بیشتری از مهندسی مقاومت، که به مفهوم <em>resiliency</em> (مقاومت) در رابطه با مجموعه‌ای از سیستم‌ها—از آتش‌نشانی تا کنترل ترافیک هوایی، سیستم‌های بیولوژیکی، و اتاق‌های عمل—نگاه می‌کند. <em>David D. Woods</em> با استناد به این حوزه، تلاش کرده است تا جنبه‌های مختلف <em>resilience</em> (مقاومت) را طبقه‌بندی کند تا به ما کمک کند تا در مورد معنای واقعی <em>resiliency</em> (مقاومت) بیشتر فکر کنیم.1 این چهار مفهوم عبارتند از:</p>
<ul>
<li>Robustness (استحکام)</li>
<p>توانایی جذب اختلالات مورد انتظار</p>
<li>Rebound (بازگشت)</li>
<p>توانایی بازیابی پس از یک رویداد آسیب‌زا</p>
<li>Graceful extensibility (قابلیت توسعه با ظرافت)</li>
<p>اینکه ما با یک موقعیت غیرمنتظره چقدر خوب کنار می‌آییم</p>
<li>Sustained adaptability (سازگاری پایدار)</li>
<p>توانایی انطباق مداوم با محیط‌های در حال تغییر، ذینفعان و تقاضاها</p>
</ul>
<p>بیایید به نوبه خود به هر یک از این مفاهیم نگاه کنیم و بررسی کنیم که چگونه این ایده‌ها ممکن است (یا ممکن است) به دنیای ساخت معماری‌های <em>microservice</em> (ریز سرویس) ما ترجمه شوند.</p>
<h5>Robustness (استحکام)</h5>
<p><em>Robustness</em> (استحکام) مفهومی است که از طریق آن ما مکانیسم‌هایی را در نرم‌افزار و فرآیندهای خود ایجاد می‌کنیم تا مشکلات مورد انتظار را برطرف کنیم. ما درک پیشرفته‌ای از انواع اختلالاتی که ممکن است با آن مواجه شویم، داریم، و ما اقداماتی را انجام می‌دهیم تا وقتی این مسائل پیش می‌آیند، سیستم ما بتواند با آنها مقابله کند. در زمینه معماری <em>microservice</em> (ریز سرویس) ما، ما مجموعه‌ای از اختلالات را داریم که ممکن است انتظار داشته باشیم: یک میزبان می‌تواند شکست بخورد، اتصال شبکه می‌تواند منقضی شود، یک <em>microservice</em> (ریز سرویس) ممکن است در دسترس نباشد. ما می‌توانیم <em>robustness</em> (استحکام) معماری خود را به روش‌های مختلفی برای مقابله با این اختلالات بهبود بخشیم، مانند راه‌اندازی خودکار یک میزبان جایگزین، انجام <em>retries</em> (تلاش مجدد)، یا رسیدگی به شکست یک <em>microservice</em> (ریز سرویس) معین به شیوه‌ای ظریف.</p>
<p>با این حال، <em>Robustness</em> (استحکام) فراتر از نرم‌افزار می‌رود. این می‌تواند برای مردم نیز اعمال شود. اگر شما یک فرد در حال تماس برای نرم‌افزار خود دارید، اگر آن شخص بیمار شود یا در زمان وقوع یک حادثه در دسترس نباشد، چه اتفاقی می‌افتد؟ این یک چیز نسبتاً آسان برای در نظر گرفتن است، و راه‌حل ممکن است این باشد که یک فرد <em>on-call</em> (در حال تماس) پشتیبان داشته باشید.</p>
<p><em>Robustness</em> (استحکام) بر اساس تعریف، نیاز به دانش قبلی دارد—ما در حال انجام اقداماتی برای مقابله با اختلالات شناخته شده هستیم. این دانش می‌تواند بر اساس دوراندیشی باشد: ما می‌توانیم از درک خود از سیستم کامپیوتری که در حال ساخت آن هستیم،</p>
<p><em>388 | Chapter 12: Resiliency</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0414</div>
            </div>
        </div>
        <!-- Page 0415 -->
        <div class="chapter" id="page-0415">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>پشتیبانی از سرویس‌ها، و افراد ما برای در نظر گرفتن اینکه چه چیزی ممکن است اشتباه پیش برود. اما <em>robustness</em> (استحکام) می‌تواند از <em>hindsight</em> (گذشته‌نگری) نیز ناشی شود—ما ممکن است <em>robustness</em> (استحکام) سیستم خود را پس از وقوع چیزی که انتظارش را نداشتیم، بهبود بخشیم. شاید ما هرگز این واقعیت را در نظر نگرفتیم که <em>filesystem</em> (سیستم فایل) جهانی ما ممکن است غیرقابل دسترس شود، یا شاید ما تأثیر در دسترس نبودن نمایندگان خدمات مشتری خود را در خارج از ساعات کاری دست‌کم گرفتیم.</p>
<p>یکی از چالش‌ها در مورد بهبود <em>robustness</em> (استحکام) سیستم ما این است که با افزایش <em>robustness</em> (استحکام) برنامه خود، پیچیدگی بیشتری را به سیستم خود وارد می‌کنیم، که می‌تواند منبع مسائل جدید باشد. بیایید بگوییم شما در حال انتقال معماری <em>microservice</em> (ریز سرویس) خود به <em>Kubernetes</em> (کوبه‌رنتیس) هستید، زیرا شما می‌خواهید آن را برای مدیریت حالت دلخواه برای <em>microservice workloads</em> (بارهای کاری ریز سرویس) خود مدیریت کنید. در نتیجه، شما ممکن است برخی از جنبه‌های <em>robustness</em> (استحکام) برنامه خود را بهبود داده باشید، اما شما همچنین نقاط درد بالقوه جدیدی را نیز معرفی کرده‌اید. به این ترتیب، هر تلاشی برای بهبود <em>robustness</em> (استحکام) یک برنامه باید در نظر گرفته شود، نه فقط از نظر یک تجزیه و تحلیل ساده هزینه/فایده، بلکه از نظر اینکه آیا شما از سیستم پیچیده‌تری که در نتیجه این کار خواهید داشت، راضی هستید یا خیر.</p>
<p><em>Robustness</em> (استحکام) حوزه‌ای است که در آن <em>microservices</em> (ریز سرویس‌ها) مجموعه‌ای از گزینه‌ها را در اختیار شما قرار می‌دهند، و بخش زیادی از آنچه در این فصل می‌آید، بر روی کاری که می‌توانید در نرم‌افزار خود انجام دهید تا <em>robustness</em> (استحکام) سیستم را بهبود بخشید، متمرکز خواهد بود. فقط به یاد داشته باشید که این نه تنها یک جنبه از <em>resiliency</em> (مقاومت) به عنوان یک کل است، بلکه مجموعه‌ای از <em>robustness</em> (استحکام)های دیگر غیر مرتبط با نرم‌افزار نیز وجود دارد که ممکن است شما نیاز داشته باشید در نظر بگیرید.</p>
<h5>Rebound (بازگشت)</h5>
<p>اینکه ما چقدر خوب از اختلالات بازیابی می‌کنیم—<em>rebound</em> (بازگشت)—یک بخش کلیدی از ساخت یک سیستم مقاوم است. من خیلی اوقات می‌بینم که مردم وقت و انرژی خود را صرف تلاش برای حذف احتمال قطع شدن، می‌کنند، فقط برای اینکه پس از وقوع یک قطعی، کاملاً آماده نباشند. به هر وسیله‌ای، تمام تلاش خود را انجام دهید تا از چیزهای بدی که فکر می‌کنید ممکن است اتفاق بیفتد—<em>robustness</em> (استحکام) سیستم خود را بهبود بخشید—محافظت کنید، اما همچنین درک کنید که با افزایش مقیاس و پیچیدگی سیستم شما، حذف هر مشکل احتمالی غیرقابل تحمل می‌شود.</p>
<p>ما می‌توانیم توانایی خود را برای بازگشت از یک حادثه با قرار دادن چیزها در پیش، بهبود بخشیم. به عنوان مثال، داشتن <em>backups</em> (پشتیبان‌گیری) در محل می‌تواند به ما اجازه دهد تا در پی از دست رفتن داده‌ها بهتر بازگردیم (البته با فرض اینکه <em>backups</em> (پشتیبان‌گیری) ما آزمایش شده باشد!). بهبود توانایی ما برای بازگشت نیز می‌تواند شامل داشتن یک <em>playbook</em> (کتابچه راهنما) باشد که ما می‌توانیم در پی یک قطعی سیستم اجرا کنیم: آیا مردم می‌دانند که نقش آنها در هنگام وقوع یک قطعی چیست؟ چه کسی مسئول رسیدگی به این وضعیت خواهد بود؟ ما با چه سرعتی باید به کاربران خود اطلاع دهیم که چه اتفاقی در حال رخ دادن است؟ چگونه با کاربران خود ارتباط برقرار خواهیم کرد؟ تلاش برای فکر کردن واضح در مورد چگونگی رسیدگی به یک قطعی در حالی که قطعی در حال وقوع است، به دلیل استرس ذاتی و هرج و مرج موقعیت، مشکل‌ساز خواهد بود.</p>
<p><em>What Is Resiliency? | 389</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0415</div>
            </div>
        </div>
        <!-- Page 0416 -->
        <div class="chapter" id="page-0416">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>2 <em>Jason Bloomberg</em>, “<em>Innovation: The Flip Side of Resilience</em>,” <em>Forbes</em>, <em>September</em> 23, 2014, https://oreil.ly/avSmU.</p>
<p>داشتن یک برنامه اقدام توافق‌شده در پیش‌بینی این نوع مشکل می‌تواند به شما در بازگشت بهتر کمک کند.</p>
<h5>Graceful Extensibility (قابلیت توسعه با ظرافت)</h5>
<p>با <em>rebound</em> (بازگشت) و <em>robustness</em> (استحکام)، ما در درجه اول با موارد مورد انتظار سروکار داریم. ما مکانیسم‌هایی را برای مقابله با مشکلاتی که می‌توانیم پیش‌بینی کنیم، قرار می‌دهیم. اما وقتی غافلگیر می‌شویم چه اتفاقی می‌افتد؟ اگر ما برای غافلگیری—برای این واقعیت که دیدگاه مورد انتظار ما از جهان ممکن است اشتباه باشد—آماده نباشیم، در نهایت به یک سیستم شکننده می‌رسیم. همانطور که ما به محدودیت‌های آنچه انتظار داریم سیستم ما قادر به مدیریت آن باشد، نزدیک می‌شویم، همه چیز از هم می‌پاشد—ما قادر به انجام مناسب نیستیم.</p>
<p>سازمان‌های مسطح‌تر—که در آن مسئولیت به جای اینکه متمرکز باشد، در سازمان توزیع می‌شود—اغلب برای مقابله با غافلگیری بهتر آماده خواهند بود. وقتی غیرمنتظره رخ می‌دهد، اگر افراد در آنچه باید انجام دهند محدود شوند، اگر مجبور باشند به مجموعه‌ای سخت‌گیرانه از قوانین پایبند باشند، توانایی آنها در مقابله با غافلگیری به‌شدت کاهش می‌یابد.</p>
<p>اغلب، در یک تلاش برای بهینه‌سازی سیستم خود، ما می‌توانیم به عنوان یک اثر جانبی نامطلوب، شکنندگی سیستم خود را افزایش دهیم. <em>Automation</em> (خودکارسازی) را به عنوان مثال در نظر بگیرید. <em>Automation</em> (خودکارسازی) فوق‌العاده است—به ما این امکان را می‌دهد که با افرادی که داریم، کارهای بیشتری انجام دهیم، اما همچنین می‌تواند به ما اجازه دهد تا افرادی را که داریم، کاهش دهیم، زیرا کارهای بیشتری را می‌توان با <em>automation</em> (خودکارسازی) انجام داد. با این حال، این کاهش در کارکنان می‌تواند نگران‌کننده باشد. <em>Automation</em> (خودکارسازی) نمی‌تواند غافلگیری را مدیریت کند—توانایی ما در گسترش ظریف سیستممان، برای مقابله با غافلگیری، ناشی از داشتن افرادی در جای خود است که مهارت، تجربه و مسئولیت مناسب را برای رسیدگی به این موقعیت‌ها در صورت بروز، دارند.</p>
<h5>Sustained Adaptability (سازگاری پایدار)</h5>
<p>داشتن <em>sustained adaptability</em> (سازگاری پایدار) مستلزم آن است که ما از خود راضی نباشیم. همانطور که <em>David Woods</em> بیان می‌کند: "مهم نیست که قبلاً چقدر خوب عمل کرده‌ایم، مهم نیست که چقدر موفق بوده‌ایم، آینده می‌تواند متفاوت باشد، و ما ممکن است به خوبی سازگار نباشیم. ممکن است در مواجهه با آن آینده جدید، بی‌ثبات و شکننده باشیم."2 اینکه ما هنوز از یک قطعی فاجعه‌بار رنج نبرده‌ایم، به این معنی نیست که این اتفاق نمی‌افتد. ما باید خودمان را به چالش بکشیم تا اطمینان حاصل کنیم که ما به‌طور مداوم در حال تطبیق کارهایی که به عنوان یک سازمان انجام می‌دهیم هستیم تا <em>resiliency</em> (مقاومت) آینده را تضمین کنیم. اگر درست انجام شود، مفهومی مانند <em>chaos engineering</em> (مهندسی آشوب)—که ما در این فصل به طور مختصر بررسی خواهیم کرد—می‌تواند یک ابزار مفید در کمک به ایجاد <em>sustained adaptability</em> (سازگاری پایدار) باشد.</p>
<p><em>Sustained adaptability</em> (سازگاری پایدار) اغلب به یک دیدگاه جامع‌تر از سیستم نیاز دارد. این، به‌طور متناقض، جایی است که یک تلاش برای تیم‌های کوچک‌تر و مستقل با افزایش مسئولیت محلی و متمرکز می‌تواند با این کار به پایان برسد که ما دید خود را نسبت به تصویر بزرگ‌تر از دست می‌دهیم. همانطور که ما</p>
<p><em>390 | Chapter 12: Resiliency</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0416</div>
            </div>
        </div>
        <!-- Page 0417 -->
        <div class="chapter" id="page-0417">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>همانطور که ما در فصل 15 بررسی خواهیم کرد، یک عمل متعادل‌سازی بین بهینه‌سازی جهانی و محلی وجود دارد وقتی نوبت به پویایی سازمانی می‌رسد، و این تعادل ایستا نیست. در آن فصل، ما به نقش تیم‌های متمرکز و همراستا با جریان نگاه خواهیم کرد که مالک <em>microservices</em> (ریز سرویس‌هایی) هستند که برای ارائه عملکرد رو به کاربر به آنها نیاز دارند و سطح مسئولیت بیشتری برای تحقق این امر دارند. ما همچنین به نقش تیم‌های فعال‌کننده نگاه خواهیم کرد، که از این تیم‌های همراستا با جریان در انجام کار خود پشتیبانی می‌کنند، و به اینکه چگونه تیم‌های فعال‌کننده می‌توانند بخش بزرگی از کمک به دستیابی به سازگاری پایدار در سطح سازمانی باشند.</p>
<p>ایجاد فرهنگی که محیطی را که در آن افراد می‌توانند آزادانه اطلاعات را به اشتراک بگذارند، بدون ترس از تلافی، اولویت‌بندی می‌کند، برای تشویق یادگیری در پی یک حادثه، حیاتی است. داشتن پهنای باند برای بررسی واقعی چنین شگفتی‌هایی و استخراج یادگیری‌های کلیدی، زمان، انرژی و افراد را می‌طلبد—همه چیزهایی که منابع موجود برای ارائه ویژگی‌ها را در کوتاه‌مدت کاهش می‌دهد. تصمیم به پذیرش <em>sustained adaptability</em> (سازگاری پایدار) تا حدی به یافتن نقطه تعادل بین تحویل کوتاه‌مدت و سازگاری بلندمدت مربوط می‌شود.</p>
<p>کار برای دستیابی به <em>sustained adaptability</em> (سازگاری پایدار) به این معنی است که شما به دنبال کشف آنچه نمی‌دانید، هستید. این نیاز به سرمایه‌گذاری مداوم دارد، نه فعالیت‌های تراکنشی یک‌باره—اصطلاح <em>sustained</em> (پایدار) در اینجا مهم است. این در مورد تبدیل <em>sustained adaptability</em> (سازگاری پایدار) به بخشی اصلی از استراتژی و فرهنگ سازمانی شما است.</p>
<h5>And Microservice Architecture (و معماری Microservice)</h5>
<p>همانطور که بحث کردیم، ما می‌توانیم راهی را ببینیم که در آن یک معماری <em>microservice</em> (ریز سرویس) می‌تواند به ما در دستیابی به ویژگی <em>robustness</em> (استحکام) کمک کند، اما اگر شما <em>resiliency</em> (مقاومت) را می‌خواهید، کافی نیست.
    به‌طور کلی‌تر، توانایی ارائه <em>resiliency</em> (مقاومت) یک ویژگی نیست که متعلق به خود نرم‌افزار باشد، بلکه متعلق به افرادی است که سیستم را می‌سازند و اجرا می‌کنند. با توجه به تمرکز این کتاب، بخش زیادی از آنچه در این فصل می‌آید، در درجه اول بر روی آنچه یک معماری <em>microservice</em> (ریز سرویس) می‌تواند از نظر <em>resiliency</em> (مقاومت) ارائه دهد—که تقریباً به‌طور کامل به بهبود <em>robustness</em> (استحکام) برنامه‌ها محدود می‌شود، متمرکز خواهد بود.</p>
<h5>Failure Is Everywhere (شکست همه‌جا هست)</h5>
<p>ما درک می‌کنیم که ممکن است اوضاع اشتباه پیش برود. هارد دیسک‌ها می‌توانند از کار بیفتند. نرم‌افزار ما می‌تواند <em>crash</em> (خراب) شود. و همانطور که هر کسی که مغالطات محاسبات توزیع‌شده را خوانده باشد، می‌تواند به شما بگوید، شبکه غیرقابل اطمینان است. ما می‌توانیم تمام تلاش خود را انجام دهیم تا تلاش کنیم علل شکست را محدود کنیم، اما در یک مقیاس خاص، شکست اجتناب‌ناپذیر می‌شود. به عنوان مثال، هارد دیسک‌ها اکنون قابل اعتمادتر از همیشه هستند، اما در نهایت خراب می‌شوند. هرچه هارد دیسک‌های بیشتری داشته باشید، احتمال خرابی برای یک واحد جداگانه در هر روز معین بیشتر می‌شود؛ شکست در مقیاس به یک قطعیت آماری تبدیل می‌شود.</p>
<p><em>Failure Is Everywhere | 391</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0417</div>
            </div>
        </div>
        <!-- Page 0418 -->
        <div class="chapter" id="page-0418">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>3 برای کسب اطلاعات بیشتر در این مورد، به "<em>Google Uncloaks Once-Secret Server</em>" اثر <em>Stephen Shankland</em> مراجعه کنید، که شامل یک نمای کلی جالب از این است که چرا <em>Google</em> فکر می‌کند این رویکرد می‌تواند بر سیستم‌های <em>UPS</em> سنتی برتری داشته باشد.</p>
<p>حتی برای ما که در مقیاس‌های شدید فکر نمی‌کنیم، اگر ما امکان شکست را بپذیریم، بهتر خواهیم بود. به عنوان مثال، اگر ما بتوانیم شکست یک <em>microservice</em> (ریز سرویس) را به‌طور ظریف مدیریت کنیم، پس این نتیجه می‌شود که ما همچنین می‌توانیم ارتقاهای درون‌مکانی یک <em>service</em> (سرویس) را انجام دهیم، زیرا یک قطعی برنامه‌ریزی‌شده بسیار راحت‌تر از یک قطعی برنامه‌ریزی‌نشده قابل مدیریت است.</p>
<p>ما همچنین می‌توانیم کمی از زمان خود را صرف تلاش برای متوقف کردن اجتناب‌ناپذیر و کمی بیشتر از زمان خود را صرف برخورد ظریف با آن کنیم. من از اینکه چقدر سازمان‌ها فرآیندها و کنترل‌ها را برای تلاش برای جلوگیری از وقوع شکست قرار می‌دهند، شگفت‌زده هستم، اما در وهله اول فکر کمی در مورد آسان‌تر کردن بازیابی از شکست نمی‌کنند.</p>
<p>درک چیزهایی که احتمالاً شکست می‌خورند، برای بهبود <em>robustness</em> (استحکام) سیستم ما، کلیدی است.</p>
<p>در نظر گرفتن این فرض که همه چیز می‌تواند و خواهد شکست، شما را به سمت تفکر متفاوت در مورد چگونگی حل مشکلات سوق می‌دهد. داستان سرورهای گوگل را که در فصل 10 در مورد آنها بحث کردیم، به یاد دارید؟ سیستم‌های گوگل به گونه‌ای ساخته شده بودند که اگر یک دستگاه شکست می‌خورد، منجر به اختلال در <em>service</em> (سرویس) نمی‌شد—<em>robustness</em> (استحکام) سیستم را به عنوان یک کل بهبود می‌بخشید. گوگل در تلاش برای بهبود <em>robustness</em> (استحکام) سرورهای خود به روش‌های دیگری نیز پیش می‌رود—در مورد اینکه چگونه هر سرور حاوی منبع تغذیه محلی خود است بحث کرده است تا اطمینان حاصل کند که می‌تواند در صورت قطعی مرکز داده، به کار خود ادامه دهد.3 همانطور که از فصل 10 به یاد خواهید آورد، درایوهای سخت در این سرورها به جای پیچ با ولکرو متصل شده بودند تا تعویض درایوها آسان شود—و به گوگل کمک می‌کرد تا دستگاه را به سرعت راه‌اندازی و اجرا کند، زمانی که یک درایو شکست خورد، و به نوبه خود به این کمک می‌کرد که آن مؤلفه سیستم، مؤثرتر بازیابی شود.</p>
<p>بنابراین اجازه دهید تکرار کنم: در مقیاس، حتی اگر بهترین کیت، گران‌ترین سخت‌افزار را بخرید، نمی‌توانید از این واقعیت اجتناب کنید که چیزها می‌توانند و خواهند شکست. بنابراین، شما باید فرض کنید که شکست می‌تواند رخ دهد. اگر شما این تفکر را در هر کاری که انجام می‌دهید ایجاد کنید و برای شکست برنامه‌ریزی کنید، شما می‌توانید <em>trade-offs</em> (تبعات) آگاهانه را انجام دهید. اگر شما می‌دانید که سیستم شما می‌تواند این واقعیت را که یک سرور می‌تواند و خواهد شکست، مدیریت کند، ممکن است بازدهی کاهشی از صرف پول بیشتر و بیشتر روی ماشین‌های جداگانه وجود داشته باشد. در عوض، داشتن تعداد بیشتری از ماشین‌های ارزان‌تر (شاید با استفاده از اجزای ارزان‌تر و مقداری ولکرو!) مانند گوگل، ممکن است بسیار منطقی‌تر باشد.</p>
<h5>How Much Is Too Much? (چقدر زیاد است؟)</h5>
<p>ما در فصل 9 به موضوع الزامات <em>cross-functional</em> (چند منظوره) اشاره کردیم. درک الزامات <em>cross-functional</em> (چند منظوره) در مورد در نظر گرفتن جنبه‌هایی مانند دوام داده‌ها، در دسترس بودن <em>services</em> (سرویس‌ها)، توان عملیاتی و تأخیر قابل قبول عملیات است. بسیاری از تکنیک‌های پوشش داده شده در این فصل در مورد رویکردهایی برای پیاده‌سازی این</p>
<p><em>392 | Chapter 12: Resiliency</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0418</div>
            </div>
        </div>
        <!-- Page 0419 -->
        <div class="chapter" id="page-0419">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>الزامات، اما فقط شما دقیقاً می‌دانید که خود الزامات چه می‌توانند باشند.
    بنابراین، هنگام مطالعه، الزامات خود را در نظر داشته باشید.</p>
<p>داشتن یک سیستم مقیاس‌بندی خودکار که قادر به واکنش به افزایش بار یا خرابی گره‌های جداگانه باشد، ممکن است فوق‌العاده باشد، اما می‌تواند برای یک سیستم گزارش‌دهی که فقط نیاز دارد دو بار در ماه اجرا شود، زیاده‌روی باشد، جایی که از کار افتادن برای یک یا دو روز آن‌قدر هم مهم نیست. به همین ترتیب، فهمیدن نحوه انجام استقرار با <em>zero-downtime</em> (خاموشی صفر) برای از بین بردن اختلال در <em>service</em> (سرویس) ممکن است برای سیستم <em>ecommerce</em> (تجارت الکترونیک) آنلاین شما منطقی باشد، اما برای پایگاه دانش اینترانت شرکت شما، احتمالاً یک گام فراتر از حد است.</p>
<p>اینکه چقدر شکست را می‌توان تحمل کرد یا سیستم شما با چه سرعتی باید کار کند، توسط کاربران سیستم شما هدایت می‌شود. آن اطلاعات به نوبه خود به شما کمک می‌کند تا بفهمید کدام تکنیک‌ها برای شما منطقی‌تر خواهد بود. با این حال، کاربران شما همیشه قادر به بیان الزامات دقیق خود نخواهند بود. بنابراین شما باید سوالاتی را بپرسید تا به استخراج اطلاعات صحیح کمک کنید و به آنها کمک کنید تا هزینه‌های نسبی ارائه سطوح مختلف <em>service</em> (سرویس) را درک کنند.</p>
<p>همانطور که قبلاً ذکر کردم، این الزامات <em>cross-functional</em> (چند منظوره) می‌توانند از <em>service</em> (سرویس) به <em>service</em> (سرویس) دیگر متفاوت باشند، اما من پیشنهاد می‌کنم که برخی از <em>cross-functionals</em> (چند منظوره)های کلی را تعریف کنید و سپس آنها را برای موارد استفاده خاص، لغو کنید. وقتی نوبت به این می‌رسد که در نظر بگیرید که آیا و چگونه سیستم خود را مقیاس‌بندی کنید تا بار یا خرابی را بهتر مدیریت کنید، با تلاش برای درک الزامات زیر شروع کنید:</p>
<ul>
<li>Response time/latency (زمان پاسخ/تاخیر)</li>
<p>انجام عملیات‌های مختلف چقدر باید طول بکشد؟ اندازه‌گیری این مورد با تعداد متفاوتی از کاربران می‌تواند مفید باشد تا درک شود که چگونه افزایش بار بر زمان پاسخ تأثیر می‌گذارد. با توجه به ماهیت شبکه‌ها، شما همیشه <em>outliers</em> (دورافتاده‌ها) را خواهید داشت، بنابراین تنظیم اهداف برای یک <em>percentile</em> (صدک) معین از پاسخ‌های نظارت‌شده می‌تواند مفید باشد. این هدف همچنین باید شامل تعداد اتصالات همزمان/کاربرانی باشد که شما انتظار دارید نرم‌افزار شما آنها را مدیریت کند. بنابراین شما ممکن است بگویید، "ما انتظار داریم وب‌سایت دارای زمان پاسخ در <em>90th-percentile</em> (صدک 90) از 2 ثانیه باشد در حالی که 200 اتصال همزمان در ثانیه را مدیریت می‌کند."</p>
<li>Availability (در دسترس بودن)</li>
<p>آیا شما انتظار دارید که یک <em>service</em> (سرویس) از کار بیفتد؟ آیا این یک <em>service</em> (سرویس) 24/7 در نظر گرفته می‌شود؟ برخی از مردم دوست دارند در هنگام اندازه‌گیری <em>availability</em> (در دسترس بودن)، به دوره‌های خرابی قابل قبول نگاه کنند، اما این برای کسی که <em>service</em> (سرویس) شما را فراخوانی می‌کند چقدر مفید است؟ یا من باید بتوانم به پاسخگویی <em>service</em> (سرویس) شما تکیه کنم یا نباید. اندازه‌گیری دوره‌های خرابی واقعاً از منظر گزارش‌دهی تاریخی مفیدتر است.</p>
<li>Durability of data (ماندگاری داده‌ها)</li>
<p>چقدر از دست رفتن داده‌ها قابل قبول است؟ داده‌ها چه مدت باید نگهداری شوند؟ این احتمالاً بر اساس هر مورد، تغییر خواهد کرد. به عنوان مثال، شما ممکن است انتخاب کنید که لاگ‌های جلسه کاربر را به مدت یک سال یا کمتر برای صرفه‌جویی در فضا نگه دارید، اما سوابق تراکنش‌های مالی شما ممکن است نیاز به نگهداری برای سال‌های زیادی داشته باشد.</p>
</ul>
<p><em>How Much Is Too Much? | 393</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0419</div>
            </div>
        </div>
        <!-- Page 0420 -->
        <div class="chapter" id="page-0420">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>تبدیل این ایده‌ها و بیان آنها به عنوان <em>service-level objectives</em> (SLOs) (اهداف سطح سرویس)، که ما در فصل 10 پوشش دادیم، می‌تواند راه خوبی برای تثبیت این الزامات به عنوان یک بخش اصلی از فرآیند تحویل نرم‌افزار شما باشد.</p>
<h5>Degrading Functionality (کاهش عملکرد)</h5>
<p>یک بخش ضروری از ساخت یک سیستم مقاوم، به‌ویژه زمانی که عملکرد شما بر روی تعدادی از <em>microservices</em> (ریز سرویس‌های) مختلف پخش می‌شود که ممکن است بالا یا پایین باشند، توانایی کاهش ایمن عملکرد است. بیایید یک صفحه وب استاندارد را در سایت <em>ecommerce</em> (تجارت الکترونیک) خود تصور کنیم. برای جمع‌آوری قسمت‌های مختلف آن وب‌سایت، ممکن است به چندین <em>microservices</em> (ریز سرویس) نیاز داشته باشیم که نقشی ایفا کنند. یک <em>microservice</em> (ریز سرویس) ممکن است جزئیات مربوط به کالای ارائه شده برای فروش را نمایش دهد. دیگری ممکن است قیمت و سطح موجودی را نشان دهد. و ما احتمالاً محتویات سبد خرید را نیز نشان می‌دهیم، که ممکن است <em>microservice</em> (ریز سرویس) دیگری باشد. اگر یکی از آن سرویس‌ها از کار بیفتد، و این منجر به غیرقابل دسترس بودن کل صفحه وب شود، پس ما قطعاً سیستمی ساخته‌ایم که مقاومت کمتری نسبت به سیستمی دارد که فقط به یک سرویس برای در دسترس بودن نیاز دارد.</p>
<p>کاری که ما باید انجام دهیم این است که تأثیر هر قطعی را درک کنیم و دریابیم که چگونه می‌توانیم عملکرد را به درستی کاهش دهیم. از دیدگاه تجاری، ما می‌خواهیم جریان کاری سفارش‌گیری ما تا حد امکان قوی باشد، و ما ممکن است خوشحال باشیم که مقداری کاهش عملکرد را بپذیریم تا اطمینان حاصل کنیم که این هنوز هم کار می‌کند. اگر سطوح موجودی در دسترس نباشد، ما ممکن است تصمیم بگیریم که همچنان به فروش ادامه دهیم و جزئیات را بعداً مشخص کنیم. اگر <em>microservice</em> (ریز سرویس) سبد خرید در دسترس نباشد، ما احتمالاً در مشکلات زیادی هستیم، اما ما هنوز هم می‌توانیم صفحه وب را با فهرست نمایش دهیم. شاید ما فقط سبد خرید را پنهان کنیم یا آن را با یک نماد جایگزین کنیم که می‌گوید "به زودی برمی‌گردم!"</p>
<p>با یک <em>application</em> (برنامه) <em>monolithic</em> (یکپارچه) تک فرآیندی، ما تصمیمات زیادی برای گرفتن نداریم. سلامت سیستم، تا حدی، در این زمینه باینری است—فرآیند یا بالا است یا پایین. اما با یک معماری <em>microservice</em> (ریز سرویس)، ما باید یک موقعیت بسیار ظریف‌تری را در نظر بگیریم. کار درست در هر شرایطی اغلب یک تصمیم فنی نیست. ما ممکن است بدانیم که از نظر فنی وقتی سبد خرید از کار می‌افتد چه چیزی ممکن است، اما تا زمانی که زمینه کسب‌وکار را درک نکنیم، متوجه نخواهیم شد که چه اقدامی باید انجام دهیم. به عنوان مثال، شاید ما کل سایت را تعطیل کنیم، همچنان به مردم اجازه دهیم که کاتالوگ اقلام را مرور کنند، یا قسمت رابط کاربری حاوی کنترل سبد را با یک شماره تلفن برای ثبت سفارش جایگزین کنیم. اما برای هر <em>interface</em> (رابط) رو به مشتری که از <em>microservices</em> (ریز سرویس‌های) متعدد استفاده می‌کند، یا هر <em>microservice</em> (ریز سرویسی) که به همکاران متعدد پایین‌دستی بستگی دارد، شما باید از خودتان بپرسید، "اگر این از کار بیفتد چه اتفاقی می‌افتد؟" و بدانید چه کاری باید انجام دهید.</p>
<p>با فکر کردن به اهمیت هر یک از قابلیت‌های ما از نظر الزامات <em>cross-functional</em> (چند منظوره) ما، ما در موقعیت بسیار بهتری قرار خواهیم گرفت تا بدانیم چه کاری می‌توانیم انجام دهیم.
    اکنون بیایید به برخی از کارهایی که می‌توانیم از دیدگاه فنی انجام دهیم تا اطمینان حاصل کنیم که وقتی شکست رخ می‌دهد، می‌توانیم آن را به‌طور ظریف مدیریت کنیم، بپردازیم.</p>
<p><em>394 | Chapter 12: Resiliency</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0420</div>
            </div>
        </div>
        <!-- Page 0421 -->
        <div class="chapter" id="page-0421">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h5>Stability Patterns (الگوهای پایداری)</h5>
<p>چندین الگو وجود دارد که ما می‌توانیم از آنها استفاده کنیم تا اطمینان حاصل کنیم که اگر مشکلی پیش بیاید، اثرات بدی را ایجاد نمی‌کند. درک این ایده‌ها ضروری است، و شما باید به‌شدت استفاده از آنها را در سیستم خود در نظر بگیرید تا اطمینان حاصل کنید که یک <em>bad citizen</em> (شهروند بد) تمام دنیا را به دور گوش شما فرو نمی‌ریزد.
    در یک لحظه، ما به چند اقدام ایمنی کلیدی که باید در نظر بگیرید، نگاهی خواهیم انداخت، اما قبل از آن، من می‌خواهم یک داستان کوتاه را به اشتراک بگذارم تا نوع مشکلی را که می‌تواند اشتباه پیش برود، نشان دهم.</p>
<p>سال‌ها پیش، من سرپرست فنی یک پروژه برای <em>AdvertCorp</em> بودم. <em>AdvertCorp</em> (نام شرکت و جزئیات تغییر یافته است تا از بی‌گناهان محافظت شود!) تبلیغات طبقه‌بندی‌شده آنلاین را از طریق یک وب‌سایت بسیار محبوب ارائه می‌کرد. خود وب‌سایت حجم‌های نسبتاً بالایی را مدیریت می‌کرد و درآمد خوبی را برای کسب‌وکار ایجاد می‌کرد. پروژه ای که من روی آن کار می‌کردم، وظیفه ادغام تعدادی از <em>services</em> (سرویس‌های) موجود را داشت که برای ارائه عملکرد مشابه برای انواع مختلف تبلیغات استفاده می‌شد. عملکرد موجود برای انواع مختلف تبلیغات به‌آرامی به سیستم جدیدی که ما در حال ساخت آن بودیم، منتقل می‌شد، و تعدادی از انواع مختلف تبلیغات هنوز از <em>services</em> (سرویس‌های) قدیمی‌تر ارائه می‌شد. برای اینکه این انتقال برای مشتری نهایی شفاف باشد، ما تمام فراخوانی‌ها را به انواع مختلف تبلیغات در سیستم جدید خود رهگیری کردیم و آنها را در صورت نیاز به سیستم‌های قدیمی هدایت کردیم، همانطور که در شکل 12-1 نشان داده شده است. این در واقع نمونه‌ای از یک الگوی انجیر خفه کننده است، که ما به طور خلاصه در "Useful Decompositional Patterns" در صفحه 79 در مورد آن بحث کردیم.</p>
<p>شکل 12-1. یک الگوی انجیر خفه کننده که برای هدایت فراخوانی‌ها به سیستم‌های قدیمی‌تر استفاده می‌شود</p>
<p>ما به تازگی محصول با بالاترین حجم و بزرگترین درآمد را به سیستم جدید منتقل کرده بودیم، اما بخش زیادی از بقیه تبلیغات هنوز توسط تعدادی از برنامه‌های قدیمی‌تر ارائه می‌شد. از نظر تعداد جستجوها و پولی که توسط این برنامه‌ها به دست می‌آمد، یک <em>long tail</em> (دنباله طولانی) وجود داشت—بسیاری از این برنامه‌های قدیمی ترافیک کمی دریافت می‌کردند و درآمد کمی ایجاد می‌کردند. سیستم جدید</p>
<p><em>Stability Patterns | 395</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 421" src="page_0421/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0421</div>
            </div>
        </div>
        <!-- Page 0422 -->
        <div class="chapter" id="page-0422">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>مدت زمانی زنده بود و به‌خوبی رفتار می‌کرد، و بار قابل توجهی را مدیریت می‌کرد. در آن زمان ما باید حدود 6000–7000 <em>request</em> (درخواست) در ثانیه در زمان اوج را مدیریت می‌کردیم، و اگرچه بیشتر آن توسط <em>reverse proxies</em> (پراکسی‌های معکوس) که در جلوی سرورهای <em>application</em> (برنامه) ما قرار داشتند، بسیار <em>cached</em> (کش) شده بود، جستجوها برای محصولات (مهمترین جنبه سایت) بیشتر <em>uncached</em> (کش‌نشده) بودند و به یک <em>server round trip</em> (رفت و برگشت کامل سرور) نیاز داشتند.</p>
<p>صبح یک روز، درست قبل از اینکه به اوج ناهار روزانه خود برسیم، سیستم شروع به رفتار کند کرد، و سپس شروع به شکست کرد. ما مقداری نظارت روی <em>application</em> (برنامه) اصلی جدید خود داشتیم، به اندازه‌ای که به ما بگوید که هر یک از گره‌های <em>application</em> (برنامه) ما به یک <em>CPU spike</em> (افزایش ناگهانی <em>CPU</em>) 100٪ می‌رسید، که بسیار بالاتر از سطوح عادی حتی در اوج بود. در یک بازه زمانی کوتاه، کل سایت از کار افتاد.</p>
<p>ما موفق شدیم مقصر را ردیابی کنیم و سایت را دوباره راه‌اندازی کنیم. مشخص شد که این یکی از سیستم‌های تبلیغاتی پایین‌دستی است، که برای این مطالعه موردی ناشناس، ما می‌گوییم مسئول تبلیغات مربوط به <em>turnip</em> (شلغم) بود. <em>Turnip ad service</em> (سرویس تبلیغات شلغم)، یکی از قدیمی‌ترین و کم‌فعال‌ترین <em>services</em> (سرویس‌ها)، شروع به پاسخگویی بسیار کند کرد.</p>
<p>پاسخگویی بسیار کند یکی از بدترین حالت‌های شکست است که شما می‌توانید تجربه کنید. اگر یک سیستم فقط وجود نداشته باشد، شما خیلی سریع متوجه می‌شوید. وقتی فقط کند است، شما در نهایت مدتی منتظر می‌مانید قبل از اینکه تسلیم شوید—این فرآیند انتظار می‌تواند کل سیستم را کند کند، باعث ایجاد <em>resource contention</em> (رقابت بر سر منابع) شود، و، همانطور که در مورد ما اتفاق افتاد، منجر به یک شکست آبشاری شود. اما هر چه علت شکست باشد، ما سیستمی ایجاد کرده بودیم که در برابر یک مشکل پایین‌دستی که باعث شکست در سراسر سیستم می‌شود، آسیب‌پذیر بود. یک <em>service</em> (سرویس) پایین‌دستی، که ما کنترل کمی روی آن داشتیم، توانست کل سیستم ما را از کار بیاندازد.</p>
<p>در حالی که یک تیم به مشکلات مربوط به سیستم شلغم نگاه می‌کرد، بقیه ما شروع به بررسی آنچه در <em>application</em> (برنامه) ما اشتباه پیش رفته بود، کردیم. ما چند مشکل پیدا کردیم، که در شکل 12-2 توضیح داده شده است. ما از یک <em>HTTP connection pool</em> (استخر اتصال <em>HTTP</em>) برای مدیریت اتصالات پایین‌دستی خود استفاده می‌کردیم. <em>threads</em> (رشته‌ها) در خود استخر، <em>time-outs</em> (مهلت زمانی) برای مدت زمانی که منتظر می‌ماندند در هنگام برقراری تماس <em>HTTP</em> پایین‌دستی، تنظیم شده بودند، که خوب است.
    مشکل این بود که کارگران همگی مدتی طول می‌کشید تا به دلیل <em>service</em> (سرویس) کند پایین‌دستی، منقضی شوند. در حالی که آنها منتظر بودند، <em>requests</em> (درخواست‌های) بیشتری به استخر رفتند و <em>worker threads</em> (رشته‌های کاری) را درخواست کردند. با عدم وجود کارگران در دسترس، این <em>requests</em> (درخواست‌ها) خودشان آویزان شدند. مشخص شد که کتابخانه استخر اتصال که ما استفاده می‌کردیم، یک <em>time-out</em> (مهلت زمانی) برای انتظار کارگران داشت، اما این به‌طور پیش‌فرض غیرفعال بود! این منجر به تجمع عظیمی از <em>blocked threads</em> (رشته‌های مسدود شده) شد. <em>Application</em> (برنامه) ما معمولاً در هر زمان معین، 40 اتصال همزمان داشت.
    در عرض پنج دقیقه، این وضعیت باعث شد که ما حدود 800 اتصال را به اوج برسانیم و سیستم را از کار بیندازیم.</p>
<p><em>396 | Chapter 12: Resiliency</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0422</div>
            </div>
        </div>
        <!-- Page 0423 -->
        <div class="chapter" id="page-0423">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>شکل 12-2. شرحی از مسائل ایجاد شده که باعث قطعی شدند</p>
<p>بدتر اینکه، <em>service</em> (سرویس) پایین‌دستی که ما با آن صحبت می‌کردیم، عملکردی را نشان می‌داد که کمتر از 5٪ از پایگاه مشتریان ما استفاده می‌کردند، و حتی درآمد کمتری نسبت به آن ایجاد می‌کرد. وقتی به این موضوع می‌رسید، ما به روش سخت فهمیدیم که سیستم‌هایی که فقط کند عمل می‌کنند، مدیریت آنها بسیار سخت‌تر از سیستم‌هایی است که فقط سریع شکست می‌خورند. در یک سیستم توزیع‌شده، تأخیر کشنده است.</p>
<p>حتی اگر ما <em>time-outs</em> (مهلت زمانی) را در استخر به‌درستی تنظیم کرده بودیم، ما همچنین یک <em>HTTP connection pool</em> (استخر اتصال <em>HTTP</em>) واحد را برای همه <em>outbound requests</em> (درخواست‌های خروجی) به اشتراک گذاشته بودیم. این به این معنی بود که یک <em>service</em> (سرویس) کند پایین‌دستی می‌توانست به تنهایی تعداد کارگران موجود را تمام کند، حتی اگر بقیه موارد سالم بودند. در نهایت، به دلیل <em>time-outs</em> (مهلت زمانی) و خطاهای مکرر، مشخص بود که <em>service</em> (سرویس) پایین‌دستی مورد نظر سالم نیست، اما با وجود این، ما همچنان ترافیک را به سمت آن ارسال می‌کردیم. در شرایط ما، این به این معنی بود که ما در واقع داشتیم یک وضعیت بد را بدتر می‌کردیم، زیرا <em>service</em> (سرویس) پایین‌دستی هیچ شانسی برای بازیابی نداشت. ما در نهایت سه اصلاحیه را برای جلوگیری از این اتفاق دوباره، اجرا کردیم: درست کردن <em>time-outs</em> (مهلت زمانی) ما، پیاده‌سازی <em>bulkheads</em> (دیواره‌ها) برای جدا کردن استخرهای اتصال مختلف، و پیاده‌سازی یک <em>circuit breaker</em> (مدار شکن) برای جلوگیری از ارسال تماس‌ها به یک سیستم ناسالم در وهله اول.</p>
<h5>Time-Outs (مهلت زمانی)</h5>
<p><em>Time-outs</em> (مهلت زمانی) آسان هستند که نادیده گرفته شوند، اما در یک سیستم توزیع‌شده، درست انجام دادن آنها مهم است. قبل از اینکه من باید از یک فراخوانی به یک <em>service</em> (سرویس) پایین‌دستی دست بکشم، چقدر می‌توانم صبر کنم؟ اگر شما خیلی طولانی صبر کنید تا تصمیم بگیرید که یک تماس شکست خورده است، شما می‌توانید کل سیستم را کند کنید. خیلی سریع <em>time out</em> (منقضی) کنید، و شما یک تماس را که ممکن است کار کرده باشد، به عنوان ناموفق در نظر خواهید گرفت. اگر اصلاً <em>time-outs</em> (مهلت زمانی) نداشته باشید، و یک <em>service</em> (سرویس) پایین‌دستی از کار افتاده باشد، می‌تواند کل سیستم شما را متوقف کند.</p>
<p><em>Stability Patterns | 397</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 423" src="page_0423/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0423</div>
            </div>
        </div>
        <!-- Page 0424 -->
        <div class="chapter" id="page-0424">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>در مورد <em>AdvertCorp</em>، ما دو مسئله مرتبط با <em>time-out</em> (مهلت زمانی) داشتیم. اولاً، ما یک <em>time-out</em> (مهلت زمانی) از دست رفته در استخر <em>HTTP request</em> (درخواست <em>HTTP</em>) داشتیم، به این معنی که هنگام درخواست از یک کارگر برای ایجاد یک <em>HTTP request</em> (درخواست <em>HTTP</em>) پایین‌دستی، <em>request thread</em> (رشته درخواست) برای همیشه مسدود می‌شد تا زمانی که یک کارگر در دسترس قرار گیرد. ثانیاً، هنگامی که ما در نهایت یک کارگر <em>HTTP</em> در دسترس برای برقراری یک <em>request</em> (درخواست) به سیستم تبلیغات شلغم داشتیم، ما مدت زیادی صبر می‌کردیم قبل از اینکه از تماس دست بکشیم. بنابراین همانطور که شکل 12-3 نشان می‌دهد، ما باید یک <em>time-out</em> (مهلت زمانی) جدید اضافه کنیم و یک مورد موجود را تغییر دهیم.</p>
<p>شکل 12-3. تغییر <em>time-outs</em> (مهلت زمانی) در سیستم <em>AdvertCorp</em></p>
<p><em>Time-outs</em> (مهلت زمانی) برای <em>HTTP requests</em> (درخواست‌های HTTP) پایین‌دستی، 30 ثانیه تنظیم شده بود—بنابراین ما 30 ثانیه منتظر پاسخ از سیستم شلغم می‌ماندیم قبل از اینکه تسلیم شویم. مسئله این است که در زمینه وسیع‌تری که این تماس در حال انجام بود، انتظار این مدت طولانی، منطقی نبود. تبلیغات مربوط به شلغم در نتیجه یکی از کاربران ما که با استفاده از یک مرورگر به وب‌سایت ما نگاه می‌کرد، درخواست می‌شد. حتی در زمانی که این اتفاق افتاد، هیچ‌کس 30 ثانیه منتظر بارگذاری یک صفحه نشد. به آنچه اتفاق می‌افتد فکر کنید اگر یک صفحه وب بعد از 5، 10 یا شاید 15 ثانیه بارگیری نشود. چه کار می‌کنید؟ شما صفحه را <em>refresh</em> (بازخوانی) می‌کنید. بنابراین ما 30 ثانیه منتظر ماندیم تا سیستم تبلیغات شلغم پاسخ دهد، اما خیلی قبل از آن <em>request</em> (درخواست) اصلی دیگر معتبر نبود زیرا کاربر به‌تازگی آن را <em>refresh</em> (بازخوانی) کرده بود، که باعث شد یک <em>request</em> (درخواست) ورودی اضافی ایجاد شود. این به نوبه خود باعث شد <em>request</em> (درخواست) دیگری برای سیستم تبلیغات وارد شود، و به همین ترتیب ادامه یافت.</p>
<p>هنگام نگاه کردن به رفتار عادی سیستم تبلیغات شلغم، ما می‌توانستیم ببینیم که ما معمولاً انتظار پاسخ را در کمتر از یک ثانیه داشتیم، بنابراین انتظار 30 ثانیه زیاده‌روی بود. علاوه بر این، ما یک هدف داشتیم که یک صفحه را در عرض 4–6 ثانیه به کاربر ارائه کنیم. بر اساس این، ما <em>time-out</em> (مهلت زمانی) را بسیار تهاجمی‌تر کردیم و آن را به 1 ثانیه تنظیم کردیم. ما همچنین یک <em>time-out</em> (مهلت زمانی) 1 ثانیه‌ای را برای انتظار یک کارگر <em>HTTP</em> قرار دادیم تا</p>
<p><em>398 | Chapter 12: Resiliency</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 424" src="page_0424/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0424</div>
            </div>
        </div>
        <!-- Page 0425 -->
        <div class="chapter" id="page-0425">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>در مورد <em>AdvertCorp</em>، ما دو مسئله مربوط به <em>time-out</em> (مهلت زمانی) داشتیم. اول، ما یک <em>time-out</em> (مهلت زمانی) از دست رفته در استخر <em>HTTP request</em> (درخواست <em>HTTP</em>) داشتیم، به این معنی که هنگام درخواست از یک کارگر برای ایجاد یک <em>HTTP request</em> (درخواست <em>HTTP</em>) پایین‌دستی، <em>request thread</em> (رشته درخواست) برای همیشه مسدود می‌شد تا زمانی که یک کارگر در دسترس قرار گیرد. ثانیاً، هنگامی که ما در نهایت یک کارگر <em>HTTP</em> در دسترس برای برقراری یک <em>request</em> (درخواست) به سیستم تبلیغات شلغم داشتیم، ما مدت زیادی صبر می‌کردیم قبل از اینکه از تماس دست بکشیم. بنابراین همانطور که شکل 12-3 نشان می‌دهد، ما باید یک <em>time-out</em> (مهلت زمانی) جدید اضافه کنیم و یک مورد موجود را تغییر دهیم.</p>
<h5>Time-Outs (مهلت زمانی)</h5>
<p><em>Time-outs</em> (مهلت زمانی) بسیار مفید هستند. <em>Time-outs</em> (مهلت زمانی) را در تمام فراخوانی‌های خارج از فرآیند قرار دهید، و یک <em>time-out</em> (مهلت زمانی) پیش‌فرض را برای همه چیز انتخاب کنید. هنگامی که <em>time-outs</em> (مهلت زمانی) رخ می‌دهد، ثبت کنید، به آنچه اتفاق می‌افتد نگاه کنید، و آنها را بر این اساس تغییر دهید. به زمان‌های پاسخ "عادی" و سالم برای <em>services</em> (سرویس‌های) پایین‌دستی خود نگاه کنید، و از آن برای راهنمایی در تنظیم آستانه <em>time-out</em> (مهلت زمانی) استفاده کنید.</p>
<p>تنظیم <em>time-out</em> (مهلت زمانی) برای یک فراخوانی <em>service</em> (سرویس) واحد ممکن است کافی نباشد. اگر این <em>time-out</em> (مهلت زمانی) به عنوان بخشی از مجموعه گسترده‌تری از عملیات‌هایی که شما ممکن است بخواهید حتی قبل از وقوع <em>time-out</em> (مهلت زمانی) از آن دست بکشید، چه اتفاقی می‌افتد؟ به عنوان مثال، در مورد <em>AdvertCorp</em>، اگر احتمال زیادی وجود داشته باشد که کاربر قبلاً درخواست را متوقف کرده باشد، هیچ فایده‌ای در انتظار آخرین قیمت‌های شلغم وجود ندارد. در چنین شرایطی، منطقی است که یک <em>time-out</em> (مهلت زمانی) برای کل عملیات در نظر بگیرید و اگر این بودجه <em>time-out</em> (مهلت زمانی) تجاوز کرد، از آن دست بکشید. برای اینکه این کار انجام شود، زمان فعلی باقی‌مانده برای عملیات باید به پایین‌دست منتقل شود. به عنوان مثال، اگر عملیات کلی برای ارائه یک صفحه باید در عرض 1000 میلی‌ثانیه تکمیل می‌شد، و تا زمانی که ما با <em>service</em> (سرویس) تبلیغات شلغم تماس گرفتیم، 300 میلی‌ثانیه از قبل گذشته بود، در این صورت ما باید اطمینان حاصل کنیم که بیش از 700 میلی‌ثانیه برای تکمیل بقیه تماس‌ها صبر نکرده‌ایم.</p>
<p>فقط در مورد <em>time-out</em> (مهلت زمانی) برای یک فراخوانی <em>service</em> (سرویس) واحد فکر نکنید؛ همچنین در مورد یک <em>time-out</em> (مهلت زمانی) برای کل عملیات فکر کنید، و اگر این بودجه <em>time-out</em> (مهلت زمانی) کلی تجاوز کرد، عملیات را متوقف کنید.</p>
<h5>Retries (تلاش مجدد)</h5>
<p>برخی از مشکلات مربوط به فراخوانی‌های پایین‌دستی موقتی هستند. بسته‌ها می‌توانند جابه‌جا شوند، یا <em>gateways</em> (دروازه‌ها) می‌توانند افزایش عجیبی در بار داشته باشند و باعث <em>time-out</em> (مهلت زمانی) شوند. اغلب، تلاش مجدد تماس می‌تواند بسیار منطقی باشد. با بازگشت به آنچه ما به‌تازگی در مورد آن صحبت کردیم، چند بار شما یک صفحه وب را <em>refresh</em> (بازخوانی) کرده‌اید که بارگیری نشده است، فقط برای اینکه متوجه شوید تلاش دوم خوب کار می‌کند؟ این یک <em>retry</em> (تلاش مجدد) در عمل است.</p>
<p>در نظر گرفتن اینکه چه نوع شکست‌های فراخوانی پایین‌دستی باید <em>retried</em> (تلاش مجدد) شوند، می‌تواند مفید باشد. به عنوان مثال، اگر از یک پروتکل مانند <em>HTTP</em> استفاده می‌کنید، شما ممکن است اطلاعات مفیدی را در کدهای پاسخ دریافت کنید که می‌تواند به شما کمک کند تا تعیین کنید آیا یک <em>retry</em> (تلاش مجدد) تضمین می‌شود یا خیر. اگر شما یک <em>404 Not Found</em> (یافت نشد 404) دریافت کردید، یک <em>retry</em> (تلاش مجدد) بعید است یک ایده مفید باشد. از طرف دیگر، یک <em>503 Service Unavailable</em> (سرویس در دسترس نیست 503) یا یک <em>504 Gateway Time-out</em> (مهلت زمانی دروازه 504) می‌تواند خطاهای موقت در نظر گرفته شود و می‌تواند یک <em>retry</em> (تلاش مجدد) را توجیه کند.</p>
<p><em>Stability Patterns | 399</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 425" src="page_0425/image_1.png"/></div>
<div class="page-image"><img alt="Image from page 425" src="page_0425/image_2.png"/></div>
</div>
                <div class="page-number">صفحه 0425</div>
            </div>
        </div>
        <!-- Page 0426 -->
        <div class="chapter" id="page-0426">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>17 <em>Laura Bell</em> et al., <em>Agile Application Security</em> (<em>Sebastopol</em>: <em>O’Reilly</em>, 2017).</p>
<p>شما احتمالاً باید قبل از تلاش مجدد، تأخیری داشته باشید. اگر <em>time-out</em> (مهلت زمانی) یا خطای اولیه به این دلیل ایجاد شده باشد که <em>microservice</em> (ریز سرویس) پایین‌دستی تحت بار بود، در این صورت بمباران آن با <em>requests</em> (درخواست‌های) اضافی ممکن است یک ایده بد باشد.</p>
<p>اگر شما قصد دارید دوباره تلاش کنید، شما باید این را هنگام در نظر گرفتن آستانه <em>time-out</em> (مهلت زمانی) خود در نظر بگیرید. اگر آستانه <em>time-out</em> (مهلت زمانی) برای یک فراخوانی پایین‌دستی روی 500 میلی‌ثانیه تنظیم شده است، اما شما حداکثر سه <em>retry</em> (تلاش مجدد) را با یک ثانیه فاصله بین هر <em>retry</em> (تلاش مجدد) مجاز می‌دانید، در این صورت ممکن است در نهایت تا 3.5 ثانیه منتظر بمانید قبل از اینکه تسلیم شوید. همانطور که قبلاً ذکر شد، داشتن یک بودجه برای مدت زمان مجاز بودن یک عملیات می‌تواند یک ایده مفید باشد—شما ممکن است تصمیم نگیرید که <em>retry</em> (تلاش مجدد) سوم (یا حتی دوم) را انجام دهید اگر شما قبلاً از بودجه کلی <em>time-out</em> (مهلت زمانی) فراتر رفته‌اید. از طرف دیگر، اگر این اتفاق به عنوان بخشی از یک عملیات غیر رو به کاربر در حال وقوع است، انتظار طولانی‌تر برای انجام یک کار ممکن است کاملاً قابل قبول باشد.</p>
<h5>Bulkheads (دیواره‌ها)</h5>
<p>در <em>Release It!</em>،4 <em>Michael Nygard</em> مفهوم یک <em>bulkhead</em> (دیواره) را به عنوان راهی برای جدا کردن خود از شکست، معرفی می‌کند. در حمل‌ونقل، یک <em>bulkhead</em> (دیواره) بخشی از کشتی است که می‌توان آن را مهر و موم کرد تا از بقیه کشتی محافظت شود. بنابراین اگر کشتی دچار نشتی شود، شما می‌توانید درهای <em>bulkhead</em> (دیواره) را ببندید. شما بخشی از کشتی را از دست می‌دهید، اما بقیه آن دست‌نخورده باقی می‌ماند.</p>
<p>از نظر معماری نرم‌افزار، ما می‌توانیم <em>bulkheads</em> (دیواره‌های) زیادی را در نظر بگیریم. با بازگشت به تجربه خودم با <em>AdvertCorp</em>، ما در واقع فرصت اجرای یک <em>bulkhead</em> (دیواره) را در رابطه با فراخوانی‌های پایین‌دستی از دست دادیم. ما باید از استخرهای اتصال مختلف برای هر اتصال پایین‌دستی استفاده می‌کردیم. به این ترتیب، اگر یک استخر اتصال تمام می‌شد، اتصالات دیگر تحت تأثیر قرار نمی‌گرفتند، همانطور که در شکل 12-4 می‌بینیم.</p>
<p>شکل 12-4. استفاده از یک استخر اتصال در هر <em>service</em> (سرویس) پایین‌دستی برای ارائه <em>bulkheads</em> (دیواره‌ها)</p>
<p><em>400 | Chapter 12: Resiliency</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 426" src="page_0426/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0426</div>
            </div>
        </div>
        <!-- Page 0427 -->
        <div class="chapter" id="page-0427">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>Separation of concerns</em> (تفکیک وظایف) همچنین می‌تواند راهی برای پیاده‌سازی <em>bulkheads</em> (دیواره‌ها) باشد. با جدا کردن عملکرد به <em>microservices</em> (ریز سرویس‌های) جداگانه، ما شانس تأثیر یک قطعی در یک حوزه بر حوزه دیگر را کاهش می‌دهیم.</p>
<p>به تمام جنبه‌های سیستم خود که می‌توانند اشتباه پیش بروند، چه در داخل <em>microservices</em> (ریز سرویس‌های) شما و چه بین آنها، نگاه کنید. آیا شما <em>bulkheads</em> (دیواره‌ها) را در جای خود دارید؟ من پیشنهاد می‌کنم که حداقل با استخرهای اتصال جداگانه برای هر اتصال پایین‌دستی شروع کنید. با این حال، شما ممکن است بخواهید جلوتر بروید، و استفاده از <em>circuit breakers</em> (مدارشکن‌ها) را نیز در نظر بگیرید، که ما در یک لحظه به آن خواهیم پرداخت.</p>
<p>از بسیاری جهات، <em>bulkheads</em> (دیواره‌ها) مهم‌ترین الگوهایی هستند که ما تاکنون به آنها نگاه کرده‌ایم. <em>Time-outs</em> (مهلت زمانی) و <em>circuit breakers</em> (مدارشکن‌ها) به شما کمک می‌کنند تا منابع را در زمانی که در حال محدود شدن هستند، آزاد کنید، اما <em>bulkheads</em> (دیواره‌ها) می‌توانند اطمینان حاصل کنند که آنها در وهله اول محدود نمی‌شوند. آنها همچنین می‌توانند به شما این امکان را بدهند که درخواست‌ها را در شرایط خاص رد کنید تا اطمینان حاصل شود که منابع حتی بیشتر اشباع نمی‌شوند؛ این امر به عنوان <em>load shedding</em> (ریزش بار) شناخته می‌شود. گاهی اوقات رد یک <em>request</em> (درخواست) بهترین راه برای جلوگیری از تحت فشار قرار گرفتن یک سیستم مهم و تبدیل شدن به یک گلوگاه برای چندین <em>service</em> (سرویس) بالادستی است.</p>
<h5>Circuit Breakers (مدارشکن‌ها)</h5>
<p>در خانه‌ خود، <em>circuit breakers</em> (مدارشکن‌ها) وجود دارند تا از دستگاه‌های الکتریکی شما در برابر <em>spikes</em> (افزایش ناگهانی) در توان، محافظت کنند. اگر یک <em>spike</em> (افزایش ناگهانی) رخ دهد، <em>circuit breaker</em> (مدارشکن) منفجر می‌شود، و از وسایل برقی گران‌قیمت خانگی شما محافظت می‌کند. شما همچنین می‌توانید به‌صورت دستی یک <em>circuit breaker</em> (مدارشکن) را غیرفعال کنید تا برق را به بخشی از خانه خود قطع کنید، و به شما اجازه می‌دهد تا با خیال راحت روی سیستم الکتریکی کار کنید. در الگوی دیگری از <em>Release It!</em>، <em>Nygard</em> نشان می‌دهد که چگونه همین ایده می‌تواند به عنوان یک مکانیسم حفاظتی برای نرم‌افزار ما شگفتی ایجاد کند.</p>
<p>ما می‌توانیم به <em>circuit breakers</em> (مدارشکن‌ها) خود به عنوان یک مکانیسم خودکار برای مهر و موم کردن یک <em>bulkhead</em> (دیواره) فکر کنیم، نه تنها برای محافظت از مصرف‌کننده در برابر مشکل پایین‌دستی بلکه همچنین به‌طور بالقوه برای محافظت از <em>service</em> (سرویس) پایین‌دستی از تماس‌های بیشتری که ممکن است تأثیر نامطلوبی داشته باشند. با توجه به خطرات شکست آبشاری، من توصیه می‌کنم که <em>circuit breakers</em> (مدارشکن‌ها) را برای تمام فراخوانی‌های همزمان پایین‌دستی خود اجباری کنید. شما مجبور نیستید مال خود را بنویسید—در سال‌هایی که از زمان نوشتن ویرایش اول این کتاب گذشته است، پیاده‌سازی‌های <em>circuit breaker</em> (مدارشکن) به‌طور گسترده در دسترس قرار گرفته‌اند.</p>
<p>با بازگشت به <em>AdvertCorp</em>، مشکل را که با سیستم شلغم داشتیم در نظر بگیرید، که قبل از اینکه در نهایت یک خطا برگرداند، بسیار کند پاسخ می‌داد. حتی اگر ما <em>time-outs</em> (مهلت زمانی) را درست دریافت کرده بودیم، ما زمان زیادی را منتظر می‌ماندیم قبل از اینکه خطا را دریافت کنیم. و سپس ما دوباره در <em>request</em> (درخواست) بعدی تلاش می‌کردیم، و منتظر می‌ماندیم. به اندازه کافی بد بود که <em>service</em> (سرویس) پایین‌دستی از کار افتاده بود، اما کل سیستم را نیز کند می‌کرد.</p>
<p>با یک <em>circuit breaker</em> (مدارشکن)، پس از اینکه تعداد مشخصی از <em>requests</em> (درخواست‌ها) به منبع پایین‌دستی شکست خوردند (به دلیل خطا یا <em>time-out</em> (مهلت زمانی))، <em>circuit breaker</em> (مدارشکن) منفجر می‌شود. تمام درخواست‌های بیشتر که از آن <em>circuit breaker</em> (مدارشکن) عبور می‌کنند، به سرعت شکست می‌خورند در حالی که <em>breaker</em> (شکن) در وضعیت</p>
<p><em>Stability Patterns | 401</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0427</div>
            </div>
        </div>
        <!-- Page 0428 -->
        <div class="chapter" id="page-0428">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>5 اصطلاحات یک شکن "باز" (<em>open</em>)، به این معنی که <em>requests</em> (درخواست‌ها) نمی‌توانند جریان داشته باشند، می‌تواند گیج‌کننده باشد، اما این از مدارهای الکتریکی گرفته شده است. وقتی <em>breaker</em> (شکن) "باز" است، مدار شکسته می‌شود و جریان نمی‌تواند جریان داشته باشد. بستن <em>breaker</em> (شکن) به مدار اجازه می‌دهد تا تکمیل شود و جریان دوباره جریان یابد.</p>
<p><em>blown</em> (باز) است،5 همانطور که در شکل 12-5 مشاهده می‌کنید. پس از یک دوره زمانی مشخص، <em>client</em> (کلاینت) چند <em>request</em> (درخواست) را ارسال می‌کند تا ببیند آیا <em>service</em> (سرویس) پایین‌دستی بازیابی شده است، و اگر پاسخ‌های کافی سالم دریافت کند، <em>circuit breaker</em> (مدارشکن) را بازنشانی می‌کند.</p>
<p>شکل 12-5. مروری بر <em>circuit breakers</em> (مدارشکن‌ها)</p>
<p>نحوه پیاده‌سازی یک <em>circuit breaker</em> (مدارشکن) بستگی به این دارد که یک <em>request</em> (درخواست) "شکست‌خورده" به چه معناست، اما وقتی من آنها را برای اتصالات <em>HTTP</em> پیاده‌سازی کرده‌ام، معمولاً شکست را به معنای <em>time-out</em> (مهلت زمانی) یا زیرمجموعه‌ای از کدهای بازگشتی 5XX <em>HTTP</em> در نظر گرفته‌ام. به این ترتیب، وقتی یک منبع پایین‌دستی در حال <em>time out</em> (منقضی شدن زمان) یا بازگرداندن خطاها است، پس از رسیدن به یک آستانه مشخص، ما به طور خودکار ارسال ترافیک را متوقف می‌کنیم و شروع به شکست سریع می‌کنیم. و ما می‌توانیم به طور خودکار دوباره شروع کنیم وقتی که همه چیز سالم است.</p>
<p>درست تنظیم کردن تنظیمات می‌تواند کمی دشوار باشد. شما نمی‌خواهید <em>circuit breaker</em> (مدارشکن) را خیلی سریع منفجر کنید، و نه شما می‌خواهید خیلی طول بکشد تا آن را منفجر کنید. به همین ترتیب، شما واقعاً می‌خواهید مطمئن شوید که <em>service</em> (سرویس) پایین‌دستی دوباره سالم است قبل از ارسال ترافیک.
    همانطور که در مورد <em>time-outs</em> (مهلت زمانی) ذکر شد، من چند پیش‌فرض معقول را انتخاب می‌کنم و در همه جا به آنها پایبند می‌شوم، و سپس آنها را برای موارد خاص تغییر می‌دهم.</p>
<p>در حالی که <em>circuit breaker</em> (مدارشکن) منفجر شده است، شما چند گزینه دارید. یکی این است که <em>requests</em> (درخواست‌ها) را در صف قرار دهید و بعداً دوباره آنها را امتحان کنید. برای برخی از موارد استفاده، این ممکن است مناسب باشد، به‌خصوص اگر شما در حال انجام مقداری کار به عنوان بخشی از یک <em>asynchronous job</em> (شغل ناهمزمان) هستید. اگر این تماس</p>
<p><em>402 | Chapter 12: Resiliency</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 428" src="page_0428/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0428</div>
            </div>
        </div>
        <!-- Page 0429 -->
        <div class="chapter" id="page-0429">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>همچنین در حالیکه  <em>synchronous call chain</em> (زنجیره فراخوانی همزمان) انجام می‌شود، بهتر است سریع شکست بخوریم. این می‌تواند به معنای انتشار یک خطا در زنجیره فراخوانی، یا یک افت عملکرد ظریف‌تر باشد.</p>
<p>در مورد <em>AdvertCorp</em>، ما <em>calls</em> (فراخوانی‌های) پایین‌دستی به سیستم‌های قدیمی را با <em>circuit breakers</em> (مدارشکن‌ها) محصور کردیم، همانطور که در شکل 12-6 نشان داده شده است. هنگامی که این <em>circuit breakers</em> (مدارشکن‌ها) منفجر شدند، ما به‌طور برنامه‌نویسی وب‌سایت را به‌روزرسانی کردیم تا نشان دهیم که در حال حاضر نمی‌توانیم تبلیغات را برای مثال، شلغم نشان دهیم. ما بقیه وب‌سایت را در حال کار نگه داشتیم و به‌طور واضح به مشتریان اطلاع دادیم که مشکلی محدود به یک بخش از محصول ما وجود دارد، همه به روشی کاملاً خودکار.</p>
<p>شکل 12-6. افزودن <em>circuit breakers</em> (مدارشکن‌ها) به <em>AdvertCorp</em></p>
<p>ما توانستیم <em>circuit breakers</em> (مدارشکن‌ها) خود را طوری تنظیم کنیم که برای هر یک از سیستم‌های قدیمی پایین‌دستی یک مورد داشته باشیم—این با این واقعیت که ما تصمیم گرفته بودیم استخرهای کارگر <em>request</em> (درخواست) مختلفی برای هر سرویس پایین‌دستی داشته باشیم، همخوانی داشت.</p>
<p>اگر ما این مکانیسم را در جای خود داشته باشیم (همانطور که با <em>circuit breakers</em> (مدارشکن‌ها) در خانه‌هایمان داریم)، ما می‌توانیم از آنها به صورت دستی برای ایمن‌تر کردن کار خود استفاده کنیم. به عنوان مثال، اگر ما می‌خواستیم یک <em>microservice</em> (ریز سرویس) را به عنوان بخشی از تعمیر و نگهداری معمول از کار بیاندازیم، ما می‌توانستیم به‌صورت دستی همه <em>circuit breakers</em> (مدارشکن‌ها) از مصرف‌کنندگان بالادستی را باز کنیم تا آنها سریع شکست بخورند در حالی که <em>microservice</em> (ریز سرویس) آفلاین است. هنگامی که دوباره راه‌اندازی شد، ما می‌توانیم <em>circuit breakers</em> (مدارشکن‌ها) را ببندیم، و همه چیز باید</p>
<p><em>Stability Patterns | 403</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 429" src="page_0429/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0429</div>
            </div>
        </div>
        <!-- Page 0430 -->
        <div class="chapter" id="page-0430">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>به حالت عادی برگردند. نوشتن فرآیند برای باز و بسته کردن دستی یک <em>circuit breaker</em> (مدارشکن) به عنوان بخشی از یک فرآیند استقرار خودکار می‌تواند یک گام منطقی بعدی باشد.</p>
<p><em>Circuit breakers</em> (مدارشکن‌ها) به <em>application</em> (برنامه) ما کمک می‌کنند سریع شکست بخورد—و سریع شکست خوردن همیشه بهتر از شکست کند است. <em>Circuit breakers</em> (مدارشکن‌ها) به ما اجازه می‌دهند قبل از اینکه زمان (و منابع) ارزشمند خود را صرف انتظار برای پاسخگویی یک <em>microservice</em> (ریز سرویس) ناسالم کنیم، شکست بخوریم. به جای اینکه منتظر بمانیم تا ما از <em>microservice</em> (ریز سرویس) پایین‌دستی استفاده کنیم تا شکست بخوریم، ما می‌توانیم وضعیت <em>circuit breakers</em> (مدارشکن‌های) خود را زودتر بررسی کنیم. اگر یک <em>microservice</em> (ریز سرویس) که ما در یک عملیات به آن تکیه می‌کنیم، در حال حاضر در دسترس نباشد، ما می‌توانیم عملیات را قبل از اینکه حتی شروع کنیم، متوقف کنیم.</p>
<h5>Isolation (انزوا)</h5>
<p>هرچه یک <em>microservice</em> (ریز سرویس) بیشتر به در دسترس بودن <em>microservice</em> (ریز سرویس) دیگری وابسته باشد، سلامت یکی بر توانایی دیگری در انجام کار خود تأثیر می‌گذارد. اگر ما بتوانیم از فناوری‌ای استفاده کنیم که به یک سرور پایین‌دستی اجازه می‌دهد که آفلاین باشد، به عنوان مثال، از طریق استفاده از <em>middleware</em> (میان‌افزار) یا نوع دیگری از سیستم بافر تماس، <em>microservices</em> (ریز سرویس‌های) بالادستی احتمال کمتری دارد که تحت تأثیر قطعی‌ها، برنامه‌ریزی شده یا برنامه‌ریزی نشده، <em>microservices</em> (ریز سرویس‌های) پایین‌دستی قرار گیرند.</p>
<p>یک مزیت دیگر برای افزایش انزوا بین <em>services</em> (سرویس‌ها) وجود دارد. هنگامی که <em>services</em> (سرویس‌ها) از یکدیگر جدا می‌شوند، هماهنگی بسیار کمتری بین مالکان <em>service</em> (سرویس) مورد نیاز است. هرچه هماهنگی کمتری بین تیم‌ها مورد نیاز باشد، آن تیم‌ها استقلال بیشتری دارند، زیرا آنها قادر به عملکرد و تکامل <em>services</em> (سرویس‌های) خود به طور آزادانه‌تری هستند.</p>
<p>انزوا همچنین از نظر چگونگی حرکت ما از منطقی به فیزیکی اعمال می‌شود. دو <em>microservices</em> (ریز سرویس) را در نظر بگیرید که به نظر می‌رسد کاملاً از یکدیگر جدا شده‌اند. آنها به هیچ وجه با یکدیگر ارتباط برقرار نمی‌کنند. یک مشکل با یکی از آنها نباید بر دیگری تأثیر بگذارد، درست است؟ اما اگر هر دو <em>microservices</em> (ریز سرویس‌ها) روی یک میزبان اجرا شوند، و یکی از <em>microservices</em> (ریز سرویس‌ها) شروع به استفاده از تمام <em>CPU</em> کند، و باعث ایجاد مشکل در آن میزبان شود، چه؟</p>
<p>یک مثال دیگر را در نظر بگیرید. دو <em>microservices</em> (ریز سرویس) هر کدام <em>database</em> (پایگاه داده) منطقاً جداگانه خود را دارند. اما هر دو <em>databases</em> (پایگاه‌های داده) در همان زیرساخت <em>database</em> (پایگاه داده) مستقر شده‌اند. یک شکست در آن زیرساخت <em>database</em> (پایگاه داده) بر هر دو <em>microservices</em> (ریز سرویس‌ها) تأثیر می‌گذارد.</p>
<p>وقتی ما در نظر می‌گیریم که چگونه می‌خواهیم <em>microservices</em> (ریز سرویس‌های) خود را مستقر کنیم، ما همچنین می‌خواهیم تلاش کنیم تا درجه‌ای از جداسازی شکست را تضمین کنیم تا از مشکلاتی مانند این جلوگیری کنیم. به عنوان مثال، اطمینان از اینکه <em>microservices</em> (ریز سرویس‌ها) در میزبان‌های مستقل با سیستم عامل و منابع محاسباتی خود در حال اجرا هستند، یک گام منطقی است—این همان چیزی است که ما هنگام اجرای نمونه‌های <em>microservice</em> (ریز سرویس) در ماشین مجازی یا <em>container</em> (کانتینر) خود به آن می‌رسیم. با این حال، این نوع انزوا می‌تواند هزینه‌بر باشد.</p>
<p>ما می‌توانیم <em>microservices</em> (ریز سرویس‌های) خود را با اجرای آنها در ماشین‌های مختلف، به‌طور مؤثرتری از یکدیگر جدا کنیم. این به این معنی است که ما به زیرساخت و <em>tooling</em> (ابزارسازی) بیشتری برای مدیریت آن زیرساخت نیاز داریم. این یک هزینه مستقیم دارد و همچنین می‌تواند به پیچیدگی سیستم ما افزوده و راه‌های جدیدی از شکست احتمالی را آشکار کند. هر <em>microservice</em> (ریز سرویس) می‌تواند داشته باشد</p>
<p><em>404 | Chapter 12: Resiliency</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0430</div>
            </div>
        </div>
        <!-- Page 0431 -->
        <div class="chapter" id="page-0431">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>زیرساخت <em>database</em> (پایگاه داده) کاملاً اختصاصی خود را داشته باشد، اما این زیرساخت بیشتری برای مدیریت است. ما می‌توانیم از <em>middleware</em> (میان‌افزار) برای ارائه <em>temporal decoupling</em> (جداسازی زمانی) بین دو <em>microservices</em> (ریز سرویس‌ها) استفاده کنیم، اما اکنون ما یک <em>broker</em> (کارگزار) داریم که باید نگران آن باشیم.</p>
<p>انزوا، مانند بسیاری از تکنیک‌های دیگری که ما به آنها نگاه کرده‌ایم، می‌تواند به بهبود <em>robustness</em> (استحکام) برنامه‌های ما کمک کند، اما به‌ندرت این کار را به‌صورت رایگان انجام می‌دهد. تصمیم‌گیری در مورد <em>trade-offs</em> (تبعات) قابل قبول پیرامون انزوا در مقابل هزینه و افزایش پیچیدگی، مانند بسیاری از موارد دیگر، می‌تواند حیاتی باشد.</p>
<h5>Redundancy (افزونگی)</h5>
<p>داشتن چیزهای بیشتر می‌تواند راهی عالی برای بهبود <em>robustness</em> (استحکام) یک مؤلفه باشد. داشتن بیش از یک نفر که می‌داند <em>database</em> (پایگاه داده) تولید چگونه کار می‌کند، منطقی به نظر می‌رسد، در صورتی که کسی شرکت را ترک کند یا در مرخصی باشد. داشتن بیش از یک نمونه <em>microservice</em> (ریز سرویس) منطقی است زیرا به شما امکان می‌دهد خرابی یکی از آن نمونه‌ها را تحمل کنید و همچنان شانس ارائه عملکرد مورد نیاز را داشته باشید.</p>
<p>یافتن اینکه به چه مقدار <em>redundancy</em> (افزونگی) نیاز دارید، و کجا، به این بستگی دارد که شما چقدر حالت‌های شکست احتمالی هر مؤلفه، تأثیر عدم در دسترس بودن آن عملکرد، و هزینه افزودن <em>redundancy</em> (افزونگی) را درک می‌کنید.</p>
<p>به عنوان مثال، در <em>AWS</em>، شما <em>SLA</em> (قرارداد سطح خدمات) برای زمان کار یک نمونه <em>EC2</em> (ماشین مجازی) واحد دریافت نمی‌کنید. شما باید با این فرض کار کنید که ممکن است از کار بیفتد و از کار بیفتد. بنابراین منطقی است که بیش از یکی داشته باشید. اما فراتر از این، نمونه‌های <em>EC2</em> در <em>availability zones</em> (مناطق در دسترس بودن) مستقر می‌شوند، و شما همچنین هیچ تضمینی در مورد در دسترس بودن یک منطقه در دسترس بودن واحد ندارید، به این معنی که شما می‌خواهید آن نمونه دوم در یک منطقه در دسترس بودن متفاوت باشد تا ریسک را گسترش دهید.</p>
<p>داشتن نسخه‌های بیشتر از یک چیز می‌تواند در پیاده‌سازی <em>redundancy</em> (افزونگی) کمک کند، اما می‌تواند در هنگام مقیاس‌بندی برنامه‌هایمان برای رسیدگی به افزایش بار نیز مفید باشد. در فصل بعد ما به نمونه‌هایی از مقیاس‌بندی سیستم نگاهی خواهیم داشت، و خواهیم دید که چگونه مقیاس‌بندی برای <em>redundancy</em> (افزونگی) یا مقیاس‌بندی برای بار می‌تواند متفاوت باشد.</p>
<h5>Middleware (میان‌افزار)</h5>
<p>در "<em>Message Brokers</em>" در صفحه 135، ما به نقش <em>middleware</em> (میان‌افزار) در قالب <em>message brokers</em> (کارگزاران پیام) برای کمک به پیاده‌سازی تعاملات مبتنی بر <em>request-response</em> (درخواست-پاسخ) و رویداد محور نگاه کردیم. یکی از ویژگی‌های مفید بیشتر <em>message brokers</em> (کارگزاران پیام)، توانایی آنها در ارائه تحویل تضمین‌شده است. شما یک پیام را به یک طرف پایین‌دستی ارسال می‌کنید، و <em>broker</em> (کارگزار) تحویل آن را تضمین می‌کند، با برخی هشدارها که قبلاً بررسی کردیم. در داخل، برای ارائه این تضمین، نرم‌افزار <em>message broker</em> (کارگزار پیام) باید مواردی مانند <em>retries</em> (تلاش مجدد) و <em>time-outs</em> (مهلت زمانی) را از طرف شما پیاده‌سازی کند—همان نوع عملیات‌هایی که شما مجبور به انجام آنها می‌شوید، اما آنها در نرم‌افزاری که نوشته شده است، انجام می‌شوند</p>
<p><em>Stability Patterns | 405</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0431</div>
            </div>
        </div>
        <!-- Page 0432 -->
        <div class="chapter" id="page-0432">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>توسط متخصصان با تمرکز عمیق بر این نوع مسائل. انجام کار توسط افراد باهوش، اغلب یک ایده خوب است.</p>
<p>اکنون، در مورد مثال خاص ما با <em>AdvertCorp</em>، استفاده از <em>middleware</em> (میان‌افزار) برای مدیریت ارتباط <em>request-response</em> (درخواست-پاسخ) با سیستم شلغم پایین‌دستی، ممکن است در واقع خیلی کمک نکرده باشد. ما همچنان پاسخ‌هایی را به مشتریان خود دریافت نمی‌کردیم. تنها مزیت بالقوه این است که ما <em>resource contention</em> (رقابت بر سر منابع) را در سیستم خود کاهش می‌دهیم، اما این فقط به افزایش تعداد <em>pending requests</em> (درخواست‌های معلق) که در <em>broker</em> (کارگزار) نگهداری می‌شوند، تغییر می‌کند. بدتر از آن، بسیاری از این <em>requests</em> (درخواست‌ها) که خواستار آخرین قیمت‌های شلغم هستند، ممکن است به <em>user requests</em> (درخواست‌های کاربر) مربوط شوند که دیگر معتبر نیستند.</p>
<p>یک جایگزین می‌تواند این باشد که تعامل را برعکس کنیم و از <em>middleware</em> (میان‌افزار) استفاده کنیم تا سیستم شلغم آخرین تبلیغات شلغم را پخش کند، و سپس ما می‌توانیم آنها را مصرف کنیم.
    اما اگر سیستم شلغم پایین‌دستی مشکلی داشت، ما همچنان نمی‌توانستیم به مشتری که به دنبال بهترین قیمت‌های شلغم بود، کمک کنیم.</p>
<p>بنابراین استفاده از <em>middleware</em> (میان‌افزار) مانند <em>message brokers</em> (کارگزاران پیام) برای کمک به کاهش برخی از نگرانی‌های <em>robustness</em> (استحکام) می‌تواند مفید باشد، اما نه در هر موقعیتی.</p>
<h5>Idempotency (هم‌ارز بودن)</h5>
<p>در عملیات <em>idempotent</em> (هم‌ارز)، نتیجه پس از اولین <em>application</em> (برنامه) تغییر نمی‌کند، حتی اگر عملیات متعاقباً چندین بار اعمال شود. اگر عملیات <em>idempotent</em> (هم‌ارز) باشد، ما می‌توانیم <em>call</em> (فراخوانی) را چندین بار بدون تأثیر نامطلوب، تکرار کنیم. این بسیار مفید است زمانی که ما می‌خواهیم پیام‌هایی را که از پردازش آنها اطمینان نداریم، دوباره پخش کنیم، یک راه رایج برای بازیابی از خطا.</p>
<p>بیایید یک فراخوانی ساده برای افزودن مقداری امتیاز در نتیجه ثبت سفارش توسط یکی از مشتریان خود را در نظر بگیریم. ما ممکن است با <em>payload</em> (بار)ی از نوع نشان داده شده در مثال 12-1 فراخوانی کنیم.</p>
<p>مثال 12-1. اعتبارسنجی امتیاز به یک حساب</p>
<p>&lt;credit&gt;
    &lt;amount&gt;100&lt;/amount&gt;
    &lt;forAccount&gt;1234&lt;/account&gt;
    &lt;/credit&gt;</p>
<p>اگر این <em>call</em> (فراخوانی) چندین بار دریافت شود، ما چندین بار 100 امتیاز اضافه می‌کنیم. بنابراین، همانطور که هست، این <em>call</em> (فراخوانی) <em>idempotent</em> (هم‌ارز) نیست. با این حال، با کمی اطلاعات بیشتر، ما به بانک امتیاز اجازه می‌دهیم که این <em>call</em> (فراخوانی) را <em>idempotent</em> (هم‌ارز) کند، همانطور که در مثال 12-2 نشان داده شده است.</p>
<p><em>406 | Chapter 12: Resiliency</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0432</div>
            </div>
        </div>
        <!-- Page 0433 -->
        <div class="chapter" id="page-0433">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>مثال 12-2. افزودن اطلاعات بیشتر به اعتبار امتیاز برای هم‌ارز کردن آن</p>
<p>&lt;credit&gt;
    &lt;amount&gt;100&lt;/amount&gt;
    &lt;forAccount&gt;1234&lt;/account&gt;
    &lt;reason&gt;
    &lt;forPurchase&gt;4567&lt;/forPurchase&gt;
    &lt;/reason&gt;
    &lt;/credit&gt;</p>
<p>ما می‌دانیم که این اعتبار به یک سفارش خاص، 4567، مربوط می‌شود. با فرض اینکه ما می‌توانیم فقط یک اعتبار را برای یک سفارش معین دریافت کنیم، ما می‌توانیم این اعتبار را دوباره اعمال کنیم بدون اینکه تعداد کل امتیازها را افزایش دهیم.
    این مکانیسم با همکاری مبتنی بر رویداد نیز به خوبی کار می‌کند و اگر شما چندین نمونه از یک نوع <em>service</em> (سرویس) مشترک در رویدادها داشته باشید، می‌تواند به‌ویژه مفید باشد. حتی اگر ما رویدادهایی را که پردازش شده‌اند ذخیره کنیم، با برخی از اشکال تحویل پیام ناهمزمان، ممکن است بازه‌های کوچکی وجود داشته باشد که در آن دو کارگر می‌توانند همان پیام را ببینند. با پردازش رویدادها به روشی <em>idempotent</em> (هم‌ارز)، ما اطمینان حاصل می‌کنیم که این امر باعث ایجاد هیچ مشکلی برای ما نمی‌شود.</p>
<p>برخی از افراد با این مفهوم بسیار درگیر می‌شوند و فرض می‌کنند که این به این معنی است که <em>calls</em> (فراخوانی‌های) بعدی با پارامترهای یکسان نمی‌توانند هیچ تأثیری داشته باشند، که ما را در یک موقعیت جالب قرار می‌دهد. ما واقعاً هنوز می‌خواهیم این واقعیت را در <em>logs</em> (لاگ‌ها)ی خود ثبت کنیم که یک <em>call</em> (فراخوانی) دریافت شده است، به عنوان مثال. ما می‌خواهیم زمان پاسخ <em>call</em> (فراخوانی) را ثبت کنیم و این داده‌ها را برای <em>monitoring</em> (پایش) جمع‌آوری کنیم. نکته کلیدی در اینجا این است که این عملیات تجاری اساسی است که ما آن را <em>idempotent</em> (هم‌ارز) در نظر می‌گیریم، نه کل وضعیت سیستم.</p>
<p>برخی از <em>HTTP verbs</em> (افعال <em>HTTP</em>)، مانند <em>GET</em> و <em>PUT</em>، در مشخصات <em>HTTP</em> به‌گونه‌ای تعریف شده‌اند که <em>idempotent</em> (هم‌ارز) باشند، اما برای اینکه این اتفاق بیفتد، آنها به <em>service</em> (سرویس) شما متکی هستند تا این <em>calls</em> (فراخوانی‌ها) را به روشی <em>idempotent</em> (هم‌ارز) مدیریت کند. اگر شما شروع به غیر <em>idempotent</em> (هم‌ارز) کردن این افعال کنید، اما تماس‌گیرنده‌ها فکر کنند که می‌توانند آنها را با خیال راحت تکرار کنند، ممکن است خودتان را به دردسر بیندازید. به یاد داشته باشید، فقط به این دلیل که شما از <em>HTTP</em> به عنوان یک پروتکل اساسی استفاده می‌کنید، به این معنی نیست که همه چیز را رایگان دریافت می‌کنید!</p>
<h5>Spreading Your Risk (پخش ریسک خود)</h5>
<p>یک راه برای مقیاس‌بندی برای <em>resilience</em> (مقاومت) این است که اطمینان حاصل کنید که شما همه تخم‌مرغ‌های خود را در یک سبد قرار نمی‌دهید. یک مثال ساده‌انگارانه از این امر، اطمینان از این است که شما چندین <em>service</em> (سرویس) را روی یک میزبان ندارید، جایی که یک قطعی بر چندین <em>service</em> (سرویس) تأثیر می‌گذارد. اما بیایید در نظر بگیریم که میزبان به چه معناست. امروزه در بیشتر موقعیت‌ها، یک "میزبان" در واقع یک مفهوم مجازی است.
    بنابراین اگر من تمام <em>services</em> (سرویس‌های) خود را روی میزبان‌های مختلف داشته باشم، اما همه آن میزبان‌ها در واقع میزبان‌های مجازی هستند که روی یک جعبه فیزیکی یکسان اجرا می‌شوند، چه؟ اگر آن جعبه از کار بیفتد، من می‌توانم چندین <em>service</em> (سرویس) را از دست بدهم. برخی از پلتفرم‌های مجازی‌سازی به شما این امکان را می‌دهند که اطمینان حاصل کنید که میزبان‌های شما</p>
<p><em>Spreading Your Risk | 407</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0433</div>
            </div>
        </div>
        <!-- Page 0434 -->
        <div class="chapter" id="page-0434">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>or container</em> (یا کانتینر)های خود را در جعبه‌های فیزیکی مختلف توزیع کنید تا شانس این اتفاق را کاهش دهید.</p>
<p>برای پلتفرم‌های مجازی‌سازی داخلی، یک عمل رایج این است که پارتیشن ریشه ماشین مجازی را به یک <em>SAN</em> (شبکه ذخیره‌سازی) واحد نگاشت کنید. اگر آن <em>SAN</em> از کار بیفتد، می‌تواند تمام <em>VMs</em> (ماشین‌های مجازی) متصل را از کار بیاندازد. <em>SANs</em> (شبکه‌های ذخیره‌سازی) بزرگ، گران‌قیمت هستند، و طوری طراحی شده‌اند که شکست نخورند. با این حال، من در 10 سال گذشته، <em>SANs</em> (شبکه‌های ذخیره‌سازی) گران‌قیمت و بزرگ را حداقل دو بار با شکست مواجه کرده‌ام، و هر بار نتایج نسبتاً جدی بودند.</p>
<p>شکل دیگری از جداسازی برای کاهش شکست این است که اطمینان حاصل کنید که همه <em>services</em> (سرویس‌های) شما در یک رک واحد در مرکز داده اجرا نمی‌شوند، یا اینکه <em>services</em> (سرویس‌های) شما در بیش از یک مرکز داده توزیع شده‌اند. اگر شما از یک <em>service provider</em> (ارائه‌دهنده سرویس) زیربنایی استفاده می‌کنید، مهم است که بدانید آیا یک <em>SLA</em> (قرارداد سطح خدمات) ارائه می‌شود و بر این اساس برنامه‌ریزی کنید. اگر شما نیاز دارید اطمینان حاصل کنید که <em>services</em> (سرویس‌های) شما بیش از چهار ساعت در هر فصل از کار نمی‌افتند، اما ارائه‌دهنده هاستینگ شما فقط می‌تواند حداکثر هشت ساعت خرابی در هر فصل را تضمین کند، شما باید <em>SLA</em> را تغییر دهید یا یک راه‌حل جایگزین ارائه دهید.
    به عنوان مثال، <em>AWS</em>، به مناطق تقسیم می‌شود، که شما می‌توانید به آنها به عنوان ابرهای متمایز فکر کنید. هر منطقه به نوبه خود به دو یا چند <em>availability zones</em> (مناطق در دسترس بودن) تقسیم می‌شود، همانطور که قبلاً بحث کردیم. این <em>availability zones</em> (مناطق در دسترس بودن) معادل <em>data center</em> (مرکز داده) <em>AWS</em> هستند. ضروری است که <em>services</em> (سرویس‌ها) در چندین <em>availability zones</em> (منطق در دسترس بودن) توزیع شوند، زیرا <em>AWS</em> هیچ تضمینی در مورد در دسترس بودن یک گره واحد، یا حتی یک <em>availability zone</em> (منطقه در دسترس بودن) کامل، ارائه نمی‌دهد. برای <em>compute service</em> (سرویس محاسباتی) خود، فقط یک زمان کار 99.95٪ را در یک دوره ماهانه معین از کل منطقه ارائه می‌دهد، بنابراین شما می‌خواهید بارهای کاری خود را در چندین <em>availability zones</em> (منطقه در دسترس بودن) در داخل یک منطقه واحد توزیع کنید. برای برخی از افراد، این کافی نیست، و آنها <em>services</em> (سرویس‌های) خود را در چندین منطقه نیز اجرا می‌کنند.</p>
<p>البته، باید توجه داشت که از آنجایی که ارائه‌دهندگان به شما یک "تضمین" <em>SLA</em> (قرارداد سطح خدمات) می‌دهند، تمایل دارند که مسئولیت خود را محدود کنند! اگر از دست دادن اهداف آنها منجر به از دست دادن مشتریان و مقدار زیادی پول شود، شما ممکن است خودتان را در حال جستجو در میان قراردادها برای دیدن اینکه آیا می‌توانید چیزی را از آنها پس بگیرید، بیابید. بنابراین، من اکیداً پیشنهاد می‌کنم که شما تأثیر شکست یک تأمین‌کننده در تعهدات خود را درک کنید، و دریابید که آیا شما نیاز دارید که یک برنامه <em>B</em> (یا <em>C</em>) در اختیار داشته باشید. به عنوان مثال، بیش از یک مشتری که من با آن کار کرده‌ام، یک پلتفرم بازیابی فاجعه با یک تأمین‌کننده دیگر داشته است تا اطمینان حاصل کند که آنها در برابر اشتباهات یک شرکت بسیار آسیب‌پذیر نبوده‌اند.</p>
<h5>CAP Theorem (قضیه CAP)</h5>
<p>ما می‌خواهیم همه چیز را داشته باشیم، اما متأسفانه می‌دانیم که نمی‌توانیم. و وقتی نوبت به سیستم‌های توزیع‌شده مانند سیستم‌هایی می‌رسد که ما با استفاده از معماری‌های <em>microservice</em> (ریز سرویس‌ها) می‌سازیم، ما حتی یک اثبات ریاضی داریم که به ما می‌گوید نمی‌توانیم. شما ممکن است در مورد قضیه <em>CAP</em> شنیده باشید، به‌ویژه در بحث در مورد مزایای انواع مختلف <em>data stores</em> (انبار داده‌ها). در قلب خود به ما می‌گوید که در یک سیستم توزیع‌شده، ما سه چیز داریم که</p>
<p><em>391 | Chapter 12: Resiliency</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0434</div>
            </div>
        </div>
        <!-- Page 0435 -->
        <div class="chapter" id="page-0435">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>می‌توانند با یکدیگر مبادله شوند: <em>consistency</em> (انسجام)، <em>availability</em> (در دسترس بودن)، و <em>partition tolerance</em> (تحمل پارتیشن).
    به‌طور خاص، این قضیه به ما می‌گوید که ما می‌توانیم دو مورد را در یک حالت شکست حفظ کنیم.</p>
<p><em>Consistency</em> (انسجام) ویژگی سیستم است که از طریق آن اگر ما به گره‌های متعدد برویم، پاسخ یکسانی دریافت خواهیم کرد. <em>Availability</em> (در دسترس بودن) به این معنی است که هر <em>request</em> (درخواست) یک پاسخ دریافت می‌کند. <em>Partition tolerance</em> (تحمل پارتیشن) توانایی سیستم در مدیریت این واقعیت است که ارتباط بین بخش‌های آن، گاهی غیرممکن است.</p>
<p>از آنجایی که <em>Eric Brewer</em> حدس اولیه خود را منتشر کرد، این ایده یک اثبات ریاضی به دست آورده است. من قصد ندارم وارد ریاضیات خود اثبات شوم، زیرا این نوع کتاب نیست، بلکه من همچنین می‌توانم تضمین کنم که آن را اشتباه خواهم فهمید. در عوض، بیایید از برخی مثال‌های کارشده استفاده کنیم که به ما کمک می‌کند تا درک کنیم که در زیر همه اینها، قضیه <em>CAP</em> یک تقطیر از یک مجموعه بسیار منطقی از استدلال است.</p>
<p>بیایید تصور کنیم که <em>Inventory microservice</em> (ریز سرویس انبار) ما در دو <em>data centers</em> (مراکز داده) جداگانه مستقر شده است، همانطور که در شکل 12-7 نشان داده شده است. پشتیبانی از نمونه <em>service</em> (سرویس) ما در هر <em>data center</em> (مرکز داده)، یک <em>database</em> (پایگاه داده) است، و این دو <em>databases</em> (پایگاه‌های داده) با یکدیگر صحبت می‌کنند تا سعی کنند داده‌ها را بین آنها همگام‌سازی کنند. خواندن و نوشتن از طریق گره <em>database</em> (پایگاه داده) محلی انجام می‌شود، و از <em>replication</em> (تکثیر) برای همگام‌سازی داده‌ها بین گره‌ها استفاده می‌شود.</p>
<p>شکل 12-7. استفاده از <em>multiprimary replication</em> (تکثیر چندگانه اولیه) برای به اشتراک گذاشتن داده‌ها بین دو گره <em>database</em> (پایگاه داده)</p>
<p><em>CAP Theorem | 409</em></p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 435" src="page_0435/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0435</div>
            </div>
        </div>
        <!-- Page 0436 -->
        <div class="chapter" id="page-0436">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>حالا بیایید در مورد آنچه اتفاق می‌افتد وقتی چیزی شکست می‌خورد، فکر کنیم. تصور کنید که چیزی به سادگی پیوند شبکه بین دو <em>data center</em> (مرکز داده) از کار می‌افتد. همگام‌سازی در این مرحله شکست می‌خورد. نوشته‌ها در <em>database</em> (پایگاه داده) اصلی در <em>DC1</em> به <em>DC2</em> منتقل نخواهند شد، و بالعکس. اکثر <em>databases</em> (پایگاه‌های داده) که از این تنظیمات پشتیبانی می‌کنند، همچنین از نوعی تکنیک صف برای اطمینان از اینکه ما می‌توانیم پس از این، بازیابی کنیم، پشتیبانی می‌کنند، اما در این بین چه اتفاقی می‌افتد؟</p>
<h5>Sacrificing Consistency (قربانی کردن انسجام)</h5>
<p>بیایید فرض کنیم که ما <em>Inventory microservice</em> (ریز سرویس انبار) را به‌طور کامل خاموش نمی‌کنیم. اگر من اکنون تغییری در داده‌های <em>DC1</em> ایجاد کنم، <em>database</em> (پایگاه داده) در <em>DC2</em> آن را نمی‌بیند. این بدان معناست که هر <em>requests</em> (درخواستی) که به گره موجودی ما در <em>DC2</em> داده می‌شود، داده‌های بالقوه منسوخ شده را می‌بیند. به عبارت دیگر، سیستم ما همچنان در دسترس است به این دلیل که هر دو گره قادر به ارائه <em>requests</em> (درخواست‌ها) هستند، و ما سیستم را علی‌رغم <em>partition</em> (پارتیشن) در حال اجرا نگه داشته‌ایم، اما <em>consistency</em> (انسجام) را از دست داده‌ایم؛ ما قرار نیست هر سه ویژگی را حفظ کنیم. این اغلب یک سیستم <em>AP</em> نامیده می‌شود، به دلیل <em>availability</em> (در دسترس بودن) و <em>partition tolerance</em> (تحمل پارتیشن) آن.</p>
<p>در طول این <em>partition</em> (پارتیشن)، اگر ما به پذیرش نوشته‌ها ادامه دهیم، در این صورت ما این واقعیت را می‌پذیریم که در زمانی در آینده باید آنها را دوباره همگام‌سازی کرد. هرچه <em>partition</em> (پارتیشن) بیشتر طول بکشد، این دوباره همگام‌سازی می‌تواند دشوارتر شود.</p>
<p>واقعیت این است که حتی اگر ما یک شکست شبکه بین گره‌های <em>database</em> (پایگاه داده) خود نداشته باشیم، تکثیر داده‌ها فوری نیست. همانطور که قبلاً اشاره شد، گفته می‌شود که سیستم‌هایی که مایل به واگذاری <em>consistency</em> (انسجام) برای حفظ <em>partition tolerance</em> (تحمل پارتیشن) و <em>availability</em> (در دسترس بودن) هستند، در نهایت <em>consistent</em> (منسجم) هستند؛ یعنی، ما انتظار داریم که در زمانی در آینده، همه گره‌ها داده‌های به‌روز شده را ببینند، اما این به‌طور همزمان اتفاق نخواهد افتاد، بنابراین ما باید با این احتمال زندگی کنیم که کاربران داده‌های قدیمی را ببینند.</p>
<h5>Sacrificing Availability (قربانی کردن در دسترس بودن)</h5>
<p>اگر ما نیاز به حفظ <em>consistency</em> (انسجام) داشته باشیم و بخواهیم چیز دیگری را رها کنیم، چه اتفاقی می‌افتد؟ خوب، برای حفظ <em>consistency</em> (انسجام)، هر گره <em>database</em> (پایگاه داده) باید بداند که کپی داده‌هایی که در اختیار دارد با گره <em>database</em> (پایگاه داده) دیگر یکسان است. اکنون در <em>partition</em> (پارتیشن)، اگر گره‌های <em>database</em> (پایگاه داده) نتوانند با یکدیگر صحبت کنند، آنها نمی‌توانند هماهنگی داشته باشند تا <em>consistency</em> (انسجام) را تضمین کنند. ما قادر به تضمین <em>consistency</em> (انسجام) نیستیم، بنابراین تنها گزینه ما این است که از پاسخگویی به <em>request</em> (درخواست) خودداری کنیم. به عبارت دیگر، ما <em>availability</em> (در دسترس بودن) را قربانی کرده‌ایم. سیستم ما منسجم و <em>partition tolerant</em> (تحمل پارتیشن) است، یا <em>CP</em>. در این حالت، <em>service</em> (سرویس) ما باید دریابد که چگونه عملکرد را تا زمانی که <em>partition</em> (پارتیشن) برطرف شود و گره‌های <em>database</em> (پایگاه داده) بتوانند دوباره همگام‌سازی شوند، کاهش دهد.</p>
<p><em>Consistency</em> (انسجام) در گره‌های متعدد واقعاً سخت است. موارد کمی (شاید هیچ‌چیز) در سیستم‌های توزیع‌شده سخت‌تر از آن نیست. لحظه‌ای به آن فکر کنید. تصور کنید که من می‌خواهم یک رکورد را از گره <em>database</em> (پایگاه داده) محلی بخوانم. چگونه می‌دانم که به‌روز است؟ من باید بروم و از گره دیگر بپرسم. اما من همچنین باید از آن گره <em>database</em> (پایگاه داده) بخواهم که در حین تکمیل خواندن، به آن اجازه به روزرسانی ندهد؛ به عبارت دیگر، من نیاز به شروع یک <em>transactional</em> (تراکنشی)</p>
<p><em>410 | Chapter 12: Resiliency</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0436</div>
            </div>
        </div>
        <!-- Page 0437 -->
        <div class="chapter" id="page-0437">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>خواندن در گره‌های متعدد <em>database</em> (پایگاه داده) برای اطمینان از <em>consistency</em> (انسجام). اما به‌طور کلی مردم <em>transactional reads</em> (خوانش تراکنشی) انجام نمی‌دهند، آیا انجام می‌دهند؟ زیرا <em>transactional reads</em> (خوانش تراکنشی) کند هستند. آنها به قفل نیاز دارند. یک خواندن می‌تواند یک سیستم کامل را مسدود کند.</p>
<p>همانطور که قبلاً بحث کردیم، سیستم‌های توزیع‌شده باید انتظار شکست را داشته باشند. <em>transactional read</em> (خوانش تراکنشی) ما را در یک مجموعه از گره‌های منسجم در نظر بگیرید. من از یک گره از راه دور می‌خواهم تا یک رکورد معین را در حالی که خواندن آغاز می‌شود، قفل کند. من خواندن را تکمیل می‌کنم و از گره از راه دور می‌خواهم که قفل خود را رها کند، اما اکنون من نمی‌توانم با آن صحبت کنم. اکنون چه اتفاقی می‌افتد؟ حتی درست کردن قفل‌ها در یک سیستم تک فرآیندی واقعاً دشوار است و پیاده‌سازی خوب آنها در یک سیستم توزیع‌شده به‌طور قابل‌توجهی دشوارتر است.</p>
<p>به یاد دارید که ما در فصل 6 در مورد <em>distributed transactions</em> (تراکنش‌های توزیع‌شده) صحبت کردیم؟ دلیل اصلی دشوار بودن آنها به دلیل این مشکل در اطمینان از <em>consistency</em> (انسجام) در گره‌های متعدد است.</p>
<p>درست کردن <em>consistency</em> (انسجام) چند گره‌ای واقعاً سخت است، بنابراین من قویاً، قویاً پیشنهاد می‌کنم که اگر به آن نیاز دارید، سعی نکنید آن را خودتان اختراع کنید. در عوض، یک انبار داده یا سرویس قفل را انتخاب کنید که این ویژگی‌ها را ارائه می‌دهد. به عنوان مثال، <em>Consul</em>، که ما در "<em>Dynamic Service Registries</em>" در صفحه 159 در مورد آن بحث کردیم، یک انبار کلید-مقدار با <em>consistency</em> (انسجام) قوی پیاده‌سازی می‌کند که برای به اشتراک گذاشتن پیکربندی بین گره‌های متعدد طراحی شده است. همراه با "دوستان به دوستان اجازه نمی‌دهند که رمزنگاری خود را بنویسند" باید "دوستان به دوستان اجازه نمی‌دهند که انبار داده‌های منسجم توزیع‌شده خود را بنویسند." را اضافه کرد. اگر شما فکر می‌کنید که نیاز دارید که انبار داده <em>CP</em> خود را بنویسید، ابتدا تمام مقالات این موضوع را بخوانید، سپس دکترا بگیرید، و سپس مشتاقانه منتظر باشید که چند سال را صرف اشتباه انجام دادن آن کنید. در ضمن، من از چیزی که از قفسه خارج شده استفاده می‌کنم که این کار را برای من انجام می‌دهد، یا به احتمال زیاد تلاش می‌کنم سیستم‌های <em>AP</em> با <em>eventually consistent</em> (سازگاری نهایی) را بسازم.</p>
<h5>Sacrificing Partition Tolerance (قربانی کردن تحمل پارتیشن)؟</h5>
<p>ما باید دو مورد را انتخاب کنیم، درست است؟ بنابراین ما سیستم <em>AP</em> با <em>eventually consistent</em> (سازگاری نهایی) خود را داریم. ما سیستم <em>CP</em> منسجم اما دشوار برای ساخت و مقیاس‌بندی خود را داریم. چرا یک سیستم <em>CA</em> (منسجم و در دسترس) نه؟ خوب، ما چگونه می‌توانیم <em>partition tolerance</em> (تحمل پارتیشن) را قربانی کنیم؟ اگر سیستم ما هیچ <em>partition tolerance</em> (تحمل پارتیشن) نداشته باشد، نمی‌تواند بر روی یک شبکه اجرا شود. به عبارت دیگر، باید یک فرآیند واحد باشد که به‌صورت محلی کار می‌کند. سیستم‌های <em>CA</em> در سیستم‌های توزیع‌شده وجود ندارند.</p>
<h5>AP or CP? (AP یا CP؟)</h5>
<p>کدام درست است، <em>AP</em> یا <em>CP</em>؟ خوب، واقعیت این است که این بستگی دارد. به عنوان افرادی که سیستم را می‌سازیم، ما می‌دانیم که این مبادله وجود دارد. ما می‌دانیم که سیستم‌های <em>AP</em> راحت‌تر مقیاس می‌شوند و ساخت آنها ساده‌تر است، و ما می‌دانیم که یک سیستم <em>CP</em> به دلیل چالش‌های پشتیبانی از <em>distributed consistency</em> (انسجام توزیع‌شده) به کار بیشتری نیاز دارد. اما ما ممکن است تأثیر تجاری این <em>trade-off</em> (مبادله) را درک نکنیم. برای سیستم انبار ما، اگر یک رکورد پنج دقیقه از تاریخ گذشته باشد، آیا این مشکلی ندارد؟ اگر پاسخ مثبت است، یک سیستم <em>AP</em> ممکن است راه‌حل باشد. اما در مورد موجودی نگه داشته شده برای یک مشتری در یک بانک چطور؟ آیا این می‌تواند از تاریخ گذشته باشد؟ بدون دانستن زمینه‌ای که عملیات در آن استفاده می‌شود، ما نمی‌توانیم</p>
<p><em>CAP Theorem | 411</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0437</div>
            </div>
        </div>
        <!-- Page 0438 -->
        <div class="chapter" id="page-0438">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>می‌دانید کار درست را انجام دهید. دانستن در مورد قضیه <em>CAP</em> به شما کمک می‌کند که درک کنید که این <em>trade-off</em> (مبادله) وجود دارد و چه سوالاتی را باید بپرسید.</p>
<h5>It’s Not All or Nothing (همه‌چیز یا هیچ‌چیز نیست)</h5>
<p>لازم نیست سیستم ما به‌طور کلی <em>AP</em> (در دسترس و تحمل‌کننده پارتیشن) یا <em>CP</em> (منسجم و تحمل‌کننده پارتیشن) باشد. فهرست <em>MusicCorp</em> (موزیک‌کورپ) ما می‌تواند <em>AP</em> (در دسترس و تحمل‌کننده پارتیشن) باشد، زیرا ما خیلی نگران یک رکورد منسوخ شده نیستیم. اما ما ممکن است تصمیم بگیریم که <em>inventory service</em> (سرویس انبار) ما نیاز دارد که <em>CP</em> (منسجم و تحمل‌کننده پارتیشن) باشد، زیرا ما نمی‌خواهیم چیزی را به یک مشتری بفروشیم که نداریم و بعداً مجبور به عذرخواهی شویم.</p>
<p>اما حتی <em>services</em> (سرویس‌های) جداگانه نیز نیازی نیست که <em>CP</em> (منسجم و تحمل‌کننده پارتیشن) یا <em>AP</em> (در دسترس و تحمل‌کننده پارتیشن) باشند.</p>
<p>بیایید به <em>Points Balance microservice</em> (ریز سرویس موجودی امتیاز) خود فکر کنیم، که در آن ما رکوردهایی از تعداد امتیازات وفاداری که مشتریان ما جمع‌آوری کرده‌اند، ذخیره می‌کنیم. ما می‌توانیم تصمیم بگیریم که ما اهمیتی نمی‌دهیم که موجودی که برای یک مشتری نشان می‌دهیم، منسوخ شده است، اما وقتی نوبت به به‌روزرسانی یک موجودی می‌رسد، ما به این نیاز داریم که منسجم باشد تا اطمینان حاصل شود که مشتریان بیش از آنچه در دسترس دارند، استفاده نمی‌کنند. آیا این <em>microservice</em> (ریز سرویس) <em>CP</em> (منسجم و تحمل‌کننده پارتیشن) است، یا <em>AP</em> (در دسترس و تحمل‌کننده پارتیشن)، یا هر دو؟ در واقع، کاری که ما انجام داده‌ایم این است که <em>trade-offs</em> (تبعات) پیرامون قضیه <em>CAP</em> را به قابلیت‌های <em>microservice</em> (ریز سرویس) فردی منتقل می‌کنیم.</p>
<p>یک پیچیدگی دیگر این است که نه <em>consistency</em> (انسجام) و نه <em>availability</em> (در دسترس بودن) همه یا هیچ‌چیز نیستند.
    بسیاری از سیستم‌ها به ما یک <em>trade-off</em> (مبادله) بسیار ظریف‌تری را می‌دهند. به عنوان مثال، با <em>Cassandra</em> من می‌توانم <em>trade-offs</em> (تبعات) متفاوتی را برای فراخوانی‌های فردی انجام دهم. بنابراین اگر من نیاز به <em>consistency</em> (انسجام) دقیق داشته باشم، من می‌توانم یک خواندن را انجام دهم که مسدود می‌شود تا زمانی که همه <em>replicas</em> (تکثیرها) پاسخ دهند، تأیید اینکه مقدار منسجم است، یا تا زمانی که یک <em>quorum</em> (حد نصاب) خاص از <em>replicas</em> (تکثیرها) پاسخ دهند، یا حتی فقط یک گره واحد. بدیهی است، اگر من منتظر پاسخگویی همه <em>replicas</em> (تکثیرها) باشم و یکی از آنها در دسترس نباشد، من برای مدت طولانی مسدود خواهم بود. از طرف دیگر، اگر من می‌خواستم که خواندن من تا حد امکان سریع پاسخ دهد، من ممکن است منتظر بمانم تا فقط از یک گره واحد پاسخ بشنوم—که در این صورت این امکان وجود دارد که این یک دیدگاه ناسازگار از داده‌های من باشد.</p>
<p>شما اغلب پست‌هایی را در مورد افرادی که قضیه <em>CAP</em> را "شکست می‌دهند" می‌بینید. آنها این کار را نکرده‌اند. آنچه آنها انجام داده‌اند، ایجاد سیستمی است که در آن برخی از قابلیت‌ها <em>CP</em> هستند، و برخی <em>AP</em>. اثبات ریاضی پشت قضیه <em>CAP</em> معتبر است.</p>
<h5>And the Real World (و دنیای واقعی)</h5>
<p>بخش زیادی از آنچه ما در مورد آن صحبت کردیم، دنیای الکترونیکی بود—بیت‌ها و بایت‌های ذخیره شده در حافظه. ما در مورد <em>consistency</em> (انسجام) به شیوه‌ای تقریباً کودکانه صحبت می‌کنیم؛ ما تصور می‌کنیم که در محدوده سیستمی که ایجاد کرده‌ایم، می‌توانیم جهان را متوقف کنیم و همه چیز را منطقی کنیم. و با این حال، بخش زیادی از آنچه ما می‌سازیم، فقط بازتابی از دنیای واقعی است، و ما نمی‌توانیم آن را کنترل کنیم، می‌توانیم؟</p>
<p>بیایید به سیستم انبار خودمان برگردیم. این به موارد فیزیکی دنیای واقعی نگاشت می‌شود. ما در سیستم خود یک شمارش از اینکه چند آلبوم در انبارهای <em>MusicCorp</em> (موزیک‌کورپ) داریم، نگه می‌داریم. در ابتدای روز ما 100 نسخه از <em>Give Blood</em> اثر <em>the Brakes</em> داشتیم. ما یکی را فروختیم. حالا ما 99 نسخه داریم. آسان است، درست است؟ اما اگر هنگام ارسال سفارش چه اتفاقی می‌افتد،</p>
<p><em>CAP Theorem | 411</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0438</div>
            </div>
        </div>
        <!-- Page 0439 -->
        <div class="chapter" id="page-0439">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>یک نفر یک نسخه از آلبوم را روی زمین می‌اندازد و روی آن پا می‌گذارد و می‌شکند؟ اکنون چه اتفاقی می‌افتد؟ سیستم‌های ما می‌گویند که 99 نسخه روی قفسه وجود دارد، اما در واقع فقط 98 نسخه وجود دارد.</p>
<p>اگر ما سیستم انبار خود را به جای آن <em>AP</em> (در دسترس و تحمل‌کننده پارتیشن) بسازیم، و ما گاهی اوقات مجبور شویم بعداً با یک کاربر تماس بگیریم و به او بگوییم که یکی از اقلام او در واقع موجودی ندارد؟ آیا این بدترین چیز در دنیا خواهد بود؟ مطمئناً ساخت و مقیاس‌بندی آن بسیار آسان‌تر خواهد بود و اطمینان حاصل می‌شود که درست است.</p>
<p>ما باید تشخیص دهیم که مهم نیست سیستم‌های ما چقدر خودشان منسجم هستند، آنها نمی‌توانند همه اتفاقاتی را که رخ می‌دهد، بدانند، به‌خصوص وقتی که ما در حال نگهداری سوابق دنیای واقعی هستیم. این یکی از دلایل اصلی است که سیستم‌های <em>AP</em> در بسیاری از موقعیت‌ها به عنوان راه‌حل مناسب شناخته می‌شوند.</p>
<h5>Antifragility (ضد شکنندگی)</h5>
<p>در چاپ اول، من در مورد مفهوم <em>antifragile</em> (ضد شکننده) صحبت کردم، که توسط <em>Nassim Taleb</em> محبوب شده است. این مفهوم چگونگی سود بردن سیستم‌ها از شکست و بی‌نظمی را توصیف می‌کند و به عنوان الهامی برای نحوه عملکرد برخی از بخش‌های <em>Netflix</em>، به‌ویژه در رابطه با مفاهیمی مانند <em>chaos engineering</em> (مهندسی آشوب) برجسته شد. با این حال، وقتی به مفهوم <em>resiliency</em> (مقاومت) به‌طور گسترده‌تر نگاه می‌کنیم، متوجه می‌شویم که <em>antifragility</em> (ضد شکنندگی) فقط یک زیرمجموعه از مفهوم <em>resiliency</em> (مقاومت) است. هنگامی که ما مفاهیم <em>graceful extensibility</em> (قابلیت توسعه با ظرافت) و <em>sustained adaptability</em> (سازگاری پایدار) را که قبلاً معرفی کردیم، در نظر می‌گیریم، این موضوع روشن می‌شود.</p>
<p>من فکر می‌کنم که وقتی <em>antifragility</em> (ضد شکنندگی) به‌طور خلاصه، به یک مفهوم پرطرفدار در <em>IT</em> تبدیل شد، این کار در برابر پیش‌زمینه‌ای از ما انجام شد که به‌طور محدود در مورد <em>resiliency</em> (مقاومت) فکر می‌کردیم—جایی که ما فقط به <em>robustness</em> (استحکام) فکر می‌کردیم، و شاید در مورد <em>rebound</em> (بازگشت)، اما بقیه را نادیده می‌گرفتیم. با توجه به اینکه رشته <em>resilience engineering</em> (مهندسی مقاومت) در حال حاضر به رسمیت شناختن و کشش بیشتری دست یافته است، به نظر می‌رسد مناسب است که فراتر از اصطلاح <em>antifragile</em> (ضد شکننده) حرکت کنیم، در حالی که همچنان اطمینان حاصل می‌کنیم که برخی از ایده‌های پشت آن را که واقعاً و به‌درستی بخشی از <em>resiliency</em> (مقاومت) به عنوان یک کل هستند، برجسته می‌کنیم.</p>
<h5>Chaos Engineering (مهندسی آشوب)</h5>
<p>از زمان انتشار اولین نسخه این کتاب، یک تکنیک دیگر که توجه بیشتری را به خود جلب کرده است، <em>chaos engineering</em> (مهندسی آشوب) است. این نام برای شیوه‌های مورد استفاده در <em>Netflix</em> گرفته شده است، می‌تواند یک رویکرد مفید برای کمک به بهبود <em>resiliency</em> (مقاومت) شما باشد—یا از نظر اطمینان از اینکه سیستم‌های شما به اندازه‌ای که فکر می‌کنید مستحکم هستند، یا به عنوان بخشی از یک رویکرد به سمت <em>sustained adaptability</em> (سازگاری پایدار) سیستم شما.</p>
<p>در اصل از کارهایی که <em>Netflix</em> در داخل انجام می‌داد الهام گرفته شده است، اصطلاح <em>chaos engineering</em> (مهندسی آشوب) تا حدودی به دلیل توضیحات گیج‌کننده از آنچه به معنای آن است، مبارزه می‌کند. برای بسیاری، این به معنای "اجرای یک ابزار روی نرم‌افزار من و دیدن آنچه می‌گوید" است، چیزی که به طور استدلالی توسط این واقعیت که بسیاری از حامیان اصلی <em>chaos engineering</em> (مهندسی آشوب) کمک نمی‌شود</p>
<p><em>Chaos Engineering | 413</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0439</div>
            </div>
        </div>
        <!-- Page 0440 -->
        <div class="chapter" id="page-0440">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>6 <em>Kripa Krishnan</em>, “<em>Weathering the Unexpected</em>,” acmqueue 10, no. 9 (2012), https://oreil.ly/BCSQ7.</p>
<p>7 <em>Russ Miles</em>, <em>Learning Chaos Engineering</em> (<em>Sebastopol</em>: <em>O’Reilly</em>, 2019).</p>
<p>اغلب خودشان ابزارهایی را برای اجرا روی نرم‌افزار شما برای انجام، خب، مهندسی آشوب، می‌فروشند.
    به دست آوردن یک تعریف روشن از معنای <em>chaos engineering</em> (مهندسی آشوب) برای متخصصان آن دشوار است. بهترین تعریف (حداقل به نظر من) که من با آن مواجه شده‌ام این است:</p>
<p><em>Chaos Engineering</em> (مهندسی آشوب) رشته‌ای از آزمایش بر روی یک سیستم است تا اعتماد به توانایی سیستم در تحمل شرایط آشفته در تولید ایجاد شود.
    —اصول <em>Chaos Engineering</em> (مهندسی آشوب)</p>
<p>حالا کلمه سیستم در اینجا کارهای زیادی انجام می‌دهد. برخی این را به طور محدود به عنوان مؤلفه‌های نرم‌افزار و سخت‌افزار مشاهده می‌کنند. اما در زمینه مهندسی <em>resiliency</em> (مقاومت)، مهم است که ما سیستم را به‌عنوان کل افراد، فرآیندها، فرهنگ، و بله، نرم‌افزار و زیرساختی که در ایجاد محصول ما دخیل هستند، ببینیم.
    این بدان معناست که ما باید <em>chaos engineering</em> (مهندسی آشوب) را گسترده‌تر از "بیایید چند دستگاه را خاموش کنیم و ببینیم چه اتفاقی می‌افتد" در نظر بگیریم.</p>
<h5>Game Days (روزهای بازی)</h5>
<p>مدت‌ها قبل از اینکه <em>chaos engineering</em> (مهندسی آشوب) نام خود را داشته باشد، مردم تمرین‌های <em>Game Day</em> (روز بازی) را برای آزمایش آمادگی مردم برای رویدادهای خاص اجرا می‌کردند. این کارها از قبل برنامه‌ریزی شده‌اند اما در حالت ایده‌آل به‌طور غافلگیرانه (برای شرکت‌کنندگان) راه‌اندازی می‌شوند، این به شما این شانس را می‌دهد که افراد و فرآیندهای خود را در پی یک موقعیت واقعی اما خیالی آزمایش کنید. در زمان حضورم در <em>Google</em>، این یک اتفاق نسبتاً رایج برای سیستم‌های مختلف بود، و من قطعاً فکر می‌کنم که بسیاری از سازمان‌ها می‌توانند از داشتن این نوع تمرین‌ها به‌طور منظم، بهره‌مند شوند. گوگل فراتر از تست‌های ساده برای تقلید از خرابی سرور می‌رود، و به عنوان بخشی از تمرین‌های <em>DiRT</em> (<em>Disaster Recovery Test</em> (تست بازیابی فاجعه)) خود، فجایع در مقیاس بزرگ مانند زلزله را شبیه‌سازی کرده است.6</p>
<p><em>Game Days</em> (روزهای بازی) را می‌توان برای بررسی منابع ضعف مشکوک در سیستم استفاده کرد. در کتاب خود، <em>Learning Chaos Engineering</em> (آموزش مهندسی آشوب)،7 <em>Russ Miles</em> (راس مایلز) نمونه‌ای از تمرین <em>Game Day</em> (روز بازی) را به اشتراک می‌گذارد که او تسهیل کرده بود و تا حدی برای بررسی اتکای بیش از حد به یک عضو واحد از کارکنان به نام <em>Bob</em> (باب) طراحی شده بود. برای <em>Game Day</em> (روز بازی)، <em>Bob</em> (باب) در یک اتاق قرنطینه شده بود و نمی‌توانست در طول قطعی شبیه‌سازی‌شده به تیم کمک کند. با این حال، <em>Bob</em> (باب) در حال مشاهده بود، و در نهایت مجبور شد وارد عمل شود وقتی که تیم، در تلاش خود برای رفع مشکلات سیستم "جعلی"، به‌اشتباه وارد تولید شد و در حال نابود کردن داده‌های تولید بود. فقط می‌توان فرض کرد که درس‌های زیادی در پی آن تمرین آموخته شد.</p>
<p><em>414 | Chapter 12: Resiliency</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0440</div>
            </div>
        </div>
        <!-- Page 0441 -->
        <div class="chapter" id="page-0441">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>Production Experiments (آزمایش‌های تولید)</em></p>
<p>مقیاسی که <em>Netflix</em> در آن فعالیت می‌کند، به‌خوبی شناخته شده است، همانطور که این واقعیت نیز شناخته شده است که <em>Netflix</em> به‌طور کامل بر روی زیرساخت <em>AWS</em> (آزمایش‌ها) متکی است. این دو عامل به این معنی است که باید شکست را خوب بپذیرد. <em>Netflix</em> متوجه شد که برنامه‌ریزی برای شکست و واقعاً دانستن اینکه نرم‌افزار شما این شکست را در هنگام وقوع مدیریت می‌کند، دو چیز متفاوت هستند. برای این منظور، <em>Netflix</em> در واقع باعث ایجاد شکست می‌شود تا اطمینان حاصل کند که سیستم‌هایش در برابر شکست، با اجرای ابزارهایی روی سیستم‌هایش، مقاوم هستند.</p>
<p>مشهورترین این ابزارها، <em>Chaos Monkey</em> است، که در ساعات معینی از روز، ماشین‌های تصادفی را در تولید خاموش می‌کند. دانستن اینکه این می‌تواند و در تولید اتفاق خواهد افتاد، به این معنی است که توسعه‌دهندگانی که سیستم‌ها را ایجاد می‌کنند، واقعاً باید برای آن آماده باشند. <em>Chaos Monkey</em> تنها یک بخش از <em>Simian Army</em> (ارتش میمون) بات‌های شکست <em>Netflix</em> است. از <em>Chaos Gorilla</em> برای از بین بردن کل <em>availability zone</em> (منطقه در دسترس بودن) (معادل <em>data center</em> (مرکز داده) <em>AWS</em>) استفاده می‌شود، در حالی که <em>Latency Monkey</em> (میمون تأخیر) اتصال شبکه کند بین دستگاه‌ها را شبیه‌سازی می‌کند. برای بسیاری، آزمایش نهایی اینکه آیا سیستم شما واقعاً مقاوم است یا خیر، ممکن است رها کردن <em>Simian Army</em> (ارتش میمون) خودتان بر روی زیرساخت تولید شما باشد.</p>
<h5>From Robustness to Beyond (از استحکام تا فراتر)</h5>
<p>اگر به باریک‌ترین شکل خود اعمال شود، <em>chaos engineering</em> (مهندسی آشوب) می‌تواند یک فعالیت مفید از نظر بهبود <em>robustness</em> (استحکام) برنامه ما باشد. به یاد داشته باشید، <em>robustness</em> (استحکام) در زمینه مهندسی <em>resilience</em> (مقاومت) به معنای میزان توانایی سیستم ما در مدیریت مشکلات مورد انتظار است. <em>Netflix</em> می‌دانست که نمی‌تواند به در دسترس بودن هر ماشین مجازی در محیط تولید خود تکیه کند، بنابراین <em>Chaos Monkey</em> را ساخت تا اطمینان حاصل کند که سیستم آن می‌تواند از این مشکل مورد انتظار جان سالم به در ببرد.</p>
<p>با این حال، اگر شما از <em>chaos engineering</em> (ابزارسازی مهندسی آشوب) به عنوان بخشی از یک رویکرد برای زیر سؤال بردن مداوم <em>resilience</em> (مقاومت) سیستم خود استفاده می‌کنید، این می‌تواند قابلیت کاربرد بسیار بیشتری داشته باشد. استفاده از ابزارهای این فضا برای کمک به پاسخگویی به سؤالات "چه می‌شود اگر" که ممکن است داشته باشید، و به‌طور مداوم درک خود را زیر سؤال می‌برید، می‌تواند تأثیر بسیار بیشتری داشته باشد. <em>The Chaos Toolkit</em> یک پروژه متن‌باز برای کمک به شما در اجرای آزمایش‌ها روی سیستم خود است، و بسیار محبوب بوده است. <em>Reliably</em>، شرکتی که توسط خالقان <em>Chaos Toolkit</em> (جعبه ابزار آشوب) تأسیس شده است، طیف وسیع‌تری از ابزارها را برای کمک به <em>chaos engineering</em> (مهندسی آشوب) به‌طور کلی ارائه می‌دهد، اگرچه شاید شناخته‌شده‌ترین فروشنده در این فضا <em>Gremlin</em> (گریملین) باشد.</p>
<p>فقط به یاد داشته باشید، اجرای یک ابزار <em>chaos engineering</em> (مهندسی آشوب) شما را مقاوم نمی‌کند.</p>
<h5>Blame (سرزنش)</h5>
<p>وقتی اوضاع اشتباه پیش می‌رود، راه‌های زیادی برای برخورد با آن وجود دارد. بدیهی است، در پی‌آمد فوری، تمرکز ما بر بازگرداندن امور و راه‌اندازی مجدد است، که منطقی است. پس از آن، اغلب، سرزنش‌ها می‌آیند. یک موقعیت پیش‌فرض برای جستجوی چیزی یا کسی برای سرزنش وجود دارد. مفهوم "<em>root cause analysis</em>" (تحلیل علت ریشه‌ای)</p>
<p><em>CAP Theorem | 411</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0441</div>
            </div>
        </div>
        <!-- Page 0442 -->
        <div class="chapter" id="page-0442">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>مروری بر قطع گسترده Telstra و پیامدهای آن</h3>
<p>در این بخش، به بررسی یک رویداد مهم در دنیای فناوری می‌پردازیم و آن را از دیدگاه مهندسی نرم‌افزار تحلیل می‌کنیم. این رویداد، قطع گسترده خدمات شرکت Telstra در استرالیا بود که در سال 2016 رخ داد.</p>
<p>8 <em>Kate Aubusson and Tim Biggs</em>، “Major Telstra Mobile Outage Hits Nationwide, with Calls and Data Affected,” <em>Sydney Morning Herald</em>, February 9, 2016, <a href="https://oreil.ly/4cBcy">https://oreil.ly/4cBcy</a>.</p>
<p>9 من در مورد حادثه Telstra در آن زمان بیشتر نوشتم — “Telstra, Human Error and Blame Culture,” <a href="https://oreil.ly/OXgUQ">https://oreil.ly/OXgUQ</a>. وقتی آن پست وبلاگ را نوشتم، متوجه نشدم که شرکتی که برای آن کار می‌کردم، Telstra را به عنوان مشتری داشت؛ کارفرمای من در آن زمان واقعاً وضعیت را بسیار خوب مدیریت کرد، حتی اگر چند ساعت ناراحت‌کننده‌ای را به وجود آورد که برخی از نظرات من توسط مطبوعات ملی انتخاب شد.</p>
<p>این اتفاق نشان می‌دهد که یک <strong>علت ریشه‌ای</strong> وجود دارد. تعجب‌آور است که چقدر ما می‌خواهیم این علت ریشه‌ای یک <strong>انسان</strong> باشد.</p>
<p>چند سال پیش، زمانی که در استرالیا کار می‌کردم، Telstra، اپراتور اصلی تلفن (و انحصارگر قبلی) یک قطع گسترده خدمات داشت که بر هر دو سرویس <strong>voice</strong> و <strong>telephony</strong> تأثیر گذاشت. این حادثه به دلیل دامنه و مدت زمان قطعی، به‌طور ویژه مشکل‌ساز بود. استرالیا دارای جوامع روستایی بسیار منزوی زیادی است و قطعی‌هایی از این قبیل، تمایل دارند که به‌ویژه جدی باشند. تقریباً بلافاصله پس از قطعی، مدیر عملیاتی Telstra بیانیه‌ای صادر کرد که مشخص کرد دقیقاً می‌دانند چه چیزی باعث این مشکل شده است:</p>
<p>“ما آن <strong>node</strong> را متوقف کردیم، متاسفانه فردی که آن مسئله را مدیریت می‌کرد، روش صحیح را دنبال نکرد و او مشتریان را دوباره به <strong>node</strong> دچار اختلال متصل کرد، به جای اینکه آنها را به ۹ <strong>node</strong>  اضافی که باید مردم را به آن منتقل می‌کرد، انتقال دهد.” خانم مک‌کنزی بعد از ظهر سه‌شنبه به خبرنگاران گفت.</p>
<p>“ما از تمام مشتریان خود عذرخواهی می‌کنیم. این یک خطای انسانی شرم‌آور است.”</p>
<p>بنابراین، اولاً توجه داشته باشید که این بیانیه چند ساعت پس از قطعی صادر شد. و با این حال، Telstra قبلاً آنچه را که باید یک سیستم بسیار پیچیده برای دانستن دقیقاً چه چیزی مقصر است - یک فرد - باز کرده بود. حال، اگر این درست باشد که یک نفر با اشتباه کردن واقعاً می‌تواند یک <strong>telco</strong> را به زانو درآورد، فکر می‌کنید این بیشتر در مورد <strong>telco</strong> است تا فرد. علاوه بر این، Telstra در آن زمان به وضوح به کارکنان خود سیگنال داد که بسیار خوشحال است که انگشت را به سمت دیگران نشانه رود و مقصر را مشخص کند.</p>
<p>مشکل سرزنش مردم در پی حوادثی از این دست این است که آنچه به عنوان یک سرزنش کوتاه‌مدت شروع می‌شود، در نهایت فرهنگی از ترس را ایجاد می‌کند، که در آن مردم تمایلی به جلو آمدن برای گفتن به شما ندارند که چه زمانی اشتباهی رخ داده است. در نتیجه، شما فرصت یادگیری از شکست را از دست خواهید داد و خود را برای تکرار همان مشکلات آماده می‌کنید. ایجاد سازمانی که در آن مردم از امنیت برای اعتراف به اشتباهات خود برخوردار باشند، در ایجاد یک فرهنگ یادگیری ضروری است و به نوبه خود می‌تواند راه زیادی را به سمت ایجاد سازمانی طی کند که قادر به ایجاد <strong>software</strong> قوی‌تر باشد، جدا از مزایای آشکار ایجاد یک مکان شادتر برای کار.</p>
<p>بازگشت به Telstra، با علت سرزنش که به وضوح در تحقیقات عمیقی که تنها چند ساعت پس از قطعی سراسری انجام شد، مشخص شد، ما به وضوح انتظار هیچ قطع بعدی را نداریم، درست است؟ متاسفانه، Telstra یک رشته</p>
<p>416 | فصل 12: انعطاف‌پذیری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0442</div>
            </div>
        </div>
        <!-- Page 0443 -->
        <div class="chapter" id="page-0443">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>نگاهی عمیق‌تر به Telstra و اهمیت فرهنگ عاری از سرزنش</h3>
<p>10 <em>John Allspaw</em>, “Blameless Post-Mortems and a Just Culture,” <em>Code as Craft</em> (blog), Etsy, May 22, 2012, <a href="https://oreil.ly/7LzmL">https://oreil.ly/7LzmL</a>.</p>
<p>قطع بعدی خدمات. خطای انسانی بیشتر؟ شاید Telstra اینطور فکر می‌کرد—در پی این مجموعه حوادث، مدیر عملیات استعفا داد.</p>
<p>برای داشتن دیدگاهی آگاهانه‌تر در مورد چگونگی ایجاد سازمانی که در آن بتوانید بهترین استفاده را از اشتباهات ببرید و محیطی دلپذیرتر برای کارکنان خود ایجاد کنید، " Blameless Post-Mortems and a Just Culture" نوشته <em>John Allspaw</em> یک نقطه شروع عالی است. 10</p>
<p>در نهایت، همانطور که من قبلاً بارها در این فصل برجسته کرده‌ام، <strong>resiliency</strong> نیازمند یک ذهن پرسشگر است—تلاش برای بررسی مداوم نقاط ضعف در سیستم ما. این امر نیازمند یک فرهنگ یادگیری است و اغلب بهترین یادگیری می‌تواند در پی یک <strong>incident</strong> حاصل شود. بنابراین، حیاتی است که اطمینان حاصل کنید که وقتی بدترین اتفاق می‌افتد، تمام تلاش خود را می‌کنید تا محیطی را ایجاد کنید که در آن بتوانید اطلاعاتی را که پس از آن جمع‌آوری می‌کنید به حداکثر برسانید تا شانس تکرار آن را کاهش دهید.</p>
<h4>خلاصه</h4>
<p>از آنجایی که <strong>software</strong> ما برای زندگی کاربران ما حیاتی‌تر می‌شود، تمایل به بهبود <strong>resiliency</strong> <strong>software</strong> که ایجاد می‌کنیم، افزایش می‌یابد. همانطور که در این فصل دیدیم، اگرچه، ما نمی‌توانیم <strong>resiliency</strong> را فقط با فکر کردن در مورد <strong>software</strong> و زیرساخت‌های خود به دست آوریم. ما همچنین باید به مردم، فرآیندها و سازمان‌های خود فکر کنیم.</p>
<p>در این فصل ما به چهار مفهوم اصلی <strong>resiliency</strong>، همانطور که توسط <em>David Woods</em> توضیح داده شده است، نگاه کردیم:</p>
<ul>
<li><strong>Robustness</strong></li>
<p>توانایی جذب اختلالات مورد انتظار</p>
<li><strong>Rebound</strong></li>
<p>توانایی بازیابی پس از یک رویداد آسیب‌زا</p>
<li><strong>Graceful extensibility</strong></li>
<p>اینکه چقدر خوب با موقعیتی که غیرمنتظره است برخورد می‌کنیم</p>
<li><strong>Sustained adaptability</strong></li>
<p>توانایی انطباق مداوم با محیط‌های در حال تغییر، ذینفعان و مطالبات</p>
</ul>
<p>با نگاه دقیق‌تر به <strong>microservices</strong>، آنها به ما مجموعه‌ای از راه‌ها را ارائه می‌دهند که می‌توانیم <strong>robustness</strong> سیستم‌های خود را بهبود بخشیم. اما این <strong>robustness</strong> بهبود یافته رایگان نیست—شما همچنان باید تصمیم بگیرید که از کدام گزینه‌ها استفاده کنید. الگوهای پایداری کلیدی مانند <strong>circuit breakers</strong>، <strong>time-outs</strong>، <strong>redundancy</strong>، <strong>isolation</strong>، <strong>idempotency</strong>، و موارد مشابه، همگی ابزارهایی هستند که در اختیار دارید، اما شما باید تصمیم بگیرید که چه زمانی و کجا از آنها استفاده کنید. فراتر از این</p>
<p>خلاصه
   | 417
  </p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0443</div>
            </div>
        </div>
        <!-- Page 0444 -->
        <div class="chapter" id="page-0444">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>Resiliency و ناشناخته‌ها</h3>
<p>در حالی که به مفاهیم اصلی <strong>resiliency</strong> می‌پردازیم، باید همواره به دنبال چیزهایی باشیم که نمی‌دانیم.</p>
<p>شما همچنین باید مشخص کنید که چقدر <strong>resiliency</strong> می‌خواهید—و این تقریباً همیشه چیزی است که توسط کاربران و صاحبان کسب و کار سیستم شما تعریف می‌شود. به عنوان یک تکنسین، شما می‌توانید مسئول نحوه انجام کارها باشید، اما دانستن اینکه چه میزان <strong>resiliency</strong> مورد نیاز است، نیازمند ارتباط نزدیک، مکرر و خوب با کاربران و صاحبان محصول است.</p>
<p>بیایید به نقل قول <em>David Woods</em> از اوایل این فصل برگردیم، که ما از آن در بحث <strong>sustained adaptability</strong> استفاده کردیم:</p>
<p>مهم نیست که قبلاً چقدر خوب عمل کرده‌ایم، مهم نیست که چقدر موفق بوده‌ایم، آینده می‌تواند متفاوت باشد و ممکن است ما به خوبی سازگار نباشیم. ممکن است در مواجهه با آن آینده جدید، ناپایدار و شکننده باشیم.</p>
<p>پرسیدن سوالات یکسان بارها و بارها به شما کمک نمی‌کند تا درک کنید که آیا برای آینده نامشخص آماده‌اید یا خیر. شما نمی‌دانید که چه چیزی را نمی‌دانید—اتخاذ رویکردی که در آن دائماً در حال یادگیری هستید، دائماً در حال سوال پرسیدن هستید، کلید ایجاد <strong>resiliency</strong> است.</p>
<p>یک نوع از الگوی پایداری که به آن نگاه کردیم، <strong>redundancy</strong>، می‌تواند بسیار مؤثر باشد. این ایده به زیبایی به فصل بعدی ما می‌رود، جایی که ما به راه‌های مختلف برای مقیاس‌بندی <strong>microservices</strong> خود نگاه خواهیم کرد، که علاوه بر کمک به ما در مدیریت بار بیشتر، می‌تواند یک راه مؤثر برای کمک به ما در پیاده‌سازی <strong>redundancy</strong> در سیستم‌هایمان باشد، و بنابراین همچنین <strong>robustness</strong> سیستم‌های ما را بهبود بخشد.</p>
<p>418 | فصل 12: <strong>Resiliency</strong></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0444</div>
            </div>
        </div>
        <!-- Page 0445 -->
        <div class="chapter" id="page-0445">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>فصل 13</h3>
<h3>مقیاس‌پذیری</h3>
<p>“You’re gonna need a bigger boat.”</p>
<p>—Chief Brody, Jaws</p>
<p>وقتی سیستم‌های خود را مقیاس‌پذیر می‌کنیم، این کار را به یکی از دو دلیل انجام می‌دهیم. اولاً، به ما این امکان را می‌دهد که عملکرد سیستم خود را بهبود بخشیم، شاید با اجازه دادن به ما برای مدیریت بار بیشتر یا بهبود <strong>latency</strong>. ثانیاً، می‌توانیم سیستم خود را مقیاس‌پذیر کنیم تا <strong>robustness</strong> آن را بهبود بخشیم.</p>
<p>در این فصل، ما به یک مدل برای توصیف انواع مختلف مقیاس‌پذیری نگاه خواهیم کرد و سپس با جزئیات به این می‌پردازیم که چگونه هر نوع مقیاس‌پذیری می‌تواند با استفاده از معماری <strong>microservice</strong> پیاده‌سازی شود. در پایان این فصل، شما باید مجموعه‌ای از تکنیک‌ها را داشته باشید تا مسائل مربوط به مقیاس‌پذیری که ممکن است با آن مواجه شوید را مدیریت کنید.</p>
<p>با این حال، برای شروع، بیایید به انواع مختلف مقیاس‌پذیری که ممکن است بخواهید اعمال کنید، نگاهی بیندازیم.</p>
<h4>چهار محور مقیاس‌پذیری</h4>
<p>یک راه درست برای مقیاس‌پذیری یک سیستم وجود ندارد، زیرا تکنیک مورد استفاده به نوع محدودیتی که ممکن است داشته باشید بستگی دارد. ما تعدادی از انواع مختلف مقیاس‌پذیری را داریم که می‌توانیم برای کمک به عملکرد، <strong>robustness</strong>، یا شاید هر دو اعمال کنیم. مدلی که من اغلب برای توصیف انواع مختلف مقیاس‌پذیری استفاده کرده‌ام، <strong>Scale Cube</strong> از کتاب The Art of Scalability1 است، که مقیاس‌پذیری را به سه دسته تقسیم می‌کند که در زمینه سیستم‌های کامپیوتری، تجزیه عملکردی، تکثیر افقی و تقسیم داده‌ها را پوشش می‌دهد. ارزش این مدل این است که به شما کمک می‌کند تا درک کنید که می‌توانید یک سیستم را در امتداد یک، دو یا هر سه محور از این محورها، بسته به نیاز خود، مقیاس‌پذیر کنید.</p>
<p>1 <em>Martin L. Abbott and Michael T. Fisher</em>, <em>The Art of Scalability: Scalable Web Architecture, Processes, and Organizations for the Modern Enterprise</em>, 2nd ed. (New York: Addison-Wesley, 2015).</p>
<p>419</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0445</div>
            </div>
        </div>
        <!-- Page 0446 -->
        <div class="chapter" id="page-0446">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>محورهای مقیاس‌پذیری (ادامه)</h3>
<p>2 همانطور که قبلاً گفته شد، من نام شرکت را ناشناس کردم—FoodCo نام واقعی آن نیست!</p>
<p>با این حال، به‌ویژه در دنیای زیرساخت‌های مجازی، من همیشه احساس می‌کردم که این مدل فاقد یک محور چهارم از مقیاس‌پذیری عمودی است، اگرچه این ویژگی ناخوشایندی خواهد داشت که دیگر مکعب نباشد. با این وجود، من فکر می‌کنم این مجموعه مفیدی از مکانیسم‌ها برای ماست تا تعیین کنیم که چگونه بهترین راه برای مقیاس‌پذیری معماری‌های <strong>microservice</strong> خود را پیدا کنیم. قبل از اینکه به این انواع مقیاس‌پذیری با جزئیات، همراه با جوانب مثبت و منفی نسبی، نگاهی بیندازیم، یک خلاصه مختصر ضروری است:</p>
<ul>
<li>مقیاس‌پذیری عمودی</li>
<p>به طور خلاصه، این به معنای گرفتن یک ماشین بزرگتر است.</p>
<li>تکثیر افقی</li>
<p>داشتن چندین چیز که قادر به انجام کار مشابهی هستند.</p>
<li>تقسیم داده‌ها</li>
<p>تقسیم کار بر اساس برخی از ویژگی‌های داده‌ها، به عنوان مثال، گروه مشتری.</p>
<li>تجزیه عملکردی</li>
<p>جداسازی کار بر اساس نوع، به عنوان مثال، تجزیه <strong>microservice</strong>.</p>
</ul>
<p>درک اینکه کدام ترکیب از این تکنیک‌های مقیاس‌پذیری مناسب‌ترین است، اساساً به ماهیت مسئله مقیاس‌پذیری که با آن مواجه هستید، بستگی دارد. برای بررسی این موضوع با جزئیات بیشتر، و همچنین نگاهی به نمونه‌هایی از چگونگی پیاده‌سازی این مفاهیم برای MusicCorp، ما همچنین مناسب بودن آنها را برای یک شرکت واقعی، FoodCo، بررسی خواهیم کرد.2 FoodCo تحویل غذا را مستقیماً به مشتریان در تعدادی از کشورهای سراسر جهان ارائه می‌دهد.</p>
<h4>مقیاس‌پذیری عمودی</h4>
<p>برخی از عملیات‌ها فقط می‌توانند از قدرت بیشتر بهره ببرند. گرفتن یک <strong>box</strong> بزرگتر با <strong>CPU</strong> سریعتر و <strong>I/O</strong> بهتر اغلب می‌تواند <strong>latency</strong> و توان عملیاتی را بهبود بخشد و به شما امکان می‌دهد کارهای بیشتری را در زمان کمتری پردازش کنید. بنابراین اگر برنامه شما به اندازه کافی سریع نیست یا نمی‌تواند درخواست‌های کافی را مدیریت کند، چرا یک ماشین بزرگتر تهیه نکنید؟</p>
<p>در مورد FoodCo، یکی از چالش‌هایی که با آن مواجه است، افزایش رقابت نوشتن در پایگاه داده اصلی آن است. به طور معمول، مقیاس‌پذیری عمودی یک گزینه مطلق برای مقیاس‌بندی سریع نوشتن در یک پایگاه داده رابطه‌ای است و در واقع FoodCo قبلاً زیرساخت‌های پایگاه داده را چندین بار ارتقا داده است. مشکل این است که FoodCo واقعاً این کار را تا جایی که راحت است، پیش برده است. مقیاس‌پذیری عمودی برای سال‌های زیادی کارساز بود، اما با توجه به پیش‌بینی‌های رشد شرکت، حتی اگر FoodCo بتواند یک ماشین بزرگتر تهیه کند، بعید است که این مشکل را در بلندمدت حل کند.</p>
<p>از نظر تاریخی، زمانی که مقیاس‌پذیری عمودی نیازمند خرید سخت‌افزار بود، این تکنیک مشکل‌سازتر بود. زمان تحویل برای خرید سخت‌افزار به این معنی بود که این</p>
<p>420 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0446</div>
            </div>
        </div>
        <!-- Page 0447 -->
        <div class="chapter" id="page-0447">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مقیاس‌پذیری عمودی (ادامه)</h4>
<p>چیزی بود که می‌توانستید با آن سبک‌سنگین وارد شوید، و اگر مشخص می‌شد که داشتن یک ماشین بزرگتر مشکلات شما را حل نمی‌کند، احتمالاً مقدار زیادی پول را که نیازی نداشتید، خرج کرده‌اید. علاوه بر این، بزرگ‌نمایی ماشین مورد نیاز به دلیل دردسرهای دریافت تأییدیه‌های بودجه، انتظار برای رسیدن ماشین و غیره، معمول بود، که به نوبه خود منجر به ظرفیت استفاده‌نشده قابل توجهی در مراکز داده شد.</p>
<p>با این حال، حرکت به سمت مجازی‌سازی و ظهور <strong>public cloud</strong> به شدت به این شکل از مقیاس‌پذیری کمک کرده است.</p>
<h4>پیاده‌سازی</h4>
<p>پیاده‌سازی بسته به این که زیرساخت‌های شما روی چه چیزی اجرا می‌شود، متفاوت خواهد بود. اگر بر روی زیرساخت مجازی‌سازی شده خودتان اجرا می‌کنید، ممکن است بتوانید اندازه <strong>VM</strong> را تغییر دهید تا از سخت‌افزار زیربنایی بیشتری استفاده کنید—این چیزی است که باید سریع و نسبتاً بدون خطر پیاده‌سازی شود. اگر <strong>VM</strong> به اندازه سخت‌افزار زیربنایی بزرگ باشد، البته این گزینه شروع‌کننده نیست—شما ممکن است مجبور شوید سخت‌افزار بیشتری بخرید.</p>
<p>به همین ترتیب، اگر شما روی سرورهای <strong>bare metal</strong> خودتان اجرا می‌کنید و هیچ سخت‌افزار یدکی ندارید که بزرگتر از آنچه در حال حاضر روی آن اجرا می‌کنید باشد، پس دوباره، به خرید ماشین‌های بیشتر نگاه می‌کنید.</p>
<p>به طور کلی، اگر به نقطه‌ای رسیده‌ام که باید زیرساخت جدیدی بخرم تا مقیاس‌پذیری عمودی را امتحان کنم، به دلیل افزایش هزینه (و زمان) برای این که تأثیری داشته باشد، ممکن است این شکل از مقیاس‌پذیری را در حال حاضر نادیده بگیرم و در عوض به تکثیر افقی نگاه کنم، که در ادامه به آن خواهیم پرداخت.</p>
<p>اما ظهور <strong>public cloud</strong> همچنین به ما این امکان را داده است که به راحتی، بر اساس ساعت (و در برخی موارد حتی در کوتاه‌مدت)، ماشین‌های کاملاً مدیریت‌شده را از طریق فروشندگان <strong>public cloud</strong> اجاره کنیم. علاوه بر این، ارائه دهندگان اصلی <strong>cloud</strong> انواع گسترده‌تری از ماشین‌ها را برای انواع مختلف مشکلات ارائه می‌دهند. آیا حجم کاری شما از نظر حافظه فشرده‌تر است؟ به خودتان یک نمونه <strong>AWS u-24tb1.metal</strong> بدهید، که 24 ترابایت حافظه (بله، درست خواندید) ارائه می‌دهد. اکنون، تعداد حجم‌های کاری که ممکن است واقعاً به این مقدار حافظه نیاز داشته باشند، نسبتاً نادر به نظر می‌رسد، اما شما آن گزینه را دارید.
   شما همچنین ماشین‌هایی دارید که برای استفاده از <strong>I/O</strong>، <strong>CPU</strong> یا <strong>GPU</strong> بالا طراحی شده‌اند. اگر راه‌حل موجود شما در حال حاضر در <strong>public cloud</strong> است، این یک شکل بسیار پیش پا افتاده از مقیاس‌بندی است که باید امتحان کنید که اگر به دنبال یک برد سریع هستید، کمی بدیهی است.</p>
<h4>مزایای کلیدی</h4>
<p>در زیرساخت‌های مجازی، به ویژه در یک ارائه دهنده <strong>public cloud</strong>، پیاده‌سازی این شکل از مقیاس‌پذیری سریع خواهد بود. بسیاری از کارهای مربوط به مقیاس‌بندی برنامه‌ها به آزمایش می‌رسد—داشتن ایده‌ای در مورد چیزی که می‌تواند سیستم شما را بهبود بخشد، ایجاد تغییر و اندازه‌گیری تأثیر. فعالیت‌هایی که سریع و نسبتاً بدون خطر هستند، همیشه ارزش انجام دادن در مراحل اولیه را دارند. و مقیاس‌پذیری عمودی در اینجا مناسب است.</p>
<p>چهار محور مقیاس‌پذیری | 421</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0447</div>
            </div>
        </div>
        <!-- Page 0448 -->
        <div class="chapter" id="page-0448">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مقیاس‌پذیری عمودی (ادامه)</h4>
<p>همچنین شایان ذکر است که مقیاس‌پذیری عمودی می‌تواند سایر انواع مقیاس‌پذیری را آسان‌تر کند. به عنوان یک مثال مشخص، انتقال زیرساخت‌های پایگاه داده خود به یک ماشین بزرگتر ممکن است به آن اجازه دهد تا پایگاه‌های داده منزوی منطقی را برای <strong>microservices</strong> تازه ایجاد شده به عنوان بخشی از تجزیه عملکردی میزبانی کند.</p>
<p>کد یا پایگاه داده شما بعید است که برای استفاده از زیرساخت‌های زیربنایی بزرگتر، به هیچ تغییری نیاز داشته باشد، با فرض اینکه سیستم عامل و چیپست‌ها یکسان باقی بمانند. حتی اگر برای استفاده از تغییر سخت‌افزار، به تغییراتی در برنامه خود نیاز داشته باشید، ممکن است به مواردی مانند افزایش مقدار حافظه در دسترس زمان اجرا از طریق <strong>flags</strong> زمان اجرا محدود شوند.</p>
<h4>محدودیت‌ها</h4>
<p>همانطور که ما ماشین‌هایی را که روی آن‌ها اجرا می‌کنیم، مقیاس می‌کنیم، <strong>CPU</strong>‌های ما اغلب در واقع سریع‌تر نمی‌شوند. ما فقط هسته‌های بیشتری داریم. این یک تغییر در 5 تا 10 سال گذشته بوده است. قبلاً اینطور بود که هر نسل جدید از سخت‌افزار پیشرفت‌های بزرگی را در سرعت ساعت <strong>CPU</strong> ارائه می‌داد، به این معنی که برنامه‌های ما جهش‌های بزرگی در عملکرد داشتند. اگرچه پیشرفت‌های سرعت ساعت به شدت کاهش یافته است، اما در عوض ما هسته‌های <strong>CPU</strong> بیشتری برای کار کردن داریم. مشکل این است که اغلب <strong>software</strong> ما برای استفاده از سخت‌افزار چند هسته‌ای نوشته نشده است. این می‌تواند به این معنی باشد که جابجایی برنامه شما از یک سیستم 4 هسته‌ای به 8 هسته‌ای ممکن است پیشرفت کمی داشته باشد، حتی اگر سیستم موجود شما محدود به <strong>CPU</strong> باشد. تغییر کد برای استفاده از سخت‌افزار چند هسته‌ای می‌تواند یک اقدام مهم باشد و ممکن است نیاز به تغییر کامل در اصطلاحات برنامه‌نویسی داشته باشد.</p>
<p>داشتن یک ماشین بزرگتر نیز احتمالاً تأثیر کمی در بهبود <strong>robustness</strong> دارد. یک سرور بزرگتر و جدیدتر ممکن است قابلیت اطمینان را بهبود بخشد، اما در نهایت اگر آن ماشین از کار بیفتد، آنگاه ماشین از کار می‌افتد. برخلاف سایر اشکال مقیاس‌پذیری که به آنها نگاه خواهیم کرد، مقیاس‌پذیری عمودی بعید است که تأثیر زیادی در بهبود <strong>robustness</strong> سیستم شما داشته باشد.</p>
<p>در نهایت، با بزرگتر شدن ماشین‌ها، گران‌تر می‌شوند—اما نه همیشه به گونه‌ای که با افزایش منابع در دسترس شما مطابقت داشته باشد. گاهی اوقات این بدان معناست که داشتن تعداد بیشتری از ماشین‌های کوچک، به جای تعداد کمتری از ماشین‌های بزرگ، می‌تواند مقرون به صرفه‌تر باشد.</p>
<h4>تکثیر افقی</h4>
<p>با تکثیر افقی، شما بخشی از سیستم خود را برای مدیریت حجم کاری بیشتر تکرار می‌کنید. مکانیسم‌های دقیق متفاوت هستند—ما به زودی به پیاده‌سازی‌ها نگاه خواهیم کرد—اما اساساً تکثیر افقی مستلزم آن است که شما راهی برای توزیع کار در این نسخه‌های تکراری داشته باشید.</p>
<p>مانند مقیاس‌پذیری عمودی، این نوع مقیاس‌پذیری در انتهای ساده‌تر طیف قرار دارد و اغلب یکی از چیزهایی است که من در مراحل اولیه آن را امتحان می‌کنم. اگر سیستم <strong>monolithic</strong> شما نمی‌تواند بار را تحمل کند، چندین نسخه از آن را راه‌اندازی کنید و ببینید آیا این کمک می‌کند!</p>
<p>422 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0448</div>
            </div>
        </div>
        <!-- Page 0449 -->
        <div class="chapter" id="page-0449">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تکثیر افقی (ادامه)</h4>
<p>3 <em>Gregor Hohpe and Bobby Woolf</em>, <em>Enterprise Integration Patterns</em> (Boston: Addison-Wesley, 2003).</p>
<h4>پیاده‌سازی‌ها</h4>
<p>شاید بارزترین شکل تکثیر افقی که به ذهن می‌رسد، استفاده از یک <strong>load balancer</strong> برای توزیع درخواست‌ها در چندین نسخه از قابلیت‌های شما است، همانطور که در شکل 13-1 می‌بینیم، جایی که ما در حال ایجاد تعادل بار در چندین نمونه از <strong>microservice</strong> کاتالوگ MusicCorp هستیم. قابلیت‌های <strong>Load balancer</strong> متفاوت است، اما شما انتظار دارید که همه آنها مکانیزمی برای توزیع بار در سراسر <strong>nodes</strong> داشته باشند و تشخیص دهند که چه زمانی یک <strong>node</strong> در دسترس نیست و آن را از مجموعه <strong>load balancer</strong> حذف کنند.</p>
<p>از دیدگاه مصرف‌کننده، <strong>load balancer</strong> یک نگرانی پیاده‌سازی کاملاً شفاف است—ما می‌توانیم آن را در این مورد به عنوان بخشی از مرز منطقی <strong>microservice</strong> در نظر بگیریم. از نظر تاریخی، <strong>load balancers</strong> در درجه اول از نظر سخت‌افزار اختصاصی در نظر گرفته می‌شدند، اما این مدت‌هاست که دیگر رایج نیست—در عوض، تعادل بار بیشتر در <strong>software</strong> انجام می‌شود، که اغلب در سمت <strong>client</strong> اجرا می‌شود.</p>
<p>شکل 13-1. <strong>Microservice</strong> کاتالوگ به عنوان نمونه‌های متعدد مستقر شده است، با یک <strong>load balancer</strong> برای پخش درخواست‌ها</p>
<p>نمونه دیگری از تکثیر افقی می‌تواند الگوی مصرف‌کننده رقیب باشد، همانطور که در <em>Enterprise Integration Patterns</em> توضیح داده شده است.3 در شکل 13-2، ما آهنگ‌های جدیدی را می‌بینیم که به MusicCorp آپلود می‌شوند. این آهنگ‌های جدید باید به فایل‌های مختلف تبدیل شوند تا به عنوان بخشی از پیشنهاد پخش جریانی جدید MusicCorp استفاده شوند. ما یک صف مشترک از کار داریم که این مشاغل در آن قرار می‌گیرند، و مجموعه‌ای از نمونه‌های <strong>Song Transcoder</strong> همگی از صف استفاده می‌کنند—نمونه‌های مختلف بر سر مشاغل رقابت می‌کنند.</p>
<p>چهار محور مقیاس‌پذیری | 423</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 449" src="page_0449/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0449</div>
            </div>
        </div>
        <!-- Page 0450 -->
        <div class="chapter" id="page-0450">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تکثیر افقی (ادامه)</h4>
<p>افزایش توان عملیاتی سیستم، می‌توانیم تعداد نمونه‌های <strong>Song Transcoder</strong> را افزایش دهیم.</p>
<p>شکل 13-2. Transcoding برای پخش جریانی که با استفاده از الگوی مصرف‌کننده رقیب مقیاس‌بندی شده است</p>
<p>در مورد FoodCo، از یک شکل از تکثیر افقی برای کاهش بار خواندن در پایگاه داده اصلی از طریق استفاده از <strong>read replicas</strong> استفاده شده است، همانطور که در شکل 13-3 می‌بینیم. این باعث کاهش بار خواندن در <strong>node</strong> پایگاه داده اصلی شده است، که منابع را برای رسیدگی به نوشتن آزاد می‌کند، و بسیار مؤثر عمل کرده است، زیرا بار زیادی بر روی سیستم اصلی، سنگین خواندن بود. این خواندن‌ها می‌توانستند به راحتی به این <strong>read replicas</strong> هدایت شوند، و استفاده از یک <strong>load balancer</strong> بر روی چندین <strong>read replicas</strong> رایج است.</p>
<p>مسیردهی به پایگاه داده اصلی یا یک <strong>read replica</strong> به صورت داخلی در <strong>microservice</strong> انجام می‌شود. برای مصرف‌کنندگان این <strong>microservice</strong> شفاف است که آیا درخواستی که ارسال می‌کنند به پایگاه داده اصلی یا <strong>read replica</strong> می‌رسد یا خیر.</p>
<p>424 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 450" src="page_0450/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0450</div>
            </div>
        </div>
        <!-- Page 0451 -->
        <div class="chapter" id="page-0451">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تکثیر افقی (ادامه)</h4>
<p>شکل 13-3. FoodCo با استفاده از <strong>read replicas</strong> برای مقیاس‌بندی ترافیک خواندن</p>
<h4>مزایای کلیدی</h4>
<p>تکثیر افقی نسبتاً ساده است. به ندرت پیش می‌آید که برنامه نیاز به به‌روزرسانی داشته باشد، زیرا کار توزیع بار اغلب می‌تواند در جای دیگری انجام شود—به عنوان مثال، از طریق یک صف که بر روی یک <strong>message broker</strong> یا شاید در یک <strong>load balancer</strong> اجرا می‌شود. اگر مقیاس‌پذیری عمودی برای من در دسترس نباشد، این شکل از مقیاس‌پذیری معمولاً اولین چیزی است که به آن نگاه می‌کنم.</p>
<p>با فرض اینکه کار را می‌توان به راحتی در سراسر نسخه‌های تکراری پخش کرد، این یک راه ظریف برای پخش بار و کاهش رقابت برای منابع محاسباتی خام است.</p>
<h4>محدودیت‌ها</h4>
<p>مانند تقریباً همه گزینه‌های مقیاس‌بندی که به آنها نگاه خواهیم کرد، تکثیر افقی به زیرساخت‌های بیشتری نیاز دارد، که البته می‌تواند هزینه بیشتری داشته باشد. همچنین می‌تواند یک ابزار کمی کند باشد—به عنوان مثال، شما ممکن است چندین نسخه کامل از برنامه <strong>monolithic</strong> خود را اجرا کنید، حتی اگر فقط بخشی از آن <strong>monolith</strong> در واقع با مشکلات مقیاس‌پذیری مواجه باشد.</p>
<p>بخش زیادی از کار در اینجا، پیاده‌سازی مکانیسم‌های توزیع بار شما است. اینها می‌توانند از ساده، مانند تعادل بار <strong>HTTP</strong>، تا پیچیده‌تر، مانند استفاده از یک <strong>message broker</strong> یا پیکربندی <strong>database read replicas</strong> متغیر باشند. شما به این مکانیسم توزیع بار متکی هستید تا کار خود را انجام دهد—درک چگونگی عملکرد آن و محدودیت‌های انتخاب خاص شما کلیدی خواهد بود.</p>
<p>برخی از سیستم‌ها ممکن است الزامات اضافی را در مکانیسم توزیع بار قرار دهند. به عنوان مثال، آنها ممکن است نیاز داشته باشند که هر درخواست مرتبط با همان جلسه کاربری به همان <strong>replica</strong> هدایت شود. این را می‌توان از طریق استفاده از یک</p>
<p>چهار محور مقیاس‌پذیری | 425</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 451" src="page_0451/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0451</div>
            </div>
        </div>
        <!-- Page 0452 -->
        <div class="chapter" id="page-0452">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تکثیر افقی (ادامه)</h4>
<p><strong>load balancer</strong> که به <strong>sticky session load balancing</strong> نیاز دارد، اما این می‌تواند محدود کند که چه مکانیسم‌های توزیع باری را می‌توانید در نظر بگیرید. شایان ذکر است که سیستم‌هایی که به <strong>sticky load balancing</strong> مانند این نیاز دارند، مستعد مشکلات دیگری هستند، و به طور کلی، از ساختن سیستم‌هایی که این نیاز را دارند، خودداری می‌کنم.</p>
<h4>تقسیم داده‌ها</h4>
<p>با شروع با اشکال ساده‌تر مقیاس‌پذیری، اکنون وارد قلمرو دشوارتری می‌شویم. تقسیم داده‌ها مستلزم آن است که ما بار را بر اساس جنبه‌ای از داده‌ها توزیع کنیم—برای مثال، توزیع بار بر اساس کاربر.</p>
<h4>پیاده‌سازی</h4>
<p>نحوه عملکرد تقسیم داده‌ها این است که ما یک <strong>key</strong> مرتبط با حجم کار را می‌گیریم و یک تابع را به آن اعمال می‌کنیم، و نتیجه، پارتیشن (گاهی اوقات <strong>shard</strong> نامیده می‌شود) است که کار را به آن توزیع خواهیم کرد. در شکل 13-4، ما دو پارتیشن داریم، و تابع ما کاملاً ساده است—اگر نام خانوادگی با A تا M شروع شود، درخواست را به یک پایگاه داده و اگر نام خانوادگی با N تا Z شروع شود، به پایگاه داده دیگری ارسال می‌کنیم. حال، این در واقع یک مثال بد از یک الگوریتم پارتیشن‌بندی است (به زودی به چرایی این موضوع خواهیم پرداخت)، اما امیدوارم این به اندازه کافی ساده باشد تا ایده را نشان دهد.</p>
<p>شکل 13-4. داده‌های مشتری در دو پایگاه داده مختلف تقسیم شده است</p>
<p>در این مثال، ما در سطح پایگاه داده پارتیشن‌بندی می‌کنیم. یک درخواست به <strong>microservice</strong> مشتری می‌تواند به هر نمونه <strong>microservice</strong> برخورد کند. اما هنگامی که ما عملیاتی را انجام می‌دهیم که به پایگاه داده نیاز دارد (خواندن یا نوشتن)، آن درخواست بر اساس نام مشتری به <strong>node</strong> پایگاه داده مناسب هدایت می‌شود. در مورد یک پایگاه داده رابطه‌ای، <strong>schema</strong> هر دو <strong>node</strong> پایگاه داده یکسان خواهد بود، اما محتویات هر کدام فقط برای زیرمجموعه‌ای از مشتریان اعمال می‌شود.</p>
<p>426 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 452" src="page_0452/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0452</div>
            </div>
        </div>
        <!-- Page 0453 -->
        <div class="chapter" id="page-0453">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تقسیم داده‌ها (ادامه)</h4>
<p>تقسیم‌بندی در سطح پایگاه داده اغلب منطقی است اگر فناوری پایگاه داده‌ای که استفاده می‌کنید، بومی از این مفهوم پشتیبانی کند، زیرا در این صورت می‌توانید این مشکل را به یک پیاده‌سازی موجود واگذار کنید. با این حال، ما می‌توانیم به جای آن در سطح نمونه <strong>microservice</strong> پارتیشن‌بندی کنیم، همانطور که در شکل 13-5 می‌بینیم. در اینجا، ما باید بتوانیم از درخواست ورودی بفهمیم که درخواست باید به کدام پارتیشن نگاشت شود—در مثال ما، این کار از طریق نوعی <strong>proxy</strong> انجام می‌شود. در مورد مدل پارتیشن‌بندی مبتنی بر مشتری ما، اگر نام مشتری در <strong>headers</strong> درخواست باشد، این کافی خواهد بود. این رویکرد منطقی است اگر می‌خواهید نمونه‌های <strong>microservice</strong> اختصاصی برای پارتیشن‌بندی داشته باشید، که اگر از <strong>in-memory caching</strong> استفاده می‌کنید، می‌تواند مفید باشد. همچنین به این معنی است که شما می‌توانید هر پارتیشن را در سطح پایگاه داده و سطح نمونه <strong>microservice</strong> مقیاس‌بندی کنید.</p>
<p>شکل 13-5. درخواست‌ها به نمونه <strong>microservice</strong> مناسب هدایت می‌شوند</p>
<p>همانطور که در مثال <strong>read replicas</strong>، ما می‌خواهیم این مقیاس‌بندی به گونه‌ای انجام شود که مصرف‌کنندگان <strong>microservice</strong> از این جزئیات پیاده‌سازی بی‌اطلاع باشند. هنگامی که یک مصرف‌کننده درخواستی را به <strong>microservice</strong> مشتری در شکل 13-5 ارسال می‌کند، ما می‌خواهیم درخواست آنها به طور پویا به پارتیشن صحیح هدایت شود. این واقعیت که ما تقسیم داده‌ها را پیاده‌سازی کرده‌ایم باید به عنوان یک جزئیات پیاده‌سازی داخلی <strong>microservice</strong> مورد نظر در نظر گرفته شود—این به ما آزادی می‌دهد تا طرح پارتیشن‌بندی را تغییر دهیم، یا شاید پارتیشن‌بندی را به طور کلی جایگزین کنیم.</p>
<p>چهار محور مقیاس‌پذیری | 427</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 453" src="page_0453/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0453</div>
            </div>
        </div>
        <!-- Page 0454 -->
        <div class="chapter" id="page-0454">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تقسیم داده‌ها (ادامه)</h4>
<p>مثال رایج دیگر از تقسیم داده‌ها، انجام آن بر اساس جغرافیایی است. شما ممکن است یک پارتیشن برای هر کشور، یا یک پارتیشن برای هر منطقه داشته باشید.</p>
<p>برای FoodCo، یک گزینه برای رسیدگی به رقابت در پایگاه داده اصلی آن، تقسیم داده‌ها بر اساس کشور است. بنابراین مشتریان در غنا به یک پایگاه داده و مشتریان در جرزی به پایگاه داده دیگری متصل می‌شوند. این مدل به دلیل تعدادی از عوامل برای FoodCo منطقی نخواهد بود. مشکل اصلی این است که FoodCo برنامه‌هایی برای ادامه توسعه جغرافیایی دارد و امیدوار است با توانایی خدمت‌رسانی به چندین مکان جغرافیایی از یک سیستم، راندمان را افزایش دهد. ایده اینکه مجبور باشید به طور مداوم پارتیشن‌های جدیدی را برای هر کشور راه‌اندازی کنید، هزینه ورود به کشورهای جدید را به شدت افزایش می‌دهد.</p>
<p>اغلب، تقسیم‌بندی توسط زیرسیستمی که به آن تکیه می‌کنید، انجام می‌شود. به عنوان مثال، Cassandra از پارتیشن‌ها برای توزیع خواندن و نوشتن در سراسر <strong>nodes</strong> در یک "حلقه" معین استفاده می‌کند و Kafka از توزیع پیام‌ها در موضوعات پارتیشن‌بندی شده پشتیبانی می‌کند.</p>
<h4>مزایای کلیدی</h4>
<p>تقسیم داده‌ها واقعاً برای حجم کاری تراکنش‌ها خوب مقیاس‌بندی می‌شود. به عنوان مثال، اگر سیستم شما محدود به نوشتن باشد، تقسیم داده‌ها می‌تواند بهبودهای زیادی را ارائه دهد.</p>
<p>ایجاد چندین پارتیشن همچنین می‌تواند باعث شود که تأثیر و دامنه فعالیت‌های نگهداری کاهش یابد. ارائه به‌روزرسانی‌ها را می‌توان بر اساس هر پارتیشن انجام داد و عملیاتی که در غیر این صورت نیاز به از کار افتادن دارند، می‌توانند تأثیر کمتری داشته باشند، زیرا فقط بر یک پارتیشن تأثیر می‌گذارند. به عنوان مثال، اگر پارتیشن‌بندی در مناطق جغرافیایی انجام شود، عملیاتی که ممکن است منجر به وقفه در سرویس شود، می‌تواند در کمترین زمان تأثیرگذار روز انجام شود، شاید در ساعات اولیه صبح.</p>
<p>تقسیم‌بندی جغرافیایی همچنین می‌تواند در صورتی که نیاز دارید اطمینان حاصل کنید که داده‌ها نمی‌توانند از حوزه‌های قضایی خاص خارج شوند—به عنوان مثال، اطمینان از اینکه داده‌های مرتبط با شهروندان اتحادیه اروپا در داخل اتحادیه اروپا ذخیره می‌شوند، بسیار مفید باشد.</p>
<p>تقسیم داده‌ها می‌تواند با تکثیر افقی خوب کار کند—هر پارتیشن می‌تواند از چندین <strong>node</strong> تشکیل شود که قادر به انجام آن کار هستند.</p>
<h4>محدودیت‌ها</h4>
<p>شایان ذکر است که تقسیم داده‌ها از نظر بهبود <strong>robustness</strong> سیستم، فایده محدودی دارد. اگر یک پارتیشن از کار بیفتد، آن بخش از درخواست‌های شما از کار خواهد افتاد. به عنوان مثال، اگر بار شما به طور مساوی در چهار پارتیشن توزیع شده باشد، و یک پارتیشن از کار بیفتد، 25٪ از درخواست‌های شما با شکست مواجه می‌شود. این به بدی یک شکست کامل نیست، اما هنوز هم بسیار بد است. به همین دلیل، همانطور که قبلاً توضیح داده شد، ترکیب تقسیم داده‌ها با تکنیکی مانند تکثیر افقی برای بهبود <strong>robustness</strong> یک پارتیشن معین رایج است.</p>
<p>428 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0454</div>
            </div>
        </div>
        <!-- Page 0455 -->
        <div class="chapter" id="page-0455">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تقسیم داده‌ها (ادامه)</h4>
<p>درست کردن <strong>partition key</strong> می‌تواند دشوار باشد. در شکل 13-5، ما از یک طرح تقسیم‌بندی نسبتاً ساده استفاده کردیم، که در آن حجم کار را بر اساس نام خانوادگی مشتری تقسیم کردیم. مشتریانی که نام خانوادگی آنها با A–M شروع می‌شود به پارتیشن 1 می‌روند و مشتریانی که نامشان با N–Z شروع می‌شود به پارتیشن 2 می‌روند. همانطور که در هنگام اشتراک این مثال اشاره کردم، این یک استراتژی تقسیم‌بندی خوب نیست. با تقسیم داده‌ها، ما توزیع یکنواخت بار را می‌خواهیم. اما ما نمی‌توانیم انتظار توزیع یکنواخت را با طرحی که من شرح داده‌ام داشته باشیم. به عنوان مثال، در چین، از نظر تاریخی تعداد بسیار کمی نام خانوادگی وجود داشته است و حتی امروزه تعداد آنها کمتر از 4000 تخمین زده می‌شود. 100 نام خانوادگی محبوب، که بیش از 80٪ از جمعیت را تشکیل می‌دهند، به شدت به سمت آن نام‌های خانوادگی که با N–Z در ماندارین شروع می‌شوند، متمایل هستند. این نمونه‌ای از یک طرح مقیاس‌بندی است که بعید است توزیع یکنواخت بار را ارائه دهد، و در سراسر کشورها و فرهنگ‌های مختلف می‌تواند نتایج بسیار متفاوتی را به همراه داشته باشد.</p>
<p>یک جایگزین معقول‌تر ممکن است تقسیم‌بندی بر اساس یک شناسه منحصربه‌فرد باشد که هنگام ثبت‌نام به هر مشتری داده می‌شود. این احتمالاً به ما توزیع یکنواختی از بار می‌دهد و همچنین با موقعیتی که در آن شخصی نام خود را تغییر می‌دهد، مقابله می‌کند.</p>
<p>افزودن پارتیشن‌های جدید به یک طرح موجود اغلب می‌تواند بدون دردسر زیاد انجام شود. به عنوان مثال، افزودن یک <strong>node</strong> جدید به یک حلقه Cassandra نیازی به متعادل‌سازی مجدد دستی داده‌ها ندارد. در عوض، Cassandra پشتیبانی داخلی برای توزیع پویا داده‌ها در سراسر <strong>nodes</strong> دارد. Kafka همچنین اضافه کردن پارتیشن‌های جدید را پس از واقعیت نسبتاً آسان می‌کند، اگرچه پیام‌هایی که قبلاً در یک پارتیشن قرار دارند جابجا نمی‌شوند—اما تولیدکنندگان و مصرف‌کنندگان می‌توانند به طور پویا مطلع شوند.</p>
<p>وقتی متوجه می‌شوید که طرح پارتیشن‌بندی شما فقط برای هدف مناسب نیست، مانند مورد طرح مبتنی بر نام خانوادگی ما که قبلاً توضیح داده شد، اوضاع پیچیده‌تر می‌شود. در آن موقعیت، ممکن است یک راه دردناک در پیش داشته باشید. من به یاد دارم که سال‌ها پیش با یک مشتری چت می‌کردم که در نهایت مجبور شد سیستم تولید اصلی خود را به مدت سه روز آفلاین کند تا طرح پارتیشن‌بندی را برای پایگاه داده اصلی خود تغییر دهد.</p>
<p>ما همچنین می‌توانیم به مشکلی در مورد <strong>queries</strong> برخورد کنیم. جستجوی یک رکورد واحد آسان است، زیرا من فقط می‌توانم تابع هشینگ را اعمال کنم تا بفهمم داده‌ها باید در کدام نمونه قرار گیرند و سپس آن را از <strong>shard</strong> صحیح بازیابی کنم. اما <strong>queries</strong> که داده‌ها را در چندین <strong>node</strong> در بر می‌گیرند، چطور؟—به عنوان مثال، یافتن همه مشتریانی که بالای 18 سال سن دارند؟ اگر می‌خواهید به تمام <strong>shards</strong> پرس و جو کنید، باید یا به هر <strong>shard</strong> جداگانه پرس و جو کنید و در حافظه به هم بپیوندید یا یک انبار خواندن جایگزین داشته باشید که در آن هر دو مجموعه داده در دسترس باشند. اغلب، <strong>querying</strong> در سراسر <strong>shards</strong> توسط یک مکانیزم ناهمزمان، با استفاده از نتایج <strong>cached</strong> انجام می‌شود. به عنوان مثال، Mongo از کارهای <strong>map/reduce</strong> برای انجام این <strong>queries</strong> استفاده می‌کند.</p>
<p>همانطور که ممکن است از این بررسی اجمالی استنباط کرده باشید، مقیاس‌بندی پایگاه‌های داده برای نوشتن جایی است که اوضاع بسیار پیچیده می‌شود، و جایی که قابلیت‌های پایگاه‌های داده مختلف واقعاً شروع به تمایز می‌کنند. من اغلب می‌بینم که مردم فناوری پایگاه داده را تغییر می‌دهند، وقتی شروع به رسیدن به محدودیت‌هایی در مورد میزان سهولت مقیاس‌بندی حجم نوشتن موجود خود می‌کنند.</p>
<p>اگر این اتفاق برای شما افتاد، خرید یک <strong>box</strong> بزرگتر اغلب سریع‌ترین راه برای حل</p>
<p>چهار محور مقیاس‌پذیری | 429</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0455</div>
            </div>
        </div>
        <!-- Page 0456 -->
        <div class="chapter" id="page-0456">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تقسیم داده‌ها (ادامه)</h4>
<p>حل مشکل است، اما در پس‌زمینه ممکن است بخواهید به انواع دیگر پایگاه‌های داده نگاهی بیندازید که ممکن است نیازهای شما را بهتر برآورده کنند. با وجود انبوه انواع مختلف پایگاه‌های داده موجود، انتخاب یک پایگاه داده جدید می‌تواند یک فعالیت دلهره‌آور باشد، اما به عنوان یک نقطه شروع، من کاملاً <em>NoSQL Distilled</em>4 خوشایند و مختصر را توصیه می‌کنم، که یک نمای کلی از سبک‌های مختلف پایگاه‌های داده <em>NoSQL</em> موجود را به شما ارائه می‌دهد—از فروشگاه‌های بسیار رابطه‌ای مانند پایگاه‌های داده نموداری گرفته تا فروشگاه‌های اسناد، فروشگاه‌های ستونی و فروشگاه‌های کلید-مقدار.</p>
<p>اساساً، تقسیم داده‌ها کار بیشتری است، به خصوص که احتمالاً نیاز به تغییرات گسترده‌ای در داده‌های سیستم موجود شما دارد. اگرچه کد برنامه احتمالاً فقط اندکی تحت تأثیر قرار خواهد گرفت.</p>
<h4>تجزیه عملکردی</h4>
<p>با تجزیه عملکردی، شما عملکرد را استخراج می‌کنید و به آن اجازه می‌دهید تا به طور مستقل مقیاس‌بندی شود. استخراج عملکرد از یک سیستم موجود و ایجاد یک <strong>microservice</strong> جدید تقریباً یک مثال متعارف از تجزیه عملکردی است. در شکل 13-6، ما نمونه‌ای از MusicCorp را می‌بینیم که در آن عملکرد سفارش از سیستم اصلی استخراج می‌شود تا به ما این امکان را بدهد که این عملکرد را جدا از بقیه مقیاس‌بندی کنیم.</p>
<p>شکل 13-6. <strong>Microservice</strong> سفارش از سیستم MusicCorp موجود استخراج شده است</p>
<p>در مورد FoodCo، این جهت رو به جلو آن است. این شرکت مقیاس‌پذیری عمودی را به پایان رسانده است، از تکثیر افقی تا آنجا که می‌تواند استفاده کرده است، تقسیم داده‌ها را کنار گذاشته است—آنچه باقی مانده این است که شروع به حرکت به سمت تجزیه عملکردی کند. داده‌ها و حجم کاری اصلی در حال حذف از سیستم اصلی و پایگاه داده اصلی هستند تا این تغییر را ایجاد کنند</p>
<p>4 <em>Pramod J. Sadalage and Martin Fowler</em>, <em>NoSQL Distilled: A Brief Guide to the Emerging World of Polyglot Persistence</em> (Upper Saddle River, NJ: Addison-Wesley 2012).</p>
<p>430 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 456" src="page_0456/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0456</div>
            </div>
        </div>
        <!-- Page 0457 -->
        <div class="chapter" id="page-0457">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تجزیه عملکردی (ادامه)</h4>
<p>اتفاق می افتد. چند برد سریع شناسایی شدند، از جمله داده‌های مرتبط با تحویل‌ها و منوها که از پایگاه داده اصلی به <strong>microservices</strong> اختصاصی منتقل شدند. این مزیت اضافه را دارد که فرصت‌هایی را برای تیم تحویل رو به رشد FoodCo ایجاد می‌کند تا شروع به سازماندهی خود در اطراف مالکیت این <strong>microservices</strong> جدید کند.</p>
<h4>پیاده‌سازی</h4>
<p>من زیاد در مورد این مکانیسم مقیاس‌بندی بحث نمی‌کنم، زیرا ما قبلاً اصول <strong>microservices</strong> را به طور گسترده در این کتاب پوشش داده‌ایم. برای بحث دقیق‌تر در مورد چگونگی ایجاد این تغییر، به فصل 3 مراجعه کنید.</p>
<h4>مزایای کلیدی</h4>
<p>این واقعیت که ما انواع مختلف حجم کاری را جدا کرده‌ایم، به این معنی است که اکنون می‌توانیم زیرساخت‌های اساسی مورد نیاز برای سیستم خود را به درستی اندازه‌گیری کنیم. عملکرد تجزیه‌شده‌ای که فقط گه‌گاه استفاده می‌شود، در صورت عدم نیاز می‌تواند خاموش شود. عملکردی که فقط الزامات بار متوسطی دارد می‌تواند بر روی ماشین‌های کوچک مستقر شود. از سوی دیگر، عملکردی که در حال حاضر محدود است می‌تواند سخت‌افزار بیشتری به آن اختصاص داده شود، شاید تجزیه عملکردی را با یکی دیگر از محورهای مقیاس‌بندی ترکیب کند—مانند اجرای چندین نسخه از <strong>microservice</strong> ما.</p>
<p>این توانایی برای اندازه‌گیری صحیح زیرساخت‌های مورد نیاز برای اجرای این حجم کاری، به ما انعطاف‌پذیری بیشتری در بهینه‌سازی هزینه زیرساخت مورد نیاز برای اجرای سیستم می‌دهد. این یک دلیل کلیدی است که چرا ارائه‌دهندگان <strong>SaaS</strong> بزرگ از <strong>microservices</strong> به شدت استفاده می‌کنند، زیرا توانایی یافتن تعادل مناسب هزینه‌های زیرساختی می‌تواند به سودآوری کمک کند.</p>
<p>به خودی خود، تجزیه عملکردی قرار نیست سیستم ما را مستحکم‌تر کند، اما حداقل این فرصت را برای ما باز می‌کند که سیستمی بسازیم که بتواند شکست جزئی عملکرد را تحمل کند، چیزی که ما در فصل 12 با جزئیات بیشتری بررسی کردیم.</p>
<p>با فرض اینکه مسیر <strong>microservices</strong> را برای تجزیه عملکردی طی کرده‌اید، فرصت بیشتری برای استفاده از فناوری‌های مختلفی خواهید داشت که می‌توانند <strong>microservice</strong> تجزیه‌شده را مقیاس‌بندی کنند. به عنوان مثال، می‌توانید عملکرد را به یک زبان برنامه‌نویسی و زمان اجرا منتقل کنید که برای نوع کاری که انجام می‌دهید کارآمدتر است، یا شاید بتوانید داده‌ها را به یک پایگاه داده منتقل کنید که برای ترافیک خواندن یا نوشتن شما مناسب‌تر است.</p>
<p>اگرچه در این فصل ما عمدتاً بر مقیاس در زمینه سیستم <strong>software</strong> خود تمرکز می‌کنیم، تجزیه عملکردی همچنین سازمان ما را نیز آسان‌تر می‌کند، موضوعی که در فصل 15 به آن باز خواهیم گشت.</p>
<p>چهار محور مقیاس‌پذیری | 431</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0457</div>
            </div>
        </div>
        <!-- Page 0458 -->
        <div class="chapter" id="page-0458">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تجزیه عملکردی (ادامه)</h4>
<h4>محدودیت‌ها</h4>
<p>همانطور که با جزئیات در فصل 3 بررسی کردیم، جدا کردن عملکرد می‌تواند یک فعالیت پیچیده باشد و بعید است که در کوتاه‌مدت مزایایی را به همراه داشته باشد. از بین تمام اشکال مقیاس‌پذیری که به آنها نگاه کرده‌ایم، این یکی است که احتمالاً بیشترین تأثیر را بر کد برنامه شما خواهد داشت—هم در <strong>frontend</strong> و هم در <strong>backend</strong>. همچنین اگر تصمیم به انتقال به <strong>microservices</strong> نیز بگیرید، می‌تواند به مقدار قابل توجهی کار در سطح داده نیاز داشته باشد.</p>
<p>شما در نهایت تعداد <strong>microservices</strong>‌هایی را که اجرا می‌کنید، افزایش خواهید داد، که پیچیدگی کلی سیستم را افزایش می‌دهد—که به طور بالقوه منجر به چیزهای بیشتری می‌شود که باید نگهداری، مستحکم و مقیاس‌بندی شوند. به طور کلی، وقتی صحبت از مقیاس‌پذیری یک سیستم می‌شود، من سعی می‌کنم سایر احتمالات را قبل از در نظر گرفتن تجزیه عملکردی، تمام کنم. دیدگاه من در این مورد ممکن است تغییر کند اگر تغییر به <strong>microservices</strong> به طور بالقوه مجموعه‌ای از چیزهای دیگر را به همراه داشته باشد که سازمان به دنبال آنهاست. به عنوان مثال، در مورد FoodCo، تمایل آن به رشد تیم توسعه خود برای پشتیبانی از کشورهای بیشتر و ارائه ویژگی‌های بیشتر کلیدی است، بنابراین مهاجرت به سمت <strong>microservices</strong> به شرکت فرصتی می‌دهد تا نه تنها برخی از مشکلات مقیاس‌پذیری سیستم خود را حل کند، بلکه مشکلات مقیاس‌بندی سازمانی خود را نیز حل کند.</p>
<h4>ترکیب مدل‌ها</h4>
<p>یکی از محرک‌های اصلی در پشت <strong>Scale Cube</strong> اصلی این بود که ما را از تفکر محدود از نظر یک نوع مقیاس‌بندی باز دارد و به ما کمک کند تا درک کنیم که اغلب منطقی است که برنامه خود را در امتداد محورهای متعدد مقیاس‌بندی کنیم، بسته به نیاز ما.</p>
<p>بیایید به مثال شرح داده شده در شکل 13-6 برگردیم. ما عملکرد سفارش خود را استخراج کرده‌ایم تا اکنون بتواند روی زیرساخت‌های خودش اجرا شود. به عنوان گام بعدی، می‌توانیم <strong>microservice</strong> سفارش را به صورت جداگانه با داشتن چندین نسخه از آن مقیاس‌بندی کنیم، همانطور که در شکل 13-7 می‌بینیم.</p>
<p>شکل 13-7. <strong>Microservice</strong> سفارش استخراج شده اکنون برای مقیاس تکرار شده است</p>
<p>432 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 458" src="page_0458/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0458</div>
            </div>
        </div>
        <!-- Page 0459 -->
        <div class="chapter" id="page-0459">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>ترکیب مدل‌ها (ادامه)</h4>
<p>در مرحله بعد، می‌توانیم تصمیم بگیریم که <strong>shards</strong> مختلف <strong>microservice</strong> سفارش خود را برای مکان‌های جغرافیایی مختلف اجرا کنیم، همانطور که در شکل 13-8 نشان داده شده است. تکثیر افقی در هر مرز جغرافیایی اعمال می‌شود.</p>
<p>شکل 13-8. <strong>Microservice</strong> سفارش MusicCorp اکنون در سراسر جغرافیا پارتیشن‌بندی شده است، با تکثیر در هر گروه</p>
<p>شایان ذکر است که با مقیاس‌بندی در امتداد یک محور، استفاده از محورهای دیگر می‌تواند آسان‌تر شود. به عنوان مثال، تجزیه عملکردی سفارش به ما این امکان را می‌دهد که سپس چندین نسخه تکراری از <strong>microservice</strong> سفارش را راه‌اندازی کنیم، و همچنین بار را در پردازش سفارش پارتیشن‌بندی کنیم. بدون آن تجزیه عملکردی اولیه، ما به اعمال آن تکنیک‌ها در <strong>monolith</strong> به عنوان یک کل محدود می‌شدیم.</p>
<p>هدف هنگام مقیاس‌بندی لزوماً این نیست که در امتداد همه محورها مقیاس‌بندی کنیم، اما باید آگاه باشیم که ما این مکانیسم‌های مختلف را در اختیار داریم. با توجه به این انتخاب، مهم است که مزایا و معایب هر مکانیسم را درک کنیم تا مشخص کنیم کدام یک منطقی‌ترین هستند.</p>
<h4>شروع کوچک</h4>
<p>در کتاب <em>The Art of Computer Programming</em> (Addison-Wesley)، <em>Donald Knuth</em> معروف گفت:</p>
<p>مشکل واقعی این است که برنامه‌نویسان زمان زیادی را صرف نگرانی در مورد کارایی در مکان‌های اشتباه و در زمان‌های اشتباه کرده‌اند. بهینه‌سازی زودرس ریشه همه بدی‌ها (یا حداقل بیشتر آن) در برنامه‌نویسی است.</p>
<p>بهینه‌سازی سیستم ما برای حل مشکلاتی که نداریم، راهی عالی برای اتلاف وقت است که می‌توانست صرف فعالیت‌های دیگر شود، و همچنین برای اطمینان از اینکه سیستمی داریم که به طور غیرضروری پیچیده‌تر است. هر نوع بهینه‌سازی باید با نیاز واقعی هدایت شود. همانطور که در "Robustness" در صفحه 388 صحبت کردیم، افزودن پیچیدگی جدید به ما</p>
<p>شروع کوچک | 433</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 459" src="page_0459/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0459</div>
            </div>
        </div>
        <!-- Page 0460 -->
        <div class="chapter" id="page-0460">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>شروع کوچک (ادامه)</h4>
<p>5 اجازه ندهید که من در مورد افرادی که شروع به صحبت در مورد فرضیه‌ها می‌کنند و سپس اطلاعاتی را انتخاب می‌کنند تا باورهای از قبل خود را تأیید کنند، شروع کنم.</p>
<p>سیستم می‌تواند منابع جدیدی از شکنندگی را نیز معرفی کند. با مقیاس‌پذیری یک بخش از برنامه خود، ما در جای دیگری یک نقطه ضعف ایجاد می‌کنیم. <strong>Microservice</strong> سفارش ما اکنون ممکن است در زیرساخت‌های خود اجرا شود و به ما کمک کند تا بار سیستم را بهتر مدیریت کنیم، اما ما <strong>microservice</strong> دیگری داریم که باید مطمئن شویم در صورت عملکرد سیستم ما در دسترس است، و همچنین زیرساخت‌های بیشتری وجود دارد که باید مدیریت و مستحکم شوند.</p>
<p>حتی اگر فکر می‌کنید یک گلوگاه را شناسایی کرده‌اید، یک فرآیند آزمایش برای اطمینان از درست بودن شما و توجیه کار بیشتر ضروری است. برای من شگفت‌انگیز است که چند نفر که با کمال میل خود را دانشمند کامپیوتر توصیف می‌کنند، به نظر می‌رسد حتی درک اساسی از روش علمی ندارند.5 اگر آنچه را که فکر می‌کنید یک مشکل است شناسایی کرده‌اید، سعی کنید مقدار کمی کار را شناسایی کنید که می‌توان برای تأیید اینکه آیا راه‌حل پیشنهادی شما کار می‌کند یا خیر، انجام داد. به عنوان مثال، در زمینه مقیاس‌بندی سیستم‌ها برای مدیریت بار، داشتن مجموعه‌ای از تست‌های بار خودکار می‌تواند فوق‌العاده مفید باشد. آزمایش‌ها را اجرا کنید تا یک خط پایه دریافت کنید و گلوگاه مورد نظر خود را دوباره ایجاد کنید، تغییری ایجاد کنید و تفاوت را مشاهده کنید. این علم موشکی نیست، اما حتی به روشی بسیار کوچک، تلاش برای علمی بودن است.</p>
<h4>CQRS و Event Sourcing</h4>
<p>الگوی جداسازی مسئولیت <strong>Command Query</strong> (CQRS) به یک مدل جایگزین برای ذخیره و پرس و جو اطلاعات اشاره دارد. به جای داشتن یک مدل واحد برای نحوه دستکاری و بازیابی داده‌ها، همانطور که معمول است، مسئولیت‌های خواندن و نوشتن در عوض توسط مدل‌های جداگانه مدیریت می‌شوند. این مدل‌های خواندن و نوشتن جداگانه، که در کد پیاده‌سازی شده‌اند، می‌توانند به عنوان واحدهای جداگانه مستقر شوند و به ما این امکان را می‌دهند که خواندن و نوشتن را به طور مستقل مقیاس‌بندی کنیم. اگرچه <strong>CQRS</strong> اغلب، اما نه همیشه، همراه با <strong>event sourcing</strong> استفاده می‌شود، که در آن—به جای ذخیره وضعیت فعلی یک موجودیت به عنوان یک رکورد واحد—ما در عوض وضعیت یک موجودیت را با نگاه کردن به تاریخچه رویدادهای مربوط به آن موجودیت پیش‌بینی می‌کنیم.</p>
<p>استدلال می‌شود، <strong>CQRS</strong> در سطح برنامه ما کاری بسیار مشابه با کاری که <strong>read replicas</strong> می‌توانند در سطح داده انجام دهند، انجام می‌دهد، اگرچه به دلیل تعداد زیاد راه‌های مختلفی که <strong>CQRS</strong> می‌تواند پیاده‌سازی شود، این یک ساده‌سازی است.</p>
<p>شخصاً، اگرچه من در برخی شرایط ارزش الگوی <strong>CQRS</strong> را می‌بینم، اما اجرای خوب آن یک الگوی پیچیده است. من با افراد بسیار باهوشی صحبت کرده‌ام که در اجرای <strong>CQRS</strong> با مشکلات کمی مواجه شده‌اند. به این ترتیب، اگر <strong>CQRS</strong> را به عنوان راهی برای کمک به مقیاس‌پذیری برنامه خود در نظر می‌گیرید، آن را به عنوان یکی از سخت‌ترین اشکال مقیاس‌بندی که باید پیاده‌سازی کنید در نظر بگیرید و شاید ابتدا برخی از کارهای آسان‌تر را امتحان کنید. به عنوان مثال، اگر شما به سادگی محدود به خواندن هستید، یک <strong>read replica</strong> ممکن است یک روش به مراتب کم خطر و</p>
<p>434 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0460</div>
            </div>
        </div>
        <!-- Page 0461 -->
        <div class="chapter" id="page-0461">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>شروع کوچک (ادامه)</h4>
<p>رویکرد سریع‌تری برای شروع. نگرانی‌های من در مورد پیچیدگی پیاده‌سازی به <strong>event sourcing</strong> گسترش می‌یابد—موقعیت‌هایی وجود دارد که واقعاً مناسب هستند، اما با مجموعه‌ای از سردردها همراه است که باید در نظر گرفته شوند. هر دو الگو به یک تغییر اساسی در تفکر برای توسعه‌دهندگان نیاز دارند، که همیشه کارها را چالش‌برانگیزتر می‌کند. اگر تصمیم به استفاده از هر یک از این الگوها گرفتید، فقط مطمئن شوید که این بار شناختی افزایش یافته برای توسعه‌دهندگان شما ارزشش را دارد.</p>
<p>یک نکته پایانی در مورد <strong>CQRS</strong> و <strong>event sourcing</strong>: از دیدگاه معماری <strong>microservice</strong>، تصمیم به استفاده یا عدم استفاده از این تکنیک‌ها یک جزئیات پیاده‌سازی داخلی <strong>microservice</strong> است. اگر تصمیم گرفته‌اید <strong>microservice</strong> را با تقسیم مسئولیت خواندن و نوشتن در فرآیندها و مدل‌های مختلف پیاده‌سازی کنید، به عنوان مثال، این باید برای مصرف‌کنندگان <strong>microservice</strong> نامرئی باشد. اگر درخواست‌های ورودی نیاز به هدایت مجدد به مدل مناسب بر اساس درخواست ارائه شده دارند، این را به مسئولیت <strong>microservice</strong> که <strong>CQRS</strong> را پیاده‌سازی می‌کند، بسپارید. پنهان نگه داشتن این جزئیات پیاده‌سازی از مصرف‌کنندگان، انعطاف‌پذیری زیادی را برای تغییر نظر شما در آینده یا تغییر نحوه استفاده از این الگوها به شما می‌دهد.</p>
<h4><strong>Caching</strong></h4>
<p><strong>Caching</strong> یک بهینه‌سازی عملکرد است که معمولاً مورد استفاده قرار می‌گیرد که بر اساس آن نتیجه قبلی برخی عملیات ذخیره می‌شود تا درخواست‌های بعدی بتوانند از این مقدار ذخیره شده استفاده کنند تا اینکه زمان و منابع را برای محاسبه مجدد مقدار صرف کنند.</p>
<p>به عنوان مثال، <strong>microservice</strong> توصیه‌ها را در نظر بگیرید که باید سطح موجودی را قبل از توصیه یک مورد بررسی کند—هیچ نقطه‌ای برای توصیه چیزی که ما در انبار نداریم وجود ندارد! اما ما تصمیم گرفته‌ایم یک کپی محلی از سطوح موجودی را در توصیه (نوعی <strong>client-side caching</strong>) نگه داریم تا <strong>latency</strong> عملیات خود را بهبود بخشیم—ما از نیاز به بررسی سطح موجودی هر زمان که نیاز به توصیه چیزی داشته باشیم، اجتناب می‌کنیم. منبع حقیقت برای سطوح موجودی، <strong>microservice</strong> موجودی است، که به عنوان منشأ <strong>cache client</strong> در <strong>microservice</strong> توصیه‌ها در نظر گرفته می‌شود. وقتی Recommendation نیاز به جستجوی یک سطح موجودی دارد، ابتدا می‌تواند به <strong>cache</strong> محلی خود نگاه کند. اگر ورودی مورد نیاز آن یافت شود، این یک <strong>cache hit</strong> در نظر گرفته می‌شود. اگر داده‌ها یافت نشد، یک <strong>cache miss</strong> است، که منجر به نیاز به دریافت اطلاعات از <strong>microservice</strong> موجودی پایین‌دستی می‌شود. از آنجا که داده‌ها در مبدأ، البته می‌توانند تغییر کنند، ما به نوعی راهی برای بی‌اعتبار کردن ورودی‌ها در <strong>cache</strong> توصیه‌ها نیاز داریم تا بدانیم چه زمانی داده‌های <strong>cached</strong> محلی آنقدر قدیمی شده‌اند که دیگر نمی‌توان از آنها استفاده کرد.</p>
<p><strong>Caches</strong> می‌توانند نتایج جستجوهای ساده را ذخیره کنند، همانطور که در این مثال، اما واقعاً آنها می‌توانند هر قطعه‌ای از داده‌ها را ذخیره کنند، مانند نتیجه یک محاسبه پیچیده. ما می‌توانیم <strong>cache</strong> کنیم تا به بهبود عملکرد سیستم خود به عنوان بخشی از کمک به کاهش <strong>latency</strong>، برای مقیاس‌بندی برنامه خود و در برخی موارد حتی برای بهبود <strong>robustness</strong> سیستم خود کمک کنیم. با در نظر گرفتن این واقعیت که تعدادی از مکانیسم‌های <strong>invalidation</strong> وجود دارد که می‌توانیم از آنها استفاده کنیم، و مکان‌های متعددی که می‌توانیم <strong>cache</strong> کنیم، به این معنی است که ما تعداد زیادی</p>
<p><strong>Caching</strong> | 435</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0461</div>
            </div>
        </div>
        <!-- Page 0462 -->
        <div class="chapter" id="page-0462">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>Caching</strong> (ادامه)</h4>
<p>جنبه‌هایی برای بحث در مورد <strong>caching</strong> در معماری <strong>microservice</strong> وجود دارد. بیایید با صحبت در مورد انواع مشکلاتی که <strong>caches</strong> می‌توانند به آنها کمک کنند، شروع کنیم.</p>
<h4>برای عملکرد</h4>
<p>با <strong>microservices</strong>، ما اغلب نگران تأثیر نامطلوب <strong>latency</strong> شبکه و هزینه نیاز به تعامل با چندین <strong>microservices</strong> برای دریافت برخی داده‌ها هستیم. دریافت داده‌ها از یک <strong>cache</strong> می‌تواند در اینجا بسیار کمک کند، زیرا از نیاز به برقراری تماس‌های شبکه اجتناب می‌کنیم، که همچنین تأثیر کاهش بار بر روی <strong>microservices</strong> پایین‌دستی را دارد. جدا از اجتناب از <strong>network hops</strong>، نیاز به ایجاد داده‌ها را در هر درخواست کاهش می‌دهد. موقعیتی را در نظر بگیرید که ما در حال درخواست لیستی از محبوب‌ترین اقلام بر اساس ژانر هستیم. این ممکن است شامل یک <strong>join query</strong> پرهزینه در سطح پایگاه داده باشد. ما می‌توانیم نتایج این <strong>query</strong> را <strong>cache</strong> کنیم، به این معنی که فقط زمانی باید نتایج را بازسازی کنیم که داده‌های <strong>cached</strong> بی‌اعتبار شوند.</p>
<h4>برای مقیاس</h4>
<p>اگر بتوانید خواندن‌ها را به <strong>caches</strong> منتقل کنید، می‌توانید از اختلاف نظر در بخش‌هایی از سیستم خود جلوگیری کنید تا به آن اجازه دهید بهتر مقیاس‌بندی شود. نمونه‌ای از این که ما قبلاً در این فصل پوشش داده‌ایم، استفاده از <strong>database read replicas</strong> است. ترافیک خواندن توسط <strong>read replicas</strong> ارائه می‌شود، که بار را در <strong>node</strong> پایگاه داده اصلی کاهش می‌دهد و به خواندن‌ها اجازه می‌دهد تا به طور مؤثر مقیاس‌بندی شوند. خواندن‌ها در یک <strong>replica</strong> در برابر داده‌هایی انجام می‌شود که ممکن است قدیمی باشند. <strong>read replica</strong> در نهایت توسط تکثیر از <strong>primary</strong> به <strong>replica node</strong> به‌روزرسانی می‌شود—این شکل از <strong>cache invalidation</strong> به طور خودکار توسط فناوری پایگاه داده مدیریت می‌شود.</p>
<p>به طور کلی، <strong>caching</strong> برای مقیاس در هر موقعیتی که مبدأ یک نقطه اختلاف است، مفید است. قرار دادن <strong>caches</strong> بین <strong>clients</strong> و مبدأ می‌تواند بار را بر روی مبدأ کاهش دهد و به آن اجازه می‌دهد بهتر مقیاس‌بندی شود.</p>
<h4>برای <strong>Robustness</strong></h4>
<p>اگر یک مجموعه کامل از داده‌ها را در یک <strong>cache</strong> محلی در دسترس دارید، این پتانسیل را دارید که حتی در صورت عدم دسترسی به مبدأ عمل کنید—این به نوبه خود می‌تواند <strong>robustness</strong> سیستم شما را بهبود بخشد. چند نکته در مورد <strong>caching</strong> برای <strong>robustness</strong> وجود دارد. نکته اصلی این است که شما احتمالاً باید مکانیسم <strong>cache invalidation</strong> خود را طوری پیکربندی کنید که داده‌های قدیمی را به طور خودکار حذف نکند و داده‌ها را در <strong>cache</strong> نگه دارد تا زمانی که بتواند به‌روزرسانی شود. در غیر این صورت، با بی‌اعتبار شدن داده‌ها، از <strong>cache</strong> حذف می‌شود و در نتیجه یک <strong>cache miss</strong> و عدم دریافت هیچ داده‌ای ایجاد می‌شود، زیرا مبدأ در دسترس نیست. این بدان معنی است که شما باید آماده خواندن داده‌هایی باشید که در صورت آفلاین بودن مبدأ، می‌تواند کاملاً قدیمی باشد. در برخی شرایط این ممکن است خوب باشد، در حالی که در موارد دیگر ممکن است بسیار مشکل‌ساز باشد.</p>
<p>436 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0462</div>
            </div>
        </div>
        <!-- Page 0463 -->
        <div class="chapter" id="page-0463">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>Caching</strong> (ادامه)</h4>
<p>اساساً، استفاده از یک <strong>cache</strong> محلی برای فعال کردن <strong>robustness</strong> در موقعیتی که مبدأ در دسترس نیست به این معنی است که شما در دسترس بودن را بر سازگاری ترجیح می‌دهید.</p>
<p>تکنیکی که من در <strong>Guardian</strong> و متعاقباً در جاهای دیگر دیدم، این بود که به طور دوره‌ای از سایت "زنده" موجود <strong>crawl</strong> می‌شد تا یک نسخه <strong>static</strong> از وب‌سایت ایجاد شود که می‌توانست در صورت بروز <strong>outage</strong> ارائه شود. اگرچه این نسخه <strong>crawled</strong> به تازگی محتوای <strong>cached</strong> ارائه شده از سیستم زنده نبود، اما در یک <strong>pinch</strong> می‌توانست اطمینان حاصل کند که نسخه‌ای از سایت نمایش داده می‌شود.</p>
<h4>کجا <strong>Cache</strong> کنیم</h4>
<p>همانطور که چندین بار پوشش داده‌ایم، <strong>microservices</strong> به شما گزینه‌هایی می‌دهند. و این کاملاً در مورد <strong>caching</strong> صادق است. ما مکان‌های مختلفی داریم که می‌توانیم <strong>cache</strong> کنیم.</p>
<p>مکان‌های <strong>cache</strong> مختلفی که در اینجا توضیح خواهم داد، دارای مبادلات متفاوتی هستند، و نوع بهینه‌سازی که شما در تلاش برای انجام آن هستید، احتمالاً شما را به سمت محل <strong>cache</strong> که برای شما منطقی‌ترین است، هدایت می‌کند.</p>
<p>برای بررسی گزینه‌های <strong>caching</strong> خود، بیایید به موقعیتی که در "نگرانی‌های تجزیه داده‌ها" در صفحه 81 به آن نگاه کردیم، بازگردیم، جایی که ما در حال استخراج اطلاعات در مورد فروش در MusicCorp بودیم. در شکل 13-9، <strong>microservice</strong> فروش، سوابقی از اقلامی که فروخته شده‌اند، نگهداری می‌کند. این فقط شناسه آیتم فروخته شده و <strong>timestamp</strong> فروش را پیگیری می‌کند. گه‌گاه، ما می‌خواهیم از <strong>microservice</strong> فروش برای لیستی از ده پرفروش‌ترین‌ها در هفت روز گذشته سؤال کنیم.</p>
<p>مشکل این است که <strong>microservice</strong> فروش نام رکوردها را نمی‌داند، فقط شناسه‌ها را می‌داند. این خیلی فایده‌ای ندارد که بگوییم، "پرفروش‌ترین این هفته شناسه 366548 را داشت، و ما 35345 نسخه فروختیم!" ما می‌خواهیم نام سی‌دی را با شناسه 366548 نیز بدانیم. <strong>microservice</strong> کاتالوگ آن اطلاعات را ذخیره می‌کند. این بدان معنی است، همانطور که شکل 13-9 نشان می‌دهد، که هنگام پاسخ به درخواست ده پرفروش‌ترین‌ها، <strong>microservice</strong> فروش باید نام ده شناسه برتر را درخواست کند. بیایید نگاهی بیندازیم که چگونه <strong>caching</strong> می‌تواند به ما کمک کند و از چه نوع <strong>caches</strong> می‌توانیم استفاده کنیم.</p>
<p><strong>Caching</strong> | 437</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0463</div>
            </div>
        </div>
        <!-- Page 0464 -->
        <div class="chapter" id="page-0464">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>کجا <strong>Cache</strong> کنیم (ادامه)</h4>
<p>شکل 13-9. مروری بر نحوه عملکرد MusicCorp در مورد پرفروش‌ترین‌ها</p>
<h4><strong>Client-side</strong></h4>
<p>با <strong>client-side caching</strong>، داده‌ها خارج از محدوده مبدأ <strong>cached</strong> می‌شوند. در مثال ما، این کار می‌تواند به سادگی با داشتن یک <strong>hashtable in-memory</strong> با یک <strong>mapping</strong> بین <strong>ID</strong> و نام آلبوم در داخل فرآیند فروش در حال اجرا انجام شود، همانطور که در شکل 13-10 نشان داده شده است. این بدان معناست که تولید ده مورد برتر ما هر تعاملی با کاتالوگ را خارج از محدوده می‌کند، با فرض اینکه ما برای هر جستجویی که باید انجام دهیم، یک <strong>cache hit</strong> دریافت کنیم. توجه به این نکته مهم است که <strong>cache client</strong> ما می‌تواند تصمیم بگیرد که فقط برخی از اطلاعاتی را که از <strong>microservice</strong> دریافت می‌کنیم، <strong>cache</strong> کند. به عنوان مثال، ممکن است اطلاعات زیادی در مورد یک سی‌دی دریافت کنیم، زمانی که ما در مورد آن اطلاعات می‌خواهیم، اما اگر تنها چیزی که به آن اهمیت می‌دهیم نام آلبوم است، این تنها چیزی است که باید در <strong>cache</strong> محلی خود ذخیره کنیم.</p>
<p>438 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 464" src="page_0464/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0464</div>
            </div>
        </div>
        <!-- Page 0465 -->
        <div class="chapter" id="page-0465">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>کجا <strong>Cache</strong> کنیم (ادامه)</h4>
<p>شکل 13-10. فروش، یک نسخه محلی از داده‌های کاتالوگ را نگه می‌دارد</p>
<p>به طور کلی، <strong>caches client-side</strong> تمایل دارند که بسیار مؤثر باشند، زیرا از تماس شبکه به <strong>microservice</strong> پایین‌دستی اجتناب می‌کنند. این امر آنها را نه تنها برای <strong>caching</strong> برای بهبود <strong>latency</strong>، بلکه برای <strong>caching</strong> برای <strong>robustness</strong> نیز مناسب می‌کند.</p>
<p>با این حال، <strong>caching client-side</strong> دارای چند اشکال است. اولاً، شما تمایل دارید که در گزینه‌های خود در مورد مکانیسم‌های <strong>invalidation</strong> محدودتر باشید—چیزی که ما به زودی بیشتر بررسی خواهیم کرد. ثانیاً، هنگامی که <strong>caching client-side</strong> زیادی در حال انجام است، می‌توانید درجه‌ای از عدم سازگاری بین <strong>clients</strong> را مشاهده کنید. موقعیتی را در نظر بگیرید که در آن <strong>microservices</strong> فروش، توصیه و تبلیغات همگی یک <strong>cache client-side</strong> از داده‌های کاتالوگ دارند. هنگامی که داده‌ها در کاتالوگ تغییر می‌کنند، هر مکانیسم <strong>invalidation</strong> که احتمالاً از آن استفاده می‌کنیم، نمی‌تواند تضمین کند که داده‌ها دقیقاً در همان لحظه در هر یک از آن سه <strong>client</strong> تازه‌سازی می‌شوند. این بدان معناست که شما می‌توانید در هر یک از آن <strong>clients</strong> در همان زمان، یک نمای متفاوت از داده‌های <strong>cached</strong> را ببینید. هرچه <strong>clients</strong> بیشتری داشته باشید، این مشکل‌آفرین‌تر خواهد بود. تکنیک‌هایی مانند <strong>invalidation</strong> مبتنی بر اعلان، که به زودی به آن نگاه خواهیم کرد، می‌تواند به کاهش این مشکل کمک کند، اما آن را از بین نمی‌برد.</p>
<p>یک راه‌حل دیگر برای این کار، داشتن یک <strong>cache client-side</strong> مشترک است، شاید با استفاده از یک ابزار <strong>caching</strong> اختصاصی مانند <strong>Redis</strong> یا <strong>memcached</strong>، همانطور که در شکل 13-11 می‌بینیم. در اینجا، ما از مشکل عدم سازگاری بین <strong>clients</strong> مختلف اجتناب می‌کنیم. این می‌تواند از نظر استفاده از منابع نیز کارآمدتر باشد، زیرا ما تعداد نسخه‌های این داده‌ها را که باید مدیریت کنیم، کاهش می‌دهیم (<strong>caches</strong> اغلب در حافظه ختم می‌شوند، و حافظه اغلب یکی از بزرگترین محدودیت‌های زیرساختی است). جنبه دیگر این است که <strong>clients</strong> ما اکنون نیاز به یک سفر رفت و برگشت به <strong>cache</strong> مشترک دارند.</p>
<p><strong>Caching</strong> | 439</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 465" src="page_0465/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0465</div>
            </div>
        </div>
        <!-- Page 0466 -->
        <div class="chapter" id="page-0466">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>کجا <strong>Cache</strong> کنیم (ادامه)</h4>
<p>شکل 13-11. چندین مصرف‌کننده از کاتالوگ با استفاده از یک <strong>cache</strong> مشترک</p>
<p>نکته دیگری که در اینجا باید در نظر گرفت این است که چه کسی مسئول این <strong>cache</strong> مشترک است. بسته به اینکه چه کسی مالک آن است و چگونه پیاده‌سازی می‌شود، یک <strong>cache</strong> مشترک مانند این می‌تواند خطوط بین <strong>caching client-side</strong> و <strong>caching server-side</strong> را محو کند، که ما در ادامه آن را بررسی می‌کنیم.</p>
<h4><strong>Server-side</strong></h4>
<p>در شکل 13-12، ما مثال ده فروش برتر خود را می‌بینیم که از <strong>caching</strong> در سمت سرور استفاده می‌کند. در اینجا، خود <strong>microservice</strong> کاتالوگ یک <strong>cache</strong> را از طرف مصرف‌کنندگان خود حفظ می‌کند. هنگامی که <strong>microservice</strong> فروش درخواست خود را برای نام سی‌دی‌ها می‌دهد، این اطلاعات به صورت شفاف توسط یک <strong>cache</strong> ارائه می‌شود.</p>
<p>در اینجا، <strong>microservice</strong> کاتالوگ مسئولیت کامل مدیریت <strong>cache</strong> را بر عهده دارد. با توجه به ماهیت نحوه پیاده‌سازی این <strong>caches</strong> معمولاً—مانند یک ساختار داده <strong>in-memory</strong>، یا یک <strong>node caching</strong> اختصاصی محلی—پیاده‌سازی مکانیسم‌های <strong>cache invalidation</strong> پیچیده‌تر آسان‌تر است. به عنوان مثال، <strong>write-through caches</strong> (که به زودی به آن نگاه خواهیم کرد)، در این شرایط پیاده‌سازی آن بسیار ساده‌تر خواهد بود.
   داشتن یک <strong>cache server-side</strong> همچنین باعث می‌شود که از مشکل دیدن مقادیر <strong>cached</strong> مختلف که با <strong>caching client-side</strong> می‌تواند رخ دهد، جلوگیری شود.</p>
<p>شایان ذکر است که، اگرچه از دیدگاه مصرف‌کننده، این <strong>caching</strong> نامرئی است (یک نگرانی در مورد پیاده‌سازی داخلی است)، این بدان معنا نیست که ما باید این را با <strong>caching</strong> در کد در یک نمونه <strong>microservice</strong> پیاده‌سازی کنیم. به عنوان مثال، ما می‌توانیم</p>
<p>440 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 466" src="page_0466/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0466</div>
            </div>
        </div>
        <!-- Page 0467 -->
        <div class="chapter" id="page-0467">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>کجا <strong>Cache</strong> کنیم (ادامه)</h4>
<p>نگهداری یک <strong>reverse proxy</strong> در مرز منطقی <strong>microservice</strong> خود، استفاده از یک <strong>node Redis</strong> پنهان، یا منحرف کردن <strong>read queries</strong> به <strong>read replicas</strong> یک پایگاه داده.</p>
<p>شکل 13-12. کاتالوگ، <strong>caching</strong> را به صورت داخلی پیاده‌سازی می‌کند و این امر را برای مصرف‌کنندگان نامرئی می‌کند</p>
<p>مشکل اصلی این شکل از <strong>caching</strong> این است که دامنه بهینه‌سازی برای <strong>latency</strong> را کاهش داده است، زیرا هنوز به یک <strong>round trip</strong> توسط مصرف‌کنندگان به <strong>microservice</strong> نیاز است. با <strong>caching</strong> در یا نزدیک به محیط یک <strong>microservice</strong>، <strong>cache</strong> می‌تواند اطمینان حاصل کند که ما نیازی به انجام عملیات‌های گران‌قیمت‌تر (مانند <strong>database queries</strong>) نداریم، اما باید تماس برقرار شود. این امر همچنین اثربخشی این شکل از <strong>caching</strong> را برای هر نوع <strong>robustness</strong> کاهش می‌دهد.</p>
<p>این ممکن است باعث شود که این شکل از <strong>caching</strong> کمتر مفید به نظر برسد، اما ارزش زیادی در بهبود شفاف عملکرد برای همه مصرف‌کنندگان یک <strong>microservice</strong> فقط با تصمیم‌گیری برای پیاده‌سازی <strong>caching</strong> داخلی وجود دارد. یک <strong>microservice</strong> که به طور گسترده در سراسر یک سازمان استفاده می‌شود، ممکن است از پیاده‌سازی نوعی <strong>caching</strong> داخلی بسیار سود ببرد و به بهبود زمان پاسخ برای تعدادی از مصرف‌کنندگان کمک کند و در عین حال به <strong>microservice</strong> اجازه می‌دهد تا مقیاس‌پذیری بیشتری داشته باشد.</p>
<p>در مورد سناریوی ده برتر ما، ما باید در نظر بگیریم که آیا این شکل از <strong>caching</strong> ممکن است کمک کند یا خیر. تصمیم ما به این بستگی دارد که نگرانی اصلی ما چیست. اگر این در مورد <strong>latency</strong> سرتاسری عملیات باشد، یک <strong>cache server-side</strong> چقدر در زمان صرفه‌جویی می‌کند؟ <strong>caching client-side</strong> احتمالاً مزیت عملکرد بهتری را به ما می‌دهد.</p>
<p><strong>Caching</strong> | 441</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 467" src="page_0467/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0467</div>
            </div>
        </div>
        <!-- Page 0468 -->
        <div class="chapter" id="page-0468">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>کجا <strong>Cache</strong> کنیم (ادامه)</h4>
<p><strong>Request cache</strong></p>
<p>با یک <strong>request cache</strong>، ما یک پاسخ <strong>cached</strong> را برای درخواست اصلی ذخیره می‌کنیم. بنابراین به عنوان مثال در شکل 13-13، ما ده ورودی برتر واقعی را ذخیره می‌کنیم. درخواست‌های بعدی برای ده پرفروش‌ترین‌ها منجر به بازگشت نتیجه <strong>cached</strong> می‌شود. هیچ جستجویی در داده‌های فروش لازم نیست، هیچ <strong>round trips</strong> به کاتالوگ—این از نظر بهینه‌سازی سرعت، مؤثرترین <strong>cache</strong> است.</p>
<p>شکل 13-13. <strong>Caching</strong> نتایج 10 درخواست برتر</p>
<p>مزایای اینجا آشکار است. این یک چیز بسیار کارآمد است. با این حال، ما باید تشخیص دهیم که این شکل از <strong>caching</strong> بسیار خاص است. ما فقط نتیجه این درخواست خاص را <strong>cached</strong> کرده‌ایم. این بدان معناست که عملیات‌های دیگری که به فروش یا کاتالوگ برخورد می‌کنند، به <strong>cache</strong> برخورد نمی‌کنند و بنابراین به هیچ وجه از این شکل بهینه‌سازی بهره‌مند نمی‌شوند.</p>
<h4><strong>Invalidation</strong></h4>
<p>فقط دو چیز دشوار در علوم کامپیوتر وجود دارد: <strong>cache invalidation</strong> و نام‌گذاری چیزها.</p>
<p>—<em>Phil Karlton</em></p>
<p><strong>Invalidation</strong> فرآیندی است که به موجب آن داده‌ها را از <strong>cache</strong> خود حذف می‌کنیم. این ایده‌ای است که از نظر مفهومی ساده است اما از نظر اجرا پیچیده است، اگر به این دلیل نباشد که از نظر چگونگی اجرای آن گزینه‌های زیادی وجود دارد، و مبادلات متعددی برای</p>
<p>442 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 468" src="page_0468/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0468</div>
            </div>
        </div>
        <!-- Page 0469 -->
        <div class="chapter" id="page-0469">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>Invalidation</strong> (ادامه)</h4>
<p>از نظر استفاده از داده‌هایی که ممکن است منسوخ شده باشند، در اولویت قرار می‌دهد. با این حال، اساساً، به این بستگی دارد که در چه موقعیت‌هایی باید یک قطعه از داده‌های <strong>cached</strong> را از <strong>cache</strong> خود حذف کنید. گاهی اوقات این اتفاق می‌افتد زیرا به ما گفته می‌شود که نسخه جدیدی از یک قطعه داده در دسترس است. در زمان‌های دیگر ممکن است از ما بخواهد که فرض کنیم کپی <strong>cached</strong> ما قدیمی است و یک کپی جدید از مبدأ دریافت کنیم.</p>
<p>با توجه به گزینه‌های <strong>invalidation</strong>، من فکر می‌کنم بررسی چند گزینه که می‌توانید در معماری <strong>microservice</strong> از آنها استفاده کنید، ایده خوبی است. با این حال، لطفاً این را به عنوان یک بررسی جامع از هر گزینه در نظر نگیرید!</p>
<h4>زمان حیات (TTL)</h4>
<p>این یکی از ساده‌ترین مکانیسم‌ها برای استفاده از <strong>cache invalidation</strong> است. فرض بر این است که هر ورودی در <strong>cache</strong> فقط برای مدت معینی در زمان معتبر است. پس از گذشت آن زمان، داده‌ها بی‌اعتبار می‌شوند و ما یک کپی جدید دریافت می‌کنیم. ما می‌توانیم مدت اعتبار را با استفاده از یک مدت زمان حیات (TTL) ساده مشخص کنیم—بنابراین یک <strong>TTL</strong> پنج دقیقه‌ای به این معنی است که <strong>cache</strong> ما با کمال میل داده‌های <strong>cache</strong> را تا پنج دقیقه ارائه می‌دهد، پس از آن ورودی <strong>cached</strong> بی‌اعتبار در نظر گرفته می‌شود و یک کپی جدید مورد نیاز است.</p>
<p>تغییراتی در این زمینه می‌تواند شامل استفاده از یک <strong>timestamp</strong> برای انقضا باشد، که در برخی شرایط می‌تواند مؤثرتر باشد، به خصوص اگر شما در حال خواندن از طریق چندین سطح <strong>cache</strong> هستید.</p>
<p><strong>HTTP</strong> از هر دو <strong>TTL</strong> (از طریق هدر <strong>Cache-Control</strong>) و توانایی تنظیم یک <strong>timestamp</strong> برای انقضا از طریق هدر <strong>Expires</strong> در پاسخ‌ها پشتیبانی می‌کند، که می‌تواند فوق‌العاده مفید باشد. این بدان معناست که خود مبدأ می‌تواند به <strong>clients</strong> پایین‌دستی بگوید که چه مدت باید فرض کنند داده‌ها تازه هستند. بازگشت به <strong>microservice</strong> موجودی ما، ما می‌توانیم موقعیتی را تصور کنیم که در آن <strong>microservice</strong> موجودی، یک <strong>TTL</strong> کوتاه‌تر برای سطوح موجودی اقلام پرفروش یا اقلامی که تقریباً موجودی نداریم، ارائه می‌دهد. برای اقلامی که زیاد نمی‌فروشیم، می‌تواند یک <strong>TTL</strong> طولانی‌تر ارائه دهد. این نشان‌دهنده استفاده تا حدودی پیشرفته از کنترل‌های <strong>cache HTTP</strong> است، و تنظیم کنترل‌های <strong>cache</strong> بر اساس هر پاسخ مانند این، کاری است که من فقط زمانی انجام می‌دهم که در حال تنظیم اثربخشی یک <strong>cache</strong> هستم. یک <strong>TTL</strong> ساده و یک اندازه برای هر نوع منبع داده‌ای که داده می‌شود، یک نقطه شروع منطقی است.</p>
<p>حتی اگر از <strong>HTTP</strong> استفاده نمی‌کنید، ایده مبدأ که به <strong>client</strong> نکاتی را ارائه می‌دهد در مورد چگونگی (و در صورت وجود) باید داده‌ها <strong>cached</strong> شوند، یک مفهوم واقعاً قدرتمند است. این بدان معناست که شما مجبور نیستید در مورد این موارد در سمت <strong>client</strong> حدس بزنید. شما در واقع می‌توانید یک انتخاب آگاهانه در مورد نحوه رسیدگی به یک قطعه داده داشته باشید.</p>
<p><strong>HTTP</strong> قابلیت‌های <strong>caching</strong> پیشرفته‌تری نسبت به این دارد، و ما در لحظه‌ای به عنوان مثال به <strong>GET</strong>های مشروط نگاه خواهیم کرد.</p>
<p>یکی از چالش‌های <strong>invalidation</strong> مبتنی بر <strong>TTL</strong> این است که اگرچه پیاده‌سازی آن ساده است، اما یک ابزار بسیار کند است. اگر ما یک کپی جدید از داده‌ها را درخواست کنیم که دارای <strong>TTL</strong> پنج دقیقه‌ای است، و یک ثانیه بعد داده‌ها در مبدأ تغییر می‌کند، سپس <strong>cache</strong> ما</p>
<p><strong>Caching</strong> | 443</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0469</div>
            </div>
        </div>
        <!-- Page 0470 -->
        <div class="chapter" id="page-0470">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>Invalidation</strong> (ادامه)</h4>
<p>در چهار دقیقه و 59 ثانیه با داده‌های منسوخ شده عمل خواهیم کرد. بنابراین سادگی پیاده‌سازی باید با میزان تحمل شما در مورد عملکرد با داده‌های قدیمی متعادل شود.</p>
<h4><strong>GET</strong>های مشروط</h4>
<p>شایسته ذکر است، زیرا این نادیده گرفته می‌شود، توانایی صدور درخواست‌های <strong>GET</strong> مشروط با <strong>HTTP</strong> است. همانطور که ما به آن اشاره کردیم، <strong>HTTP</strong> این توانایی را فراهم می‌کند که هدرهای <strong>Cache-Control</strong> و <strong>Expires</strong> را در پاسخ‌ها مشخص کنید تا <strong>caching client-side</strong> هوشمندتر را فعال کنید. اما اگر ما مستقیماً با <strong>HTTP</strong> کار می‌کنیم، یک گزینه دیگر در زرادخانه چیزهای خوب <strong>HTTP</strong> ما وجود دارد: <strong>entity tags</strong>، یا <strong>ETags</strong>. یک <strong>Etag</strong> برای تعیین اینکه آیا مقدار یک منبع تغییر کرده است یا خیر استفاده می‌شود. اگر من یک رکورد مشتری را به‌روزرسانی کنم، <strong>URI</strong> منبع یکسان است اما مقدار متفاوت است، بنابراین انتظار دارم <strong>Etag</strong> تغییر کند.
   این زمانی قدرتمند می‌شود که ما از چیزی به نام <strong>conditional GET</strong> استفاده می‌کنیم. هنگام ایجاد یک درخواست <strong>GET</strong>، می‌توانیم <strong>headers</strong> اضافی را مشخص کنیم، و به سرویس بگوییم که منبع را فقط در صورت برآورده شدن معیارهای خاص برای ما ارسال کند.</p>
<p>به عنوان مثال، بیایید تصور کنیم که یک رکورد مشتری را واکشی می‌کنیم، و <strong>Etag</strong> آن به عنوان o5t6fkd2sa برمی‌گردد. بعداً، شاید به این دلیل که یک دستورالعمل <strong>Cache-Control</strong> به ما گفته است که باید منبع را منسوخ شده در نظر بگیریم، ما می‌خواهیم مطمئن شویم که آخرین نسخه را دریافت می‌کنیم. هنگام صدور درخواست <strong>GET</strong> بعدی، می‌توانیم در If-None-Match: o5t6fkd2sa را منتقل کنیم. این به سرور می‌گوید که ما منبع را در <strong>URI</strong> مشخص شده می‌خواهیم، مگر اینکه قبلاً با این مقدار <strong>Etag</strong> مطابقت داشته باشد. اگر در حال حاضر نسخه به‌روز را داریم، سرویس یک پاسخ 304 Not Modified را برای ما ارسال می‌کند و به ما می‌گوید که ما آخرین نسخه را داریم. اگر نسخه جدیدتری در دسترس باشد، ما یک 200 OK با منبع تغییر یافته و یک <strong>Etag</strong> جدید برای منبع دریافت می‌کنیم.</p>
<p>البته، با یک <strong>conditional GET</strong>، ما همچنان درخواست را از <strong>client</strong> به سرور انجام می‌دهیم. اگر <strong>caching</strong> را برای کاهش <strong>network round trips</strong> انجام می‌دهید، این ممکن است به شما کمکی نکند. جایی که مفید است در اجتناب از هزینه بازسازی بی‌مورد منابع است. با <strong>invalidation</strong> مبتنی بر <strong>TTL</strong>، <strong>client</strong> یک کپی جدید از منبع را درخواست می‌کند، حتی اگر منبع تغییر نکرده باشد—سرویس <strong>microservice</strong> که این درخواست را دریافت می‌کند سپس باید آن منبع را دوباره تولید کند، حتی اگر دقیقاً همان چیزی باشد که <strong>client</strong> قبلاً دارد. اگر هزینه ایجاد پاسخ زیاد باشد، شاید نیاز به مجموعه‌ای گران‌قیمت از <strong>database queries</strong> داشته باشد، سپس درخواست‌های <strong>GET</strong> مشروط می‌توانند یک مکانیسم مؤثر باشند.</p>
<h4>مبتنی بر اعلان</h4>
<p>با <strong>invalidation</strong> مبتنی بر اعلان، ما از رویدادها برای کمک به مشترکین در دانستن اینکه آیا ورودی‌های <strong>cache</strong> محلی آنها نیاز به <strong>invalidated</strong> دارند یا خیر، استفاده می‌کنیم. به نظر من، این ظریف‌ترین مکانیسم برای <strong>invalidation</strong> است، اگرچه این با پیچیدگی نسبی آن نسبت به <strong>invalidation</strong> مبتنی بر <strong>TTL</strong> متعادل است.</p>
<p>در شکل 13-14، <strong>microservice</strong> توصیه‌های ما در حال حفظ یک <strong>cache client-side</strong> است. ورودی‌های موجود در آن <strong>cache</strong> زمانی که <strong>microservice</strong> موجودی یک</p>
<p>444 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0470</div>
            </div>
        </div>
        <!-- Page 0471 -->
        <div class="chapter" id="page-0471">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>Invalidation</strong> (ادامه)</h4>
<p>رویداد تغییر موجودی، به Recommendation (یا هر مشترک دیگری در این رویداد) اطلاع می‌دهد که سطح موجودی برای یک مورد معین افزایش یا کاهش یافته است.</p>
<p>شکل 13-14. موجودی، رویدادهای تغییر موجودی را <strong>fires</strong> می‌کند، که Recommendation می‌تواند از آنها برای به‌روزرسانی <strong>cache</strong> محلی خود استفاده کند</p>
<p>مزیت اصلی این مکانیسم این است که پنجره احتمالی را که در آن <strong>cache</strong> در حال ارائه داده‌های قدیمی است، کاهش می‌دهد. پنجره‌ای که در آن <strong>cache</strong> ممکن است در حال حاضر داده‌های قدیمی را ارائه دهد، به زمان لازم برای ارسال و پردازش اعلان محدود می‌شود. بسته به مکانیزمی که برای ارسال اعلان استفاده می‌کنید، این می‌تواند بسیار سریع باشد.</p>
<p>منفی اینجا پیچیدگی پیاده‌سازی است. ما نیاز داریم که مبدأ بتواند اعلان‌ها را منتشر کند، و ما نیاز داریم که طرف‌های ذینفع بتوانند به این اعلان‌ها پاسخ دهند. اکنون، این یک مکان طبیعی برای استفاده از چیزی مانند یک <strong>message broker</strong> است، زیرا این مدل به طرز ماهرانه‌ای در تعاملات معمولی <strong>pub/sub-style</strong> که بسیاری از <strong>brokers</strong> ارائه می‌کنند، قرار می‌گیرد. ضمانت‌های اضافی که <strong>broker</strong> ممکن است بتواند به ما بدهد نیز می‌تواند مفید باشد. با این حال، همانطور که قبلاً در "<strong>Message Brokers</strong>" در صفحه 135 بحث کردیم، یک سربار برای مدیریت <strong>middleware</strong> پیام‌رسانی وجود دارد، و اگر فقط برای این منظور از آن استفاده می‌کردید، ممکن است زیاد باشد. با این حال، اگر از <strong>brokers</strong> برای سایر اشکال ارتباط بین <strong>microservice</strong> استفاده می‌کردید، استفاده از فناوری که قبلاً در اختیار داشتید منطقی بود.</p>
<p>یک مشکل که باید هنگام استفاده از <strong>invalidation</strong> مبتنی بر اعلان از آن آگاه باشید این است که ممکن است بخواهید بدانید که آیا مکانیسم اعلان واقعاً کار می‌کند یا خیر. موقعیتی را در نظر بگیرید که ما مدتی است هیچ رویداد <strong>Stock Changed</strong> از موجودی دریافت نکرده‌ایم. آیا این بدان معناست که ما در آن مدت هیچ اقلامی را نفروخته‌ایم یا اقلامی را دوباره موجود نکرده‌ایم؟ شاید. همچنین می‌تواند به این معنی باشد که مکانیسم اعلان ما از کار افتاده است و دیگر به‌روزرسانی‌ها برای ما ارسال نمی‌شود. اگر این یک نگرانی است، پس ما می‌توانیم یک رویداد <strong>heartbeat</strong> را از طریق همان مکانیسم اعلان ارسال کنیم—Recommendation، در مورد ما—به مشترکین اطلاع دهیم که هنوز اعلان‌هایی در حال آمدن است، اما هیچ</p>
<p><strong>Caching</strong> | 445</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 471" src="page_0471/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0471</div>
            </div>
        </div>
        <!-- Page 0472 -->
        <div class="chapter" id="page-0472">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>Invalidation</strong> (ادامه)</h4>
<p>واقعاً تغییر کرده است. اگر یک رویداد <strong>heartbeat</strong> دریافت نشود، <strong>client</strong> می‌تواند یک مشکل را فرض کند و می‌تواند هر کاری را که مناسب‌تر است انجام دهد—شاید به یک کاربر اطلاع دهد که داده‌های قدیمی را می‌بیند، یا شاید فقط عملکرد را خاموش کند.</p>
<p>شما همچنین باید در نظر بگیرید که اعلان شامل چه چیزی است. اگر اعلان فقط می‌گوید "این چیز تغییر کرده است" بدون اینکه بگوید تغییر چیست، پس هنگام دریافت اعلان، یک مصرف‌کننده باید به مبدأ برود و داده‌های جدید را دریافت کند. از سوی دیگر، اگر اعلان شامل وضعیت فعلی داده‌ها باشد، مصرف‌کنندگان می‌توانند آن را مستقیماً در <strong>cache</strong> محلی خود بارگذاری کنند. داشتن یک اعلان که حاوی داده‌های بیشتری است می‌تواند باعث ایجاد مشکلاتی در رابطه با اندازه شود و همچنین خطر بالقوه قرار دادن داده‌های حساس را به طور گسترده ایجاد می‌کند. ما قبلاً این معاوضه را با نگاهی به ارتباطات مبتنی بر رویداد در "What’s in an Event?" در صفحه 111 با جزئیات بیشتری بررسی کردیم.</p>
<h4><strong>Write-through</strong></h4>
<p>با یک <strong>write-through cache</strong>، <strong>cache</strong> همزمان با حالت مبدأ به‌روزرسانی می‌شود. "همزمان" جایی است که <strong>caches write-through</strong> دشوار می‌شوند، البته. پیاده‌سازی یک مکانیسم <strong>write-through</strong> در یک <strong>cache server-side</strong> تا حدودی ساده است، زیرا شما می‌توانید یک پایگاه داده و یک <strong>cache in-memory</strong> را در همان تراکنش بدون مشکل زیاد به‌روزرسانی کنید. اگر <strong>cache</strong> در جای دیگری باشد، استدلال در مورد اینکه "همزمان" به معنای به‌روزرسانی این ورودی‌ها است، دشوارتر است.</p>
<p>به دلیل این دشواری، شما معمولاً می‌بینید که <strong>caching write-through</strong> در معماری <strong>microservice</strong> در سمت سرور استفاده می‌شود. مزایای آن کاملاً واضح است—پنجره‌ای که در آن یک <strong>client</strong> ممکن است داده‌های قدیمی را ببیند، می‌تواند عملاً حذف شود. این امر در مقابل این واقعیت متعادل است که <strong>caches server-side</strong> ممکن است به طور کلی کمتر مفید باشند، که شرایطی را محدود می‌کند که در آن یک <strong>cache write-through</strong> در <strong>microservices</strong> مؤثر خواهد بود.</p>
<h4><strong>Write-behind</strong></h4>
<p>با یک <strong>write-behind cache</strong>، خود <strong>cache</strong> ابتدا به‌روزرسانی می‌شود، و سپس مبدأ به‌روزرسانی می‌شود. از نظر مفهومی، شما می‌توانید <strong>cache</strong> را به عنوان یک بافر در نظر بگیرید. نوشتن در <strong>cache</strong> سریعتر از به‌روزرسانی مبدأ است. بنابراین ما نتیجه را در <strong>cache</strong> می‌نویسیم، که امکان خواندن‌های بعدی سریعتر را فراهم می‌کند، و اطمینان داریم که مبدأ پس از آن به‌روزرسانی می‌شود.</p>
<p>نگرانی اصلی در مورد <strong>caches write-behind</strong> به طور بالقوه از دست رفتن داده‌ها خواهد بود. اگر خود <strong>cache</strong> بادوام نباشد، ما می‌توانیم داده‌ها را قبل از نوشته شدن داده‌ها به مبدأ از دست بدهیم. علاوه بر این، ما اکنون در یک نقطه جالب هستیم—مبدأ در این زمینه چیست؟ ما انتظار داریم که مبدأ، <strong>microservice</strong> باشد که این داده‌ها از آن منبع گرفته شده‌اند—اما اگر ابتدا <strong>cache</strong> را به‌روزرسانی کنیم، آیا این واقعاً مبدأ است؟ منبع حقیقت ما چیست؟ هنگام استفاده از <strong>caching</strong>، مهم است که داده‌های <strong>cached</strong> (و احتمالاً منسوخ شده) و داده‌هایی را که می‌توان در واقع</p>
<p>446 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0472</div>
            </div>
        </div>
        <!-- Page 0473 -->
        <div class="chapter" id="page-0473">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>Invalidation</strong> (ادامه)</h4>
<p>به‌روزرسانی است. <strong>Write-behind caches</strong> در زمینه <strong>microservices</strong> این موضوع را بسیار کمتر شفاف می‌کند.</p>
<p>در حالی که <strong>write-behind caches</strong> اغلب برای بهینه‌سازی درون فرآیندی استفاده می‌شوند، من آنها را بسیار کمتر برای معماری‌های <strong>microservice</strong> دیده‌ام، تا حدی به دلیل این واقعیت که سایر اشکال ساده‌تر <strong>caching</strong> به اندازه کافی خوب هستند، اما عمدتاً به دلیل پیچیدگی رسیدگی به از دست رفتن داده‌های <strong>cached</strong> نوشته نشده است.</p>
<h4>قانون طلایی <strong>Caching</strong></h4>
<p>در مورد <strong>caching</strong> در مکان‌های بیش از حد مراقب باشید! هرچه <strong>caches</strong> بیشتری بین شما و منبع داده‌های تازه وجود داشته باشد، داده‌ها می‌توانند قدیمی‌تر شوند، و تعیین تازگی داده‌هایی که در نهایت یک <strong>client</strong> می‌بیند، دشوارتر می‌شود. همچنین استدلال در مورد جایی که داده‌ها باید <strong>invalidated</strong> شوند، دشوارتر می‌شود. مبادله پیرامون <strong>caching</strong>—تعادل تازگی داده‌ها در برابر بهینه‌سازی سیستم شما برای بار یا <strong>latency</strong>—یکی از ظریف‌ترین‌ها است، و اگر شما نمی‌توانید به راحتی در مورد اینکه داده‌ها چقدر تازه (یا نه) ممکن است باشند، استدلال کنید، این موضوع دشوار می‌شود.</p>
<p>موقعیتی را در نظر بگیرید که در آن <strong>microservice</strong> موجودی، سطوح موجودی را <strong>caching</strong> می‌کند. درخواست‌ها به موجودی برای سطوح موجودی ممکن است از این <strong>cache server-side</strong> ارائه شوند، که سرعت درخواست را بر این اساس افزایش می‌دهد. بیایید همچنین فرض کنیم که ما یک <strong>TTL</strong> را برای این <strong>cache</strong> داخلی تنظیم کرده‌ایم که یک دقیقه باشد، به این معنی که <strong>cache server-side</strong> ما می‌تواند تا یک دقیقه پشت سطح موجودی واقعی باشد. اکنون، مشخص می‌شود که ما همچنین در سمت <strong>client</strong> در داخل توصیه‌ها <strong>caching</strong> می‌کنیم، جایی که ما نیز از یک <strong>TTL</strong> یک دقیقه‌ای استفاده می‌کنیم.
   وقتی یک ورودی در <strong>cache client-side</strong> منقضی می‌شود، ما از Recommendation درخواستی برای موجودی ارسال می‌کنیم تا یک سطح موجودی به‌روز دریافت کنیم، اما بدون اطلاع ما، درخواست ما به <strong>cache server-side</strong> برخورد می‌کند، که در این مرحله می‌تواند تا یک دقیقه نیز قدیمی باشد. بنابراین ما می‌توانیم در نهایت یک رکورد را در <strong>cache client-side</strong> خود ذخیره کنیم که از ابتدا تا یک دقیقه قدیمی است. این بدان معناست که سطوح موجودی که Recommendation از آنها استفاده می‌کند، به‌طور بالقوه می‌تواند تا دو دقیقه از تاریخ منسوخ شود، حتی اگر از دیدگاه Recommendation، فکر می‌کنیم که آنها می‌توانند فقط تا یک دقیقه از تاریخ منسوخ شوند.</p>
<p>تعدادی راه برای جلوگیری از مشکلاتی از این قبیل وجود دارد. استفاده از یک <strong>expiration</strong> مبتنی بر <strong>timestamp</strong> برای شروع، بهتر از <strong>TTLs</strong> خواهد بود، اما همچنین نمونه‌ای از آنچه در هنگام <strong>caching</strong> به طور مؤثر تودرتو اتفاق می‌افتد است. اگر نتیجه عملیاتی را <strong>cache</strong> کنید که به نوبه خود مبتنی بر ورودی‌های <strong>cached</strong> است، چقدر می‌توانید در مورد به‌روز بودن نتیجه نهایی مطمئن باشید؟</p>
<p>بازگشت به نقل قول معروف از <em>Knuth</em> در اوایل، بهینه‌سازی زودرس می‌تواند باعث ایجاد مشکل شود. <strong>Caching</strong> پیچیدگی را اضافه می‌کند، و ما می‌خواهیم تا حد امکان پیچیدگی کمی اضافه کنیم. تعداد ایده‌آل مکان‌ها برای <strong>cache</strong> صفر است. هر چیز دیگری باید بهینه‌سازی باشد که شما باید انجام دهید—اما از پیچیدگی که می‌تواند به همراه داشته باشد آگاه باشید.</p>
<p><strong>Caching</strong> | 447</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0473</div>
            </div>
        </div>
        <!-- Page 0474 -->
        <div class="chapter" id="page-0474">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>Caching</strong> (ادامه)</h4>
<p>در درجه اول با <strong>caching</strong> به عنوان یک بهینه‌سازی عملکرد رفتار کنید. <strong>Cache</strong> را در کمترین مکان ممکن قرار دهید تا استدلال در مورد تازگی داده‌ها آسان‌تر شود.</p>
<h4>تازگی در مقابل بهینه‌سازی</h4>
<p>بازگشت به مثال ما از <strong>invalidation</strong> مبتنی بر <strong>TTL</strong>، من قبلاً توضیح دادم که اگر یک کپی تازه از داده‌ها را درخواست کنیم که دارای <strong>TTL</strong> پنج دقیقه‌ای است، و یک ثانیه بعد داده‌ها در مبدأ تغییر می‌کند، سپس <strong>cache</strong> ما برای چهار دقیقه و 59 ثانیه باقی‌مانده بر روی داده‌های قدیمی عمل خواهد کرد. اگر این غیرقابل قبول باشد، یک راه‌حل کاهش <strong>TTL</strong> خواهد بود، و در نتیجه مدت زمانی را که می‌توانیم بر روی داده‌های قدیمی عمل کنیم، کاهش می‌دهیم. بنابراین شاید <strong>TTL</strong> را به یک دقیقه کاهش دهیم. این بدان معناست که پنجره قدمت ما به یک پنجم آنچه بود کاهش می‌یابد، اما ما پنج برابر تماس‌های بیشتری با مبدأ برقرار کرده‌ایم، بنابراین باید تأثیر <strong>latency</strong> و بار مرتبط را در نظر بگیریم.</p>
<p>تعادل این نیروها به درک الزامات کاربر نهایی و سیستم گسترده‌تر بستگی دارد. کاربران بدیهی است که همیشه می‌خواهند بر روی تازه‌ترین داده‌ها کار کنند، اما نه اگر این بدان معنا باشد که سیستم تحت بار از کار می‌افتد. به همین ترتیب، گاهی اوقات امن‌ترین کار این است که اگر یک <strong>cache</strong> از کار افتاد، ویژگی‌ها را خاموش کنید، تا از اضافه بار بر مبدأ که باعث ایجاد مشکلات جدی‌تر می‌شود، جلوگیری کنید. وقتی نوبت به تنظیم دقیق آنچه، کجا و نحوه <strong>cache</strong> کردن می‌رسد، اغلب خود را در حال تعادل در امتداد تعدادی از محورها خواهید یافت. این فقط یک دلیل دیگر برای تلاش برای حفظ سادگی چیزها تا حد امکان است—هرچه <strong>caches</strong> کمتر باشند، استدلال در مورد سیستم آسان‌تر می‌شود.</p>
<h4>مسمومیت <strong>Cache</strong>: یک داستان هشداردهنده</h4>
<p>با <strong>caching</strong>، ما اغلب فکر می‌کنیم که اگر در این مورد اشتباه کنیم، بدترین اتفاقی که می‌تواند بیفتد این است که برای مدتی داده‌های قدیمی را ارائه می‌کنیم. اما اگر در نهایت برای همیشه داده‌های قدیمی را ارائه دهید چه اتفاقی می‌افتد؟ در فصل 12، من <em>AdvertCorp</em> را معرفی کردم، که در آن من در تلاش بودم تا به انتقال تعدادی از برنامه‌های قدیمی موجود به یک پلتفرم جدید با استفاده از الگوی انجیر خفه‌کننده کمک کنم. این شامل رهگیری تماس‌ها با چندین برنامه قدیمی و در مواردی که این برنامه‌ها به پلتفرم جدید منتقل شده‌اند، منحرف کردن تماس‌ها بود. برنامه جدید ما به طور مؤثر به عنوان یک <strong>proxy</strong> عمل می‌کرد. ترافیک برنامه‌های قدیمی‌تری که ما هنوز مهاجرت نکرده بودیم، از طریق برنامه جدید ما به برنامه‌های قدیمی پایین‌دستی هدایت می‌شد. برای تماس با برنامه‌های قدیمی، ما چند کار نظافت انجام دادیم. به عنوان مثال، ما اطمینان حاصل کردیم که نتایج حاصل از برنامه قدیمی، <strong>headers cache HTTP</strong> مناسب را اعمال کرده است.</p>
<p>یک روز، اندکی پس از یک انتشار معمول، اتفاق عجیبی شروع به رخ دادن کرد. یک باگ معرفی شده بود که به موجب آن زیرمجموعه‌ای کوچک از صفحات از یک شرط منطقی در کد درج هدر <strong>cache</strong> ما عبور می‌کرد، که منجر به این شد که ما هدر را به هیچ وجه تغییر ندهیم. متأسفانه، این برنامه پایین‌دستی نیز مدتی</p>
<p>448 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 474" src="page_0474/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0474</div>
            </div>
        </div>
        <!-- Page 0475 -->
        <div class="chapter" id="page-0475">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مسمومیت <strong>Cache</strong>: یک داستان هشداردهنده (ادامه)</h4>
<p>قبلاً برای گنجاندن هدر <strong>HTTP</strong> منقضی نشده است: هرگز. این قبلاً هیچ اثری نداشت، زیرا ما این هدر را لغو می‌کردیم. حالا دیگر اینطور نبودیم.</p>
<p>برنامه ما از <strong>Squid</strong> برای <strong>cache</strong> ترافیک <strong>HTTP</strong> استفاده زیادی می‌کرد، و ما مشکل را نسبتاً سریع متوجه شدیم، زیرا درخواست‌های بیشتری را می‌دیدیم که خود <strong>Squid</strong> را دور می‌زدند تا به سرورهای برنامه ما برخورد کنند. ما کد هدر <strong>cache</strong> را درست کردیم و یک نسخه منتشر کردیم، و همچنین ناحیه مربوطه <strong>cache Squid</strong> را به صورت دستی پاک کردیم. با این حال، این کافی نبود.</p>
<p>همانطور که ما فقط بحث کردیم، شما می‌توانید در چندین مکان <strong>cache</strong> کنید—اما گاهی اوقات داشتن <strong>caches</strong> زیاد زندگی شما را سخت‌تر می‌کند، نه آسان‌تر. وقتی صحبت از ارائه محتوا به کاربران یک برنامه وب عمومی می‌شود، شما می‌توانید چندین <strong>cache</strong> بین خود و مشتری خود داشته باشید. نه تنها ممکن است وب‌سایت خود را با چیزی مانند یک شبکه تحویل محتوا <strong>fronting</strong> کنید، بلکه برخی از <strong>ISPs</strong> از <strong>caching</strong> استفاده می‌کنند. آیا می‌توانید آن <strong>caches</strong> را کنترل کنید؟ و حتی اگر می‌توانید، یک <strong>cache</strong> وجود دارد که شما کنترل کمی بر آن دارید: <strong>cache</strong> در مرورگر کاربر.</p>
<p>آن صفحات با <strong>Expires: Never</strong> در <strong>caches</strong> بسیاری از کاربران ما گیر کرده بودند و تا زمانی که <strong>cache</strong> پر نشود یا کاربر آنها را به صورت دستی پاک نکند، هرگز بی‌اعتبار نمی‌شدند. بدیهی است که ما نمی‌توانستیم هیچ یک از این کارها را انجام دهیم؛ تنها گزینه ما این بود که <strong>URLs</strong> این صفحات را تغییر دهیم تا دوباره بازیابی شوند.</p>
<p><strong>Caching</strong> در واقع می‌تواند بسیار قدرتمند باشد، اما شما باید مسیر کامل داده‌ها را که از منبع به مقصد <strong>cached</strong> شده است، درک کنید تا واقعاً پیچیدگی‌های آن و آنچه می‌تواند اشتباه شود را درک کنید.</p>
<h4>مقیاس‌بندی خودکار</h4>
<p>اگر شما به اندازه کافی خوش‌شانس هستید که دارای <strong>provisioning</strong> کاملاً خودکار <strong>virtual hosts</strong> هستید و می‌توانید استقرار نمونه‌های <strong>microservice</strong> خود را کاملاً خودکار کنید، در این صورت شما بلوک‌های سازنده‌ای دارید که به شما امکان می‌دهد تا <strong>microservices</strong> خود را به طور خودکار مقیاس‌بندی کنید.</p>
<p>به عنوان مثال، شما می‌توانید مقیاس‌بندی را با روند‌های شناخته شده فعال کنید. ممکن است بدانید که بار اوج سیستم شما بین ساعت 9 صبح تا 5 بعد از ظهر است، بنابراین شما نمونه‌های اضافی را در ساعت 8:45 صبح راه‌اندازی می‌کنید و آنها را در ساعت 5:15 بعد از ظهر خاموش می‌کنید. اگر از چیزی مانند <strong>AWS</strong> استفاده می‌کنید (که پشتیبانی بسیار خوبی از <strong>autoscaling</strong> داخلی دارد)، خاموش کردن نمونه‌هایی که دیگر به آنها نیاز ندارید به صرفه‌جویی در هزینه کمک می‌کند. شما به داده‌هایی نیاز دارید تا درک کنید که چگونه بار شما در طول زمان، روز به روز و هفته به هفته تغییر می‌کند.
   برخی از مشاغل نیز دارای چرخه‌های فصلی آشکار هستند، بنابراین ممکن است برای تصمیم‌گیری‌های مناسب به داده‌هایی نیاز داشته باشید که به مسیر منصفانه‌ای برگردند.</p>
<p>از سوی دیگر، شما می‌توانید واکنشی باشید، نمونه‌های اضافی را هنگام مشاهده افزایش بار یا خرابی یک نمونه بالا بیاورید، و نمونه‌ها را زمانی که دیگر به آنها نیاز ندارید حذف کنید. دانستن اینکه چقدر سریع می‌توانید پس از مشاهده یک روند صعودی مقیاس‌بندی کنید، کلیدی است. اگر می‌دانید که فقط چند دقیقه قبل از افزایش بار اطلاع‌رسانی دریافت خواهید کرد</p>
<p>مقیاس‌پذیری خودکار | 449</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0475</div>
            </div>
        </div>
        <!-- Page 0476 -->
        <div class="chapter" id="page-0476">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مقیاس‌پذیری خودکار (ادامه)</h4>
<p>بار، اما مقیاس‌بندی حداقل 10 دقیقه طول می‌کشد، پس می‌دانید که باید ظرفیت اضافی را برای پر کردن این شکاف در اطراف نگه دارید. داشتن مجموعه‌ای خوب از تست‌های بار تقریباً در اینجا ضروری است. شما می‌توانید از آنها برای آزمایش قوانین <strong>autoscaling</strong> خود استفاده کنید. اگر تست‌هایی ندارید که بتوانند بارهای مختلف را که باعث راه‌اندازی مقیاس‌بندی می‌شوند، تولید کنند، پس شما فقط در تولید متوجه می‌شوید که اگر قوانین را اشتباه گرفته‌اید. و عواقب شکست عالی نیستند!</p>
<p>یک سایت خبری نمونه‌ای عالی از نوع کسب‌وکاری است که در آن ممکن است یک ترکیب از مقیاس‌بندی پیش‌بینی‌کننده و واکنشی بخواهید. در آخرین سایت خبری که روی آن کار کردم، ما روند‌های روزانه بسیار واضحی را دیدیم، با بازدیدهایی که از صبح تا ناهار افزایش می‌یافت و سپس شروع به کاهش می‌کرد. این الگو روز به روز تکرار می‌شد، با ترافیک معمولاً در آخر هفته کمتر. این به ما یک روند نسبتاً واضح داد که می‌تواند مقیاس‌بندی فعالانه منابع را هدایت کند، چه بالا و چه پایین. از سوی دیگر، یک خبر بزرگ باعث افزایش غیرمنتظره می‌شود، که به ظرفیت بیشتری نیاز دارد و اغلب در مدت زمان کوتاهی.</p>
<p>من در واقع می‌بینم که <strong>autoscaling</strong> بیشتر برای رسیدگی به خرابی نمونه‌ها استفاده می‌شود تا برای واکنش به شرایط بار. <strong>AWS</strong> به شما این امکان را می‌دهد که قوانینی مانند "باید حداقل پنج نمونه در این گروه وجود داشته باشد" را مشخص کنید، به طوری که اگر یک نمونه از کار افتاد، یک نمونه جدید به طور خودکار راه‌اندازی می‌شود. من این رویکرد را دیده‌ام که منجر به یک بازی سرگرم‌کننده <strong>whack-a-mole</strong> می‌شود، زمانی که کسی فراموش می‌کند قانون را خاموش کند و سپس سعی می‌کند نمونه‌ها را برای نگهداری حذف کند، فقط می‌بیند که آنها همچنان در حال چرخش هستند!</p>
<p>مقیاس‌بندی واکنشی و پیش‌بینی‌کننده هر دو بسیار مفید هستند و اگر از پلتفرمی استفاده می‌کنید که به شما امکان می‌دهد فقط برای منابع محاسباتی که استفاده می‌کنید، پرداخت کنید، می‌تواند به شما کمک کند تا هزینه را بسیار مؤثرتر کنید. اما آنها همچنین به مشاهده دقیق داده‌های موجود برای شما نیاز دارند. من پیشنهاد می‌کنم ابتدا از <strong>autoscaling</strong> برای شرایط خرابی استفاده کنید در حالی که داده‌ها را جمع‌آوری می‌کنید. هنگامی که می‌خواهید برای بار شروع به <strong>autoscaling</strong> کنید، مطمئن شوید که در مورد مقیاس‌بندی سریع بیش از حد محتاط هستید. در اکثر موقعیت‌ها، داشتن قدرت محاسباتی بیشتر از آنچه نیاز دارید، بسیار بهتر از نداشتن قدرت کافی است!</p>
<h4>شروع دوباره</h4>
<p>معماری که شما را شروع می‌کند ممکن است معماری نباشد که شما را در زمانی که سیستم شما مجبور به رسیدگی به حجم بسیار متفاوتی از بار است، حفظ کند. همانطور که قبلاً دیده‌ایم، برخی از اشکال مقیاس‌پذیری وجود دارد که می‌تواند تأثیر بسیار محدودی بر معماری سیستم شما داشته باشد—به عنوان مثال، مقیاس‌پذیری عمودی و تکثیر افقی. با این حال، در نقاط خاصی، شما باید کاری کاملاً اساسی برای تغییر معماری سیستم خود انجام دهید تا از سطح بعدی رشد پشتیبانی کنید.</p>
<p>داستان <em>Gilt</em> را به یاد بیاورید، که در "اجرای ایزوله" در صفحه 228 به آن اشاره کردیم. یک برنامه ساده <strong>Rails monolithic</strong> به مدت دو سال برای <em>Gilt</em> خوب عمل کرد. کسب‌وکار آن به طور فزاینده‌ای موفق شد، که به معنای مشتریان بیشتر و بار بیشتر بود. در یک نقطه عطف معین، این شرکت مجبور شد برنامه را دوباره طراحی کند تا بار در حال مشاهده را مدیریت کند.</p>
<p>450 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0476</div>
            </div>
        </div>
        <!-- Page 0477 -->
        <div class="chapter" id="page-0477">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>شروع دوباره (ادامه)</h4>
<p>یک طراحی مجدد ممکن است به معنای جدا کردن یک <strong>monolith</strong> موجود باشد، همانطور که برای <em>Gilt</em> این اتفاق افتاد. یا ممکن است به معنای انتخاب فروشگاه‌های داده جدیدی باشد که بتوانند بار را بهتر مدیریت کنند. همچنین می‌تواند به معنای اتخاذ تکنیک‌های جدید، مانند انتقال از <strong>request-response</strong> همزمان به سیستم‌های مبتنی بر رویداد، اتخاذ پلتفرم‌های استقرار جدید، تغییر کل پشته‌های فناوری، یا هر چیزی در این بین باشد.</p>
<p>این خطر وجود دارد که مردم نیاز به <strong>rearchitect</strong> را در صورت رسیدن به آستانه‌های مقیاس‌بندی خاصی به عنوان دلیلی برای ساختن از ابتدا برای مقیاس عظیم ببینند. این می‌تواند فاجعه‌بار باشد. در ابتدای یک پروژه جدید، ما اغلب دقیقاً نمی‌دانیم چه می‌خواهیم بسازیم، و همچنین نمی‌دانیم که آیا موفق خواهد شد یا خیر. ما باید بتوانیم به سرعت آزمایش کنیم و بفهمیم چه قابلیت‌هایی را باید بسازیم. اگر ما در تلاش برای ساختن برای مقیاس عظیم در ابتدا بودیم، مقدار زیادی از کار را برای آماده شدن برای باری که ممکن است هرگز نیاید، <strong>front-loading</strong> می‌کردیم، در حالی که تلاش‌ها را از فعالیت‌های مهم‌تر، مانند درک اینکه آیا کسی واقعاً می‌خواهد از محصول ما استفاده کند، منحرف می‌کردیم. <em>Eric Ries</em> داستان شش ماه را روایت می‌کند که صرف ساختن محصولی کرد که هیچ‌کس آن را دانلود نکرد. او فکر کرد که می‌توانست یک لینک را در یک صفحه وب قرار دهد که وقتی مردم روی آن کلیک می‌کنند 404 بود تا ببیند آیا تقاضایی وجود دارد، و در عوض شش ماه را در ساحل گذراند، و به همان اندازه یاد گرفت!</p>
<p>نیاز به تغییر سیستم‌های ما برای مقابله با مقیاس‌بندی، نشانه شکست نیست. این نشانه موفقیت است.</p>
<h4>خلاصه</h4>
<p>همانطور که می‌بینیم، هر نوع مقیاس‌پذیری که به دنبال آن هستید، <strong>microservices</strong> گزینه‌های مختلفی را از نظر نحوه برخورد شما با مشکل به شما ارائه می‌دهند.</p>
<p>محورهای مقیاس‌بندی می‌توانند یک مدل مفید برای استفاده در هنگام در نظر گرفتن انواع مقیاس‌بندی‌های موجود برای شما باشند:</p>
<ul>
<li>مقیاس‌پذیری عمودی</li>
<p>به طور خلاصه، این به معنای گرفتن یک ماشین بزرگتر است.</p>
<li>تکثیر افقی</li>
<p>داشتن چندین چیز که قادر به انجام کار مشابهی هستند.</p>
<li>تقسیم داده‌ها</li>
<p>تقسیم کار بر اساس برخی از ویژگی‌های داده‌ها، به عنوان مثال، گروه مشتری.</p>
<li>تجزیه عملکردی</li>
<p>جداسازی کار بر اساس نوع، به عنوان مثال، تجزیه <strong>microservice</strong>.</p>
</ul>
<p>کلید بسیاری از این موارد، درک این است که شما چه می‌خواهید—تکنیک‌هایی که در مقیاس‌بندی برای بهبود <strong>latency</strong> مؤثر هستند ممکن است در کمک به مقیاس برای حجم مؤثر نباشند.</p>
<p>خلاصه | 451</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0477</div>
            </div>
        </div>
        <!-- Page 0478 -->
        <div class="chapter" id="page-0478">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>خلاصه (ادامه)</h4>
<p>با این حال، امیدوارم نشان داده باشم که بسیاری از اشکال مقیاس‌پذیری که ما در مورد آنها بحث کرده‌ایم، منجر به افزایش پیچیدگی در سیستم شما می‌شود. بنابراین هدفمند بودن از نظر آنچه می‌خواهید تغییر دهید و اجتناب از خطرات بهینه‌سازی زودرس مهم است.</p>
<p>در مرحله بعد، ما از نگاه به آنچه در پشت صحنه اتفاق می‌افتد به قابل مشاهده‌ترین بخش‌های سیستم خود—رابط کاربری—می‌رویم.</p>
<p>452 | فصل 13: مقیاس‌پذیری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0478</div>
            </div>
        </div>
        <!-- Page 0479 -->
        <div class="chapter" id="page-0479">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>بخش سوم</h3>
<h3>مردم</h3>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0479</div>
            </div>
        </div>
        <!-- Page 0481 -->
        <div class="chapter" id="page-0481">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>فصل 14</h3>
<h3>رابط‌های کاربری</h3>
<p>تاکنون، ما واقعاً به دنیای رابط کاربری نپرداخته‌ایم. شاید تعداد کمی از شما در آنجا یک <strong>API</strong> سرد، سخت و بالینی را به مشتریان خود ارائه می‌دهید، اما بسیاری از ما خود را در حال ایجاد رابط‌های کاربری زیبا و کاربردی می‌یابیم که مشتریان ما را خوشحال می‌کند. به هر حال، رابط کاربری جایی است که ما تمام این <strong>microservices</strong> را در کنار هم قرار می‌دهیم تا چیزی را ایجاد کنیم که برای مشتریان ما معنی‌دار باشد.</p>
<p>وقتی برای اولین بار شروع به کار با کامپیوتر کردم، ما بیشتر در مورد <strong>clients</strong> بزرگ و سنگین صحبت می‌کردیم که روی دسکتاپ‌های ما اجرا می‌شدند. من ساعت‌های زیادی را با <em>Motif</em> و سپس <em>Swing</em> صرف کردم و سعی کردم <strong>software</strong> خود را تا حد امکان خوب و کاربردی کنم. اغلب این سیستم‌ها فقط برای ایجاد و دستکاری فایل‌های محلی بودند، اما بسیاری از آنها یک مؤلفه سمت سرور داشتند. اولین کار من در <em>Thoughtworks</em> شامل ایجاد یک سیستم نقطه فروش الکترونیکی مبتنی بر <em>Swing</em> بود که فقط یکی از تعداد زیادی قطعات متحرک بود، که بیشتر آنها روی سرور بودند.</p>
<p>سپس وب آمد. ما به جای آن شروع به فکر کردن به <strong>UIs</strong> خود به عنوان "<strong>thin</strong>" کردیم، با منطق بیشتر در سمت سرور. در ابتدا، برنامه‌های سمت سرور ما کل صفحه را رندر می‌کردند و آن را به مرورگر <strong>client</strong> ارسال می‌کردند، که بسیار کم کار می‌کرد. هر تعاملی در سمت سرور از طریق <strong>GETs</strong> و <strong>POSTs</strong> که با کلیک کاربر روی لینک‌ها یا پر کردن فرم‌ها ایجاد می‌شد، انجام می‌شد. با گذشت زمان، <em>JavaScript</em> به یک گزینه محبوب‌تر برای افزودن رفتار پویا به رابط کاربری مبتنی بر مرورگر تبدیل شد، و می‌توان استدلال کرد که برخی از برنامه‌ها به اندازه <strong>clients</strong> قدیمی دسکتاپ "<strong>fat</strong>" بودند. متعاقباً ما شاهد ظهور برنامه موبایل بودیم، و امروزه ما یک چشم‌انداز متنوع برای ارائه رابط‌های کاربری گرافیکی به کاربران خود داریم—پلتفرم‌های مختلف، و فناوری‌های مختلف برای آن پلتفرم‌ها. این طیف وسیعی از فناوری‌ها، مجموعه‌ای از گزینه‌ها را برای چگونگی ایجاد رابط‌های کاربری مؤثر که توسط <strong>microservices</strong> پشتیبانی می‌شوند، به ما می‌دهد. ما همه اینها و موارد دیگر را در این فصل بررسی خواهیم کرد.</p>
<p>455</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0481</div>
            </div>
        </div>
        <!-- Page 0482 -->
        <div class="chapter" id="page-0482">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>به سوی دیجیتال</h4>
<p>در طی چند سال گذشته، سازمان‌ها شروع به دور شدن از این فکر کرده‌اند که باید با وب یا موبایل متفاوت رفتار کرد. آنها در عوض به طور کلی‌تر به <strong>digital</strong> فکر می‌کنند. بهترین راه برای استفاده مشتریان ما از خدماتی که ارائه می‌دهیم چیست؟ و این چه تاثیری بر معماری سیستم ما دارد؟ این درک که ما نمی‌توانیم دقیقاً پیش‌بینی کنیم که مشتری چگونه ممکن است با محصولات ما تعامل داشته باشد، باعث پذیرش <strong>APIs</strong> دقیق‌تر شده است، مانند <strong>APIs</strong> ارائه شده توسط <strong>microservices</strong>. با ترکیب قابلیت‌هایی که <strong>microservices</strong> ما به روش‌های مختلف در معرض نمایش می‌گذارند، می‌توانیم تجربیات متفاوتی را برای مشتریان خود در برنامه دسکتاپ، دستگاه تلفن همراه و دستگاه پوشیدنی آنها و حتی در فرم فیزیکی در صورت بازدید از فروشگاه‌های <em>brick-and-mortar</em> خود ارائه دهیم.</p>
<p>بنابراین رابط‌های کاربری را به عنوان مکان‌هایی در نظر بگیرید که در آن رشته‌های مختلف قابلیت‌هایی را که می‌خواهیم به کاربران خود ارائه دهیم، به هم می‌بافیم. با در نظر گرفتن این موضوع، چگونه تمام این رشته‌ها را در کنار هم قرار دهیم؟ ما باید به این مشکل از دو جهت نگاه کنیم: چه کسی و چگونه. اولاً، ما جنبه‌های سازمانی را در نظر خواهیم گرفت—چه کسی مسئولیت‌ها را در هنگام ارائه رابط‌های کاربری بر عهده دارد؟ ثانیاً، ما به مجموعه‌ای از الگوها نگاه خواهیم کرد که می‌توانند برای پیاده‌سازی این رابط‌ها استفاده شوند.</p>
<h4>مدل‌های مالکیت</h4>
<p>همانطور که در فصل 1 بحث کردیم، معماری لایه‌ای سنتی می‌تواند در هنگام ارائه مؤثر <strong>software</strong> مشکلاتی ایجاد کند. در شکل 14-1، ما یک مثال را می‌بینیم که در آن مسئولیت لایه رابط کاربری متعلق به یک تیم <strong>frontend</strong> واحد است، در حالی که کار خدمات <strong>backend</strong> توسط تیم دیگری انجام می‌شود. در این مثال، افزودن یک کنترل ساده شامل کاری است که توسط سه تیم مختلف انجام می‌شود. این نوع ساختارهای سازمانی <strong>tiered</strong> می‌توانند به دلیل نیاز به هماهنگی مداوم تغییرات و واگذاری کار بین تیم‌ها، تأثیر قابل‌توجهی بر سرعت تحویل ما بگذارند.</p>
<p>456 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0482</div>
            </div>
        </div>
        <!-- Page 0483 -->
        <div class="chapter" id="page-0483">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مدل‌های مالکیت (ادامه)</h4>
<p>شکل 14-1. ایجاد تغییر در تمام سه لایه درگیرتر است</p>
<p>مدلی که من بسیار ترجیح می‌دهم و احساس می‌کنم با دستیابی به هدف استقرار مستقل همسوتر است، این است که <strong>UI</strong> را از هم جدا کرده و توسط تیمی مدیریت شود که اجزای سمت سرور را نیز مدیریت می‌کند، همانطور که در شکل 14-2 می‌بینیم. در اینجا، یک تیم واحد مسئول تمام تغییراتی می‌شود که ما برای افزودن کنترل جدید خود باید انجام دهیم.</p>
<p>تیم‌هایی که مالکیت کامل عملکرد <strong>end-to-end</strong> را دارند، می‌توانند تغییرات را سریع‌تر ایجاد کنند. داشتن مالکیت کامل، هر تیم را تشویق می‌کند تا یک نقطه تماس مستقیم با یک کاربر نهایی <strong>software</strong> داشته باشد. با تیم‌های <strong>backend</strong>، ردیابی اینکه کاربر نهایی کیست، آسان است.</p>
<p>با وجود اشکالات، من (متأسفانه) همچنان تیم <strong>frontend</strong> اختصاصی را به عنوان الگوی سازمانی رایج‌تر در بین شرکت‌هایی که از <strong>microservices</strong> استفاده می‌کنند، می‌بینم. چرا اینطور است؟</p>
<p>مدل‌های مالکیت | 457</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 483" src="page_0483/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0483</div>
            </div>
        </div>
        <!-- Page 0484 -->
        <div class="chapter" id="page-0484">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مدل‌های مالکیت (ادامه)</h4>
<p>شکل 14-2. <strong>UI</strong> از هم جدا شده و متعلق به تیمی است که عملکرد سمت سرور را که از <strong>UI</strong> پشتیبانی می‌کند نیز مدیریت می‌کند</p>
<h4>عوامل محرک برای تیم‌های <strong>Frontend</strong> اختصاصی</h4>
<p>به نظر می‌رسد که تمایل به تیم‌های <strong>frontend</strong> اختصاصی به سه عامل اصلی برمی‌گردد: کمبود متخصصان، تمایل به ثبات و چالش‌های فنی.</p>
<p>اولاً، ارائه یک رابط کاربری نیازمند درجه‌ای از مهارت‌های تخصصی است. جنبه‌های تعامل و طراحی گرافیکی وجود دارد، و سپس دانش فنی لازم برای ارائه یک تجربه وب یا برنامه بومی عالی وجود دارد. متخصصانی با این مهارت‌ها می‌توانند به سختی به دست آیند، و از آنجایی که این افراد یک کالای کمیاب هستند، وسوسه می‌شود که همه آنها را در کنار هم قرار دهید تا بتوانید مطمئن شوید که فقط روی تخصص خود تمرکز می‌کنند.</p>
<p>دومین عامل محرک برای یک تیم <strong>frontend</strong> جداگانه، ثبات است. اگر شما یک تیم مسئول ارائه رابط کاربری مشتری‌محور خود دارید، می‌توانید اطمینان حاصل کنید که <strong>UI</strong> شما ظاهری ثابت دارد. شما از مجموعه ثابتی از کنترل‌ها برای حل مشکلات مشابه استفاده می‌کنید تا رابط کاربری مانند یک موجودیت واحد و منسجم به نظر برسد.</p>
<p>458 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 484" src="page_0484/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0484</div>
            </div>
        </div>
        <!-- Page 0485 -->
        <div class="chapter" id="page-0485">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مدل‌های مالکیت (ادامه)</h4>
<p>1 <em>Matthew Skelton and Manuel Pais</em>, <em>Team Topologies</em> (Portland, OR: IT Revolution, 2019).</p>
<p>2 همانطور که <em>Charity Majors</em> می‌گوید، "شما توسعه‌دهنده <em>full stack</em> نیستید مگر اینکه <strong>chips</strong> را بسازید."</p>
<p>در نهایت، برخی از فناوری‌های رابط کاربری می‌توانند در یک روش غیر <strong>monolithic</strong> چالش‌برانگیز باشند. در اینجا من به طور خاص به برنامه‌های تک صفحه‌ای (<strong>SPAs</strong>) فکر می‌کنم، که حداقل از نظر تاریخی، جدا کردن آنها آسان نبوده است. به طور سنتی، یک رابط کاربری وب از چندین صفحه وب تشکیل می‌شد، و شما از یک صفحه به صفحه دیگر پیمایش می‌کردید. با <strong>SPAs</strong>، در عوض کل برنامه در یک صفحه وب واحد ارائه می‌شود. فریم‌ورک‌هایی مانند <em>Angular</em>، <em>React</em> و <em>Vue</em> از نظر تئوری امکان ایجاد رابط‌های کاربری پیچیده‌تری را نسبت به وب‌سایت‌های "قدیمی" فراهم می‌کنند. ما به مجموعه‌ای از الگوها نگاه خواهیم کرد که می‌تواند گزینه‌های مختلفی را برای نحوه تجزیه یک رابط کاربری به شما ارائه دهد، و از نظر <strong>SPAs</strong> من نشان خواهم داد که چگونه مفهوم <strong>micro front-end</strong> می‌تواند به شما اجازه دهد از فریم‌ورک‌های <strong>SPA</strong> استفاده کنید، در حالی که هنوز از نیاز به یک رابط کاربری <strong>monolithic</strong> اجتناب می‌کنید.</p>
<h4>به سمت تیم‌های <strong>Stream-Aligned</strong></h4>
<p>من فکر می‌کنم داشتن یک تیم <strong>frontend</strong> اختصاصی به طور کلی یک اشتباه است، اگر سعی می‌کنید عملکرد خوبی را بهینه کنید—این امر نقاط تحویل جدیدی را در سازمان شما ایجاد می‌کند و سرعت کارها را کاهش می‌دهد. در حالت ایده‌آل، تیم‌های ما حول بخش‌های <strong>end-to-end</strong> از عملکرد همسو هستند، و به هر تیم اجازه می‌دهند تا ویژگی‌های جدید را به مشتریان خود ارائه دهد و در عین حال میزان هماهنگی مورد نیاز را کاهش دهد. مدل مورد علاقه من تیمی است که مالک تحویل <strong>end-to-end</strong> عملکرد در یک بخش خاص از دامنه باشد. این با آنچه <em>Matthew Skelton</em> و <em>Manuel Pais</em> به عنوان تیم‌های <strong>stream-aligned</strong> در کتاب خود، <em>Team Topologies</em> توصیف می‌کنند، مطابقت دارد.1 همانطور که آنها توصیف می‌کنند:</p>
<p>یک تیم <strong>stream-aligned</strong>، تیمی است که با یک جریان کاری واحد و با ارزش همسو است...[T]یم توانمند است تا ارزش مشتری یا کاربر را تا حد امکان سریع، ایمن و مستقل بسازد و ارائه دهد، بدون نیاز به تحویل به تیم‌های دیگر برای انجام بخش‌هایی از کار.</p>
<p>به یک معنا، ما در مورد تیم‌های <strong>full stack</strong> صحبت می‌کنیم (به جای توسعه‌دهندگان <strong>full stack</strong>).2 تیمی که مسئولیت <strong>end-to-end</strong> تحویل عملکرد <em>user-facing</em> را بر عهده دارد، همچنین ارتباط مستقیم‌تری با کاربر نهایی خواهد داشت. من اغلب تیم‌های "<strong>backend</strong>" را دیده‌ام که ایده مبهمی در مورد عملکرد <strong>software</strong> یا نیازهای کاربران دارند، که می‌تواند باعث ایجاد انواع سوء تفاهم‌ها در هنگام پیاده‌سازی عملکرد جدید شود. از سوی دیگر، تیم‌های <strong>end-to-end</strong>، برقراری ارتباط مستقیم با افرادی که از <strong>software</strong> ایجاد شده توسط آنها استفاده می‌کنند را بسیار آسان‌تر خواهند یافت—آنها می‌توانند بیشتر بر این تمرکز کنند که اطمینان حاصل کنند افرادی که به آنها خدمت می‌کنند، آنچه را که نیاز دارند، دریافت می‌کنند.</p>
<p>به عنوان یک مثال مشخص، من مدتی را با <em>FinanceCo</em>، یک شرکت <em>Fintech</em> موفق و در حال رشد مستقر در اروپا، کار کردم. در <em>FinanceCo</em>، تقریباً همه تیم‌ها روی</p>
<p>به سمت تیم‌های <strong>Stream-Aligned</strong> | 459</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0485</div>
            </div>
        </div>
        <!-- Page 0486 -->
        <div class="chapter" id="page-0486">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>به سمت تیم‌های <strong>Stream-Aligned</strong> (ادامه)</h4>
<p><strong>software</strong> که مستقیماً بر تجربه مشتری تأثیر می‌گذارد و دارای شاخص‌های کلیدی عملکرد (<strong>KPIs</strong>) مشتری‌محور است—موفقیت یک تیم معین کمتر با تعداد ویژگی‌هایی که ارسال کرده و بیشتر با کمک به بهبود تجربه افرادی که از <strong>software</strong> استفاده می‌کنند، هدایت می‌شود. این موضوع مشخص می‌شود که چگونه یک تغییر می‌تواند بر مشتریان تأثیر بگذارد. این تنها به دلیل این واقعیت امکان‌پذیر است که اکثریت تیم‌ها مسئولیت‌های مستقیم و <em>customer-facing</em> را از نظر <strong>software</strong> که ارائه می‌دهند، دارند. هنگامی که شما بیشتر از کاربر نهایی حذف می‌شوید، درک اینکه آیا مشارکت‌های شما موفقیت‌آمیز است، دشوارتر می‌شود، و شما می‌توانید بر اهدافی تمرکز کنید که بسیار دور از چیزهایی است که افرادی که از <strong>software</strong> شما استفاده می‌کنند، به آنها اهمیت می‌دهند.</p>
<p>بیایید دوباره به دلایلی که تیم‌های <strong>frontend</strong> اختصاصی وجود دارند—متخصصان، ثبات، و چالش‌های فنی—نگاهی بیندازیم و اکنون بیایید نگاهی بیندازیم که چگونه می‌توان به این مسائل رسیدگی کرد.</p>
<h4>اشتراک‌گذاری متخصصان</h4>
<p>توسعه‌دهندگان خوب می‌توانند به سختی پیدا شوند، و یافتن آنها زمانی پیچیده‌تر می‌شود که به توسعه‌دهندگانی با یک تخصص خاص نیاز دارید. به عنوان مثال، در زمینه رابط‌های کاربری، اگر شما رابط‌های بومی موبایل و همچنین وب را ارائه می‌دهید، ممکن است خود را نیازمند افرادی کنید که با <em>iOS</em> و <em>Android</em> و همچنین توسعه وب مدرن تجربه داشته باشند. این جدای از این واقعیت است که شما ممکن است طراحان تعامل اختصاصی، طراحان گرافیک، متخصصان دسترسی‌پذیری و موارد مشابه را بخواهید. افرادی با مهارت‌های مناسب برای این زمینه‌های "باریک" ممکن است کم باشند، و آنها همیشه کار بیشتری از آنچه زمان دارند، داشته باشند.</p>
<p>همانطور که قبلاً اشاره کردیم، رویکرد سنتی برای ساختارهای سازمانی این است که شما تمام افرادی را که دارای مجموعه مهارت‌های مشابهی هستند، در یک تیم قرار دهید، و به شما اجازه می‌دهد تا آنچه را که روی آن کار می‌کنند، به طور دقیق کنترل کنید. اما همانطور که ما نیز بحث کردیم، این امر منجر به سازمان‌های <em>siloed</em> می‌شود.</p>
<p>قرار دادن افراد با مهارت‌های تخصصی در تیم اختصاصی خود، شما را از فرصت‌هایی برای اینکه توسعه‌دهندگان دیگر این مهارت‌های مورد تقاضا را کسب کنند، محروم می‌کند. شما نیازی ندارید که هر توسعه‌دهنده یاد بگیرد که چگونه یک توسعه‌دهنده <em>iOS</em> متخصص شود، به عنوان مثال، اما هنوز هم می‌تواند برای برخی از توسعه‌دهندگان شما مفید باشد که مهارت‌های کافی را در آن زمینه یاد بگیرند تا به کارهای آسان کمک کنند، و متخصصان شما را آزاد بگذارند تا وظایف واقعاً سخت را انجام دهند.
   به اشتراک‌گذاری مهارت‌ها همچنین می‌تواند با ایجاد جوامع عمل کمک شود—شما ممکن است در نظر بگیرید که یک جامعه <strong>UI</strong> داشته باشید که از تیم‌های شما عبور می‌کند و به مردم امکان می‌دهد ایده‌ها و چالش‌ها را با همتایان خود به اشتراک بگذارند.</p>
<p>به یاد دارم زمانی که همه تغییرات پایگاه داده باید توسط یک مجموعه مرکزی از مدیران پایگاه داده (<em>DBAs</em>) انجام می‌شد. توسعه‌دهندگان در نتیجه، آگاهی کمی از نحوه عملکرد پایگاه‌های داده داشتند، و بیشتر <strong>software</strong> را ایجاد می‌کردند که به درستی از پایگاه داده استفاده نمی‌کرد. علاوه بر این، بسیاری از کارهایی که از <em>DBAs</em> باتجربه خواسته می‌شد انجام دهند، شامل تغییرات جزئی بود. با کشیده شدن کارهای بیشتر پایگاه داده به تیم‌های تحویل، توسعه‌دهندگان به طور کلی درک بهتری از پایگاه‌های داده پیدا کردند و می‌توانستند خودشان کارهای پیش پا افتاده را انجام دهند و <em>DBAs</em> باارزش را آزاد کنند تا بر روی پایگاه داده‌های پیچیده‌تر تمرکز کنند</p>
<p>460 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0486</div>
            </div>
        </div>
        <!-- Page 0487 -->
        <div class="chapter" id="page-0487">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>به سمت تیم‌های <strong>Stream-Aligned</strong> (ادامه)</h4>
<p>مسائلی، که از مهارت‌ها و تجربه‌های عمیق‌تر آنها استفاده بهتری می‌کردند. یک تغییر مشابه در فضای عملیات و <strong>testers</strong> رخ داده است، که در آن کارهای بیشتری از این نوع وارد تیم‌ها شده است.</p>
<p>بنابراین، برعکس، انتقال متخصصان از تیم‌های اختصاصی، توانایی متخصصان را برای انجام کارشان مهار نمی‌کند. در واقع، احتمالاً پهنای باند آنها را برای تمرکز بر مشکلات دشواری که واقعاً به توجه آنها نیاز دارند، افزایش می‌دهد.</p>
<p>ترفند این است که راهی مؤثرتر برای استقرار متخصصان خود پیدا کنید. در حالت ایده‌آل، آنها در تیم‌ها تعبیه می‌شوند. با این حال، گاهی اوقات، ممکن است کار کافی برای توجیه حضور تمام وقت آنها در یک تیم معین وجود نداشته باشد، که در این صورت ممکن است زمان خود را بین چندین تیم تقسیم کنند. مدل دیگر این است که تیمی اختصاصی با این مهارت‌ها داشته باشید که کار صریح آنها این است که تیم‌های دیگر را فعال کنند. در <em>Team Topologies</em>، <em>Skelton</em> و <em>Pais</em> این تیم‌ها را به عنوان تیم‌های فعال‌کننده توصیف می‌کنند. کار آنها این است که به تیم‌های دیگری که بر ارائه ویژگی‌های جدید تمرکز دارند کمک کنند تا کار خود را انجام دهند. شما می‌توانید در مورد این تیم‌ها بیشتر شبیه یک مشاوره داخلی فکر کنید—آنها می‌توانند وارد شوند و زمان هدفمندی را با یک تیم <strong>stream-aligned</strong> سپری کنند، و به آن کمک کنند تا در یک منطقه خاص خودکفا شود یا زمان اختصاصی را برای کمک به راه‌اندازی یک قطعه کار دشوار فراهم کند.</p>
<p>بنابراین، چه متخصصان شما به صورت تمام وقت در یک تیم تعبیه شده باشند، یا برای فعال کردن دیگران برای انجام همان کار کار کنند، می‌توانید <em>silos</em> سازمانی را حذف کنید و در عین حال به ارتقای مهارت همکاران خود کمک کنید.</p>
<h4>اطمینان از ثبات</h4>
<p>دومین موضوعی که اغلب به عنوان دلیلی برای تیم‌های <strong>frontend</strong> اختصاصی ذکر می‌شود، ثبات است. با داشتن یک تیم واحد که مسئول یک رابط کاربری است، شما اطمینان حاصل می‌کنید که <strong>UI</strong> ظاهری ثابت دارد. این می‌تواند از موارد آسان مانند استفاده از رنگ‌ها و فونت‌های یکسان تا حل مشکلات رابط مشابه به همان روش گسترش یابد—با استفاده از یک زبان طراحی و تعامل ثابت که به کاربران کمک می‌کند با سیستم تعامل داشته باشند.</p>
<p>این ثبات فقط به برقراری ارتباط درجه‌ای از <em>polish</em> در مورد خود محصول کمک نمی‌کند، بلکه تضمین می‌کند که کاربران استفاده از عملکرد جدید را هنگام ارائه آن آسان‌تر خواهند یافت.</p>
<p>راه‌هایی وجود دارد که به کمک آنها می‌توان درجه‌ای از ثبات را در بین تیم‌ها تضمین کرد. اگر از مدل تیم فعال‌کننده استفاده می‌کنید، با متخصصانی که زمان خود را با چندین تیم می‌گذرانند، آنها می‌توانند کمک کنند تا اطمینان حاصل شود که کار انجام شده توسط هر تیم سازگار است. ایجاد منابع مشترک مانند یک راهنمای سبک <strong>CSS</strong> زنده یا اجزای <strong>UI</strong> مشترک نیز می‌تواند کمک کند.</p>
<p>به عنوان یک مثال مشخص از یک تیم فعال‌کننده که برای کمک به ثبات استفاده می‌شود، تیم <em>Financial Times Origami</em> اجزای وب را با همکاری تیم طراحی می‌سازد، که هویت برند را در بر می‌گیرد—اطمینان از یک ظاهر و حس ثابت در سراسر تیم‌های <strong>stream-aligned</strong>. این نوع تیم فعال‌کننده دو فرم</p>
<p>به سمت تیم‌های <strong>Stream-Aligned</strong> | 461</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0487</div>
            </div>
        </div>
        <!-- Page 0488 -->
        <div class="chapter" id="page-0488">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>به سمت تیم‌های <strong>Stream-Aligned</strong> (ادامه)</h4>
<p>از کمک—اولاً، تخصص خود را در ارائه اجزای از قبل ساخته شده به اشتراک می‌گذارد، و ثانیاً، به اطمینان از ارائه یک تجربه کاربری ثابت <strong>UIs</strong> کمک می‌کند.</p>
<p>با این حال، شایسته ذکر است که عامل ثبات نباید به طور جهانی درست در نظر گرفته شود. برخی از سازمان‌ها تصمیمات ظاهراً آگاهانه‌ای می‌گیرند مبنی بر اینکه در رابط‌های کاربری خود نیاز به ثبات ندارند، زیرا احساس می‌کنند که اجازه دادن به خودمختاری بیشتر تیم‌ها ارجحیت دارد. <em>Amazon</em> یکی از این سازمان‌ها است. نسخه‌های قبلی سایت خرید اصلی آن دارای درجات زیادی از ناسازگاری بودند، با <strong>widgets</strong> که از سبک‌های کنترل کاملاً متفاوتی استفاده می‌کردند.</p>
<p>این موضوع حتی بیشتر نشان داده می‌شود، زمانی که به کنترل پنل وب برای <strong>Amazon Web Services (AWS)</strong> نگاه می‌کنید. محصولات مختلف در <strong>AWS</strong> دارای مدل‌های تعامل بسیار متفاوتی هستند، که باعث می‌شود رابط کاربری بسیار گیج‌کننده باشد. با این حال، به نظر می‌رسد این یک گسترش منطقی از تمایل <em>Amazon</em> به کاهش هماهنگی داخلی بین تیم‌ها است.</p>
<p>افزایش خودمختاری تیم‌های محصول در <strong>AWS</strong> نیز به طرق دیگری آشکار می‌شود، نه فقط از نظر تجربه کاربری اغلب گسسته. اغلب راه‌های مختلفی برای دستیابی به یک کار یکسان وجود دارد (به عنوان مثال، با اجرای یک حجم کاری کانتینری)، با تیم‌های محصول مختلف در داخل <strong>AWS</strong> که اغلب راه‌حل‌های مشابه اما ناسازگار با یکدیگر همپوشانی دارند. شما ممکن است نتیجه نهایی را مورد انتقاد قرار دهید، اما <strong>AWS</strong> نشان داده است که با داشتن این تیم‌های بسیار مستقل و محصول‌محور، شرکتی را ایجاد کرده است که از رهبری بازار آشکاری برخوردار است. سرعت تحویل، ثبات تجربه کاربری را تحت‌الشعاع قرار می‌دهد، حداقل تا آنجا که به <strong>AWS</strong> مربوط می‌شود.</p>
<h4>کار از طریق چالش‌های فنی</h4>
<p>ما در هنگام توسعه رابط‌های کاربری، تحولات جالبی را پشت سر گذاشته‌ایم—از رابط‌های کاربری متنی مبتنی بر ترمینال با صفحه‌نمایش سبز تا برنامه‌های دسکتاپ غنی، وب، و اکنون تجربه‌های موبایل بومی. از بسیاری جهات، ما یک دایره کامل رفته‌ایم و بعد هم—برنامه‌های <strong>client</strong> ما اکنون با چنین پیچیدگی و ظرافتی ساخته شده‌اند که کاملاً با پیچیدگی برنامه‌های دسکتاپ غنی که در دهه اول قرن بیست و یکم توسعه رابط کاربری را حفظ می‌کردند، رقابت می‌کنند.</p>
<p>تا حدودی، هرچه بیشتر چیزها تغییر می‌کنند، به همان اندازه باقی می‌مانند. ما اغلب هنوز با همان کنترل‌های <strong>UI</strong> 20 سال پیش کار می‌کنیم—دکمه‌ها، <strong>checkboxes</strong>، فرم‌ها، <strong>combo boxes</strong> و موارد مشابه. ما چند مؤلفه دیگر را به این فضا اضافه کرده‌ایم، اما بسیار کمتر از آنچه فکر می‌کنید. آنچه تغییر کرده است، فناوری‌ای است که ما در وهله اول برای ایجاد این رابط‌های کاربری گرافیکی استفاده می‌کنیم.</p>
<p>برخی از فناوری‌های جدیدتر در این فضا، به‌ویژه برنامه‌های تک صفحه‌ای، در هنگام تجزیه یک رابط کاربری، برای ما مشکل ایجاد می‌کنند. علاوه بر این، تنوع گسترده‌تری از دستگاه‌هایی که انتظار داریم همان رابط کاربری در آنها ارائه شود، مشکلات دیگری ایجاد می‌کند که باید حل شوند.</p>
<p>462 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0488</div>
            </div>
        </div>
        <!-- Page 0489 -->
        <div class="chapter" id="page-0489">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>کار از طریق چالش‌های فنی (ادامه)</h4>
<p>اساساً، کاربران ما می‌خواهند به راحت‌ترین شکل ممکن با <strong>software</strong> ما درگیر شوند. چه از طریق یک مرورگر در دسکتاپ باشد، یا از طریق یک برنامه موبایل بومی یا وب، نتیجه یکسان است—کاربران با <strong>software</strong> ما از طریق یک صفحه واحد تعامل دارند. آنها نباید اهمیتی بدهند که آیا رابط کاربری به روش ماژولار یا <strong>monolithic</strong> ساخته شده است یا خیر. بنابراین ما باید به دنبال راه‌هایی برای جدا کردن عملکرد رابط کاربری خود و جمع کردن دوباره آن باشیم، همه اینها در حالی که چالش‌های ناشی از برنامه‌های تک صفحه‌ای، دستگاه‌های تلفن همراه و موارد دیگر را حل می‌کنیم. این مسائل بقیه این فصل را به خود اختصاص خواهند داد.</p>
<h4>الگو: <strong>Frontend Monolithic</strong></h4>
<p>الگوی <strong>frontend monolithic</strong> یک معماری را توصیف می‌کند که در آن تمام حالت و رفتار <strong>UI</strong> در خود <strong>UI</strong> تعریف می‌شود، با تماس‌هایی که به <strong>microservices</strong> پشتیبان برای دریافت داده‌های مورد نیاز یا انجام عملیات‌های مورد نیاز انجام می‌شود. شکل 14-3 نمونه‌ای از این را نشان می‌دهد. صفحه ما می‌خواهد اطلاعاتی در مورد یک آلبوم و فهرست آهنگ‌های آن نمایش دهد، بنابراین <strong>UI</strong> درخواستی را برای دریافت این داده‌ها از <strong>microservice</strong> آلبوم انجام می‌دهد. ما همچنین اطلاعاتی در مورد جدیدترین پیشنهادهای ویژه با درخواست اطلاعات از <strong>microservice</strong> تبلیغات نمایش می‌دهیم. در این مثال، <strong>microservices</strong> ما <strong>JSON</strong> را برمی‌گردانند که <strong>UI</strong> برای به‌روزرسانی اطلاعات نمایش داده شده استفاده می‌کند.</p>
<p>شکل 14-3. صفحه جزئیات آلبوم ما اطلاعات را از <strong>microservices</strong> پایین‌دستی می‌گیرد تا <strong>UI</strong> را رندر کند</p>
<p>الگو: <strong>Frontend Monolithic</strong> | 463</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 489" src="page_0489/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0489</div>
            </div>
        </div>
        <!-- Page 0490 -->
        <div class="chapter" id="page-0490">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: <strong>Frontend Monolithic</strong> (ادامه)</h4>
<p>3 <em>Cam Jackson</em>, “Micro Frontends,” martinfowler.com, June 19, 2019, <a href="https://oreil.ly/U3K40">https://oreil.ly/U3K40</a>.</p>
<p>این مدل رایج‌ترین مدل برای افرادی است که برنامه‌های <strong>monolithic single-page</strong> را می‌سازند، که اغلب با یک تیم <strong>frontend</strong> اختصاصی همراه است. الزامات <strong>microservices</strong> ما بسیار ساده است—آنها فقط باید اطلاعات را به شکلی به اشتراک بگذارند که به راحتی توسط <strong>UI</strong> تفسیر شود. در مورد یک <strong>UI</strong> مبتنی بر وب، این بدان معناست که <strong>microservices</strong> ما احتمالاً باید داده‌ها را در یک قالب متنی ارائه کنند، که <strong>JSON</strong> محتمل‌ترین انتخاب است. سپس <strong>UI</strong> باید اجزای مختلفی را که رابط را تشکیل می‌دهند، ایجاد کند، و هماهنگ‌سازی وضعیت و موارد مشابه را با <strong>backend</strong> انجام دهد. استفاده از یک پروتکل باینری برای ارتباط <em>service-to-service</em> برای <strong>clients</strong> مبتنی بر وب دشوارتر خواهد بود، اما می‌تواند برای دستگاه‌های تلفن همراه بومی یا برنامه‌های دسکتاپ "<strong>thick</strong>" خوب باشد.</p>
<h4>چه زمانی از آن استفاده کنیم</h4>
<p>چند اشکال برای این رویکرد وجود دارد. اولاً، با توجه به ماهیت آن به عنوان یک موجودیت <strong>monolithic</strong>، می‌تواند به یک محرک برای (یا توسط) یک تیم <strong>frontend</strong> اختصاصی تبدیل شود. داشتن چندین تیم که مسئولیت این <strong>frontend monolithic</strong> را به اشتراک می‌گذارند، به دلیل منابع متعدد اختلاف، می‌تواند چالش‌برانگیز باشد. ثانیاً، ما توانایی کمی برای تنظیم پاسخ‌ها برای انواع مختلف دستگاه‌ها داریم. اگر از فناوری وب استفاده می‌کنیم، می‌توانیم طرح‌بندی یک صفحه را تغییر دهیم تا محدودیت‌های دستگاه‌های مختلف را در خود جای دهد، اما این لزوماً به تغییر تماس‌هایی که با <strong>microservices</strong> پشتیبان برقرار می‌شود، گسترش نمی‌یابد. <strong>client</strong> تلفن همراه من ممکن است فقط بتواند 10 فیلد از یک سفارش را نمایش دهد، اما اگر <strong>microservice</strong> تمام صد فیلد سفارش را دریافت کند، ما در نهایت داده‌های غیرضروری را بازیابی می‌کنیم.</p>
<p>یک راه‌حل برای این رویکرد این است که رابط کاربری مشخص کند که هنگام درخواست، چه فیلدهایی را باید دریافت کند، اما این فرض را دارد که هر <strong>microservice</strong> پشتیبان از این شکل تعامل پشتیبانی می‌کند. در "<em>GraphQL</em>" در صفحه 488، ما به چگونگی استفاده از هر دو الگوی <strong>backend for frontend</strong> و <strong>GraphQL</strong> در این مورد نگاه خواهیم کرد.</p>
<p>واقعاً، این الگو زمانی بهترین عملکرد را دارد که شما بخواهید تمام پیاده‌سازی و رفتار <strong>UI</strong> خود را در یک واحد قابل استقرار داشته باشید. برای یک تیم واحد که هم <strong>frontend</strong> و هم تمام <strong>microservices</strong> پشتیبان را توسعه می‌دهد، این ممکن است خوب باشد. شخصاً، اگر بیش از یک تیم روی <strong>software</strong> شما کار می‌کند، فکر می‌کنم شما باید با آن تمایل مبارزه کنید، زیرا می‌تواند منجر به این شود که شما به یک معماری لایه‌ای با <em>silos</em> سازمانی مرتبط با آن بلغزید. با این حال، اگر شما قادر به اجتناب از یک معماری لایه‌ای و ساختار سازمانی منطبق نیستید، این احتمالاً الگویی است که در نهایت از آن استفاده خواهید کرد.</p>
<h4>الگو: <strong>Micro Frontends</strong></h4>
<p>رویکرد <strong>micro frontend</strong> یک الگوی سازمانی است که به موجب آن می‌توان بر روی بخش‌های مختلفی از یک <strong>frontend</strong> کار کرد و آنها را به طور مستقل مستقر کرد. برای نقل قول از یک مقاله بسیار توصیه شده توسط <em>Cam Jackson</em> در این زمینه،3 ما می‌توانیم <strong>micro frontends</strong> را به عنوان</p>
<p>464 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0490</div>
            </div>
        </div>
        <!-- Page 0491 -->
        <div class="chapter" id="page-0491">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: <strong>Micro Frontends</strong> (ادامه)</h4>
<p>به شرح زیر است: "یک سبک معماری که در آن برنامه‌های <strong>frontend</strong> که به طور مستقل قابل تحویل هستند، به یک کل بزرگتر تبدیل می‌شوند."</p>
<p>این یک الگوی ضروری برای تیم‌های <strong>stream-aligned</strong> می‌شود که می‌خواهند مالک تحویل <strong>microservices backend</strong> و <strong>UI</strong> پشتیبانی‌کننده باشند. در جایی که <strong>microservices</strong>، استقرار مستقل را برای عملکرد <strong>backend</strong> ارائه می‌دهند، <strong>micro frontends</strong> استقرار مستقل را برای <strong>frontend</strong> ارائه می‌دهند.</p>
<p>مفهوم <strong>micro frontend</strong> به دلیل چالش‌های ایجاد شده توسط <strong>UIs</strong> وب <strong>monolithic</strong> و جاوا اسکریپت سنگین، همانطور که در برنامه‌های تک صفحه‌ای نشان داده می‌شود، محبوبیت پیدا کرده است. با یک <strong>micro frontend</strong>، تیم‌های مختلف می‌توانند روی بخش‌های مختلف <strong>frontend</strong> کار کنند و در آنها تغییرات ایجاد کنند. با بازگشت به شکل 14-2، تیم سهام، تیم جریان خرید و تیم <em>customer profile</em>، هر کدام می‌توانند عملکرد <strong>frontend</strong> مرتبط با جریان کاری خود را مستقل از تیم‌های دیگر تغییر دهند.</p>
<h4>پیاده‌سازی</h4>
<p>برای <strong>frontends</strong> مبتنی بر وب، ما می‌توانیم دو تکنیک تجزیه کلیدی را در نظر بگیریم که می‌تواند به پیاده‌سازی الگوی <strong>micro frontend</strong> کمک کند. تجزیه مبتنی بر <strong>Widget</strong> شامل اتصال بخش‌های مختلفی از یک <strong>frontend</strong> در کنار هم به یک صفحه واحد است. از سوی دیگر، تجزیه مبتنی بر صفحه، دارای <strong>frontend</strong> است که به صفحات وب مستقل تقسیم می‌شود. هر دو رویکرد شایسته بررسی بیشتر هستند، که ما به زودی به آنها خواهیم پرداخت.</p>
<h4>چه زمانی از آن استفاده کنیم</h4>
<p>اگر می‌خواهید تیم‌های <strong>end-to-end</strong> و <strong>stream-aligned</strong> را اتخاذ کنید، جایی که سعی دارید از یک معماری لایه‌ای دور شوید، الگوی <strong>micro frontend</strong> ضروری است. من همچنین می‌توانم تصور کنم که در موقعیتی مفید باشد که شما می‌خواهید یک معماری لایه‌ای را حفظ کنید، اما عملکرد <strong>frontend</strong> اکنون آنقدر بزرگ است که به چندین تیم <strong>frontend</strong> اختصاصی نیاز است.</p>
<p>یک مشکل کلیدی با این رویکرد وجود دارد که مطمئن نیستم قابل حل باشد. گاهی اوقات قابلیت‌های ارائه شده توسط یک <strong>microservice</strong> به خوبی در یک <strong>widget</strong> یا یک صفحه جای نمی‌گیرد. مطمئناً، من ممکن است بخواهم توصیه‌ها را در یک <strong>box</strong> در یک صفحه وب‌سایت خود نشان دهم، اما اگر بخواهم توصیه‌های پویا را در جای دیگری ادغام کنم چه؟ به عنوان مثال، وقتی جستجو می‌کنم، می‌خواهم <strong>type ahead</strong> به طور خودکار توصیه‌های تازه را فعال کند. هرچه یک شکل تعامل متقاطع‌تر باشد، احتمال اینکه این مدل مناسب باشد، کمتر است، و احتمال اینکه ما دوباره به تماس‌های <strong>API</strong> برگردیم، بیشتر است.</p>
<p>الگو: <strong>Micro Frontends</strong> | 465</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0491</div>
            </div>
        </div>
        <!-- Page 0492 -->
        <div class="chapter" id="page-0492">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: سیستم‌های خودکفا</h4>
<p>یک سیستم خودکفا (<strong>SCS</strong>) یک سبک معماری است که احتمالاً از عدم تمرکز بر نگرانی‌های <strong>UI</strong> در سال‌های اولیه <strong>microservices</strong> به وجود آمده است. یک <strong>SCS</strong> می‌تواند از چندین بخش متحرک (به طور بالقوه <strong>microservices</strong>) تشکیل شود که در کنار هم یک <strong>SCS</strong> واحد را تشکیل می‌دهند.</p>
<p>همانطور که تعریف شده است، یک سیستم خودکفا باید با برخی معیارهای خاص مطابقت داشته باشد که می‌توانیم همپوشانی‌هایی با برخی از همان چیزهایی که ما در تلاش برای دستیابی به آنها با <strong>microservices</strong> هستیم، مشاهده کنیم. شما می‌توانید اطلاعات بیشتری در مورد سیستم‌های خودکفا در وب‌سایت بسیار واضح <strong>SCS</strong> بیابید، اما در اینجا برخی از نکات برجسته وجود دارد:</p>
<ul>
<li>هر <strong>SCS</strong> یک برنامه وب مستقل با هیچ <strong>UI</strong> مشترکی نیست.</li>
<li>هر <strong>SCS</strong> متعلق به یک تیم است.</li>
<li>ارتباط <em>async</em> باید در صورت امکان استفاده شود.</li>
<li>هیچ کد تجاری نمی‌تواند بین <strong>SCSs</strong> به اشتراک گذاشته شود.</li>
</ul>
<p>رویکرد <strong>SCS</strong> به اندازه <strong>microservices</strong> مورد توجه قرار نگرفته است، و این مفهومی نیست که من زیاد با آن مواجه شوم، با وجود این واقعیت که من با بسیاری از اصولی که مطرح می‌کند موافقم. من به‌ویژه دوست دارم اشاره کنم که یک سیستم خودکفا باید متعلق به یک تیم باشد. من تعجب می‌کنم که آیا این عدم استفاده گسترده‌تر توضیح می‌دهد که چرا برخی از جنبه‌های رویکرد <strong>SCS</strong> بیش از حد محدود و تجویزی به نظر می‌رسند. به عنوان مثال، اصرار بر اینکه هر <strong>SCS</strong> یک "برنامه وب مستقل" باشد، به این معنی است که بسیاری از انواع رابط کاربری هرگز نمی‌توانند یک <strong>SCS</strong> در نظر گرفته شوند. آیا این بدان معناست که برنامه <em>iOS</em> بومی که من ساخته‌ام و از <em>gRPC</em> استفاده می‌کند می‌تواند بخشی از یک <strong>SCS</strong> باشد یا نه؟</p>
<p>بنابراین آیا رویکرد <strong>SCS</strong> با <strong>microservices</strong> در تضاد است؟ واقعاً نه. من روی بسیاری از <strong>microservices</strong> کار کرده‌ام که، وقتی به تنهایی در نظر گرفته می‌شوند، تعریف یک <strong>SCS</strong> را دارند. ایده‌های جالبی در رویکرد <strong>SCS</strong> وجود دارد که من با آنها موافقم، و بسیاری از آنها را قبلاً در این کتاب پوشش داده‌ایم. من فقط رویکرد را بیش از حد تجویزی می‌دانم، تا جایی که کسی که به <strong>SCSs</strong> علاقه‌مند است ممکن است پیاده‌سازی رویکرد را فوق‌العاده چالش‌برانگیز بداند، زیرا ممکن است به تغییرات کلی در بسیاری از جنبه‌های تحویل <strong>software</strong> خود نیاز داشته باشد.</p>
<p>من نگران هستم که بیانیه‌هایی مانند مفهوم <strong>SCS</strong> می‌توانند ما را در مسیری هدایت کنند که بیش از حد بر فعالیت تمرکز کنیم، تا بر اصول و نتایج. شما می‌توانید از هر ویژگی <strong>SCS</strong> پیروی کنید و همچنان به طور بالقوه نکته را از دست بدهید. با تأمل، من احساس می‌کنم که رویکرد <strong>SCS</strong> یک رویکرد متمرکز بر فناوری برای ترویج یک مفهوم سازمانی است.
   به این ترتیب، من ترجیح می‌دهم بر اهمیت تیم‌های <strong>stream-aligned</strong> با هماهنگی کاهش یافته تمرکز کنم، و اجازه دهم فناوری و معماری از این جریان سرچشمه بگیرند.</p>
<p>466 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0492</div>
            </div>
        </div>
        <!-- Page 0493 -->
        <div class="chapter" id="page-0493">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: تجزیه مبتنی بر صفحه</h4>
<p>در تجزیه مبتنی بر صفحه، <strong>UI</strong> ما به چندین صفحه وب تجزیه می‌شود. مجموعه‌های مختلفی از صفحات را می‌توان از <strong>microservices</strong> مختلف ارائه کرد. در شکل 14-4، ما نمونه‌ای از این الگو را برای MusicCorp می‌بینیم. درخواست‌ها برای صفحات در /albums/ مستقیماً به <strong>microservice</strong> آلبوم مسیریابی می‌شوند، که مدیریت ارائه آن صفحات را بر عهده دارد، و ما کار مشابهی را با /artists/ انجام می‌دهیم. از یک ناوبری رایج برای کمک به دوختن این صفحات به یکدیگر استفاده می‌شود. این <strong>microservices</strong> به نوبه خود ممکن است اطلاعاتی را که برای ساخت این صفحات مورد نیاز است، واکشی کنند—به عنوان مثال، واکشی سطوح موجودی از <strong>microservice</strong> موجودی برای نشان دادن اقلام موجود در <strong>UI</strong>.</p>
<p>شکل 14-4. رابط کاربری از چندین صفحه تشکیل شده است، که گروه‌های مختلفی از صفحات از <strong>microservices</strong> مختلف ارائه می‌شوند</p>
<p>با این مدل، تیمی که مالک <strong>microservice</strong> آلبوم است، می‌تواند یک <strong>UI</strong> کامل را <strong>end to end</strong> رندر کند و درک تیم از چگونگی تأثیر تغییرات آن بر کاربر را آسان می‌کند.</p>
<p>الگو: تجزیه مبتنی بر صفحه | 467</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 493" src="page_0493/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0493</div>
            </div>
        </div>
        <!-- Page 0494 -->
        <div class="chapter" id="page-0494">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: تجزیه مبتنی بر صفحه (ادامه)</h4>
<p>4 من به شما نگاه می‌کنم، <em>Sydney Morning Herald</em>!</p>
<h4>وب</h4>
<p>قبل از برنامه‌های تک صفحه‌ای، ما وب را داشتیم. تعامل ما با وب بر اساس بازدید از <strong>URLs</strong> و کلیک کردن بر روی لینک‌هایی بود که باعث می‌شد صفحات جدید در مرورگر ما بارگیری شوند. مرورگرهای ما برای امکان پیمایش در اطراف این صفحات ساخته شده بودند، با نشانک‌هایی برای علامت‌گذاری صفحات مورد علاقه و کنترل‌های عقب و جلو برای بازبینی صفحات قبلاً دسترسی یافته. ممکن است همه شما چشمان خود را بچرخانید و فکر کنید، "البته من می‌دانم وب چگونه کار می‌کند!"؛ با این حال، این یک سبک از رابط کاربری است که به نظر می‌رسد از لطف خارج شده است. سادگی آن چیزی است که من از دست می‌دهم وقتی پیاده‌سازی‌های رابط کاربری مبتنی بر وب فعلی خود را می‌بینم—ما با فرض خودکار اینکه یک <strong>UI</strong> مبتنی بر وب به معنای برنامه‌های تک صفحه‌ای است، چیزهای زیادی را از دست داده‌ایم.</p>
<p>از نظر برخورد با انواع مختلف <strong>clients</strong>، هیچ چیزی وجود ندارد که مانع از این شود که صفحه آنچه را که بر اساس ماهیت دستگاهی که صفحه را درخواست می‌کند، نشان می‌دهد، تطبیق دهد. مفاهیم بهبود تدریجی (یا زوال ظریف) باید اکنون به خوبی درک شده باشند.</p>
<p>سادگی تجزیه مبتنی بر صفحه از دیدگاه پیاده‌سازی فنی، یک جذابیت واقعی در اینجا است. شما به هیچ <em>JavaScript</em> فانتزی که در مرورگر اجرا می‌شود نیاز ندارید، و همچنین نیازی به استفاده از <em>iFrames</em> مشکل‌ساز ندارید. کاربر روی یک پیوند کلیک می‌کند، و یک صفحه جدید درخواست می‌شود.</p>
<h4>جایی که از آن استفاده کنیم</h4>
<p>برای یک <strong>frontend monolithic</strong> یا یک رویکرد <strong>micro frontend</strong> مفید است، تجزیه مبتنی بر صفحه، اگر رابط کاربری من یک وب‌سایت باشد، انتخاب پیش‌فرض من برای تجزیه رابط کاربری خواهد بود. صفحه وب به عنوان یک واحد تجزیه، یک مفهوم اصلی از وب به عنوان یک کل است که به یک تکنیک ساده و آشکار برای شکستن یک رابط کاربری بزرگ مبتنی بر وب تبدیل می‌شود.</p>
<p>من فکر می‌کنم مشکل این است که در هجوم برای استفاده از فناوری برنامه تک صفحه‌ای، این رابط‌های کاربری به طور فزاینده‌ای نادر می‌شوند، تا جایی که تجربیات کاربری که به نظر من بهتر با یک پیاده‌سازی وب‌سایت مطابقت دارد، در نهایت به یک برنامه تک صفحه‌ای 4 منتقل می‌شود. شما البته می‌توانید تجزیه مبتنی بر صفحه را با برخی از الگوهای دیگری که پوشش داده‌ایم، ترکیب کنید. به عنوان مثال، من می‌توانم صفحه‌ای داشته باشم که حاوی <strong>widgets</strong> باشد—چیزی که در ادامه به آن نگاه خواهیم کرد.</p>
<p>468 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0494</div>
            </div>
        </div>
        <!-- Page 0495 -->
        <div class="chapter" id="page-0495">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: تجزیه مبتنی بر <strong>Widget</strong></h4>
<p>با تجزیه مبتنی بر <strong>widget</strong>، یک صفحه در یک رابط گرافیکی شامل <strong>widgets</strong> است که می‌توانند به طور مستقل تغییر کنند. در شکل 14-5، ما نمونه‌ای از <strong>frontend</strong> Music Corp را می‌بینیم، با دو <strong>widget</strong> که عملکرد <strong>UI</strong> را برای سبد خرید و توصیه‌ها ارائه می‌دهند.</p>
<p>شکل 14-5. <strong>Widgets</strong> سبد خرید و توصیه در حال استفاده در MusicCorp</p>
<p><strong>Widget</strong> توصیه‌ها برای MusicCorp یک چرخ فلک از توصیه‌ها را دریافت می‌کند که می‌توان چرخید و فیلتر کرد. همانطور که در شکل 14-6 می‌بینیم، هنگامی که کاربر با <strong>widget</strong> توصیه‌ها تعامل می‌کند—به عنوان مثال، چرخ زدن به مجموعه بعدی توصیه‌ها، یا افزودن اقلام به لیست آرزوهای خود—ممکن است منجر به ایجاد تماس با <strong>microservices</strong> پشتیبان شود، شاید در این مورد <strong>microservices</strong> توصیه‌ها و لیست آرزوها. این می‌تواند با تیمی که مالک هر دو <strong>microservices</strong> پشتیبان و خود مؤلفه است، همسو شود.</p>
<p>الگو: تجزیه مبتنی بر <strong>Widget</strong> | 469</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 495" src="page_0495/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0495</div>
            </div>
        </div>
        <!-- Page 0496 -->
        <div class="chapter" id="page-0496">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: تجزیه مبتنی بر <strong>Widget</strong> (ادامه)</h4>
<p>شکل 14-6. تعاملات بین <strong>micro frontend</strong> توصیه‌ها و <strong>microservices</strong> پشتیبان</p>
<p>به طور کلی، شما به یک برنامه "<strong>container</strong>" نیاز دارید که چیزهایی مانند ناوبری اصلی رابط و <strong>widgets</strong> که باید گنجانده شوند را تعریف می‌کند. اگر ما از نظر تیم‌های <strong>stream-oriented end-to-end</strong> فکر می‌کردیم، می‌توانستیم تیمی را تصور کنیم که <strong>widget</strong> توصیه‌ها را ارائه می‌دهد و همچنین مسئول یک <strong>microservice</strong> توصیه‌های پشتیبان است.</p>
<p>این الگو در دنیای واقعی بسیار یافت می‌شود. به عنوان مثال، رابط کاربری <em>Spotify</em>، به شدت از این الگو استفاده می‌کند. یک <strong>widget</strong> ممکن است یک <em>playlist</em> را نگه دارد، دیگری ممکن است اطلاعاتی در مورد یک هنرمند را نگه دارد، و یک <strong>widget</strong> سوم ممکن است اطلاعاتی در مورد هنرمندان و سایر کاربران <em>Spotify</em> که شما دنبال می‌کنید، نگه دارد. این <strong>widgets</strong> به روش‌های مختلفی در موقعیت‌های مختلف ترکیب می‌شوند.</p>
<p>شما هنوز به نوعی لایه مونتاژ برای جمع‌آوری این قطعات نیاز دارید. با این حال، این می‌تواند به سادگی استفاده از الگوهای سمت سرور یا سمت <strong>client</strong> باشد.</p>
<h4>پیاده‌سازی</h4>
<p>نحوه اتصال یک <strong>widget</strong> به <strong>UI</strong> شما، تا حد زیادی به نحوه ایجاد <strong>UI</strong> شما بستگی دارد. با یک وب‌سایت ساده، گنجاندن <strong>widgets</strong> به عنوان قطعات <strong>HTML</strong> با استفاده از الگوهای سمت <strong>client</strong> یا سمت سرور می‌تواند بسیار ساده باشد، اگرچه اگر <strong>widgets</strong> دارای رفتار پیچیده‌تری باشند، ممکن است با مشکلاتی مواجه شوید. به عنوان مثال، اگر <strong>widget</strong> توصیه‌های ما شامل تعداد زیادی عملکرد <em>JavaScript</em> باشد، چگونه اطمینان حاصل کنیم که این</p>
<p>470 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 496" src="page_0496/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0496</div>
            </div>
        </div>
        <!-- Page 0497 -->
        <div class="chapter" id="page-0497">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: تجزیه مبتنی بر <strong>Widget</strong> (ادامه)</h4>
<p>با بقیه صفحه وب تداخل نداشته باشد؟ در حالت ایده‌آل، کل <strong>widget</strong> می‌تواند به گونه‌ای بسته‌بندی شود که سایر جنبه‌های <strong>UI</strong> را خراب نکند.</p>
<p>مشکل نحوه ارائه عملکرد خودکفا در یک <strong>UI</strong> بدون شکستن عملکرد دیگر، از نظر تاریخی به‌ویژه با برنامه‌های تک صفحه‌ای، تا حدی به این دلیل که مفهوم ماژولار شدن به نظر نمی‌رسد که نگرانی اصلی برای نحوه ایجاد فریم‌ورک‌های <strong>SPA</strong> پشتیبان بوده باشد، مشکل‌ساز بوده است. این چالش‌ها ارزش بررسی بیشتر را دارند.</p>
<h4>وابستگی‌ها</h4>
<p>اگرچه <em>iFrames</em> یک تکنیک پرکاربرد در گذشته بوده‌اند، اما ما تمایل داریم از استفاده از آنها برای اتصال <strong>widgets</strong> مختلف به یک صفحه وب واحد اجتناب کنیم. <em>iFrames</em> دارای مجموعه‌ای از چالش‌ها در مورد اندازه و از نظر دشوار کردن ارتباط بین بخش‌های مختلف <strong>frontend</strong> هستند. در عوض، <strong>widgets</strong> معمولاً یا با استفاده از الگوهای سمت سرور یا در غیر این صورت به صورت پویا در سمت <strong>client</strong> در مرورگر درج می‌شوند. در هر دو مورد، چالش این است که <strong>widget</strong> در همان صفحه مرورگر با سایر قسمت‌های <strong>frontend</strong> در حال اجرا است، به این معنی که شما باید مراقب باشید که <strong>widgets</strong> مختلف با یکدیگر تداخل نداشته باشند.</p>
<p>به عنوان مثال، <strong>widget</strong> توصیه‌های ما ممکن است از <em>React v16</em> استفاده کند، در حالی که <strong>widget</strong> سبد خرید هنوز از <em>React v15</em> استفاده می‌کند. این البته می‌تواند یک نعمت باشد، زیرا می‌تواند به ما کمک کند فناوری‌های مختلف را امتحان کنیم (ما می‌توانیم از فریم‌ورک‌های مختلف <strong>SPA</strong> برای <strong>widgets</strong> مختلف استفاده کنیم)، اما همچنین می‌تواند به ما در هنگام به‌روزرسانی نسخه‌های فریم‌ورک‌های مورد استفاده کمک کند. من با تعدادی از تیم‌ها صحبت کرده‌ام که در انتقال بین نسخه‌های <em>Angular</em> یا <em>React</em> با چالش‌هایی مواجه شده‌اند، که تا حد زیادی به دلیل تفاوت در قراردادهای مورد استفاده در نسخه‌های جدیدتر فریم‌ورک است. ارتقای یک <strong>UI</strong> <strong>monolithic</strong> کامل می‌تواند دلهره‌آور باشد، اما اگر بتوانید آن را به صورت افزایشی انجام دهید، به روزرسانی بخش‌هایی از <strong>frontend</strong> خود، می‌توانید کار را بشکنید و همچنین خطر معرفی مشکلات جدید توسط ارتقا را کاهش دهید.</p>
<p>نقطه ضعف این است که شما می‌توانید به مقدار زیادی تکرار بین وابستگی‌ها ختم شوید، که به نوبه خود می‌تواند منجر به یک <strong>bloat</strong> بزرگ از نظر اندازه بار صفحه شود. من می‌توانم در نهایت شامل نسخه‌های مختلفی از فریم‌ورک <em>React</em> و وابستگی‌های انتقالی مرتبط با آن باشم، به عنوان مثال. جای تعجب نیست که بسیاری از وب‌سایت‌ها اکنون اندازه بار صفحه‌ای چندین برابر بزرگتر از اندازه برخی از سیستم‌های عامل دارند. به عنوان یک مطالعه غیرعلمی سریع، من بار صفحه وب‌سایت <em>CNN</em> را در زمان نوشتن بررسی کردم، و 7.9 مگابایت بود، که بسیار بزرگتر از 5 مگابایت برای <em>Alpine Linux</em> است. 7.9 مگابایت در واقع در انتهای کوچک برخی از اندازه‌های بار صفحه است که من می‌بینم.</p>
<p>الگو: تجزیه مبتنی بر <strong>Widget</strong> | 471</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0497</div>
            </div>
        </div>
        <!-- Page 0498 -->
        <div class="chapter" id="page-0498">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: تجزیه مبتنی بر <strong>Widget</strong> (ادامه)</h4>
<h4>ارتباط بین <strong>widgets</strong> درون صفحه</h4>
<p>اگرچه <strong>widgets</strong> ما می‌توانند به طور مستقل ساخته و مستقر شوند، اما ما هنوز می‌خواهیم که آنها بتوانند با یکدیگر تعامل داشته باشند. به عنوان مثال از MusicCorp، وقتی کاربر یکی از آلبوم‌ها را در نمودار پرفروش‌ها انتخاب می‌کند، ما می‌خواهیم سایر قسمت‌های <strong>UI</strong> بر اساس انتخاب به‌روز شوند، همانطور که در شکل 14-7 نشان داده شده است.</p>
<p>شکل 14-7. <strong>Widget</strong> نمودارها می‌تواند رویدادهایی را منتشر کند که سایر قسمت‌های <strong>UI</strong> به آن گوش می‌دهند</p>
<p>راهی که ما به این امر می‌رسیم این است که <strong>widget</strong> نمودارها یک رویداد سفارشی را منتشر کنند. مرورگرها در حال حاضر از تعدادی رویداد استاندارد پشتیبانی می‌کنند که می‌توانیم از آنها برای فعال کردن رفتار استفاده کنیم. این رویدادها به ما اجازه می‌دهند تا به دکمه‌های فشرده شده، اسکرول شدن ماوس و موارد مشابه واکنش نشان دهیم، و شما احتمالاً قبلاً از این <em>event handling</em> به شدت استفاده کرده‌اید، اگر زمانی را صرف ساخت <strong>frontends JavaScript</strong> کرده باشید. ایجاد رویدادهای سفارشی خودتان یک قدم ساده است.</p>
<p>بنابراین در مورد ما، هنگامی که یک مورد در نمودار انتخاب می‌شود، آن <strong>widget</strong> یک رویداد سفارشی انتخاب آلبوم را ایجاد می‌کند. <strong>widgets</strong> توصیه‌ها و جزئیات آلبوم هر دو در رویداد مشترک هستند و بر این اساس واکنش نشان می‌دهند، با به‌روزرسانی توصیه‌ها بر اساس انتخاب، و بارگذاری جزئیات آلبوم. البته این تعامل باید قبلاً برای ما آشنا باشد، زیرا تعامل مبتنی بر رویداد بین <strong>microservices</strong> را تقلید می‌کند که ما در "الگو: ارتباط مبتنی بر رویداد" در صفحه 108 مورد بحث قرار دادیم. تنها تفاوت واقعی این است که این تعاملات رویداد در داخل مرورگر اتفاق می‌افتد.</p>
<p>472 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 498" src="page_0498/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0498</div>
            </div>
        </div>
        <!-- Page 0499 -->
        <div class="chapter" id="page-0499">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>Web Components</strong></h4>
<p>در نگاه اول، <strong>Web Component Standard</strong> باید یک راه بدیهی برای پیاده‌سازی این <strong>widgets</strong> باشد. <strong>Web Component Standard</strong> توضیح می‌دهد که چگونه می‌توانید یک جزء <strong>UI</strong> ایجاد کنید که می‌تواند جنبه‌های <strong>HTML</strong>، <strong>CSS</strong> و <em>JavaScript</em> خود را <strong>sandbox</strong> کند. متأسفانه، به نظر می‌رسد که <strong>web components standard</strong> مدت زیادی طول کشیده است تا مستقر شود، و مدت زمان بیشتری طول کشید تا به درستی توسط مرورگرها پشتیبانی شود. به نظر می‌رسد که بسیاری از کارهای اولیه در اطراف آنها متوقف شده است، که بدیهی است بر پذیرش تأثیر گذاشته است. من هنوز با سازمانی روبرو نشده‌ام که از <strong>web components</strong> ارائه شده از <strong>microservices</strong> استفاده کند، به عنوان مثال.</p>
<p>با توجه به اینکه <strong>Web Component Standard</strong> در حال حاضر نسبتاً خوب پشتیبانی می‌شود، این امکان وجود دارد که ما آنها را به عنوان یک راه رایج برای پیاده‌سازی <strong>widgets</strong> <strong>sandboxed</strong> یا <strong>micro frontends</strong> بزرگتر در آینده ببینیم، اما پس از سال‌ها انتظار برای وقوع این اتفاق، من نفس خود را حبس نمی‌کنم.</p>
<h4>چه زمانی از آن استفاده کنیم</h4>
<p>این الگو، اگر می‌خواهید تیم‌های <strong>stream-aligned</strong> را <strong>end-to-end</strong> اتخاذ کنید، ضروری است، جایی که شما در تلاش برای دور شدن از یک معماری لایه‌ای هستید. من همچنین می‌توانم تصور کنم که در موقعیتی مفید باشد که شما می‌خواهید یک معماری لایه‌ای را حفظ کنید، اما عملکرد <strong>frontend</strong> اکنون آنقدر بزرگ است که به چندین تیم <strong>frontend</strong> اختصاصی نیاز است.</p>
<p>یک مشکل کلیدی با این رویکرد وجود دارد که مطمئن نیستم قابل حل باشد. گاهی اوقات قابلیت‌های ارائه شده توسط یک <strong>microservice</strong> به خوبی در یک <strong>widget</strong> یا یک صفحه جای نمی‌گیرد. مطمئناً، من ممکن است بخواهم توصیه‌ها را در یک <strong>box</strong> در یک صفحه وب‌سایت خود نشان دهم، اما اگر بخواهم توصیه‌های پویا را در جای دیگری ادغام کنم چه؟ به عنوان مثال، وقتی جستجو می‌کنم، می‌خواهم <strong>type ahead</strong> به طور خودکار توصیه‌های تازه را فعال کند. هرچه یک شکل تعامل متقاطع‌تر باشد، احتمال اینکه این مدل مناسب باشد، کمتر است، و احتمال اینکه ما دوباره به تماس‌های <strong>API</strong> برگردیم، بیشتر است.</p>
<p>الگو: تجزیه مبتنی بر <strong>Widget</strong> | 473</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0499</div>
            </div>
        </div>
        <!-- Page 0500 -->
        <div class="chapter" id="page-0500">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: تجزیه مبتنی بر <strong>Widget</strong> (ادامه)</h4>
<p>5 امیدوارم نیازی به گفتن نباشد که من یک وکیل نیستم، اما اگر مایلید به قوانین مربوط به این موضوع در بریتانیا نگاهی بیندازید، این قانون برابری 2010 است، به طور خاص بخش 20. <em>W3C</em> همچنین مروری خوب بر دستورالعمل‌های دسترسی‌پذیری دارد.</p>
<p>از سوی دیگر، اگر <strong>widgets</strong> از نظر ماهیت ساده‌تر باشند و عمدتاً اجزای <strong>static</strong> باشند، امکان گنجاندن آنها با استفاده از چیزی به سادگی الگوهای سمت <strong>client-side</strong> یا سمت سرور، در مقایسه بسیار ساده است.</p>
<h4>محدودیت‌ها</h4>
<p>قبل از اینکه به بحث در مورد الگوی بعدی خود بپردازیم، می‌خواهم به موضوع محدودیت‌ها بپردازم. به طور فزاینده‌ای، کاربران <strong>software</strong> ما با آن از طریق دستگاه‌های مختلف تعامل دارند. هر یک از این دستگاه‌ها محدودیت‌های متفاوتی را تحمیل می‌کنند که <strong>software</strong> ما باید آنها را در نظر بگیرد. به عنوان مثال، در یک برنامه وب دسکتاپ، ما محدودیت‌هایی مانند مرورگری که بازدیدکنندگان از آن استفاده می‌کنند، یا وضوح صفحه نمایش آنها را در نظر می‌گیریم. افرادی که بینایی ضعیفی دارند ممکن است از <strong>software</strong> ما از طریق <strong>screen readers</strong> استفاده کنند، و افرادی که تحرک محدودی دارند ممکن است بیشتر از ورودی‌های سبک صفحه کلید برای پیمایش صفحه استفاده کنند.</p>
<p>بنابراین، اگرچه خدمات اصلی ما—پیشنهاد اصلی ما—ممکن است یکسان باشد، ما به روشی برای انطباق آنها با محدودیت‌های مختلفی که برای هر نوع رابط وجود دارد، و برای نیازهای مختلف کاربران خود نیاز داریم. اگر می‌خواهید، این می‌تواند صرفاً از یک نقطه نظر مالی هدایت شود—مشتریان خوشحال‌تر به معنای پول بیشتر است. اما همچنین یک ملاحظات اخلاقی انسانی وجود دارد که به پیش می‌آید: وقتی مشتریانی را که نیازهای خاصی دارند نادیده می‌گیریم، شانس استفاده از خدمات ما را از آنها سلب می‌کنیم. در برخی زمینه‌ها، غیرممکن کردن پیمایش افراد در یک <strong>UI</strong> به دلیل تصمیمات طراحی، منجر به اقدام قانونی و جریمه‌ها شده است—به عنوان مثال، بریتانیا، همراه با تعدادی از کشورهای دیگر، به‌درستی قانون‌گذاری را برای اطمینان از دسترسی به وب‌سایت‌ها برای افراد دارای معلولیت‌ها دارد.5</p>
<p>دستگاه‌های تلفن همراه مجموعه‌ای از محدودیت‌های جدید را به ارمغان آورده‌اند. نحوه ارتباط برنامه‌های تلفن همراه ما با یک سرور می‌تواند تأثیرگذار باشد. این فقط در مورد نگرانی‌های پهنای باند خالص نیست، جایی که محدودیت‌های شبکه‌های تلفن همراه می‌توانند نقش داشته باشند. انواع مختلف تعاملات می‌توانند باتری را خالی کنند، که منجر به ناراحتی برخی از مشتریان می‌شود.
   ماهیت تعاملات نیز با توجه به دستگاه تغییر می‌کند. من نمی‌توانم به راحتی روی یک تبلت راست کلیک کنم. در یک تلفن همراه، ممکن است بخواهم رابط خود را برای استفاده عمدتاً یک دستی طراحی کنم، که در آن اکثر عملیات‌ها توسط یک انگشت شست کنترل می‌شوند. در جای دیگر، من ممکن است به مردم اجازه دهم از طریق <em>SMS</em> در مکان‌هایی که پهنای باند در سطح بالایی قرار دارد، با خدمات تعامل داشته باشند—به عنوان مثال، استفاده از <em>SMS</em> به عنوان یک رابط در جنوب جهانی بسیار زیاد است.</p>
<p>بحث گسترده‌تری در مورد دسترسی‌پذیری رابط‌های کاربری خارج از محدوده این کتاب است، اما ما می‌توانیم حداقل چالش‌های خاص ناشی از انواع مختلف <strong>clients</strong>، مانند دستگاه‌های تلفن همراه را بررسی کنیم. یک راه‌حل رایج برای رسیدگی به نیازهای مختلف دستگاه‌های <strong>client</strong>، انجام نوعی فیلتر کردن و جمع‌آوری تماس در <strong>client</strong> است</p>
<p>الگو: تجزیه مبتنی بر <strong>Widget</strong> | 474</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0500</div>
            </div>
        </div>
        <!-- Page 0501 -->
        <div class="chapter" id="page-0501">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>محدودیت‌ها (ادامه)</h4>
<p>جانب <strong>client</strong>. داده‌هایی که مورد نیاز نیستند را می‌توان حذف کرد و نیازی به ارسال آنها به دستگاه نیست، و می‌توان چندین تماس را در یک تماس ترکیب کرد.</p>
<p>در مرحله بعد، ما به دو الگو نگاه خواهیم کرد که می‌توانند در این فضا مفید باشند—<strong>central aggregating gateway</strong> و الگوی <strong>backend for frontend</strong>. ما همچنین به این موضوع نگاه خواهیم کرد که چگونه از <em>GraphQL</em> برای کمک به تنظیم پاسخ‌ها برای انواع مختلف رابط‌ها استفاده می‌شود.</p>
<h4>الگو: <strong>Central Aggregating Gateway</strong></h4>
<p>یک <strong>central-purpose aggregating gateway</strong> بین رابط‌های کاربری خارجی و <strong>microservices</strong> پایین‌دستی قرار می‌گیرد و <strong>call filtering</strong> و تجمیع را برای همه رابط‌های کاربری انجام می‌دهد. بدون تجمیع، یک رابط کاربری ممکن است مجبور شود چندین تماس برای دریافت اطلاعات مورد نیاز انجام دهد، که اغلب داده‌هایی را که بازیابی شده‌اند اما مورد نیاز نبوده‌اند، دور می‌ریزد.</p>
<p>در شکل 14-8، ما چنین وضعیتی را می‌بینیم. ما می‌خواهیم صفحه‌ای را با اطلاعاتی در مورد سفارش‌های اخیر مشتری نمایش دهیم. صفحه باید برخی اطلاعات کلی در مورد مشتری را نمایش دهد و سپس تعدادی از سفارش‌های آنها را به ترتیب تاریخ، همراه با اطلاعات خلاصه، با نشان دادن تاریخ و وضعیت هر سفارش و همچنین قیمت فهرست کند.</p>
<p>شکل 14-8. برقراری تماس‌های متعدد برای دریافت اطلاعات برای یک صفحه واحد</p>
<p>ما یک تماس مستقیم با <strong>microservice</strong> مشتری برقرار می‌کنیم و اطلاعات کامل در مورد مشتری را دریافت می‌کنیم، حتی اگر فقط به چند فیلد نیاز داشته باشیم. سپس جزئیات سفارش را از <strong>microservice</strong> سفارش دریافت می‌کنیم. ما می‌توانیم تا حدودی وضعیت را بهبود بخشیم، شاید با تغییر <strong>microservice</strong> مشتری یا سفارش به منظور بازگرداندن داده‌هایی که با نیازهای ما در این مورد خاص مطابقت دارد، اما این همچنان مستلزم برقراری دو تماس است.</p>
<p>با یک <strong>aggregating gateway</strong>، ما می‌توانیم در عوض یک تماس واحد از رابط کاربری به <strong>gateway</strong> صادر کنیم. سپس <strong>aggregating gateway</strong> تمام تماس‌های مورد نیاز را انجام می‌دهد،</p>
<p>الگو: <strong>Central Aggregating Gateway</strong> | 475</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 501" src="page_0501/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0501</div>
            </div>
        </div>
        <!-- Page 0502 -->
        <div class="chapter" id="page-0502">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: <strong>Central Aggregating Gateway</strong> (ادامه)</h4>
<p>نتایج را در یک پاسخ واحد ترکیب می‌کند، و هر داده‌ای را که رابط کاربری به آن نیاز ندارد، دور می‌ریزد (شکل 14-9).</p>
<p>شکل 14-9. <strong>Gateway</strong> مرکزی سمت سرور، فیلتر کردن و تجمیع تماس‌ها را با <strong>microservices</strong> پایین‌دستی انجام می‌دهد</p>
<p>چنین <strong>gateway</strong> می‌تواند به تماس‌های <strong>batch</strong> نیز کمک کند. به عنوان مثال، به جای نیاز به جستجوی 10 <strong>order ID</strong> از طریق تماس‌های جداگانه، می‌توانم یک درخواست <strong>batch</strong> را به <strong>aggregating gateway</strong> ارسال کنم، و می‌تواند بقیه کارها را انجام دهد.</p>
<p>اساساً، داشتن نوعی <strong>aggregating gateway</strong> می‌تواند تعداد تماس‌هایی را که <strong>client</strong> خارجی باید انجام دهد و مقدار داده‌ای را که باید برگردانده شود، کاهش دهد. این می‌تواند منجر به مزایای قابل توجهی از نظر کاهش استفاده از پهنای باند و بهبود <strong>latency</strong> برنامه شود.</p>
<h4>مالکیت</h4>
<p>از آنجایی که رابط‌های کاربری بیشتری از <strong>central gateway</strong> استفاده می‌کنند، و از آنجایی که <strong>microservices</strong> بیشتری به منطق تجمیع و فیلتر تماس برای آن رابط‌های کاربری نیاز دارند، <strong>gateway</strong> به یک منبع بالقوه برای اختلاف تبدیل می‌شود. چه کسی مالک <strong>gateway</strong> است؟ آیا این متعلق به افرادی است که رابط‌های کاربری را ایجاد می‌کنند، یا توسط افرادی که مالک <strong>microservices</strong> هستند؟</p>
<p>اغلب متوجه می‌شوم که <strong>central aggregating gateway</strong> کارهای زیادی را انجام می‌دهد که در نهایت متعلق به یک تیم اختصاصی می‌شود. سلام، معماری لایه‌ای <em>siloed</em>!</p>
<p>476 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 502" src="page_0502/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0502</div>
            </div>
        </div>
        <!-- Page 0503 -->
        <div class="chapter" id="page-0503">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: <strong>Central Aggregating Gateway</strong> (ادامه)</h4>
<p>اساساً، ماهیت تجمیع و فیلتر تماس‌ها تا حد زیادی با الزامات رابط‌های کاربری خارجی هدایت می‌شود. به این ترتیب، منطقی است که <strong>gateway</strong> متعلق به تیمی باشد که <strong>UI</strong> را ایجاد می‌کند. متأسفانه، به‌ویژه در سازمانی که شما یک تیم <strong>frontend</strong> اختصاصی دارید، آن تیم ممکن است مهارت‌های لازم برای ساختن چنین مؤلفه <strong>backend</strong> حیاتی را نداشته باشد.</p>
<p>صرف نظر از اینکه چه کسی در نهایت مالک <strong>central gateway</strong> می‌شود، این پتانسیل را دارد که به یک گلوگاه برای تحویل تبدیل شود. اگر چندین تیم نیاز به ایجاد تغییراتی در <strong>gateway</strong> داشته باشند، توسعه آن مستلزم هماهنگی بین آن تیم‌ها خواهد بود و سرعت کارها را کاهش می‌دهد. اگر یک تیم مالک آن باشد، آن تیم می‌تواند در زمان تحویل به یک گلوگاه تبدیل شود. ما خواهیم دید که چگونه الگوی <strong>backend for frontend</strong> می‌تواند به زودی به حل این مشکلات کمک کند.</p>
<h4>انواع مختلف رابط‌های کاربری</h4>
<p>اگر چالش‌های مربوط به مالکیت را بتوان مدیریت کرد، یک <strong>central aggregating gateway</strong> ممکن است همچنان به خوبی کار کند، تا زمانی که موضوع دستگاه‌های مختلف و نیازهای متفاوت آنها را در نظر بگیریم. همانطور که ما بحث کرده‌ایم، قابلیت‌های یک دستگاه تلفن همراه بسیار متفاوت است. ما فضای صفحه کمتری داریم، که به این معنی است که می‌توانیم داده‌های کمتری را نمایش دهیم. باز کردن تعداد زیادی اتصال به منابع سمت سرور می‌تواند عمر باتری و طرح‌های داده‌ای محدود را تخلیه کند.
   علاوه بر این، ماهیت تعاملاتی که ما می‌خواهیم در یک دستگاه تلفن همراه ارائه دهیم می‌تواند به شدت متفاوت باشد. به یک خرده‌فروش آجری-و-ملات معمولی فکر کنید. در یک برنامه دسکتاپ، من ممکن است به شما اجازه دهم که اقلامی را که برای فروش هستند ببینید و آنها را به صورت آنلاین سفارش دهید یا در یک فروشگاه رزرو کنید. اما در دستگاه تلفن همراه، ممکن است بخواهم به شما اجازه دهم که بارکدها را اسکن کنید تا مقایسه‌های قیمت را انجام دهید یا پیشنهادهای مبتنی بر متن را در حین حضور در فروشگاه به شما ارائه دهم. همانطور که ما برنامه‌های تلفن همراه بیشتری را ساختیم، متوجه شدیم که مردم از آنها بسیار متفاوت استفاده می‌کنند، و بنابراین عملکردی که ما باید در معرض نمایش قرار دهیم نیز متفاوت خواهد بود.</p>
<p>بنابراین در عمل، دستگاه‌های تلفن همراه ما می‌خواهند تماس‌های متفاوتی و کمتری برقرار کنند و می‌خواهند داده‌های متفاوتی (و احتمالاً کمتری) را نسبت به همتایان دسکتاپ خود نمایش دهند. این بدان معناست که ما باید عملکرد اضافی را به <strong>backend API</strong> خود اضافه کنیم تا از انواع مختلف رابط‌های کاربری پشتیبانی کنیم. در شکل 14-10، ما رابط وب MusicCorp و رابط موبایل را می‌بینیم که هر دو از یک <strong>gateway</strong> برای صفحه خلاصه مشتری استفاده می‌کنند، اما هر <strong>client</strong> مجموعه متفاوتی از اطلاعات را می‌خواهد. رابط وب اطلاعات بیشتری در مورد مشتری می‌خواهد و همچنین یک خلاصه مختصر از اقلام موجود در هر سفارش دارد. این ما را به پیاده‌سازی دو تماس تجمیع و فیلتر مختلف در <strong>backend gateway</strong> خود سوق می‌دهد.</p>
<p>الگو: <strong>Central Aggregating Gateway</strong> | 477</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0503</div>
            </div>
        </div>
        <!-- Page 0504 -->
        <div class="chapter" id="page-0504">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: <strong>Central Aggregating Gateway</strong> (ادامه)</h4>
<p>شکل 14-10. پشتیبانی از تماس‌های <strong>aggregating</strong> مختلف برای دستگاه‌های مختلف</p>
<p>این می‌تواند منجر به مقدار زیادی <strong>bloat</strong> در <strong>gateway</strong> شود، به خصوص اگر ما برنامه‌های بومی تلفن همراه مختلف، وب‌سایت‌های <em>customer-facing</em>، رابط‌های اداری داخلی و موارد مشابه را در نظر بگیریم. ما همچنین این مشکل را داریم که، البته، در حالی که این <strong>UIs</strong> مختلف ممکن است متعلق به تیم‌های مختلف باشند، <strong>gateway</strong> یک واحد واحد است—ما همان مشکلات قدیمی را داریم که چندین تیم باید روی یک <strong>artifact</strong> مستقر شده کار کنند. <strong>Backend aggregating</strong> واحد ما می‌تواند به یک گلوگاه تبدیل شود، زیرا تغییرات زیادی در تلاش برای ایجاد همان <strong>artifact</strong> قابل استقرار وجود دارد.</p>
<h4>نگرانی‌های متعدد</h4>
<p>مجموعه‌ای از نگرانی‌ها وجود دارد که ممکن است هنگام رسیدگی به تماس‌های <strong>API</strong>، در سمت سرور باید به آنها رسیدگی شود. جدا از تجمیع و فیلتر کردن تماس، ما می‌توانیم به نگرانی‌های عمومی‌تری مانند مدیریت کلید <strong>API</strong>، <strong>authentication</strong> کاربر، یا مسیریابی تماس فکر کنیم. اغلب این نگرانی‌های عمومی را می‌توان با محصولات <strong>API gateway</strong> مدیریت کرد، که در اندازه‌های مختلف و برای قیمت‌های مختلف (که برخی از آنها بسیار بالا هستند!) در دسترس هستند. بسته به میزان پیچیدگی مورد نیاز شما، خرید یک محصول (یا مجوز یک سرویس) برای رسیدگی به برخی از این نگرانی‌ها برای شما می‌تواند منطقی باشد. آیا واقعاً می‌خواهید انتشار کلید <strong>API</strong>، ردیابی، محدودیت نرخ و غیره را خودتان مدیریت کنید؟ به هر وسیله، به محصولات موجود در این فضا نگاه کنید تا این موارد عمومی را حل کنید</p>
<p>478 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 504" src="page_0504/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0504</div>
            </div>
        </div>
        <!-- Page 0505 -->
        <div class="chapter" id="page-0505">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: <strong>Central Aggregating Gateway</strong> (ادامه)</h4>
<p>نگرانی‌ها، اما مراقب باشید که سعی نکنید از این محصولات برای انجام تجمیع و فیلتر کردن تماس‌های خود نیز استفاده کنید، حتی اگر ادعا می‌کنند که می‌توانند این کار را انجام دهند.</p>
<p>هنگام سفارشی کردن یک محصول که توسط شخص دیگری ساخته شده است، شما اغلب مجبور هستید در دنیای آنها کار کنید. <strong>toolchain</strong> شما محدود شده است، زیرا ممکن است نتوانید از زبان برنامه‌نویسی و شیوه‌های توسعه خود استفاده کنید. به جای نوشتن کد <em>Java</em>، شما در حال پیکربندی قوانین مسیریابی در یک <em>DSL</em> خاص محصول هستید (احتمالاً با استفاده از <strong>JSON</strong>). این می‌تواند یک تجربه ناامیدکننده باشد، و شما مقداری از هوشمندی سیستم خود را در یک محصول شخص ثالث وارد می‌کنید. این می‌تواند توانایی شما را برای جابجایی این رفتار در آینده کاهش دهد. معمول است که متوجه شوید که یک الگوی تجمیع تماس در واقع مربوط به برخی از عملکردهای دامنه است که می‌تواند یک <strong>microservice</strong> را به خودی خود توجیه کند (چیزی که ما به زودی بیشتر بررسی خواهیم کرد زمانی که در مورد <strong>BFFs</strong> صحبت می‌کنیم). اگر این رفتار در یک پیکربندی خاص فروشنده باشد، جابجایی این عملکرد می‌تواند مشکل‌سازتر باشد، زیرا احتمالاً مجبور خواهید بود آن را دوباره اختراع کنید.</p>
<p>اگر <strong>aggregating gateway</strong> به اندازه کافی پیچیده شود که نیاز به تیمی اختصاصی برای مالکیت و مدیریت آن داشته باشد، وضعیت می‌تواند حتی بدتر شود. در بدترین حالت، اتخاذ مالکیت تیم افقی‌تر می‌تواند منجر به وضعیتی شود که برای راه‌اندازی برخی از عملکردهای جدید، شما باید تیم <strong>frontend</strong> را وادار به ایجاد تغییرات کنید، تیم <strong>aggregating gateway</strong> را وادار به ایجاد تغییرات کنید، و تیم(های) که مالک <strong>microservice</strong> هستند نیز تغییرات خود را ایجاد کنند. ناگهان همه چیز شروع به بسیار کندتر شدن می‌کند.</p>
<p>بنابراین اگر می‌خواهید از یک <strong>API gateway</strong> اختصاصی استفاده کنید، ادامه دهید—اما اکیداً در نظر بگیرید که منطق فیلتر و تجمیع خود را در جای دیگری داشته باشید.</p>
<h4>چه زمانی از آن استفاده کنیم</h4>
<p>برای یک راه‌حل متعلق به یک تیم واحد، جایی که یک تیم رابط کاربری و <strong>microservices backend</strong> را توسعه می‌دهد، من با داشتن یک <strong>aggregating gateway</strong> مرکزی واحد مشکلی ندارم. با این حال، به نظر می‌رسد که این تیم کارهای زیادی انجام می‌دهد—در چنین شرایطی، من تمایل دارم که درجه بالایی از انطباق در رابط‌های کاربری را ببینم، که اغلب در وهله اول، نیاز به این نقاط تجمیع را از بین می‌برد.</p>
<p>اگر تصمیم به اتخاذ یک <strong>aggregating gateway</strong> مرکزی واحد دارید، لطفاً مراقب باشید که چه عملکردی را در داخل آن قرار می‌دهید. من از فشار دادن این عملکرد به یک محصول <strong>API gateway</strong> عمومی‌تر، به عنوان مثال، به دلایلی که قبلاً توضیح داده شد، بسیار محتاط خواهم بود.</p>
<p>با این حال، مفهوم انجام نوعی فیلتر کردن و تجمیع تماس در <strong>backend</strong> می‌تواند از نظر بهینه‌سازی تجربه کاربر از رابط‌های کاربری ما واقعاً مهم باشد. مسئله این است که در یک سازمان تحویل با چندین تیم، یک <strong>gateway</strong> مرکزی می‌تواند منجر به نیاز به هماهنگی زیاد در بین آن تیم‌ها شود.</p>
<p>بنابراین اگر هنوز می‌خواهیم تجمیع و فیلتر را در <strong>backend</strong> انجام دهیم اما می‌خواهیم مشکلات مرتبط با مدل مالکیت یک <strong>gateway</strong> مرکزی را حذف کنیم، چه می‌توانیم بکنیم؟ اینجاست که الگوی <strong>backend for frontend</strong> وارد می‌شود.</p>
<p>الگو: <strong>Central Aggregating Gateway</strong> | 479</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0505</div>
            </div>
        </div>
        <!-- Page 0506 -->
        <div class="chapter" id="page-0506">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: <strong>Backend for Frontend (BFF)</strong></h4>
<p>6 مقاله "<strong>BFF @ SoundCloud</strong>" نوشته <em>Lukasz Plotnicki</em> را برای یک نمای کلی عالی از نحوه استفاده <em>SoundCloud</em> از الگوی <strong>BFF</strong> مشاهده کنید.</p>
<p>الگوی <strong>Backend for Frontend (BFF)</strong></p>
<p>تمایز اصلی بین یک <strong>BFF</strong> و یک <strong>central aggregating gateway</strong> این است که یک <strong>BFF</strong> از نظر ماهیت تک منظوره است—برای یک رابط کاربری خاص توسعه یافته است. این الگو در کمک به رسیدگی به نگرانی‌های مختلف رابط‌های کاربری بسیار موفق بوده است، و من دیده‌ام که در تعدادی از سازمان‌ها، از جمله <em>SoundCloud</em>6 و <em>REA</em>، خوب عمل می‌کند. همانطور که در شکل 14-11 می‌بینیم، جایی که به MusicCorp بازمی‌گردیم، رابط‌های خرید وب و موبایل اکنون <strong>backends aggregating</strong> خود را دارند.</p>
<p>شکل 14-11. هر رابط کاربری، <strong>BFF</strong> خود را دارد</p>
<p>با توجه به ماهیت خاص خود، <strong>BFF</strong> از برخی از نگرانی‌ها در مورد <strong>central aggregating gateway</strong> اجتناب می‌کند. از آنجایی که ما در تلاش نیستیم که همه چیز را برای همه افراد فراهم کنیم، یک <strong>BFF</strong> از تبدیل شدن به یک گلوگاه برای توسعه اجتناب می‌کند، با چندین تیم که همه در تلاشند تا مالکیت مشترک داشته باشند. ما همچنین کمتر نگران اتصال به رابط کاربری هستیم، زیرا اتصال بسیار قابل قبول‌تر است. یک <strong>BFF</strong> معین برای یک رابط کاربری خاص است—با فرض اینکه آنها متعلق به همان تیم هستند، سپس جفت شدن ذاتی بسیار راحت‌تر مدیریت می‌شود. من</p>
<p>480 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 506" src="page_0506/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0506</div>
            </div>
        </div>
        <!-- Page 0507 -->
        <div class="chapter" id="page-0507">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: <strong>Backend for Frontend (BFF)</strong> (ادامه)</h4>
<p>اغلب استفاده از یک <strong>BFF</strong> با یک رابط کاربری را توصیف می‌کنند، گویی <strong>UI</strong> در واقع به دو بخش تقسیم شده است. یک بخش روی دستگاه <strong>client</strong> (رابط وب یا برنامه موبایل بومی) قرار دارد، که بخش دوم، <strong>BFF</strong>، در سمت سرور تعبیه شده است.</p>
<p><strong>BFF</strong> به یک تجربه کاربری خاص متصل است و معمولاً توسط همان تیمی که رابط کاربری را دارد، نگهداری می‌شود، بنابراین تعریف و انطباق <strong>API</strong> را با توجه به نیاز <strong>UI</strong> آسان‌تر می‌کند، در حالی که فرآیند هماهنگی انتشار اجزای <strong>client</strong> و سرور را نیز ساده می‌کند.</p>
<h4>چند <strong>BFF</strong>؟</h4>
<p>وقتی صحبت از ارائه تجربه کاربری یکسان (یا مشابه) در پلتفرم‌های مختلف می‌شود، من دو رویکرد مختلف را دیده‌ام. مدلی که من ترجیح می‌دهم (و مدلی که اغلب می‌بینم) این است که دقیقاً یک <strong>BFF</strong> واحد برای هر نوع <strong>client</strong> متفاوت داشته باشیم—این مدلی است که من در <em>REA</em> دیدم، همانطور که در شکل 14-12 نشان داده شده است. برنامه‌های <em>Android</em> و <em>iOS</em>، در حالی که عملکردهای مشابهی را پوشش می‌دهند، هر کدام <strong>BFF</strong> خود را داشتند.</p>
<p>شکل 14-12. برنامه‌های <em>iOS</em> و <em>Android</em> <em>REA</em> دارای <strong>BFFs</strong> متفاوتی هستند</p>
<p>الگو: <strong>Backend for Frontend (BFF)</strong> | 481</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 507" src="page_0507/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0507</div>
            </div>
        </div>
        <!-- Page 0508 -->
        <div class="chapter" id="page-0508">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: <strong>Backend for Frontend (BFF)</strong> (ادامه)</h4>
<p>یک تغییر این است که به دنبال فرصت‌هایی برای استفاده از یک <strong>BFF</strong> یکسان برای بیش از یک نوع <strong>client</strong> باشید، اگرچه برای همان نوع رابط کاربری. برنامه <em>Listener</em> <em>SoundCloud</em> به مردم اجازه می‌دهد تا به محتوا در دستگاه‌های <em>Android</em> یا <em>iOS</em> خود گوش دهند. <em>SoundCloud</em> از یک <strong>BFF</strong> واحد برای هر دو <em>Android</em> و <em>iOS</em> استفاده می‌کند، همانطور که در شکل 14-13 نشان داده شده است.</p>
<p>شکل 14-13. <em>SoundCloud</em> به اشتراک‌گذاری یک <strong>BFF</strong> بین برنامه‌های <em>iOS</em> و <em>Android</em></p>
<p>نگرانی اصلی من در مورد این مدل دوم این است که هرچه <strong>clients</strong> بیشتری داشته باشید که از یک <strong>BFF</strong> واحد استفاده می‌کنند، وسوسه بیشتری برای <strong>BFF</strong> وجود دارد که با رسیدگی به نگرانی‌های متعدد، متورم شود. با این حال، نکته اصلی که باید در اینجا درک کرد این است که حتی زمانی که <strong>clients</strong> یک <strong>BFF</strong> را به اشتراک می‌گذارند، این برای همان کلاس رابط کاربری است—بنابراین در حالی که برنامه‌های <em>Listener</em> بومی <em>SoundCloud</em> برای <em>iOS</em> و <em>Android</em> از همان <strong>BFF</strong> استفاده می‌کنند، برنامه‌های بومی دیگر از <strong>BFFs</strong> متفاوتی استفاده می‌کنند. من در مورد استفاده از این مدل اگر همان تیم مالک هر دو برنامه <em>Android</em> و <em>iOS</em> و همچنین مالک <strong>BFF</strong> باشد، راحت‌تر هستم—اگر این برنامه‌ها توسط تیم‌های مختلف نگهداری شوند، من بیشتر تمایل دارم که مدل سخت‌گیرانه‌تر را توصیه کنم. بنابراین شما می‌توانید ساختار سازمانی خود را به عنوان یکی از محرک‌های اصلی برای تصمیم‌گیری در مورد اینکه کدام مدل منطقی‌ترین است، ببینید (قانون <em>Conway</em> دوباره برنده می‌شود).</p>
<p>482 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 508" src="page_0508/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0508</div>
            </div>
        </div>
        <!-- Page 0509 -->
        <div class="chapter" id="page-0509">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: <strong>Backend for Frontend (BFF)</strong> (ادامه)</h4>
<p>7 <em>Stewart</em> به نوبه خود، این توصیه را به <em>Phil Calçado</em> و <em>Mustafa Sezgin</em> نسبت داده است.</p>
<p><em>Stewart Gleadow</em> از <em>REA</em>، دستورالعمل "یک تجربه، یک <strong>BFF</strong>" را پیشنهاد کرده است.</p>
<p>بنابراین اگر تجربیات <em>iOS</em> و <em>Android</em> بسیار مشابه باشند، توجیه داشتن یک <strong>BFF</strong> واحد آسان‌تر است.7 با این حال، اگر آنها به شدت از هم جدا شوند، داشتن <strong>BFFs</strong> جداگانه منطقی‌تر است. در مورد <em>REA</em>، اگرچه همپوشانی بین این دو تجربه وجود داشت، تیم‌های مختلف مالک آنها بودند و ویژگی‌های مشابه را به روش‌های مختلفی راه‌اندازی می‌کردند.
   گاهی اوقات ممکن است همان ویژگی به طور متفاوتی در یک دستگاه تلفن همراه متفاوت مستقر شود—آنچه که به یک تجربه بومی برای یک برنامه <em>Android</em> می‌رسد ممکن است لازم باشد دوباره کار شود تا در <em>iOS</em> بومی احساس شود.</p>
<p>درس دیگری از داستان <em>REA</em> (و داستانی که ما قبلاً چندین بار آن را پوشش داده‌ایم) این است که <strong>software</strong> اغلب زمانی بهترین عملکرد را دارد که حول مرزهای تیم‌ها همسو شده باشد، و <strong>BFFs</strong> نیز از این قاعده مستثنی نیستند. داشتن یک تیم تلفن همراه واحد <em>SoundCloud</em> باعث می‌شود داشتن یک <strong>BFF</strong> واحد در نگاه اول منطقی به نظر برسد، همانطور که <em>REA</em> دو <strong>BFF</strong> متفاوت برای دو تیم جداگانه دارد. شایان ذکر است که مهندسان <em>SoundCloud</em> که من با آنها صحبت کردم پیشنهاد کردند که داشتن یک <strong>BFF</strong> برای برنامه‌های <em>listener</em> <em>Android</em> و <em>iOS</em> چیزی است که ممکن است دوباره در نظر بگیرند—آنها یک تیم موبایل واحد داشتند، اما در واقع آنها ترکیبی از متخصصان <em>Android</em> و <em>iOS</em> بودند، و آنها خود را یافتند که بیشتر روی یک یا دیگری از برنامه‌ها کار می‌کنند، که نشان می‌دهد آنها در واقع دو تیم بودند.</p>
<p>اغلب عامل داشتن تعداد کمتری <strong>BFFs</strong>، تمایل به استفاده مجدد از عملکرد سمت سرور برای جلوگیری از تکرار بیش از حد است، اما راه‌های دیگری برای رسیدگی به این موضوع وجود دارد که در ادامه به آن خواهیم پرداخت.</p>
<h4>استفاده مجدد و <strong>BFFs</strong></h4>
<p>یکی از نگرانی‌های داشتن یک <strong>BFF</strong> واحد در هر رابط کاربری این است که شما می‌توانید با مقدار زیادی تکرار در میان <strong>BFFs</strong> به پایان برسید. به عنوان مثال، آنها ممکن است در نهایت همان نوع تجمیع را انجام دهند، کد یکسان یا مشابهی برای ارتباط با سرویس‌های پایین‌دستی داشته باشند و غیره. اگر شما به دنبال استخراج عملکرد مشترک هستید، در این صورت اغلب یکی از چالش‌ها در یافتن آن است. این تکرار ممکن است در خود <strong>BFFs</strong> رخ دهد، اما همچنین می‌تواند در <strong>clients</strong> مختلف نیز اعمال شود. با توجه به این واقعیت که این <strong>clients</strong> از <em>technology stacks</em> بسیار متفاوتی استفاده می‌کنند، شناسایی این واقعیت که این تکرار در حال وقوع است، می‌تواند دشوار باشد. با سازمان‌هایی که تمایل به داشتن یک <em>technology stack</em> مشترک برای اجزای سمت سرور دارند، داشتن <strong>BFFs</strong> متعدد با تکرار ممکن است آسان‌تر باشد و بتوان آن را از بین برد.</p>
<p>برخی از مردم به این موضوع با تمایل به ادغام <strong>BFFs</strong> به عقب واکنش نشان می‌دهند، و آنها در نهایت با یک <strong>aggregating gateway</strong> با هدف عمومی مواجه می‌شوند. نگرانی من در مورد بازگشت به یک <strong>aggregating gateway</strong> واحد این است که ما می‌توانیم بیشتر از آنچه به دست می‌آوریم، از دست بدهیم، به خصوص که راه‌های دیگری برای نزدیک شدن به این تکرار وجود دارد.</p>
<p>الگو: <strong>Backend for Frontend (BFF)</strong> | 483</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0509</div>
            </div>
        </div>
        <!-- Page 0510 -->
        <div class="chapter" id="page-0510">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>BFFs</strong> و استفاده مجدد از کد</h4>
<p>همانطور که قبلاً گفتم، من در مورد کد تکراری در <strong>microservices</strong> نسبتاً آرام هستم. که یعنی، در حالی که در یک مرز <strong>microservice</strong> واحد، معمولاً هر کاری را که می‌توانم برای <em>refactor</em> کردن تکرار در انتزاع‌های مناسب انجام می‌دهم، همان واکنش را در مواجهه با تکرار در سراسر <strong>microservices</strong> ندارم. این بیشتر به این دلیل است که من اغلب بیشتر در مورد پتانسیل استخراج کد مشترک برای ایجاد اتصال تنگاتنگ بین سرویس‌ها نگران هستم (موضوعی که ما در "<em>DRY</em> و خطرات استفاده مجدد از کد در دنیای <strong>Microservice</strong>" در صفحه 154 بررسی کردیم). با این حال، مطمئناً مواردی وجود دارد که این موضوع موجه است.</p>
<p>وقتی زمان آن فرا می‌رسد که کد مشترک را برای فعال کردن استفاده مجدد بین <strong>BFFs</strong> استخراج کنیم، دو گزینه آشکار وجود دارد. اولین گزینه، که اغلب ارزان‌تر است اما با مشکلات بیشتری همراه است، استخراج نوعی کتابخانه مشترک است. دلیل اینکه این می‌تواند مشکل‌ساز باشد این است که کتابخانه‌های مشترک منبع اصلی <strong>coupling</strong> هستند، به خصوص زمانی که برای تولید کتابخانه‌های <strong>client</strong> برای فراخوانی سرویس‌های پایین‌دستی استفاده می‌شوند. با این وجود، موقعیت‌هایی وجود دارد که این کار درست به نظر می‌رسد—به‌ویژه زمانی که کدی که انتزاع می‌شود، صرفاً یک نگرانی در داخل سرویس است.</p>
<p>گزینه دیگر این است که عملکرد مشترک را در یک <strong>microservice</strong> جدید استخراج کنید. اگر عملکرد استخراج شده، عملکرد دامنه کسب‌وکار را نشان دهد، این می‌تواند به خوبی کار کند. یک تغییر در این رویکرد ممکن است این باشد که مسئولیت‌های تجمیع را به <strong>microservices</strong> بیشتر در پایین‌دست فشار دهید. بیایید موقعیتی را در نظر بگیریم که در آن ما می‌خواهیم لیستی از اقلام موجود در لیست آرزوهای مشتری را، همراه با اطلاعاتی در مورد اینکه آیا آن اقلام موجود هستند یا خیر و قیمت فعلی، نمایش دهیم، همانطور که در جدول 14-1 نشان داده شده است.</p>
<p>جدول 14-1. نمایش لیست آرزوها برای مشتری MusicCorp</p>
<p><em>The Brakes</em>, <em>Give Blood</em></p>
<p>موجود است!</p>
<p>$5.99</p>
<p><em>Blue Juice</em>, <em>Retrospectable</em></p>
<p>موجود نیست</p>
<p>$7.50</p>
<p><em>Hot Chip</em>, <em>Why Make Sense?</em></p>
<p>سریع تمام می‌شود! (2 باقی مانده) $9.99</p>
<p><strong>microservice</strong> مشتری اطلاعاتی در مورد لیست آرزوها و شناسه هر مورد ذخیره می‌کند. <strong>microservice</strong> کاتالوگ نام و قیمت هر مورد را ذخیره می‌کند، و سطوح موجودی در <strong>microservice</strong> موجودی ما ذخیره می‌شود. برای نمایش این کنترل یکسان در هر دو برنامه <em>iOS</em> و <em>Android</em>، هر <strong>BFF</strong> باید همان سه تماس را با <strong>microservices</strong> پشتیبان برقرار کند، همانطور که در شکل 14-14 نشان داده شده است.</p>
<p>484 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0510</div>
            </div>
        </div>
        <!-- Page 0511 -->
        <div class="chapter" id="page-0511">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>BFFs</strong> و استفاده مجدد از کد (ادامه)</h4>
<p>شکل 14-14. هر دو <strong>BFFs</strong>، عملیات مشابهی را برای نمایش یک لیست آرزوها انجام می‌دهند</p>
<p>یک راه برای کاهش تکرار در عملکرد در اینجا، استخراج این رفتار مشترک به یک <strong>microservice</strong> جدید است. در شکل 14-15، ما <strong>microservice</strong> جدید لیست آرزوهای اختصاصی خود را می‌بینیم که برنامه‌های <em>Android</em> و <em>iOS</em> ما هر دو می‌توانند از آن استفاده کنند.</p>
<p>باید بگویم که استفاده از کد یکسان در دو مکان، لزوماً باعث نمی‌شود که من بخواهم یک سرویس را به این روش استخراج کنم، اما اگر هزینه تراکنش ایجاد یک سرویس جدید به اندازه کافی کم بود، یا اگر من از کد در بیش از دو مکان استفاده می‌کردم، مطمئناً این را در نظر می‌گرفتم—در این شرایط خاص، اگر ما همچنین لیست‌های آرزو را در رابط وب خود نمایش می‌دادیم، به عنوان مثال، یک <strong>microservice</strong> اختصاصی حتی جذاب‌تر به نظر می‌رسید. من فکر می‌کنم ضرب‌المثل قدیمی ایجاد یک انتزاع زمانی که می‌خواهید چیزی را برای سومین بار پیاده‌سازی کنید، هنوز هم یک قانون سرانگشتی خوب به نظر می‌رسد، حتی در سطح سرویس.</p>
<p>الگو: <strong>Backend for Frontend (BFF)</strong> | 485</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 511" src="page_0511/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0511</div>
            </div>
        </div>
        <!-- Page 0512 -->
        <div class="chapter" id="page-0512">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>BFFs</strong> و استفاده مجدد از کد (ادامه)</h4>
<p>شکل 14-15. عملکرد مشترک به یک <strong>microservice</strong> لیست آرزوها استخراج می‌شود، که امکان استفاده مجدد در سراسر <strong>BFFs</strong> را فراهم می‌کند</p>
<h4><strong>BFFs</strong> برای وب دسکتاپ و فراتر از آن</h4>
<p>شما می‌توانید به <strong>BFFs</strong> به عنوان راه‌حلی برای حل محدودیت‌های دستگاه‌های تلفن همراه فکر کنید. تجربه وب دسکتاپ معمولاً در دستگاه‌های قدرتمندتر با اتصال بهتر ارائه می‌شود، جایی که هزینه ایجاد چندین تماس پایین‌دستی قابل مدیریت است. این می‌تواند به برنامه وب شما اجازه دهد تا چندین تماس را مستقیماً با سرویس‌های پایین‌دستی برقرار کند، بدون نیاز به یک <strong>BFF</strong>.</p>
<p>با این حال، من موقعیت‌هایی را دیده‌ام که در آنها استفاده از یک <strong>BFF</strong> برای وب نیز می‌تواند مفید باشد. هنگامی که شما بخش بزرگی از <strong>UI</strong> وب را در سمت سرور ایجاد می‌کنید (به عنوان مثال، با استفاده از الگوبرداری سمت سرور)، یک <strong>BFF</strong> مکان واضحی است که این کار را می‌توان انجام داد. این رویکرد همچنین می‌تواند <strong>caching</strong> را تا حدودی ساده کند، زیرا می‌توانید یک <em>reverse proxy</em> را در جلوی <strong>BFF</strong> قرار دهید، که به شما امکان می‌دهد نتایج تماس‌های <em>aggregated</em> را <strong>cache</strong> کنید.</p>
<p>486 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 512" src="page_0512/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0512</div>
            </div>
        </div>
        <!-- Page 0513 -->
        <div class="chapter" id="page-0513">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>BFFs</strong> برای وب دسکتاپ و فراتر از آن (ادامه)</h4>
<p>من حداقل یک سازمان را دیده‌ام که از <strong>BFFs</strong> برای سایر اشخاص ثالثی که نیاز به برقراری تماس دارند، استفاده می‌کند. با بازگشت به مثال همیشگی من از MusicCorp، من ممکن است یک <strong>BFF</strong> را در معرض دید قرار دهم تا به اشخاص ثالث اجازه دهم اطلاعات پرداخت حق امتیاز را استخراج کنند، یا به پخش جریانی به طیف وسیعی از دستگاه‌های <em>set-top box</em> اجازه دهم، همانطور که در شکل 14-16 می‌بینیم. اینها دیگر واقعاً <strong>BFFs</strong> نیستند، زیرا اشخاص ثالث "رابط کاربری" ارائه نمی‌دهند، اما این نمونه‌ای از همان الگو است که در یک زمینه متفاوت استفاده می‌شود، بنابراین فکر کردم ارزش به اشتراک‌گذاری دارد.</p>
<p>شکل 14-16. استفاده از <strong>BFFs</strong> برای مدیریت <strong>APIs</strong> خارجی</p>
<p>این رویکرد می‌تواند به‌ویژه مؤثر باشد، زیرا اشخاص ثالث اغلب توانایی محدودی (یا تمایلی) به استفاده یا تغییر تماس‌های <strong>API</strong> که برقرار می‌کنند ندارند. با یک <strong>backend API</strong> مرکزی، ممکن است مجبور شوید نسخه‌های قدیمی <strong>API</strong> را فقط برای راضی کردن زیرمجموعه کوچکی از اشخاص خارجی خود که قادر به ایجاد تغییر نیستند، نگه دارید. با یک <strong>BFF</strong>، این مشکل به‌طور قابل توجهی کاهش می‌یابد. این امر همچنین تأثیر تغییرات را محدود می‌کند. شما می‌توانید <strong>API</strong> را برای فیس‌بوک به گونه‌ای تغییر دهید که با سایر اشخاص ناسازگار شود، اما از آنجایی که آنها از یک <strong>BFF</strong> متفاوت استفاده می‌کنند، تحت تأثیر این تغییر قرار نمی‌گیرند.</p>
<h4>چه زمانی از آن استفاده کنیم</h4>
<p>برای برنامه‌ای که فقط یک <strong>UI</strong> وب را ارائه می‌دهد، من معتقدم که <strong>BFF</strong> فقط در صورتی منطقی است که شما مقدار قابل توجهی از تجمیع را در سمت سرور نیاز داشته باشید. در غیر این صورت، من فکر می‌کنم برخی از تکنیک‌های ترکیب <strong>UI</strong> دیگری که قبلاً پوشش داده‌ایم، می‌توانند به همان خوبی و بدون نیاز به یک مؤلفه سمت سرور اضافی کار کنند.</p>
<p>الگو: <strong>Backend for Frontend (BFF)</strong> | 487</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 513" src="page_0513/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0513</div>
            </div>
        </div>
        <!-- Page 0514 -->
        <div class="chapter" id="page-0514">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>BFFs</strong> برای وب دسکتاپ و فراتر از آن (ادامه)</h4>
<p>در لحظه‌ای که شما نیاز به ارائه عملکرد خاصی برای یک <strong>UI</strong> موبایل یا شخص ثالث دارید، من قویاً استفاده از <strong>BFFs</strong> را برای هر <strong>client</strong> از همان ابتدا در نظر می‌گیرم. من ممکن است در صورت بالا بودن هزینه استقرار خدمات اضافی، دوباره فکر کنم، اما جدایی نگرانی‌هایی که یک <strong>BFF</strong> می‌تواند به همراه داشته باشد، آن را به یک پیشنهاد کاملاً قانع‌کننده در اکثر موارد تبدیل می‌کند. من حتی بیشتر تمایل دارم از یک <strong>BFF</strong> استفاده کنم اگر جدایی قابل توجهی بین افرادی که <strong>UI</strong> را می‌سازند و سرویس‌های پایین‌دستی وجود داشته باشد، به دلایلی که توضیح دادم.</p>
<p>سپس ما به این سوال می‌رسیم که چگونه <strong>BFF</strong> را پیاده‌سازی کنیم—بیایید به <em>GraphQL</em> و نقشی که می‌تواند ایفا کند، نگاهی بیندازیم.</p>
<h4><em>GraphQL</em></h4>
<p><em>GraphQL</em> یک زبان <strong>query</strong> است که به <strong>clients</strong> اجازه می‌دهد تا <strong>queries</strong> را برای دسترسی یا تغییر داده‌ها صادر کنند. مانند <strong>SQL</strong>، <em>GraphQL</em> به این <strong>queries</strong> اجازه می‌دهد تا به صورت پویا تغییر داده شوند، و به <strong>client</strong> اجازه می‌دهد تا دقیقاً اطلاعاتی را که می‌خواهد برگرداند، تعریف کند. به عنوان مثال، با یک تماس <strong>REST</strong> استاندارد بر روی <strong>HTTP</strong>، هنگام صدور یک درخواست <strong>GET</strong> برای یک منبع سفارش، شما تمام فیلدهای آن سفارش را دریافت می‌کنید. اما اگر، در آن وضعیت خاص، شما فقط مقدار کل سفارش را می‌خواستید چه؟ شما می‌توانید به سادگی فیلدهای دیگر را نادیده بگیرید، یا یک منبع جایگزین (شاید یک خلاصه سفارش) ارائه دهید که فقط شامل اطلاعات مورد نیاز شما باشد. با <em>GraphQL</em>، شما می‌توانید درخواستی را صادر کنید که فقط فیلدهایی را که نیاز دارید، بپرسید، همانطور که در مثال 14-1 می‌بینیم.</p>
<p>مثال 14-1. یک مثال <strong>query GraphQL</strong> که برای دریافت اطلاعات سفارش استفاده می‌شود</p>
<pre><code class="language-text">{
    order(id: 123) {
        date
        total
        status
        delivery {
            company
            driver
            duedate
        }
    }
}
</code></pre>
<p>در این <strong>query</strong>، ما درخواست سفارش 123 را داشته‌ایم، و قیمت کل و وضعیت سفارش را خواسته‌ایم. ما فراتر رفته‌ایم و اطلاعاتی در مورد تحویل این سفارش خواسته‌ایم، بنابراین می‌توانیم اطلاعاتی در مورد نام راننده‌ای که بسته ما را تحویل می‌دهد، شرکتی که برای آن کار می‌کند و زمان تحویل بسته دریافت کنیم.
   با یک <strong>API REST</strong> معمولی، مگر اینکه اطلاعات تحویل در داخل منبع سفارش گنجانده شده باشد، ممکن است مجبور شویم برای دریافت این اطلاعات، یک تماس اضافی برقرار کنیم. بنابراین نه تنها <em>GraphQL</em> به ما کمک می‌کند تا دقیقاً فیلدهایی را که می‌خواهیم، درخواست کنیم، بلکه همچنین می‌تواند</p>
<p>الگو: <strong>Backend for Frontend (BFF)</strong> | 487</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0514</div>
            </div>
        </div>
        <!-- Page 0515 -->
        <div class="chapter" id="page-0515">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>الگو: <strong>Backend for Frontend (BFF)</strong> (ادامه)</h4>
<p>کاهش <em>round trips</em>. یک <strong>query</strong> مانند این مستلزم آن است که ما انواع داده‌های مختلفی را که به آنها دسترسی داریم تعریف کنیم—تعریف صریح انواع، بخش کلیدی <em>GraphQL</em> است.</p>
<p>برای پیاده‌سازی <em>GraphQL</em>، ما به یک <strong>resolver</strong> نیاز داریم تا <strong>queries</strong> را مدیریت کند. یک <strong>resolver GraphQL</strong> در سمت سرور قرار دارد و <strong>queries GraphQL</strong> را به تماس‌هایی برای دریافت اطلاعات، نگاشت می‌کند. بنابراین در مورد معماری <strong>microservice</strong>، ما به یک <strong>resolver</strong> نیاز داریم که قادر به نگاشت درخواست برای سفارش با <strong>ID</strong> 123 به یک تماس معادل با یک <strong>microservice</strong> باشد.</p>
<p>به این ترتیب، ما می‌توانیم از <em>GraphQL</em> برای پیاده‌سازی یک <strong>aggregating gateway</strong>، یا حتی یک <strong>BFF</strong> استفاده کنیم. مزیت <em>GraphQL</em> این است که ما به راحتی می‌توانیم تجمیع و فیلتر کردن مورد نظر خود را به سادگی با تغییر <strong>query</strong> از سمت <strong>client</strong> تغییر دهیم. تا زمانی که انواع <em>GraphQL</em> از <strong>query</strong> مورد نظر ما پشتیبانی کنند، نیازی به تغییر در سمت سرور <em>GraphQL</em> نیست. اگر دیگر نمی‌خواستیم نام راننده را در <strong>query</strong> مثال مشاهده کنیم، می‌توانستیم به سادگی این را از خود <strong>query</strong> حذف کنیم و دیگر ارسال نمی‌شد. از سوی دیگر، اگر می‌خواستیم تعداد امتیازهایی را که برای این سفارش دریافت کرده‌ایم، ببینیم، با فرض اینکه این اطلاعات در نوع سفارش موجود است، می‌توانستیم این را به <strong>query</strong> اضافه کنیم و اطلاعات بازگردانده می‌شد. این یک مزیت قابل توجه نسبت به پیاده‌سازی‌های <strong>BFF</strong> است که نیاز به اعمال تغییرات در منطق تجمیع به خود <strong>BFF</strong> نیز دارد.</p>
<p>انعطاف‌پذیری که <em>GraphQL</em> به دستگاه <strong>client</strong> می‌دهد تا به‌طور پویا <strong>queries</strong> را بدون تغییرات سمت سرور تغییر دهد، به این معنی است که احتمال کمتری وجود دارد که سرور <em>GraphQL</em> شما به یک منبع مشترک و مورد اختلاف تبدیل شود، همانطور که در مورد <strong>aggregating gateway</strong> با هدف عمومی بحث کردیم. با این حال، اگر شما نیاز به ارائه انواع جدید یا افزودن فیلدهایی به انواع موجود دارید، همچنان به تغییرات سمت سرور نیاز خواهید داشت. به این ترتیب، ممکن است همچنان به چندین <strong>backend</strong> سرور <em>GraphQL</em> نیاز داشته باشید تا با مرزهای تیم همسو شوید—بنابراین <em>GraphQL</em> به یک روش برای پیاده‌سازی یک <strong>BFF</strong> تبدیل می‌شود.</p>
<p>من در مورد <em>GraphQL</em> نگرانی‌هایی دارم، که من آنها را با جزئیات در فصل 5 توضیح دادم. با این حال، این یک راه‌حل مناسب است که امکان <strong>querying</strong> پویا را برای مطابقت با نیازهای انواع مختلف رابط‌های کاربری فراهم می‌کند.</p>
<h4>یک رویکرد ترکیبی</h4>
<p>بسیاری از گزینه‌های ذکر شده نیازی نیست که <strong>one-size-fits-all</strong> باشند. من می‌توانم ببینم که یک سازمان رویکرد تجزیه مبتنی بر <strong>widget</strong> را برای ایجاد یک وب‌سایت اتخاذ می‌کند، اما هنگام استفاده از برنامه تلفن همراه خود، از رویکرد <strong>backend for frontend</strong> استفاده می‌کند. نکته کلیدی این است که ما باید انسجام قابلیت‌های اساسی را که به کاربران خود ارائه می‌دهیم، حفظ کنیم. ما باید اطمینان حاصل کنیم که منطق مرتبط با سفارش موسیقی یا تغییر جزئیات مشتری در داخل آن سرویس‌ها وجود دارد که آن عملیات را مدیریت می‌کنند و در سراسر سیستم ما پخش نمی‌شود. اجتناب از تله قرار دادن رفتار بیش از حد در هر لایه واسطه‌ای، یک عمل متعادل‌کننده دشوار است.</p>
<p>یک رویکرد ترکیبی | 489</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0515</div>
            </div>
        </div>
        <!-- Page 0516 -->
        <div class="chapter" id="page-0516">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>خلاصه</h4>
<p>همانطور که امیدوارم نشان داده باشم، تجزیه عملکرد نیازی به توقف در سمت سرور ندارد، و داشتن تیم‌های <strong>frontend</strong> اختصاصی اجتناب‌ناپذیر نیست. من تعدادی از راه‌های مختلف برای ساخت یک رابط کاربری را به اشتراک گذاشته‌ام که می‌تواند از <strong>microservices</strong> پشتیبان استفاده کند در حالی که امکان ارائه <strong>end-to-end</strong> متمرکز را فراهم می‌کند.</p>
<p>در فصل بعدی، ما از جنبه‌های فنی به جنبه‌های مردمی می‌رویم، زمانی که ما با جزئیات بیشتر به تعامل <strong>microservices</strong> و ساختارهای سازمانی می‌پردازیم.</p>
<p>490 | فصل 14: رابط‌های کاربری</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0516</div>
            </div>
        </div>
        <!-- Page 0517 -->
        <div class="chapter" id="page-0517">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>فصل 15</h3>
<h3>ساختارهای سازمانی</h3>
<p>در حالی که تاکنون بخش زیادی از این کتاب بر چالش‌های فنی در حرکت به سمت یک معماری <em>fine-grained</em> متمرکز بوده است، ما همچنین به تعامل بین معماری <strong>microservice</strong> و نحوه سازماندهی تیم‌هایمان نگاه کرده‌ایم. در "به سمت تیم‌های <strong>Stream-Aligned</strong>" در صفحه 459، ما به مفهوم تیم‌های <strong>stream-aligned</strong> نگاه کردیم، که مسئولیت <strong>end-to-end</strong> تحویل عملکرد <em>user-facing</em> را بر عهده دارند، و همچنین به این موضوع نگاه کردیم که چگونه <strong>microservices</strong> می‌تواند به تحقق چنین ساختارهای تیمی کمک کند.</p>
<p>ما اکنون باید این ایده‌ها را شرح دهیم و به سایر ملاحظات سازمانی نگاه کنیم. همانطور که خواهیم دید، اگر می‌خواهید بیشترین بهره را از <strong>microservices</strong> ببرید، نمودار سازمانی شرکت خود را در معرض خطر نادیده بگیرید!</p>
<h4>سازمان‌های <strong>Loosely Coupled</strong></h4>
<p>در سراسر این کتاب، من پرونده‌ای را برای یک معماری <strong>loosely coupled</strong> تشکیل داده‌ام و استدلال کرده‌ام که هم‌ترازی با تیم‌های <strong>stream-aligned</strong> خودمختارتر و <strong>loosely coupled</strong> احتمالاً بهترین نتایج را به همراه خواهد داشت. تغییر به یک معماری <strong>microservice</strong> بدون تغییر در ساختار سازمانی، مفید بودن <strong>microservices</strong> را کم‌رنگ می‌کند—شما ممکن است در نهایت هزینه (قابل توجه) را برای تغییر معماری بپردازید، بدون اینکه بازگشت سرمایه خود را دریافت کنید. من به طور کلی در مورد نیاز به کاهش هماهنگی بین تیم‌ها نوشته‌ام تا به تسریع تحویل کمک کنم، که به نوبه خود تیم‌ها را قادر می‌سازد تا تصمیمات بیشتری را برای خود بگیرند. اینها ایده‌هایی هستند که ما در این فصل بیشتر به آنها خواهیم پرداخت، و ما برخی از این تغییرات سازمانی و رفتاری مورد نیاز را شرح خواهیم داد، اما قبل از آن، فکر می‌کنم مهم است که دیدگاه خود را برای آنچه یک سازمان <strong>loosely coupled</strong> به نظر می‌رسد، به اشتراک بگذارم.</p>
<p>491</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0517</div>
            </div>
        </div>
        <!-- Page 0518 -->
        <div class="chapter" id="page-0518">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>سازمان‌های <strong>Loosely Coupled</strong> (ادامه)</h4>
<p>1 <em>Nicole Forsgren, Jez Humble, and Gene Kim</em>, <em>Accelerate: The Science of Building and Scaling High Performing Technology Organizations</em> (Portland, OR: IT Revolution, 2018).</p>
<p>در کتاب <em>Accelerate</em>،1 <em>Nicole Forsgren</em>، <em>Jez Humble</em> و <em>Gene Kim</em> به ویژگی‌های تیم‌های خودگردان و <strong>loosely coupled</strong> نگاه کردند تا درک بهتری از رفتارهایی که برای دستیابی به عملکرد بهینه مهم هستند، به دست آورند. به گفته نویسندگان، آنچه مهم است این است که آیا تیم‌ها می‌توانند:</p>
<ul>
<li>تغییرات گسترده‌ای در طراحی سیستم خود بدون اجازه کسی خارج از تیم ایجاد کنند.</li>
<li>تغییرات گسترده‌ای در طراحی سیستم خود بدون وابستگی به تیم‌های دیگر برای ایجاد تغییر در سیستم‌های آنها یا ایجاد کار قابل توجه برای تیم‌های دیگر ایجاد کنند.</li>
<li>کار خود را بدون برقراری ارتباط و هماهنگی با افراد خارج از تیم خود تکمیل کنند.</li>
<li>محصول یا سرویس خود را در صورت تقاضا مستقر و منتشر کنند، صرف نظر از سایر سرویس‌هایی که به آنها وابسته است.</li>
<li>اکثر آزمایش‌های خود را در صورت تقاضا انجام دهند، بدون نیاز به یک محیط آزمایشی یکپارچه</li>
<li>استقرارها را در ساعات کاری عادی با حداقل <em>downtime</em> انجام دهند.</li>
</ul>
<p>تیم <strong>stream-aligned</strong>، مفهومی که ما برای اولین بار در فصل 1 با آن برخورد کردیم، با این چشم‌انداز برای یک سازمان <strong>loosely coupled</strong> همسو است. اگر شما در تلاش برای حرکت به سمت یک ساختار تیم <strong>stream-aligned</strong> هستید، این ویژگی‌ها یک فهرست عالی برای اطمینان از این هستند که در مسیر درست قرار دارید.</p>
<p>به نظر می‌رسد که برخی از این ویژگی‌ها از نظر ماهیت، فنی‌تر هستند—به عنوان مثال، توانایی استقرار در ساعات کاری عادی می‌تواند از طریق معماری که از استقرار <em>zero-downtime</em> پشتیبانی می‌کند، فعال شود. اما همه اینها در واقع به یک تغییر رفتاری نیاز دارند. برای اینکه تیم‌ها حس مالکیت بیشتری در مورد سیستم‌های خود داشته باشند، نیاز به دور شدن از کنترل متمرکز است، از جمله نحوه تصمیم‌گیری معماری (چیزی که ما در فصل 16 بررسی می‌کنیم). اساساً، دستیابی به ساختارهای سازمانی <strong>loosely coupled</strong> نیازمند غیرمتمرکز شدن قدرت و پاسخگویی است.</p>
<p>اکثر این فصل به این موضوع می‌پردازد که چگونه همه اینها را عملی کنیم، با نگاهی به اندازه‌های تیم، انواع مدل‌های مالکیت، نقش پلتفرم و موارد دیگر. شما می‌توانید تغییرات متعددی را برای حرکت سازمان خود در مسیر درست در نظر بگیرید.
   با این حال، قبل از همه اینها، بیایید کمی بیشتر به تعامل بین سازمان و معماری بپردازیم.</p>
<p>492 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0518</div>
            </div>
        </div>
        <!-- Page 0519 -->
        <div class="chapter" id="page-0519">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>قانون <em>Conway</em></h4>
<p>صنعت ما جوان است و به نظر می‌رسد که دائماً در حال اختراع مجدد خود است. و با این حال چند "قانون" کلیدی، آزمون زمان را پس داده‌اند. به عنوان مثال، قانون <em>Moore</em> بیان می‌کند که تراکم ترانزیستورها در مدارهای مجتمع هر دو سال یک بار دو برابر می‌شود، و این ثابت کرده است که به طرز عجیبی دقیق است (اگرچه این روند در حال کاهش است). یک قانون که من تقریباً جهانی می‌دانم، و در کار روزمره من بسیار مفیدتر است، قانون <em>Conway</em> است.</p>
<p>مقاله <em>Melvin Conway</em> با عنوان "کمیته‌ها چگونه اختراع می‌کنند؟" که در مجله <em>Datamation</em> در آوریل 1968 منتشر شد، مشاهده کرد که:</p>
<p>هر سازمانی که سیستمی را طراحی می‌کند (که در اینجا گسترده‌تر از سیستم‌های اطلاعاتی تعریف شده است) به ناچار طرحی را تولید می‌کند که ساختار آن، نسخه‌ای از ساختار ارتباطی سازمان است.</p>
<p>این بیانیه اغلب به اشکال مختلفی به عنوان قانون <em>Conway</em> نقل می‌شود. <em>Eric S. Raymond</em> این پدیده را در <em>The New Hacker’s Dictionary</em> (<em>MIT Press</em>) با بیان اینکه، "اگر شما چهار گروه در حال کار بر روی یک کامپایلر دارید، یک کامپایلر 4 پاسی دریافت خواهید کرد." خلاصه کرد.</p>
<p>قانون <em>Conway</em> به ما نشان می‌دهد که یک سازمان <strong>loosely coupled</strong> منجر به یک معماری <strong>loosely coupled</strong> می‌شود (و بالعکس)، که این ایده را تقویت می‌کند که امیدواریم مزایای یک معماری <strong>microservice</strong> <strong>loosely coupled</strong> را بدون در نظر گرفتن سازمانی که <strong>software</strong> را می‌سازد، به دست آوریم، که مشکل‌ساز خواهد بود.</p>
<h4>شواهد</h4>
<p>داستان این است که وقتی <em>Melvin Conway</em> مقاله خود را در این مورد به <em>Harvard Business Review</em> ارائه کرد، مجله آن را رد کرد و ادعا کرد که او پایان‌نامه خود را اثبات نکرده است. من دیده‌ام که نظریه او در موقعیت‌های مختلفی آشکار شده است که من آن را درست پذیرفته‌ام. اما شما لازم نیست حرف من را قبول کنید: از زمان ارائه اولیه <em>Conway</em>، کارهای زیادی در این زمینه انجام شده است. تعدادی مطالعه برای بررسی رابطه متقابل ساختار سازمانی و سیستم‌هایی که ایجاد می‌کنند، انجام شده است.</p>
<p>سازمان‌های <strong>Loosely</strong> و <strong>Tightly Coupled</strong></p>
<p>در "بررسی دوگانگی بین محصولات و معماری‌های سازمانی"،2 نویسندگان به تعدادی از سیستم‌های <strong>software</strong> مختلف نگاه می‌کنند، که به طور کلی به عنوان ایجاد شده توسط "سازمان‌های <strong>loosely coupled</strong>" یا "سازمان‌های <strong>tightly coupled</strong>" طبقه‌بندی می‌شوند. برای سازمان‌های <strong>tightly coupled</strong>، به شرکت‌های تولید محصول تجاری فکر کنید که</p>
<p>قانون <em>Conway</em> | 493</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0519</div>
            </div>
        </div>
        <!-- Page 0520 -->
        <div class="chapter" id="page-0520">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>سازمان‌های <strong>Loosely Coupled</strong> (ادامه)</h4>
<p>3 <em>Nachiappan Nagappan, Brendan Murphy, and Victor Basili</em>, “The Influence of Organizational Structure on Software Quality: An Empirical Case Study” <em>ICSE ’08: Proceedings of the 30th International Conference on Software Engineering</em> (New York: ACM, 2008).</p>
<p>4 و همه ما می‌دانیم که <em>Windows Vista</em> کاملاً مستعد خطا بود!</p>
<p>معمولاً با دیدگاه‌ها و اهداف قوی هماهنگ هستند، در حالی که سازمان‌های <strong>loosely coupled</strong> به خوبی توسط جوامع <em>open source</em> توزیع‌شده نشان داده می‌شوند.</p>
<p>در مطالعه خود، که در آن آنها جفت محصولات مشابه را از هر نوع سازمان مطابقت دادند، نویسندگان دریافتند که سازمان‌های <strong>loosely coupled</strong> بیشتر در واقع سیستم‌های <em>modular</em>تر و کمتر <em>coupled</em> ایجاد می‌کنند، در حالی که <strong>software</strong> سازمان <strong>tightly coupled</strong> کمتر ماژول‌بندی شده است.</p>
<h4><em>Windows Vista</em></h4>
<p><em>Microsoft</em> یک مطالعه تجربی3 انجام داد که در آن به این موضوع نگاه کرد که چگونه ساختار سازمانی خود بر کیفیت یک محصول <strong>software</strong> خاص، <em>Windows Vista</em> تأثیر می‌گذارد. به‌طور خاص، محققان به عوامل متعددی نگاه کردند تا تعیین کنند که یک مؤلفه در سیستم چقدر مستعد خطا خواهد بود.4 پس از بررسی معیارهای متعدد، از جمله معیارهای کیفیت <strong>software</strong> که معمولاً استفاده می‌شود، مانند پیچیدگی کد، آنها دریافتند که معیارهای مرتبط با ساختارهای سازمانی (مانند تعداد مهندسانی که روی یک قطعه کد کار کرده‌اند) ثابت شده‌اند. مهم‌ترین معیارهای مرتبط از نظر آماری هستند.</p>
<p>بنابراین در اینجا ما یک مثال دیگر از ساختار یک سازمان داریم که بر ماهیت سیستمی که آن سازمان ایجاد می‌کند، تأثیر می‌گذارد.</p>
<h4><em>Netflix</em> و <em>Amazon</em></h4>
<p>احتمالاً دو نمونه برجسته برای این ایده که سازمان‌ها و معماری باید همسو شوند، <em>Amazon</em> و <em>Netflix</em> هستند. در اوایل، <em>Amazon</em> شروع به درک مزایای تیم‌هایی کرد که مالک کل چرخه حیات سیستم‌هایی بودند که مدیریت می‌کردند. آنها می‌خواستند تیم‌ها، سیستم‌هایی را که مراقبت می‌کردند، داشته باشند و اداره کنند، و کل چرخه حیات را مدیریت کنند. اما <em>Amazon</em> همچنین می‌دانست که تیم‌های کوچک می‌توانند سریعتر از تیم‌های بزرگ کار کنند.
   این امر منجر به تیم‌های معروف دو پیتزایی آن شد، که در آن هیچ تیمی نباید آنقدر بزرگ باشد که نتوان با دو پیتزا آن را تغذیه کرد. این، البته، یک معیار کاملاً مفید نیست—ما هرگز متوجه نمی‌شویم که آیا پیتزا را برای ناهار یا شام (یا صبحانه!) می‌خوریم، و نه اینکه پیتزاها چقدر بزرگ هستند—اما باز هم، ایده کلی این است که اندازه تیم بهینه 8–10 نفر است، و اینکه این تیم باید <em>customer facing</em> باشد. این عامل محرک برای تیم‌های کوچک که مالک کل چرخه حیات خدمات خود هستند، یک دلیل اصلی برای توسعه <em>Amazon Web Services</em> توسط <em>Amazon</em> است. این شرکت نیاز داشت تا ابزارهایی را ایجاد کند تا به تیم‌های خود اجازه دهد تا خودکفا باشند.</p>
<p>494 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0520</div>
            </div>
        </div>
        <!-- Page 0521 -->
        <div class="chapter" id="page-0521">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>اندازه تیم</h4>
<p><em>Netflix</em> از این مثال آموخت و اطمینان حاصل کرد که از ابتدا خود را حول تیم‌های کوچک و مستقل ساختار می‌دهد، به طوری که سرویس‌هایی که ایجاد کردند نیز از یکدیگر مستقل باشند. این امر تضمین می‌کرد که معماری سیستم برای سرعت تغییر بهینه شده است. در واقع، <em>Netflix</em> ساختار سازمانی را برای معماری سیستمی که می‌خواست، طراحی کرد. من همچنین شنیده‌ام که این به نقشه‌های نشستن برای تیم‌ها در <em>Netflix</em> گسترش یافته است—تیم‌هایی که سرویس‌هایشان با یکدیگر صحبت می‌کردند، در کنار هم می‌نشستند. ایده این است که شما می‌خواهید ارتباط مکررتری با تیم‌هایی داشته باشید که از سرویس‌های شما استفاده می‌کنند، یا تیم‌هایی که خود شما از سرویس‌های آنها استفاده می‌کنید.</p>
<p>اندازه تیم</p>
<p>از هر توسعه‌دهنده بپرسید که اندازه یک تیم باید چقدر باشد، و در حالی که پاسخ‌های متفاوتی دریافت خواهید کرد، یک اجماع کلی وجود خواهد داشت مبنی بر اینکه، تا یک نقطه، کوچکتر بهتر است. اگر آنها را وادار کنید که یک عدد را برای اندازه تیم "ایده‌آل" قرار دهند، تا حد زیادی پاسخ‌هایی در محدوده 5 تا 10 نفر دریافت خواهید کرد.</p>
<p>من در مورد بهترین اندازه تیم برای توسعه <strong>software</strong> مقداری تحقیق کردم. من مطالعات زیادی پیدا کردم، اما بسیاری از آنها به گونه‌ای ناقص هستند که نتیجه‌گیری برای دنیای گسترده‌تر توسعه <strong>software</strong> بسیار دشوار است. بهترین مطالعه‌ای که پیدا کردم، "یافته‌های تجربی در مورد اندازه تیم و بهره‌وری در توسعه <strong>Software</strong>"،5 حداقل توانست از یک داده بزرگ استخراج کند، اگرچه لزوماً نماینده توسعه <strong>software</strong> به عنوان یک کل نیست. یافته‌های محققان نشان داد که، "همانطور که از ادبیات انتظار می‌رود، بهره‌وری برای آن پروژه‌هایی که (اندازه متوسط تیم) 9 نفر یا بیشتر است، بدترین است." این تحقیق حداقل به نظر می‌رسد که تجربه حکایتی من را تأیید می‌کند.</p>
<p>ما دوست داریم در تیم‌های کوچک کار کنیم، و سخت نیست که ببینیم چرا. با گروه کوچکی از افرادی که همگی بر روی نتایج یکسانی متمرکز شده‌اند، حفظ هم‌راستایی و هماهنگی در کار آسان‌تر است. من یک فرضیه (آزمایش‌نشده) دارم مبنی بر اینکه پراکندگی جغرافیایی یا داشتن تفاوت‌های منطقه زمانی زیاد در بین اعضای تیم، چالش‌هایی را ایجاد می‌کند که ممکن است اندازه تیم بهینه را بیشتر محدود کند، اما احتمالاً این تفکر بهتر است توسط شخص دیگری غیر از من بررسی شود.</p>
<p>بنابراین تیم‌های کوچک خوب هستند، تیم‌های بزرگ بد. این کاملاً ساده به نظر می‌رسد. حال، اگر شما می‌توانید تمام کارهایی را که باید انجام دهید با یک تیم واحد انجام دهید، عالی است! دنیای شما ساده است، و احتمالاً می‌توانید از بخش زیادی از بقیه این فصل صرف نظر کنید. اما اگر کار بیشتری از زمانی که دارید دارید، چه؟ یک واکنش آشکار به آن، اضافه کردن افراد است. اما همانطور که می‌دانیم، اضافه کردن افراد لزوماً به شما کمک نمی‌کند که کارهای بیشتری انجام دهید.</p>
<p>5 <em>Daniel Rodriguez et al.</em>, “Empirical Findings on Team Size and Productivity in Software Development,” <em>Journal of Systems and Software</em> 85, no. 3 (2012), doi.org/10.1016/j.jss.2011.09.009.</p>
<p>اندازه تیم | 495</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0521</div>
            </div>
        </div>
        <!-- Page 0522 -->
        <div class="chapter" id="page-0522">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>درک قانون <em>Conway</em></h4>
<p>شواهد حکایتی و تجربی نشان می‌دهد که ساختار سازمانی ما تأثیر زیادی بر ماهیت (و کیفیت) سیستم‌هایی که ایجاد می‌کنیم دارد. ما همچنین می‌دانیم که تیم‌های کوچکتر را نیز می‌خواهیم. بنابراین چگونه این درک به ما کمک می‌کند؟ خوب، اساساً، اگر ما یک معماری <strong>loosely coupled</strong> را می‌خواهیم تا امکان ایجاد تغییرات آسان‌تر را فراهم کنیم، یک سازمان <strong>loosely coupled</strong> را نیز می‌خواهیم. به عبارت دیگر، دلیلی که ما اغلب یک سازمان <strong>loosely coupled</strong>تر را می‌خواهیم، این است که ما می‌خواهیم بخش‌های مختلف سازمان بتوانند سریع‌تر و کارآمدتر تصمیم‌گیری و عمل کنند، و یک معماری سیستم‌های <strong>loosely coupled</strong> به این امر بسیار کمک می‌کند.</p>
<p>در <em>Accelerate</em>، نویسندگان همبستگی قابل توجهی بین سازمان‌هایی که دارای معماری <strong>loosely coupled</strong> بودند و توانایی آنها برای استفاده مؤثرتر از تیم‌های تحویل بزرگ‌تر یافتند:</p>
<p>اگر ما به یک معماری <strong>loosely coupled</strong> و <strong>well-encapsulated</strong> با یک ساختار سازمانی متناسب با آن دست یابیم، دو اتفاق مهم رخ می‌دهد. اولاً، ما می‌توانیم به عملکرد تحویل بهتری دست یابیم، هم سرعت و هم ثبات را افزایش دهیم و در عین حال فرسودگی شغلی و درد استقرار را کاهش دهیم. ثانیاً، ما می‌توانیم اندازه سازمان مهندسی خود را به میزان قابل توجهی افزایش دهیم و بهره‌وری را به‌صورت خطی—یا بهتر از خطی—با این کار افزایش دهیم.</p>
<p>از نظر سازمانی، تغییری که مدتی است در حال وقوع است، به‌ویژه برای سازمان‌هایی که در مقیاس فعالیت می‌کنند، حرکت به سمت مدل‌های فرماندهی و کنترل متمرکز است. با تصمیم‌گیری متمرکز، سرعتی که سازمان ما می‌تواند به آن واکنش نشان دهد، به‌طور قابل توجهی کاهش می‌یابد. این امر با رشد سازمان، تشدید می‌شود—هرچه بزرگتر می‌شود، ماهیت متمرکز آن، راندمان تصمیم‌گیری و سرعت عمل را کاهش می‌دهد.</p>
<p>سازمان‌ها به طور فزاینده‌ای متوجه شده‌اند که اگر می‌خواهید سازمان خود را مقیاس‌بندی کنید اما همچنان می‌خواهید سریع حرکت کنید، باید مسئولیت را به طور مؤثرتری توزیع کنید، تصمیم‌گیری مرکزی را از بین ببرید و تصمیمات را به بخش‌هایی از سازمان که می‌توانند با خودمختاری بیشتر عمل کنند، منتقل کنید.</p>
<p>بنابراین، ترفند این است که سازمان‌های بزرگ را از تیم‌های کوچک و خودمختار ایجاد کنید.</p>
<p>تیم‌های کوچک، سازمان بزرگ</p>
<p>افزودن نیروی انسانی به یک پروژه <strong>software</strong> دیرهنگام، آن را دیرتر می‌کند.</p>
<p>—<em>Fred Brooks</em> (قانون <em>Brooks’s Law</em>)</p>
<p>در مقاله معروف خود، "<em>The Mythical Man-Month</em>"،6 نویسنده <em>Fred Brooks</em> تلاش می‌کند توضیح دهد که چرا استفاده از "یک نفر-ماه" به عنوان یک تکنیک تخمین، به دلیل</p>
<p>6 <em>Frederick P. Brooks Jr</em>، <em>The Mythical Man-Month: Essays on Software Engineering</em>، نسخه سالگرد (<em>Boston</em>: <em>Addison-Wesley</em>، 1995).</p>
<p>496 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0522</div>
            </div>
        </div>
        <!-- Page 0523 -->
        <div class="chapter" id="page-0523">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تیم‌های کوچک، سازمان بزرگ (ادامه)</h4>
<p>7 <em>John Rossman</em>, <em>Think Like Amazon: 50 1/2 Ideas to Become a Digital Leader</em> (New York: McGraw-Hill, 2019).</p>
<p>8 <em>Matthew Skelton and Manuel Pais</em>, <em>Team Topologies</em> (Portland, OR: IT Revolution, 2019).</p>
<p>این واقعیت که باعث می‌شود ما در تله فکر کردن بیفتیم که می‌توانیم افراد بیشتری را به سمت مشکل پرتاب کنیم تا سریع‌تر پیش برویم. این نظریه این‌گونه پیش می‌رود: اگر انجام یک کار شش ماه طول بکشد، پس اگر یک توسعه‌دهنده دوم اضافه کنیم، فقط سه ماه طول می‌کشد. اگر پنج توسعه‌دهنده اضافه کنیم، بنابراین اکنون شش نفر در کل داریم، کار باید فقط در یک ماه انجام شود! البته، <strong>software</strong> اینطور کار نمی‌کند.</p>
<p>برای اینکه بتوانید افراد (یا تیم‌های) بیشتری را به یک مشکل پرتاب کنید تا سریع‌تر پیش بروید، کار باید تا حدی به وظایفی تقسیم شود که بتوان تا حدی به موازات روی آنها کار کرد. اگر یک توسعه‌دهنده در حال انجام کاری باشد که توسعه‌دهنده دیگری منتظر آن است، کار نمی‌تواند به موازات انجام شود، باید به ترتیب انجام شود. حتی اگر کار را بتوان به صورت موازی انجام داد، اغلب نیاز به هماهنگی بین افرادی که جریان‌های مختلف کار را انجام می‌دهند وجود دارد، که منجر به سربار اضافی می‌شود. هرچه کار در هم تنیده‌تر باشد، افزودن افراد بیشتر، مؤثرتر نخواهد بود.</p>
<p>اگر شما نمی‌توانید کار را به زیروظایفی تقسیم کنید که بتوانند به طور مستقل روی آنها کار کنند، پس شما نمی‌توانید فقط افراد را به سمت مشکل پرتاب کنید. بدتر از آن، انجام این کار احتمالاً باعث می‌شود که شما کندتر شوید—افزودن افراد جدید یا راه‌اندازی تیم‌های جدید هزینه دارد. زمان لازم است تا به این افراد کمک شود تا کاملاً مولد باشند، و اغلب توسعه‌دهندگانی که کارهای زیادی برای انجام دادن دارند، همان توسعه‌دهندگانی هستند که باید زمان خود را صرف کمک به سرعت بخشیدن به افراد کنند.</p>
<p>بزرگترین هزینه برای کارآمدی در مقیاس در تحویل <strong>software</strong>، نیاز به هماهنگی است. هرچه هماهنگی بین تیم‌هایی که روی وظایف مختلف کار می‌کنند بیشتر باشد، شما کندتر خواهید بود. <em>Amazon</em>، به عنوان یک شرکت، این موضوع را درک کرده است، و خود را به گونه‌ای ساختار می‌دهد که نیاز به هماهنگی بین تیم‌های کوچک دو پیتزایی خود را کاهش دهد. در واقع به همین دلیل یک تلاش آگاهانه برای محدود کردن میزان هماهنگی بین تیم‌ها وجود داشته است، و این هماهنگی، در صورت امکان، به مناطقی محدود می‌شود که کاملاً مورد نیاز است—بین تیم‌هایی که مرزی را بین <strong>microservices</strong> به اشتراک می‌گذارند. از <em>Think Like Amazon</em>،7 نوشته <em>John Rossman</em>، مدیر اجرایی سابق <em>Amazon</em>:</p>
<p>تیم دو پیتزایی خودمختار است. تعامل با تیم‌های دیگر محدود است، و زمانی که اتفاق می‌افتد، به خوبی مستند می‌شود، و رابط‌ها به وضوح تعریف می‌شوند. این تیم مالک هر جنبه‌ای از سیستم‌های خود است و در قبال آنها مسئول است. یکی از اهداف اصلی، کاهش سربار ارتباطات در سازمان‌ها، از جمله تعداد جلسات، نقاط هماهنگی، برنامه‌ریزی، آزمایش یا انتشار است. تیم‌هایی که مستقل‌تر هستند، سریع‌تر حرکت می‌کنند.</p>
<p>درک اینکه یک تیم چگونه با سازمان بزرگتر مطابقت دارد، ضروری است. <em>Team Topologies</em> مفهوم یک <strong>API</strong> تیم را تعریف می‌کند، که به طور کلی نحوه تعامل آن تیم با بقیه سازمان را تعریف می‌کند، نه فقط از نظر رابط‌های <strong>microservice</strong>، بلکه از نظر شیوه‌های کاری:8</p>
<p>تیم‌های کوچک، سازمان بزرگ | 497</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0523</div>
            </div>
        </div>
        <!-- Page 0524 -->
        <div class="chapter" id="page-0524">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تیم‌های کوچک، سازمان بزرگ (ادامه)</h4>
<p>9 <em>Famous</em> برای توسعه ماده ضدآب <em>Gore-Tex</em>.</p>
<p><strong>API</strong> تیم باید به صراحت قابلیت استفاده توسط تیم‌های دیگر را در نظر بگیرد. آیا تیم‌های دیگر، تعامل با ما را آسان و سرراست خواهند یافت، یا دشوار و گیج‌کننده خواهد بود؟ چقدر برای یک تیم جدید آسان خواهد بود که با کد و شیوه‌های کاری ما همراه شود؟ چگونه به درخواست‌های <em>pull</em> و پیشنهادات تیم‌های دیگر پاسخ می‌دهیم؟ آیا برنامه <em>backlog</em> تیم و نقشه راه محصول ما به راحتی توسط تیم‌های دیگر قابل مشاهده و درک است؟</p>
<h4>در مورد خودمختاری</h4>
<p>صرف نظر از صنعتی که در آن فعالیت می‌کنید، همه چیز مربوط به افراد شماست، و اینکه آنها را در حال انجام کارهای درست درک کنید، و به آنها اعتماد به نفس، انگیزه، آزادی و میل به دستیابی به پتانسیل واقعی‌شان را ارائه دهید.</p>
<p>—<em>John Timpson</em></p>
<p>داشتن تیم‌های کوچک زیاد به خودی خود کمکی نخواهد کرد، اگر این تیم‌ها صرفاً به <em>silos</em> بیشتری تبدیل شوند که هنوز هم برای انجام کارها به تیم‌های دیگر وابسته هستند. ما باید اطمینان حاصل کنیم که هر یک از این تیم‌های کوچک دارای خودمختاری برای انجام کاری است که مسئول آن هستند. این بدان معناست که ما باید به تیم‌ها قدرت بیشتری برای تصمیم‌گیری و ابزارهایی برای اطمینان از اینکه می‌توانند تا حد امکان کار را انجام دهند، بدون اینکه مجبور شوند دائماً کار را با تیم‌های دیگر هماهنگ کنند، بدهیم. بنابراین فعال کردن خودمختاری کلیدی است.</p>
<p>بسیاری از سازمان‌ها مزایای ایجاد تیم‌های خودمختار را نشان داده‌اند. کوچک نگه داشتن گروه‌های سازمانی، اجازه دادن به آنها برای ایجاد پیوندهای نزدیک و همکاری مؤثر با یکدیگر بدون ایجاد بوروکراسی بیش از حد، به بسیاری از سازمان‌ها کمک کرده است تا رشد کنند و به طور مؤثرتری مقیاس‌بندی شوند. <em>W. L. Gore and Associates</em>9 موفقیت‌های زیادی را با اطمینان از اینکه هیچ یک از واحدهای تجاری‌اش هرگز به بیش از 150 نفر نرسد، به دست آورده است، تا اطمینان حاصل شود که همه یکدیگر را می‌شناسند. برای اینکه این واحدهای تجاری کوچکتر کار کنند، باید به آنها قدرت و مسئولیت داده شود تا به عنوان واحدهای خودمختار کار کنند.</p>
<p>به نظر می‌رسد که بسیاری از این سازمان‌ها از کار انجام شده توسط مردم‌شناس <em>Robin Dunbar</em>، که به توانایی انسان‌ها در ایجاد گروه‌های اجتماعی نگاه می‌کرد، استفاده کرده‌اند. نظریه او این بود که ظرفیت شناختی ما محدودیت‌هایی را در مورد میزان مؤثر بودن ما در حفظ اشکال مختلف روابط اجتماعی ایجاد می‌کند. او 150 نفر را تخمین زد که قبل از نیاز به جدا شدن، یک گروه می‌تواند به این اندازه بزرگ شود یا در غیر این صورت تحت وزن خود فرو می‌پاشد.</p>
<p><em>Timpson</em>، یک خرده‌فروش بسیار موفق بریتانیایی، با توانمندسازی نیروی کار خود، کاهش نیاز به عملکردهای مرکزی و اجازه دادن به فروشگاه‌های محلی برای تصمیم‌گیری برای خود، به چنین مقیاس عظیمی دست یافته است، مانند اینکه چقدر به مشتریان ناراضی بازپرداخت کنند.
   اکنون، <em>John Timpson</em>، رئیس شرکت، به دلیل حذف قوانین داخلی و جایگزینی آنها با فقط دو قانون، مشهور است:</p>
<p>498 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0524</div>
            </div>
        </div>
        <!-- Page 0525 -->
        <div class="chapter" id="page-0525">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تیم‌های کوچک، سازمان بزرگ (ادامه)</h4>
<p>10 که معروف است حتی <em>Spotify</em> دیگر از آن استفاده نمی‌کند.</p>
<ul>
<li>ظاهر مناسب داشته باشید.</li>
<li>پول در صندوق بریزید.</li>
</ul>
<p>خودمختاری در مقیاس کوچک‌تر نیز کار می‌کند، و اکثر شرکت‌های مدرنی که من با آنها کار می‌کنم به دنبال ایجاد تیم‌های خودمختارتر در داخل سازمان خود هستند، که اغلب در تلاشند تا مدل‌هایی را از سازمان‌های دیگر، مانند مدل تیم دو پیتزایی <em>Amazon</em>، یا "مدل <em>Spotify</em>" که مفهوم اصناف و فصل‌ها را رایج کرد، کپی کنند.10 البته من باید در اینجا یک یادداشت احتیاطی را مطرح کنم—به هر وسیله‌ای، از آنچه سازمان‌های دیگر انجام می‌دهند بیاموزید، اما درک کنید که کپی کردن آنچه شخص دیگری انجام می‌دهد و انتظار همان نتایج را داشتن، بدون اینکه واقعاً بفهمید چرا سازمان دیگر کارهایی را که انجام می‌دهد، انجام می‌دهد، ممکن است منجر به نتیجه مورد نظر شما نشود.</p>
<p>اگر به درستی انجام شود، خودمختاری تیم می‌تواند به افراد قدرت بدهد، به آنها کمک کند تا گام بردارند و رشد کنند، و کار را سریع‌تر انجام دهند. هنگامی که تیم‌ها مالک <strong>microservices</strong> هستند و کنترل کاملی بر آن <strong>microservices</strong> دارند، می‌توانند خودمختاری بیشتری را در یک سازمان بزرگ‌تر داشته باشند.
   مفهوم خودمختاری شروع به تغییر درک ما از مالکیت در یک معماری <strong>microservice</strong> می‌کند. بیایید این موضوع را با جزئیات بیشتری بررسی کنیم.</p>
<h4>مالکیت قوی در مقابل مالکیت جمعی</h4>
<p>در "تعریف مالکیت" در صفحه 213، ما در مورد انواع مختلف مالکیت بحث کردیم و پیامدهای این سبک‌های مالکیت را در زمینه ایجاد تغییرات در کد بررسی کردیم. به عنوان یک خلاصه مختصر، دو شکل اصلی مالکیت کد که ما توصیف کردیم عبارتند از:</p>
<ul>
<li>مالکیت قوی</li>
<p>یک <strong>microservice</strong> متعلق به یک تیم است، و آن تیم تصمیم می‌گیرد که چه تغییراتی در آن <strong>microservice</strong> ایجاد کند. اگر یک تیم خارجی می‌خواهد تغییراتی ایجاد کند، یا باید از تیم مالک بخواهد که تغییر را از طرف آن ایجاد کند، یا ممکن است مجبور شود یک <em>pull request</em> ارسال کند—سپس کاملاً به تیم مالک بستگی دارد که تحت چه شرایطی مدل <em>pull request</em> پذیرفته شود. یک تیم ممکن است بیش از یک <strong>microservice</strong> را در اختیار داشته باشد.</p>
<li>مالکیت جمعی</li>
<p>هر تیمی می‌تواند هر <strong>microservice</strong> را تغییر دهد. هماهنگی دقیق برای اطمینان از اینکه تیم‌ها در مسیر یکدیگر قرار نمی‌گیرند، مورد نیاز است.</p>
</ul>
<p>بیایید بیشتر پیامدهای این مدل‌های مالکیت را بررسی کنیم و اینکه چگونه می‌توانند به تلاش برای افزایش خودمختاری تیم کمک کنند (یا مانع شوند).</p>
<p>مالکیت قوی در مقابل مالکیت جمعی | 499</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0525</div>
            </div>
        </div>
        <!-- Page 0526 -->
        <div class="chapter" id="page-0526">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مالکیت قوی</h4>
<p>با مالکیت قوی، تیمی که مالک <strong>microservice</strong> است، تصمیم‌گیری می‌کند. در سطح ابتدایی، این تیم کنترل کاملی بر تغییرات کد ایجاد شده دارد. با این وجود، تیم ممکن است قادر به تصمیم‌گیری در مورد استانداردهای کدنویسی، اصطلاحات برنامه‌نویسی، زمان استقرار <strong>software</strong>، فناوری مورد استفاده برای ساخت <strong>microservice</strong>، پلتفرم استقرار، و موارد دیگر باشد. با داشتن مسئولیت بیشتر در قبال تغییراتی که در <strong>software</strong> رخ می‌دهد، تیم‌هایی با مالکیت قوی، از خودمختاری بیشتری برخوردار خواهند بود، با تمام مزایایی که به همراه دارد.</p>
<p>مالکیت قوی در نهایت همه چیز در مورد بهینه‌سازی برای خودمختاری آن تیم است. بازگشت به روش انجام کار <em>Amazon</em> از <em>Think Like Amazon</em>:</p>
<p>وقتی صحبت از تیم‌های معروف دو پیتزایی <em>Amazon</em> می‌شود، اکثر مردم نکته را از دست می‌دهند. این به اندازه تیم مربوط نمی‌شود. این در مورد خودمختاری، پاسخگویی و ذهنیت کارآفرینی تیم است. تیم دو پیتزایی در مورد مجهز کردن یک تیم کوچک در داخل یک سازمان برای فعالیت مستقل و چابک است.</p>
<p>مدل‌های مالکیت قوی می‌توانند به تنوع محلی بیشتر اجازه دهند. به عنوان مثال، ممکن است شما آرام باشید، در مورد اینکه یک تیم تصمیم می‌گیرد <strong>microservice</strong> خود را به سبک عملکردی <em>Java</em> ایجاد کند، زیرا این تصمیمی است که فقط باید بر آنها تأثیر بگذارد. البته، این تنوع نیاز به تعدیل دارد، زیرا برخی از تصمیمات، درجه‌ای از ثبات را در اطراف خود تضمین می‌کنند. به عنوان مثال، اگر بقیه افراد از <strong>APIs</strong> مبتنی بر <strong>REST-over-HTTP</strong> برای <strong>microservice endpoints</strong> خود استفاده می‌کنند، اما شما تصمیم می‌گیرید از <strong>GRPC</strong> استفاده کنید، ممکن است برای افراد دیگری که می‌خواهند از <strong>microservice</strong> شما استفاده کنند، مشکلاتی ایجاد کنید. از سوی دیگر، اگر آن <strong>endpoint GRPC</strong> فقط در داخل تیم شما استفاده می‌شد، این ممکن است مشکل‌ساز نباشد. بنابراین هنگام تصمیم‌گیری در سطح محلی که بر تیم‌های دیگر تأثیر می‌گذارد، ممکن است همچنان به هماهنگی نیاز باشد. مشخص کردن زمان و نحوه درگیر کردن یک سازمان گسترده‌تر، چیزی است که ما به زودی هنگام نگاه به تعادل بهینه‌سازی محلی در مقابل جهانی بررسی خواهیم کرد.</p>
<p>اساساً، هرچه مدل مالکیت قوی‌تری را یک تیم بتواند اتخاذ کند، هماهنگی کمتری مورد نیاز است، و بنابراین تیم می‌تواند مولدتر باشد.</p>
<p>مالکیت قوی تا چه حد پیش می‌رود؟</p>
<p>تا این مرحله، ما عمدتاً در مورد جنبه‌هایی مانند ایجاد تغییرات در کد یا انتخاب فناوری صحبت کرده‌ایم. اما مفهوم مالکیت می‌تواند بسیار عمیق‌تر شود. برخی از سازمان‌ها مدلی را اتخاذ می‌کنند که من آن را مالکیت کامل چرخه حیات می‌نامم. با مالکیت کامل چرخه حیات، یک تیم واحد طرح را ارائه می‌دهد، تغییرات را ایجاد می‌کند، <strong>microservice</strong> را مستقر می‌کند، آن را در تولید مدیریت می‌کند، و در نهایت <strong>microservice</strong> را زمانی که دیگر مورد نیاز نیست، از رده خارج می‌کند.</p>
<p>این مدل مالکیت کامل چرخه حیات، خودمختاری تیم را بیشتر افزایش می‌دهد، زیرا الزامات هماهنگی خارجی کاهش می‌یابد. بلیط‌ها با</p>
<p>500 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0526</div>
            </div>
        </div>
        <!-- Page 0527 -->
        <div class="chapter" id="page-0527">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مالکیت قوی (ادامه)</h4>
<p>تیم‌های عملیاتی برای استقرار چیزها، هیچ شخص ثالثی تغییرات را تأیید نمی‌کند، و تیم تصمیم می‌گیرد چه تغییراتی باید ایجاد شود و چه زمانی باید ارسال شود.</p>
<p>برای بسیاری از شما، چنین مدلی ممکن است خیالی باشد، زیرا شما در حال حاضر تعدادی روش موجود در مورد نحوه انجام کارها دارید. همچنین ممکن است مهارت‌های مناسبی در تیم برای پذیرش مالکیت کامل نداشته باشید، یا ممکن است به ابزارهای جدیدی (به عنوان مثال، مکانیسم‌های استقرار خودکار) نیاز داشته باشید. البته، لازم به ذکر است که شما یک شبه به مالکیت کامل چرخه حیات نمی‌رسید، حتی اگر آن را به عنوان یک هدف آرمانی در نظر بگیرید. تعجب نکنید اگر این تغییر برای پذیرش کامل سال‌ها طول بکشد، به‌ویژه با یک سازمان بزرگتر. بسیاری از جنبه‌های مالکیت کامل چرخه حیات می‌تواند مستلزم تغییرات فرهنگی و تعدیل‌های قابل توجهی از نظر انتظارات شما از برخی از افراد شما باشد، مانند نیاز به پشتیبانی از <strong>software</strong> آنها خارج از ساعات اداری. اما هرچه مسئولیت بیشتری برای جنبه‌های <strong>microservice</strong> خود در تیم خود قرار دهید، خودمختاری شما را بیشتر خواهید کرد.</p>
<p>من نمی‌خواهم بگویم که این مدل به هیچ وجه برای استفاده از <strong>microservices</strong> ضروری است—من قویاً معتقدم که مالکیت قوی برای سازمان‌های چند تیمی، منطقی‌ترین مدل برای استفاده حداکثری از <strong>microservices</strong> است. یک مدل مالکیت قوی در مورد تغییرات کد یک مکان خوب برای شروع است—شما می‌توانید برای حرکت به سمت مالکیت کامل چرخه حیات در طول زمان تلاش کنید.</p>
<h4>مالکیت جمعی</h4>
<p>با یک مدل مالکیت جمعی، یک <strong>microservice</strong> می‌تواند توسط هر یک از تعدادی از تیم‌ها تغییر داده شود. یکی از مزایای اصلی مالکیت جمعی این است که شما می‌توانید افراد را به جایی که نیاز دارند، منتقل کنید. این می‌تواند مفید باشد اگر گلوگاه شما از نظر تحویل، ناشی از کمبود افراد باشد. به عنوان مثال، چندین تغییر نیاز به ایجاد برخی به‌روزرسانی‌ها در <strong>microservice</strong> پرداخت برای اجازه دادن به صدور صورتحساب ماهانه خودکار دارد—شما می‌توانید به سادگی افراد اضافی را برای پیاده‌سازی این تغییر اختصاص دهید. البته، پرتاب کردن افراد به یک مشکل همیشه باعث نمی‌شود که شما سریع‌تر حرکت کنید، اما با مالکیت جمعی، شما قطعاً در این زمینه انعطاف‌پذیری بیشتری دارید.</p>
<p>با حرکت تیم‌ها—و افراد—از یک <strong>microservice</strong> به <strong>microservice</strong>، ما به درجه بالاتری از ثبات در مورد نحوه انجام کارها نیاز داریم. شما نمی‌توانید مجموعه‌ای وسیع از انتخاب‌های فناوری یا انواع مختلف مدل‌های استقرار را داشته باشید، اگر انتظار دارید یک توسعه‌دهنده هر هفته روی یک <strong>microservice</strong> متفاوت کار کند. برای به دست آوردن هر درجه‌ای از اثربخشی از یک مدل مالکیت جمعی با <strong>microservices</strong>، شما در نهایت نیاز خواهید داشت که اطمینان حاصل کنید که کار بر روی یک <strong>microservice</strong> تقریباً مشابه کار روی هر <strong>microservice</strong> دیگری است.</p>
<p>ذاتاً، این امر می‌تواند یکی از مزایای اصلی <strong>microservices</strong> را تضعیف کند. بازگشت به نقل قولی که در ابتدای کتاب از آن استفاده کردیم، <em>James Lewis</em> گفته است که "<strong>microservices</strong> به شما گزینه‌هایی را می‌فروشند." با یک مدل مالکیت جمعی‌تر، شما احتمالاً نیاز خواهید داشت که گزینه‌ها را کاهش دهید تا درجه ثبات بیشتری را در آنچه تیم‌ها انجام می‌دهند و نحوه پیاده‌سازی <strong>microservices</strong>، معرفی کنید.</p>
<p>مالکیت قوی در مقابل مالکیت جمعی | 501</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0527</div>
            </div>
        </div>
        <!-- Page 0528 -->
        <div class="chapter" id="page-0528">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مالکیت قوی در مقابل مالکیت جمعی (ادامه)</h4>
<p>مالکیت جمعی نیازمند درجه بالایی از هماهنگی در میان افراد و در میان تیم‌هایی است که آن افراد در آن قرار دارند. این درجه بالاتر از هماهنگی منجر به افزایش درجه <strong>coupling</strong> در سطح سازمانی می‌شود. با بازگشت به مقاله <em>MacCormack</em> و همکارانش، که در ابتدای این فصل به آن اشاره شد، ما این مشاهده را داریم:</p>
<p>در سازمان‌های <strong>tightly-coupled</strong>...حتی اگر یک انتخاب مدیریتی صریح نباشد، طراحی به طور طبیعی به <strong>tightly-coupled</strong> تبدیل می‌شود.</p>
<p>هماهنگی بیشتر می‌تواند منجر به <strong>coupling</strong> سازمانی بیشتر شود که به نوبه خود منجر به طرح‌های سیستم <strong>coupled</strong>تر می‌شود. <strong>Microservices</strong> زمانی بهترین عملکرد را دارند که بتوانند به طور کامل مفهوم استقرار مستقل را در آغوش بگیرند—و یک معماری <strong>tightly coupled</strong> مخالف چیزی است که شما می‌خواهید.</p>
<p>اگر شما تعداد کمی توسعه‌دهنده، و شاید فقط یک تیم واحد دارید، یک مدل مالکیت جمعی ممکن است کاملاً خوب باشد. اما با افزایش تعداد توسعه‌دهندگان، هماهنگی ظریف مورد نیاز برای ایجاد مالکیت جمعی، در نهایت به یک عامل منفی قابل توجه از نظر دریافت مزایای اتخاذ معماری <strong>microservice</strong> تبدیل می‌شود.</p>
<h4>در سطح تیم در مقابل سطح سازمانی</h4>
<p>مفاهیم مالکیت قوی و جمعی را می‌توان در سطوح مختلف یک سازمان اعمال کرد. در داخل یک تیم، شما می‌خواهید که افراد در یک صفحه باشند، بتوانند به طور مؤثر با یکدیگر همکاری کنند، و شما می‌خواهید در نتیجه درجه بالایی از مالکیت جمعی را تضمین کنید. به عنوان مثال، این امر از نظر اینکه همه اعضای یک تیم قادر به ایجاد تغییرات مستقیم در کدبیس هستند، خود را نشان می‌دهد. یک تیم چند مهارتی که بر ارائه <strong>end-to-end</strong> <strong>software</strong> <em>customer-facing</em> متمرکز شده است، باید در داشتن مالکیت جمعی بسیار خوب باشد. در سطح سازمانی، اگر شما می‌خواهید تیم‌ها درجه بالایی از خودمختاری داشته باشند، مهم است که آنها همچنین یک مدل مالکیت قوی داشته باشند.</p>
<h4>مدل‌های متعادل‌کننده</h4>
<p>در نهایت، هرچه بیشتر به سمت مالکیت جمعی تمایل داشته باشید، حفظ ثبات در نحوه انجام کارها مهم‌تر می‌شود. هرچه سازمان شما به سمت مالکیت قوی‌تر گرایش داشته باشد، شما می‌توانید بهینه‌سازی محلی را بیشتر مجاز کنید، همانطور که در شکل 15-1 می‌بینیم. این تعادل نیازی به ثابت بودن ندارد—شما احتمالاً این را در زمان‌های مختلف و در اطراف عوامل مختلف تغییر خواهید داد. به عنوان مثال، ممکن است به تیم‌ها آزادی کامل در انتخاب یک زبان برنامه‌نویسی بدهید اما همچنان از آنها بخواهید که بر روی همان پلتفرم <strong>cloud</strong> استقرار یابند.</p>
<p>502 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0528</div>
            </div>
        </div>
        <!-- Page 0529 -->
        <div class="chapter" id="page-0529">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مدل‌های متعادل‌کننده (ادامه)</h4>
<p>شکل 15-1. تعادل بین ثبات جهانی و بهینه‌سازی محلی</p>
<p>اساساً، با یک مدل مالکیت جمعی، شما تقریباً همیشه به سمت انتهای سمت چپ این طیف مجبور می‌شوید—یعنی به سمت نیاز به درجه بالاتری از ثبات جهانی. طبق تجربه من، سازمان‌هایی که بیشترین بهره را از <strong>microservices</strong> می‌برند، دائماً در تلاشند راه‌هایی برای تغییر تعادل به سمت راست پیدا کنند. با این حال، برای بهترین سازمان‌ها، این چیزی نیست که در سنگ حک شده باشد، بلکه چیزی است که به طور مداوم در حال ارزیابی است.</p>
<p>واقعیت این است که شما نمی‌توانید هیچ نوع تعادلی را انجام دهید مگر اینکه تا حدی از آنچه در سراسر سازمان شما در حال انجام است، آگاه باشید. حتی اگر مسئولیت زیادی را به خود تیم‌ها بسپارید، هنوز هم می‌تواند ارزشی در داشتن یک عملکرد در سازمان تحویل شما وجود داشته باشد که بتواند این عمل متعادل‌کننده را انجام دهد.</p>
<h4>تیم‌های فعال‌کننده</h4>
<p>ما آخرین بار به تیم‌های فعال‌کننده در "به اشتراک‌گذاری متخصصان" در صفحه 460 در زمینه رابط‌های کاربری نگاه کردیم، اما آنها کاربردهای گسترده‌تری نسبت به آن دارند. همانطور که در <em>Team Topologies</em> توضیح داده شد، اینها تیم‌هایی هستند که برای حمایت از تیم‌های <strong>stream-aligned</strong> ما کار می‌کنند.
   هر جا که تیم‌های <strong>stream-aligned</strong> ما که مالک <strong>microservice</strong> هستند و بر <strong>end-to-end</strong> متمرکز شده‌اند، روی ارائه عملکرد <em>user-facing</em> تمرکز می‌کنند، برای انجام کار خود به کمک دیگران نیاز دارند. هنگام بحث در مورد رابط کاربری، ما در مورد ایده داشتن یک تیم فعال‌کننده صحبت کردیم که می‌تواند به تیم‌های دیگر در ایجاد تجربیات کاربری مؤثر و ثابت کمک کند. همانطور که در شکل 15-2 نشان داده شده است، ما می‌توانیم این را به عنوان تیم‌های فعال‌کننده در نظر بگیریم که برای پشتیبانی از چندین تیم <strong>stream-aligned</strong> در برخی از جنبه‌های <em>cross-cutting</em> کار می‌کنند.</p>
<p>تیم‌های فعال‌کننده | 503</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 529" src="page_0529/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0529</div>
            </div>
        </div>
        <!-- Page 0530 -->
        <div class="chapter" id="page-0530">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تیم‌های فعال‌کننده (ادامه)</h4>
<p>شکل 15-2. تیم‌های فعال‌کننده، از تیم‌های <strong>stream-aligned</strong> متعدد پشتیبانی می‌کنند</p>
<p>اما تیم‌های فعال‌کننده می‌توانند شکل‌ها و اندازه‌های مختلفی داشته باشند.</p>
<p>شکل 15-3 را در نظر بگیرید. هر تیم تصمیم گرفته است که یک زبان برنامه‌نویسی متفاوت را انتخاب کند. وقتی این تصمیمات را به صورت مجزا بررسی می‌کنیم، به نظر می‌رسد که هر یک از این تصمیمات منطقی هستند—هر تیم زبان برنامه‌نویسی را انتخاب کرده است که از آن راضی است. اما در مورد سازمان به عنوان یک کل چطور؟ آیا شما می‌خواهید مجبور باشید از چندین زبان برنامه‌نویسی مختلف در سازمان خود پشتیبانی کنید؟ از این منظر، این امر چگونه کار بین تیم‌ها را پیچیده می‌کند و چگونه بر استخدام تأثیر می‌گذارد؟</p>
<p>شما ممکن است تصمیم بگیرید که در واقع این بهینه‌سازی محلی را نمی‌خواهید—اما شما باید از این انتخاب‌های مختلف آگاه باشید و توانایی بحث در مورد این تغییرات را داشته باشید، اگر درجه‌ای از کنترل را می‌خواهید. این معمولاً جایی است که من یک گروه پشتیبانی بسیار کوچک را می‌بینم که در سراسر تیم‌ها کار می‌کند تا به برقراری ارتباط افراد کمک کند تا این بحث‌ها به درستی انجام شوند.</p>
<p>من می‌توانم جای آشکاری را برای استقرار معماران، حداقل برای بخشی از زمان‌شان، در این گروه‌های پشتیبانی <em>cross-cutting</em> ببینم. یک معمار قدیمی به مردم می‌گفت که چه کاری انجام دهند. در سازمان جدید، مدرن و غیرمتمرکز، معماران در حال بررسی چشم‌انداز هستند، روندها را شناسایی می‌کنند، به برقراری ارتباط مردم کمک می‌کنند و به عنوان یک <em>sounding board</em> برای کمک به تیم‌های دیگر در انجام کارها عمل می‌کنند. آنها در این جهان یک واحد کنترل نیستند. آنها یک عملکرد فعال‌کننده دیگر هستند (اغلب با یک نام جدید—من اصطلاحاتی مانند مهندس اصلی را برای افرادی که نقش کسی را بازی می‌کنند که من معمار در نظر می‌گیرم، دیده‌ام). ما نقش معماران را در فصل 16 بیشتر بررسی خواهیم کرد.</p>
<p>504 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 530" src="page_0530/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0530</div>
            </div>
        </div>
        <!-- Page 0531 -->
        <div class="chapter" id="page-0531">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تیم‌های فعال‌کننده (ادامه)</h4>
<p>شکل 15-3. هر تیم یک زبان برنامه‌نویسی متفاوت را انتخاب کرده است</p>
<p>یک تیم فعال‌کننده می‌تواند به شناسایی مشکلاتی کمک کند که بهتر است در خارج از تیم‌ها برطرف شوند. یک سناریو را در نظر بگیرید که در آن هر تیم، ایجاد پایگاه داده‌ها را با داده‌های آزمایشی در آنها دشوار می‌دانست. هر تیم با این مشکل به روش‌های مختلفی کنار آمده بود، اما این موضوع هرگز به اندازه کافی برای هیچ تیمی مهم نبود که آن را به درستی برطرف کند.
   اما سپس ما به چندین تیم نگاه می‌کنیم و متوجه می‌شویم که بسیاری از آنها ممکن است از یک راه‌حل مناسب برای این مشکل بهره‌مند شوند، و ناگهان مشخص می‌شود که باید به آن رسیدگی شود.</p>
<h4>جوامع عمل</h4>
<p>یک <em>community of practice</em> (<em>CoP</em>) یک گروه <em>cross-cutting</em> است که به اشتراک‌گذاری و یادگیری بین همتایان کمک می‌کند. وقتی این کار به خوبی انجام شود، جوامع عمل یک راه فوق‌العاده برای ایجاد سازمانی هستند که در آن افراد قادر به یادگیری و رشد مداوم هستند. در کتاب عالی خود در این زمینه، <em>Building Successful Communities of Practice</em>،11 <em>Emily Webber</em> می‌نویسد:</p>
<p>جوامع عمل، محیط مناسبی را برای یادگیری اجتماعی، یادگیری تجربی و یک برنامه درسی گرد هم می‌آورند، که منجر به یادگیری تسریع شده برای اعضا می‌شود... این می‌تواند یک فرهنگ یادگیری را تشویق کند که در آن افراد به دنبال راه‌های بهتری برای انجام کارها هستند، نه فقط استفاده از مدل‌های موجود.</p>
<p>تیم‌های فعال‌کننده | 505</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 531" src="page_0531/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0531</div>
            </div>
        </div>
        <!-- Page 0532 -->
        <div class="chapter" id="page-0532">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تیم‌های فعال‌کننده (ادامه)</h4>
<p>11 <em>Emily Webber</em>, <em>Building Successful Communities of Practice</em> (<em>San Francisco</em>: <em>Blurb</em>, 2016).</p>
<p>12 <em>Paul Ingles</em>, “Convergence to Kubernetes,” <em>Medium</em>, June 18, 2018, <a href="https://oreil.ly/Ho7kY">https://oreil.ly/Ho7kY</a>.</p>
<p>اکنون، من معتقدم که در برخی موارد، همان گروه می‌تواند هم یک <em>CoP</em> و هم یک تیم فعال‌کننده باشد، اما طبق تجربه خودم این نادر است. اگرچه همپوشانی مشخصی وجود دارد.
   هم تیم‌های فعال‌کننده و هم جوامع عمل، به شما این امکان را می‌دهند که در مورد آنچه در تیم‌های مختلف در سراسر سازمان شما اتفاق می‌افتد، بینش پیدا کنید. این بینش می‌تواند به شما کمک کند تا درک کنید که آیا نیاز دارید بهینه‌سازی جهانی در مقابل محلی خود را دوباره متعادل کنید، یا به شما کمک کند تا نیاز به کمک مرکزی‌تری را شناسایی کنید، اما شکاف در اینجا در مسئولیت‌ها و قابلیت‌های گروه است.</p>
<p>اعضای یک تیم فعال‌کننده اغلب به عنوان بخشی از تیم به صورت تمام وقت کار می‌کنند، یا زمان قابل توجهی از زمان خود را برای این منظور اختصاص داده‌اند. به این ترتیب، آنها پهنای باند بیشتری برای عملی کردن تغییرات دارند—برای اینکه واقعاً با تیم‌های دیگر کار کنند و به آنها کمک کنند. جوامع عمل بیشتر بر توانمندسازی یادگیری متمرکز هستند—افراد در این گروه اغلب حداکثر چند ساعت در هفته در یک انجمن شرکت می‌کنند، و عضویت در چنین گروهی اغلب سیال است.</p>
<p>البته، <em>CoPs</em> و تیم‌های فعال‌کننده می‌توانند با هم بسیار مؤثر کار کنند. اغلب، یک <em>CoP</em> می‌تواند بینش‌های ارزشمندی را ارائه دهد که می‌تواند به یک تیم فعال‌کننده کمک کند تا درک بهتری از آنچه مورد نیاز است، داشته باشد. یک <em>Kubernetes CoP</em> را در نظر بگیرید که تجربه خود را در مورد اینکه چگونه کار کردن در خوشه توسعه شرکتش با تیم پلتفرم که خوشه را مدیریت می‌کند، چقدر دردناک بوده است، به اشتراک می‌گذارد. در مورد تیم‌های پلتفرم، این موضوع ارزش دارد که با جزئیات بیشتری به آن نگاه کنیم.</p>
<h4>پلتفرم</h4>
<p>برای بازگشت به تیم‌های <strong>loosely coupled</strong> و <strong>stream-aligned</strong> ما، ما از آنها انتظار داریم که آزمایش‌های خود را در محیط‌های ایزوله انجام دهند، استقرارها را به گونه‌ای مدیریت کنند که بتوانند در طول روز انجام شوند، و در صورت نیاز تغییراتی در معماری سیستم خود ایجاد کنند. به نظر می‌رسد که همه اینها مسئولیت و کار بیشتری را به این تیم‌ها تحمیل می‌کند. تیم‌های فعال‌کننده به عنوان یک مفهوم کلی می‌توانند در اینجا کمک کنند، اما در نهایت تیم‌های <strong>stream-aligned</strong> به مجموعه‌ای از ابزارهای <em>self-service</em> نیاز دارند که به آنها اجازه می‌دهد کار خود را انجام دهند—این پلتفرم است.</p>
<p>در واقع، بدون یک پلتفرم، ممکن است تغییر سازمان برای شما دشوار باشد. در مقاله خود با عنوان "<em>Convergence to Kubernetes</em>"،12 <em>Paul Ingles</em>، <em>CTO</em> <em>RVU</em>، تجربه وب‌سایت مقایسه قیمت <em>Uswitch</em> را به اشتراک می‌گذارد که از استفاده مستقیم از سرویس‌های سطح پایین <em>AWS</em> به سمت یک پلتفرم انتزاعی‌تر مبتنی بر <em>Kubernetes</em> حرکت کرده است.
   ایده این بود که این پلتفرم به تیم‌های <strong>stream-aligned</strong> <em>RVU</em> اجازه می‌دهد تا بیشتر بر ارائه ویژگی‌های جدید تمرکز کنند و زمان کمتری را صرف مدیریت زیرساخت‌ها کنند. همانطور که <em>Paul</em> می‌گوید:</p>
<p>ما سازمان خود را تغییر ندادیم زیرا می‌خواستیم از <em>Kubernetes</em> استفاده کنیم. ما از <em>Kubernetes</em> استفاده کردیم، زیرا می‌خواستیم سازمان خود را تغییر دهیم.</p>
<p>506 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0532</div>
            </div>
        </div>
        <!-- Page 0533 -->
        <div class="chapter" id="page-0533">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>پلتفرم</h4>
<p>یک پلتفرم که می‌تواند عملکرد مشترک را پیاده‌سازی کند، مانند توانایی مدیریت وضعیت دلخواه برای <strong>microservices</strong>، تجمیع <em>log</em>، و <strong>authorization</strong> و <strong>authentication</strong> بین <strong>microservice</strong>ها، می‌تواند پیشرفت‌های عظیمی در بهره‌وری ایجاد کند و تیم‌ها را قادر می‌سازد تا مسئولیت بیشتری را بر عهده بگیرند، بدون اینکه مجبور شوند میزان کارهای خود را به شدت افزایش دهند. در واقع، یک پلتفرم باید به تیم‌ها پهنای باند بیشتری بدهد تا روی ارائه ویژگی‌ها تمرکز کنند.</p>
<h4>تیم پلتفرم</h4>
<p>یک پلتفرم به کسی نیاز دارد که آن را اجرا و مدیریت کند. این <em>technology stacks</em> می‌توانند به اندازه کافی پیچیده باشند تا مستلزم مقداری تخصص خاص شوند. با این حال، نگرانی من این است که گاهی اوقات برای تیم‌های پلتفرم آسان است که هدف وجود خود را از دست بدهند.</p>
<p>یک تیم پلتفرم، به همان روشی که هر تیم دیگری، کاربران دارد. اگر شما در یک تیم پلتفرم هستید، کار شما این است که زندگی آنها را آسان‌تر کنید (البته این کار هر تیم فعال‌کننده است). این بدان معناست که پلتفرمی که شما ایجاد می‌کنید باید با نیازهای تیم‌هایی که از آن استفاده می‌کنند، مطابقت داشته باشد. همچنین به این معنی است که شما باید با تیم‌هایی که از پلتفرم شما استفاده می‌کنند کار کنید، نه تنها برای کمک به آنها در استفاده خوب از آن، بلکه برای دریافت بازخورد و الزامات آنها برای بهبود پلتفرمی که ارائه می‌کنید.
   در گذشته، من ترجیح می‌دادم چنین تیمی را چیزی مانند "خدمات تحویل" یا "پشتیبانی تحویل" بنامم تا هدف آن را بهتر بیان کنم. در واقع، کار یک تیم پلتفرم ساختن یک پلتفرم نیست. این است که توسعه و ارسال عملکرد را آسان کنیم. ساختن یک پلتفرم فقط یک راه است که اعضای یک تیم پلتفرم می‌توانند به این هدف برسند. من نگرانم که آنها با نامیدن خود به عنوان یک تیم پلتفرم، همه مشکلات را به عنوان چیزهایی ببینند که می‌توانند و باید توسط پلتفرم حل شوند، به جای اینکه به راه‌های گسترده‌تری در مورد راه‌های دیگر برای آسان‌تر کردن زندگی توسعه‌دهندگان فکر کنند.</p>
<p>مانند هر تیم فعال‌کننده خوب، یک تیم پلتفرم باید تقریباً تا حدودی مانند یک مشاوره داخلی عمل کند. اگر شما در یک تیم پلتفرم هستید، باید به دنبال مشکلاتی باشید که مردم با آن مواجه هستند و با آنها کار کنید تا به آنها در رفع این مشکلات کمک کنید. اما از آنجایی که شما در نهایت پلتفرم را نیز می‌سازید، باید مقدار زیادی کار توسعه محصول را نیز در آنجا داشته باشید. در واقع، اتخاذ یک رویکرد توسعه محصول برای نحوه ساختن پلتفرم خود یک ایده عالی است و می‌تواند مکان بسیار خوبی برای کمک به رشد مالکان محصول جدید باشد.</p>
<h4>جاده آسفالت شده</h4>
<p>مفهومی که در توسعه <strong>software</strong> رایج شده است، مفهوم "جاده آسفالت شده" است. ایده این است که شما به وضوح نحوه انجام کارها را منتقل می‌کنید و سپس مکانیسم‌هایی را ارائه می‌دهید که از طریق آنها این کارها را می‌توان به راحتی انجام داد. به عنوان مثال، ممکن است بخواهید اطمینان حاصل کنید که همه <strong>microservices</strong> از طریق <em>mutual TLS</em> ارتباط برقرار می‌کنند. سپس می‌توانید این را با ارائه یک فریم‌ورک یا پلتفرم استقرار مشترک پشتیبان‌گیری کنید که</p>
<p>تیم‌های فعال‌کننده | 507</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0533</div>
            </div>
        </div>
        <!-- Page 0534 -->
        <div class="chapter" id="page-0534">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تیم‌های فعال‌کننده (ادامه)</h4>
<p>13 “Organizational Evolution for Accelerating Delivery of Comparison Services at Uswitch,” <em>Team Topologies</em>, June 24, 2020, <a href="https://oreil.ly/zoyvv">https://oreil.ly/zoyvv</a>.</p>
<p>به‌طور خودکار <em>mutual TLS</em> را برای <strong>microservices</strong> که بر روی آن اجرا می‌شوند، ارائه می‌دهد. یک پلتفرم می‌تواند یک راه عالی برای ارائه در آن جاده آسفالت شده باشد.</p>
<p>مفهوم اصلی در پشت یک جاده آسفالت شده این است که استفاده از جاده آسفالت شده اجباری نیست—فقط یک راه آسان‌تر برای رسیدن به مقصد شما فراهم می‌کند. بنابراین اگر یک تیم می‌خواست اطمینان حاصل کند که <strong>microservices</strong> آن از طریق <em>mutual TLS</em> ارتباط برقرار می‌کنند بدون استفاده از فریم‌ورک مشترک، باید راه دیگری برای انجام این کار پیدا می‌کرد، اما همچنان مجاز بود. تشبیه در اینجا این است که در حالی که ما ممکن است بخواهیم همه به یک مقصد برسند، مردم آزاد هستند که مسیرهای خود را در آنجا پیدا کنند—امید این است که جاده آسفالت شده آسان‌ترین راه برای رسیدن به جایی است که نیاز دارید.</p>
<p>مفهوم جاده آسفالت شده با هدف آسان کردن موارد رایج، در عین حال، فضایی را برای استثنائات در صورت لزوم باقی می‌گذارد.</p>
<p>اگر ما به پلتفرم به عنوان یک جاده آسفالت شده فکر کنیم، با اختیاری کردن آن، شما تیم پلتفرم را تشویق می‌کنید تا پلتفرم را آسان‌تر کند. در اینجا دوباره <em>Paul Ingles</em>، در مورد اندازه‌گیری اثربخشی تیم پلتفرم:</p>
<p>ما [اهداف و نتایج کلیدی (<em>OKRs</em>)] را در مورد تعداد تیم‌هایی که می‌خواهیم پلتفرم را اتخاذ کنند، تعداد برنامه‌هایی که از سرویس <strong>autoscaling</strong> پلتفرم استفاده می‌کنند، نسبت برنامه‌هایی که به سرویس اعتبارات پویا پلتفرم تغییر یافته‌اند، و غیره تعیین خواهیم کرد. برخی از اینها را در دوره‌های زمانی طولانی‌تری پیگیری می‌کنیم، و بقیه برای هدایت پیشرفت برای یک فصل مفید بودند و سپس آنها را به نفع چیز دیگری رها می‌کردیم.
   ما هرگز استفاده از پلتفرم را اجباری نکردیم، بنابراین تنظیم نتایج کلیدی برای تعداد تیم‌های <em>onboarded</em> ما را مجبور می‌کرد که بر حل مشکلاتی تمرکز کنیم که باعث پذیرش می‌شوند.
   ما همچنین به دنبال معیارهای طبیعی پیشرفت هستیم: نسبت ترافیک ارائه شده توسط پلتفرم، و نسبت درآمد ارائه شده از طریق خدمات پلتفرم، هر دو نمونه خوبی از این موضوع هستند.</p>
<p>وقتی شما موانعی را در مسیر افراد قرار می‌دهید که خودسرانه و خودخواهانه به نظر می‌رسند، آن افراد راه‌هایی برای دور زدن موانع برای انجام کار پیدا می‌کنند. بنابراین به طور کلی، من بسیار مؤثرتر می‌دانم که توضیح دهم چرا باید کارها را به روشی خاص انجام داد، و سپس انجام کارها را به آن روش آسان کنید، تا اینکه سعی کنید کارهایی را که دوست ندارید غیرممکن کنید.</p>
<p>تغییر به سمت تیم‌های <strong>stream-aligned</strong> خودمختارتر، نیاز به داشتن یک چشم‌انداز فنی روشن یا روشن بودن در مورد موارد خاصی که همه تیم‌ها ملزم به انجام آنها هستند را از بین نمی‌برد. اگر محدودیت‌های مشخصی وجود داشته باشد (به عنوان مثال، نیاز به <em>cloud-vendor agnostic</em> بودن) یا الزامات خاصی که همه تیم‌ها باید از آن اطاعت کنند (همه <em>PII</em> باید در حالت استراحت با استفاده از الگوریتم‌های خاص رمزگذاری شوند)، پس همچنان باید آنها را به وضوح منتقل کرد، و دلایل آنها را مشخص کرد. سپس پلتفرم می‌تواند نقشی در آسان‌تر کردن این کارها ایفا کند. با استفاده از پلتفرم، شما در</p>
<p>پلتفرم | 508 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0534</div>
            </div>
        </div>
        <!-- Page 0535 -->
        <div class="chapter" id="page-0535">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>پلتفرم (ادامه)</h4>
<p>جاده آسفالت شده—شما در نهایت کارهای درست زیادی را بدون صرف تلاش زیاد انجام خواهید داد.</p>
<p>از سوی دیگر، من می‌بینم که برخی از سازمان‌ها سعی می‌کنند از طریق پلتفرم حکومت کنند. به جای اینکه به وضوح بیان کنند که چه چیزی باید انجام شود و چرا، در عوض آنها به سادگی می‌گویند "شما باید از این پلتفرم استفاده کنید." مشکل این است که اگر پلتفرم آسان نباشد یا برای یک مورد استفاده خاص مناسب نباشد، افراد راه‌هایی برای دور زدن خود پلتفرم پیدا می‌کنند. هنگامی که تیم‌ها در خارج از پلتفرم کار می‌کنند، هیچ حس روشنی از اینکه چه محدودیت‌هایی برای سازمان مهم است، ندارند و خود را در حال انجام کار "اشتباه" بدون اینکه متوجه شوند، می‌بینند.</p>
<h4><strong>Microservices</strong> مشترک</h4>
<p>همانطور که قبلاً بحث کردم، من طرفدار سرسخت مدل‌های مالکیت قوی برای <strong>microservices</strong> هستم. به طور کلی، یک <strong>microservice</strong> باید متعلق به یک تیم واحد باشد. با وجود این، من هنوز متوجه می‌شوم که <strong>microservices</strong> توسط چندین تیم به اشتراک گذاشته می‌شوند. چرا اینطور است؟ و شما چه کاری می‌توانید (یا باید) در این مورد انجام دهید؟ محرک‌هایی که باعث می‌شوند مردم <strong>microservices</strong> را به اشتراک بگذارند، مهم هستند، به‌ویژه از آنجایی که ممکن است بتوانیم برخی از مدل‌های جایگزین قانع‌کننده را پیدا کنیم که می‌توانند به نگرانی‌های اساسی مردم رسیدگی کنند.</p>
<h4>تقسیم کردن بیش از حد دشوار است</h4>
<p>بدیهی است، یکی از دلایلی که ممکن است خود را با یک <strong>microservice</strong> که بیش از یک تیم مالک آن است، مواجه کنید، این است که هزینه تقسیم <strong>microservice</strong> به قطعاتی که می‌توانند توسط تیم‌های مختلف مالک شوند، بسیار بالا است، یا شاید سازمان شما نقطه آن را نبیند. این یک اتفاق رایج در سیستم‌های بزرگ و <strong>monolithic</strong> است. اگر این چالش اصلی است که با آن روبرو هستید، امیدوارم که برخی از توصیه‌های ارائه شده در فصل 3 مفید باشد. شما همچنین می‌توانید ادغام تیم‌ها را برای همسویی بیشتر با خود معماری در نظر بگیرید.</p>
<p><em>FinanceCo</em>، یک شرکت <em>FinTech</em> که قبلاً در "به سمت تیم‌های <strong>Stream-Aligned</strong>" در صفحه 459 با آن آشنا شدیم، تا حد زیادی یک مدل مالکیت قوی را با درجه بالایی از خودمختاری تیم اعمال می‌کند. با این حال، هنوز یک سیستم <strong>monolithic</strong> موجود دارد که به آرامی در حال جدا شدن بود. آن برنامه <strong>monolithic</strong> برای همه مقاصد و اهداف توسط چندین تیم به اشتراک گذاشته شده بود، و هزینه افزایش یافته کار در این کدبیس مشترک، آشکار بود.</p>
<h4>تغییرات <em>Cross-Cutting</em></h4>
<p>بسیاری از آنچه ما تاکنون در این کتاب در مورد تعامل ساختار سازمانی و معماری مورد بحث قرار داده‌ایم، با هدف کاهش نیاز به هماهنگی بین تیم‌ها بوده است. بیشتر اینها در مورد تلاش برای کاهش تغییرات <em>cross-cutting</em> تا حد امکان</p>
<p><strong>Microservices</strong> مشترک | 509</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0535</div>
            </div>
        </div>
        <!-- Page 0536 -->
        <div class="chapter" id="page-0536">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>Microservices</strong> مشترک (ادامه)</h4>
<p>در حالی که ما می‌توانیم. با این حال، ما باید تشخیص دهیم که برخی از تغییرات <em>cross-cutting</em> ممکن است اجتناب‌ناپذیر باشند.</p>
<p><em>FinanceCo</em> به یک مشکل از این دست برخورد کرد. وقتی در ابتدا شروع به کار کرد، یک حساب به یک کاربر متصل بود. با رشد شرکت و جذب کاربران تجاری بیشتر (که قبلاً بیشتر بر مصرف‌کنندگان متمرکز بود)، این به یک محدودیت تبدیل شد. شرکت می‌خواست به مدلی روی بیاورد که در آن یک حساب واحد با <em>FinanceCo</em> بتواند چندین کاربر را در خود جای دهد.
   این یک تغییر اساسی بود، زیرا تا آن زمان، این فرض در سراسر سیستم این بود که یک حساب = یک کاربر.</p>
<p>یک تیم واحد برای ایجاد این تغییر تشکیل شده بود. مشکل این بود که مقدار زیادی از کار شامل ایجاد تغییرات در <strong>microservices</strong> بود که قبلاً توسط تیم‌های دیگر اداره می‌شد. این بدان معنا بود که کار تیم تا حدی در مورد ایجاد تغییرات و ارسال <em>pull requests</em>، یا درخواست از تیم‌های دیگر برای ایجاد تغییرات بود. هماهنگی این تغییرات بسیار دردناک بود، زیرا تعداد قابل توجهی از <strong>microservices</strong> نیاز به اصلاح برای پشتیبانی از عملکرد جدید داشتند.</p>
<p>با بازسازی تیم‌ها و معماری خود برای حذف یک مجموعه از تغییرات <em>cross-cutting</em>، ما ممکن است در واقع خود را در معرض مجموعه‌ای متفاوت از تغییرات <em>cross-cutting</em> قرار دهیم که ممکن است تأثیر قابل‌توجه‌تری داشته باشد. این مورد در مورد <em>FinanceCo</em> صدق می‌کرد—نوع سازماندهی مجددی که برای کاهش هزینه عملکرد چندکاربره لازم بود، هزینه ایجاد تغییرات دیگر و رایج‌تر را افزایش می‌داد. <em>FinanceCo</em> متوجه شد که این تغییر خاص بسیار دردناک خواهد بود، اما از آنجا که این نوع تغییر استثنایی بود، این درد قابل قبول بود.</p>
<h4>گلوگاه‌های تحویل</h4>
<p>یکی از دلایل اصلی که مردم به سمت مالکیت جمعی حرکت می‌کنند، با <strong>microservices</strong> که بین تیم‌ها به اشتراک گذاشته می‌شوند، اجتناب از گلوگاه‌های تحویل است. اگر یک <em>backlog</em> بزرگ از تغییراتی وجود داشته باشد که باید در یک سرویس واحد ایجاد شوند، چه؟ بیایید به MusicCorp برگردیم، و بیایید تصور کنیم که ما در حال راه‌اندازی قابلیت دیدن ژانر یک آهنگ برای مشتری در محصولات خود، و همچنین افزودن یک نوع جدید از سهام: زنگ‌های موسیقی مجازی برای تلفن همراه هستیم. تیم وب‌سایت باید تغییری ایجاد کند تا اطلاعات ژانر را نشان دهد، و تیم برنامه تلفن همراه در حال تلاش برای این است که به کاربران اجازه دهد زنگ‌ها را مرور، پیش‌نمایش و خریداری کنند. هر دو تغییر باید در <strong>microservice</strong> کاتالوگ ایجاد شوند، اما متاسفانه نیمی از تیم در حال تشخیص یک خرابی تولید هستند، و نیمه دیگر با مسمومیت غذایی پس از یک گردش اخیر تیمی به یک <em>food truck</em> در حال اجرا از یک کوچه رفته‌اند.</p>
<p>ما چند گزینه داریم که می‌توانیم برای جلوگیری از نیاز به اشتراک <strong>microservice</strong> کاتالوگ توسط تیم‌های وب‌سایت و موبایل در نظر بگیریم. اولین مورد این است که فقط صبر کنیم. تیم‌های برنامه وب‌سایت و موبایل به سراغ چیز دیگری می‌روند. بسته به میزان اهمیت ویژگی یا مدت زمان احتمالی تأخیر، این ممکن است خوب باشد، یا ممکن است یک مشکل بزرگ باشد.</p>
<p>510 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0536</div>
            </div>
        </div>
        <!-- Page 0537 -->
        <div class="chapter" id="page-0537">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>گلوگاه‌های تحویل (ادامه)</h4>
<p>شما می‌توانید به جای آن، افراد را به تیم کاتالوگ اضافه کنید تا به آنها کمک کنید تا کار خود را سریع‌تر پیش ببرند. هرچه <em>technology stack</em> و اصطلاحات برنامه‌نویسی در سراسر سیستم شما استانداردتر باشند، تغییرات توسط افراد دیگر در سرویس‌های شما آسان‌تر خواهد بود. البته، همانطور که قبلاً بحث کردیم، استانداردسازی تمایل دارد که توانایی یک تیم برای اتخاذ راه‌حل مناسب برای کار را کاهش دهد و می‌تواند منجر به انواع مختلفی از ناکارآمدی‌ها شود.</p>
<p>گزینه دیگری که نیاز به <strong>microservice</strong> کاتالوگ مشترک را از بین می‌برد، این است که کاتالوگ را به یک کاتالوگ موسیقی عمومی جداگانه و یک کاتالوگ زنگ استخراج کنید. اگر تغییری که برای پشتیبانی از زنگ‌ها ایجاد می‌شود نسبتاً کوچک باشد، و احتمال اینکه این یک منطقه باشد که ما در آینده در آن به شدت توسعه خواهیم داد نیز بسیار کم است، این ممکن است زودرس باشد. از سوی دیگر، اگر 10 هفته ویژگی‌های مرتبط با زنگ‌ها جمع شده باشد، جدا کردن سرویس می‌تواند منطقی باشد، و تیم موبایل مالکیت را بر عهده خواهد گرفت.</p>
<p>با این حال، چند مدل دیگر وجود دارد که می‌توانیم در نظر بگیریم. در لحظه‌ای، ما به آنچه که از نظر ایجاد <strong>microservice</strong> مشترک "قابل اتصال" می‌توان انجام داد، نگاه خواهیم کرد، که به تیم‌های دیگر اجازه می‌دهد کد خود را از طریق کتابخانه‌ها مشارکت کنند یا از یک فریم‌ورک مشترک توسعه دهند. اما، ابتدا، ما باید پتانسیل وارد کردن برخی از ایده‌ها را از دنیای توسعه <em>open source</em> به شرکت خود بررسی کنیم.</p>
<h4><em>Open Source</em> داخلی</h4>
<p>بسیاری از سازمان‌ها تصمیم گرفته‌اند نوعی <em>open source</em> داخلی را پیاده‌سازی کنند، هم برای کمک به مدیریت مسئله کدبیس‌های مشترک، و هم برای آسان‌تر کردن مشارکت افراد خارج از یک تیم برای ایجاد تغییرات در یک <strong>microservice</strong> که ممکن است از آن استفاده کنند.
   با <em>open source</em> معمولی، گروه کوچکی از افراد به عنوان <em>core committers</em> در نظر گرفته می‌شوند. آنها متولیان کد هستند. اگر شما یک تغییر در یک پروژه <em>open source</em> می‌خواهید، یا از یکی از <em>committers</em> می‌خواهید که تغییر را برای شما ایجاد کند یا شما خودتان تغییر را ایجاد می‌کنید و یک <em>pull request</em> برای آنها ارسال می‌کنید. <em>core committers</em> همچنان مسئول کدبیس هستند. آنها مالکان هستند.</p>
<p>در داخل یک سازمان، این الگو نیز می‌تواند به خوبی کار کند. شاید افرادی که در ابتدا روی سرویس کار می‌کردند دیگر با هم در یک تیم نباشند. شاید اکنون در سراسر سازمان پراکنده شده‌اند. اگر آنها همچنان حق <em>commit</em> دارند، شما می‌توانید آنها را پیدا کنید و از آنها کمک بخواهید، شاید با آنها جفت شوید. یا اگر <strong>tooling</strong> مناسب را دارید، می‌توانید یک <em>pull request</em> برای آنها ارسال کنید.</p>
<h4>نقش <em>Core Committers</em></h4>
<p>ما همچنان می‌خواهیم که سرویس‌های ما منطقی باشند. ما می‌خواهیم که کد از کیفیت مناسبی برخوردار باشد، و خود <strong>microservice</strong> نوعی ثبات را در نحوه کنار هم قرار گرفتن آن نشان دهد. ما همچنین می‌خواهیم اطمینان حاصل کنیم که تغییراتی که در حال حاضر ایجاد می‌شوند، تغییرات برنامه‌ریزی‌شده آینده را بسیار سخت‌تر از آنچه لازم است، نمی‌کند. این بدان معناست که ما نیاز داریم</p>
<p><em>Open Source</em> داخلی | 511</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0537</div>
            </div>
        </div>
        <!-- Page 0538 -->
        <div class="chapter" id="page-0538">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><em>Open Source</em> داخلی (ادامه)</h4>
<p>باید الگوهای مشابهی را که در <em>open source</em> معمولی استفاده می‌شود، در داخل هم اتخاذ کنید، به این معنی که جداسازی <em>committers</em> مورد اعتماد (تیم اصلی) از <em>committers</em> غیرقابل اعتماد (افراد خارج از تیم که تغییراتی را ارسال می‌کنند) ضروری است.</p>
<p>تیم مالک اصلی باید راه‌هایی برای بررسی و تأیید تغییرات داشته باشد. باید اطمینان حاصل شود که تغییرات از نظر <em>idiomatically consistent</em> هستند—یعنی، آنها دستورالعمل‌های کلی کدنویسی بقیه کدبیس را دنبال می‌کنند. بنابراین افرادی که در حال بررسی هستند باید زمان خود را صرف کار با ارسال‌کنندگان کنند تا اطمینان حاصل شود که هر تغییری از کیفیت کافی برخوردار است.</p>
<p>متصدیان دروازه خوب، تلاش زیادی در این زمینه انجام می‌دهند، با ارسال‌کنندگان ارتباط واضحی برقرار می‌کنند و رفتار خوب را تشویق می‌کنند. متصدیان دروازه بد می‌توانند از این امر به عنوان بهانه‌ای برای اعمال قدرت بر دیگران یا داشتن جنگ‌های مذهبی در مورد تصمیمات فنی خودسرانه استفاده کنند. با دیدن هر دو مجموعه از رفتارها، می‌توانم به شما یک چیز را بگویم: هر دو راه زمان‌بر است.
   هنگام در نظر گرفتن اجازه به <em>committers</em> غیرقابل اعتماد برای ارسال تغییرات به کدبیس خود، شما باید تصمیم بگیرید که آیا سربار متصدی دروازه بودن ارزش دردسر را دارد یا خیر: آیا تیم اصلی می‌تواند کارهای بهتری را با زمانی که صرف بررسی وصله‌ها می‌کند، انجام دهد؟</p>
<h4>بلوغ</h4>
<p>هرچه یک سرویس بی‌ثبات‌تر یا بالغ‌تر باشد، اجازه دادن به افراد خارج از تیم اصلی برای ارسال وصله‌ها دشوارتر خواهد بود. قبل از اینکه ستون فقرات کلیدی یک سرویس در جای خود قرار گیرد، تیم ممکن است ندانند که "خوب" چگونه به نظر می‌رسد و بنابراین ممکن است در دانستن اینکه یک ارائه خوب چگونه به نظر می‌رسد، مشکل داشته باشد. در این مرحله، خود سرویس در حال تغییر زیاد است.</p>
<p>اکثر پروژه‌های <em>open source</em> تمایل دارند که از ارسال‌ها از یک گروه گسترده‌تر از <em>committers</em> غیرقابل اعتماد استفاده نکنند تا زمانی که هسته نسخه اول تمام شود. پیروی از یک مدل مشابه برای سازمان خود منطقی است. اگر یک سرویس بسیار بالغ است و به ندرت تغییر می‌کند—به عنوان مثال، سرویس سبد خرید ما—پس شاید این زمان مناسبی برای باز کردن آن برای مشارکت‌های دیگر باشد.</p>
<h4>ابزارها</h4>
<p>برای پشتیبانی بهتر از یک مدل <em>open source</em> داخلی، شما به مقداری ابزار نیاز خواهید داشت.
   استفاده از یک ابزار کنترل نسخه توزیع‌شده با امکان ارسال درخواست‌های <em>pull</em> توسط افراد (یا چیز مشابهی) مهم است. بسته به اندازه سازمان، شما همچنین ممکن است به ابزاری برای امکان بحث و تکامل درخواست‌های وصله نیاز داشته باشید. این ممکن است به این معنی باشد یا نباشد که یک سیستم بررسی کد کامل، اما توانایی نظر دادن <em>inline</em> در مورد وصله‌ها بسیار مفید است. در نهایت، شما باید این کار را بسیار آسان کنید که یک <em>committer</em>، <strong>software</strong> شما را بسازد و مستقر کند و آن را برای دیگران در دسترس قرار دهد. معمولاً این شامل داشتن <strong>pipelines</strong> استقرار و ساخت تعریف شده و <em>repositories</em> <em>artifact</em> متمرکز است. هرچه <em>technology stack</em> شما استانداردتر باشد، ویرایش و ارائه وصله‌ها به یک <strong>microservice</strong> برای افراد در تیم‌های دیگر آسان‌تر خواهد بود.</p>
<p>512 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0538</div>
            </div>
        </div>
        <!-- Page 0539 -->
        <div class="chapter" id="page-0539">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>Microservices</strong> مدولار و قابل اتصال</h4>
<p>در <em>FinanceCo</em>، من یک چالش جالب مرتبط با یک <strong>microservice</strong> خاص را دیدم که در حال تبدیل شدن به یک گلوگاه برای بسیاری از تیم‌ها بود. برای هر کشور، <em>FinanceCo</em> تیم‌های اختصاصی داشت که بر روی عملکرد خاص آن کشور متمرکز بودند. این امر منطقی بود، زیرا هر کشور الزامات و چالش‌های خاصی داشت. اما برای این سرویس مرکزی مشکلاتی ایجاد کرد، که نیاز به به‌روزرسانی عملکردهای خاص برای هر کشور داشت. تیمی که مالک <strong>microservice</strong> مرکزی بود، با <em>pull requests</em> ارسالی به آن غرق شده بود. تیم کار فوق‌العاده‌ای در پردازش سریع این <em>pull requests</em> انجام می‌داد، و در واقع بر این موضوع متمرکز بود که این بخش اصلی از مسئولیت‌های آن است، اما از نظر ساختاری، وضعیت واقعاً پایدار نبود.</p>
<p>این نمونه‌ای است که در آن تیمی که تعداد زیادی <em>pull requests</em> دارد می‌تواند نشانه‌ای از بسیاری از مشکلات بالقوه مختلف باشد. آیا <em>pull requests</em> از تیم‌های دیگر جدی گرفته می‌شوند؟ یا آیا این <em>pull requests</em> نشانه‌ای از این است که <strong>microservice</strong> ممکن است باید مالکیت را تغییر دهد؟</p>
<p>اگر یک تیم، تعداد زیادی <em>pull requests</em> ورودی داشته باشد، می‌تواند نشانه‌ای از این باشد که
   شما واقعاً یک <strong>microservice</strong> دارید که توسط چندین تیم به اشتراک گذاشته شده است.</p>
<h4>تغییر مالکیت</h4>
<p>گاهی اوقات کاری که باید انجام دهید این است که مالکیت یک <strong>microservice</strong> را تغییر دهید. به مثال MusicCorp توجه کنید. تیم تعامل با مشتری مجبور است تعداد زیادی <em>pull requests</em> مربوط به <strong>microservice</strong> توصیه‌ها را به تیم بازاریابی و تبلیغات ارسال کند. این به این دلیل است که تعدادی از تغییرات در نحوه مدیریت اطلاعات مشتری در حال انجام است، و همچنین به این دلیل که ما نیاز داریم این توصیه‌ها را به روش‌های مختلفی ارائه دهیم.</p>
<p>در این شرایط، ممکن است منطقی باشد که تیم تعامل با مشتری، مالکیت <strong>microservice</strong> توصیه‌ها را بر عهده بگیرد. با این حال، در مثال <em>FinanceCo</em>، چنین گزینه‌ای وجود نداشت. مشکل این بود که منابع <em>pull requests</em> از تیم‌های مختلف متعددی می‌آمد. پس چه کار دیگری می‌توانست انجام شود؟</p>
<h4>اجرای انواع مختلف</h4>
<p>یک گزینه که ما بررسی کردیم این بود که هر تیم کشوری، نسخه خود را از <strong>microservice</strong> مشترک اجرا کند. بنابراین تیم ایالات متحده، نسخه خود، تیم سنگاپور نسخه خود، و غیره را اجرا می‌کند.</p>
<p>البته، مشکل این رویکرد، تکرار کد است. <strong>microservice</strong> مشترک، مجموعه‌ای از رفتارهای استاندارد و قوانین مشترک را پیاده‌سازی می‌کرد، اما همچنین می‌خواست که مقداری از این عملکرد برای هر کشور تغییر کند. ما نمی‌خواستیم که</p>
<p><strong>Microservices</strong> مدولار و قابل اتصال | 513</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 539" src="page_0539/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0539</div>
            </div>
        </div>
        <!-- Page 0540 -->
        <div class="chapter" id="page-0540">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><strong>Microservices</strong> مشترک (ادامه)</h4>
<p>عملکرد رایج را. ایده این بود که تیمی که در حال حاضر <strong>microservice</strong> مشترک را مدیریت می‌کند، در عوض یک فریم‌ورک ارائه کند، که واقعاً فقط از <strong>microservice</strong> موجود با فقط عملکرد مشترک تشکیل شده بود. هر تیم مختص کشور می‌توانست نمونه خود را از <strong>microservice</strong> اسکلت را راه‌اندازی کند، و عملکرد سفارشی خود را به آن متصل کند، همانطور که در شکل 15-4 نشان داده شده است.</p>
<p>شکل 15-4. یک فریم‌ورک مشترک می‌تواند به چندین نوع از <strong>microservice</strong> یکسان اجازه دهد تا توسط تیم‌های مختلف اداره شوند</p>
<p>نکته مهم در اینجا این است که اگرچه ما می‌توانیم عملکرد مشترک را در این مثال در سراسر هر نوع <strong>microservice</strong> خاص کشور به اشتراک بگذاریم، اما این عملکرد مشترک را نمی‌توان در همه انواع <strong>microservice</strong> در یک زمان بدون نیاز به انتشار <em>lockstep</em> در مقیاس بزرگ به‌روزرسانی کرد. تیم اصلی که فریم‌ورک را مدیریت می‌کند ممکن است یک نسخه جدید را در دسترس قرار دهد، اما این به عهده هر تیم خواهد بود که آخرین نسخه کد مشترک را وارد کند و آن را دوباره مستقر کند. در این وضعیت خاص، <em>FinanceCo</em> با این محدودیت مشکلی نداشت.</p>
<p>لازم به ذکر است که این وضعیت خاص، نسبتاً نادر بود، و چیزی بود که من فقط یک یا دو بار قبل از آن با آن روبرو شده بودم. تمرکز اولیه من بر یافتن راه‌هایی برای جدا کردن مسئولیت‌های این <strong>microservice</strong> مشترک مرکزی بود یا اینکه مالکیت را دوباره اختصاص دهم. نگرانی من این بود که ایجاد فریم‌ورک‌های داخلی می‌تواند یک فعالیت دشوار باشد. این کار بسیار آسان است که فریم‌ورک بیش از حد متورم شود یا توسعه تیم‌هایی را که از آن استفاده می‌کنند محدود کند. این نوع مشکلی است که در روز اول خود را نشان نمی‌دهد. هنگام ایجاد یک فریم‌ورک داخلی، همه چیز با بهترین نیت‌ها شروع می‌شود. اگرچه من در موقعیت <em>FinanceCo</em> احساس می‌کردم که این راه درستی است، اما من نسبت به اتخاذ این رویکرد، مگر اینکه شما سایر گزینه‌های خود را بررسی کرده باشید، هشدار می‌دهم.</p>
<h4>مشارکت خارجی از طریق کتابخانه‌ها</h4>
<p>یک تغییر در این رویکرد این است که در عوض هر تیم خاص کشور، یک کتابخانه را با عملکرد خاص کشور خود در داخل آن مشارکت دهد، و سپس</p>
<p>پلتفرم | 514 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 540" src="page_0540/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0540</div>
            </div>
        </div>
        <!-- Page 0541 -->
        <div class="chapter" id="page-0541">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><em>Open Source</em> داخلی (ادامه)</h4>
<p>این کتابخانه‌ها را در یک <strong>microservice</strong> مشترک واحد بسته‌بندی کنند، همانطور که در شکل 15-5 نشان داده شده است.</p>
<p>شکل 15-5. تیم‌ها کتابخانه‌هایی را با رفتار سفارشی خود به یک <strong>microservice</strong> مرکزی کمک می‌کنند</p>
<p>ایده در اینجا این است که اگر تیم ایالات متحده نیاز به پیاده‌سازی منطق خاص ایالات متحده داشته باشد، تغییری در یک کتابخانه ایجاد می‌کند که سپس به عنوان بخشی از ساخت <strong>microservice</strong> مرکزی گنجانده می‌شود.
   این رویکرد نیاز به اجرای <strong>microservices</strong> اضافی را کاهش می‌دهد. ما نیازی به اجرای یک سرویس در هر کشور نداریم—ما می‌توانیم یک <strong>microservice</strong> مرکزی واحد را اجرا کنیم که عملکرد سفارشی را برای هر کشور مدیریت می‌کند. چالش در اینجا این است که تیم‌های کشوری مسئول تصمیم‌گیری در مورد زمان راه‌اندازی عملکرد سفارشی خود نیستند. آنها می‌توانند تغییر را ایجاد کنند و درخواست کنند که این تغییر جدید مستقر شود، اما تیم مرکزی باید این استقرار را برنامه‌ریزی کند.
   علاوه بر این، این امکان وجود دارد که یک باگ در یکی از این کتابخانه‌های خاص کشور بتواند باعث ایجاد یک مشکل تولید شود که تیم مرکزی ممکن است مسئولیت حل آن را بر عهده داشته باشد. این می‌تواند عیب‌یابی تولید را در نتیجه پیچیده‌تر کند.</p>
<p>با این وجود، این گزینه ممکن است ارزش در نظر گرفتن را داشته باشد، اگر به شما کمک کند تا از یک <strong>microservice</strong> مرکزی تحت مالکیت جمعی دور شوید، به‌ویژه زمانی که شما نمی‌توانید اجرای انواع مختلف یک <strong>microservice</strong> یکسان را توجیه کنید.</p>
<h4>بررسی تغییرات</h4>
<p>هنگام اتخاذ یک رویکرد <em>open source</em> داخلی، مفهوم بررسی یک اصل اساسی است—تغییر باید قبل از پذیرش، بررسی شود. اما حتی زمانی که در داخل یک تیم بر روی یک کدبیس کار می‌کنید که در آن مجوزهای <em>commit</em> مستقیم دارید، همچنان ارزش دارد که تغییرات شما بررسی شود.</p>
<p>من طرفدار بزرگی برای بررسی تغییرات خود هستم. من همیشه احساس کرده‌ام که کد من از یک جفت چشم دوم سود برده است. تا حد زیادی، شکل بررسی مورد علاقه من از نوع</p>
<p><strong>Microservices</strong> مدولار و قابل اتصال | 515</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 541" src="page_0541/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0541</div>
            </div>
        </div>
        <!-- Page 0542 -->
        <div class="chapter" id="page-0542">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>بررسی تغییرات</h4>
<p>فرآیند بررسی، <strong>review</strong> فوری که به عنوان بخشی از <em>pair programming</em> دریافت می‌کنید. شما و توسعه‌دهنده دیگری کد را با هم می‌نویسید و تغییرات را با یکدیگر مورد بحث قرار می‌دهید. این قبل از اینکه شما <em>check in</em> کنید، بررسی می‌شود.</p>
<p>شما مجبور نیستید حرف من را قبول کنید. با بازگشت به <em>Accelerate</em>، کتابی که ما قبلاً چندین بار به آن ارجاع داده‌ایم:</p>
<p>ما دریافتیم که تأیید فقط برای تغییرات پرخطر با عملکرد تحویل <strong>software</strong> همبستگی ندارد. تیم‌هایی که هیچ فرآیند تأییدی را گزارش نکردند یا از بررسی همتا استفاده کردند، عملکرد تحویل <strong>software</strong> بالاتری داشتند. در نهایت، تیم‌هایی که به تأیید یک نهاد خارجی نیاز داشتند، عملکرد کمتری داشتند.</p>
<p>در اینجا ما یک تمایز بین بررسی همتا و بررسی تغییرات خارجی می‌بینیم. یک بررسی تغییر همتا توسط شخصی انجام می‌شود که به احتمال زیاد در همان تیم شما است، و روی همان کدبیس شما کار می‌کند. بدیهی است که آنها در ارزیابی اینکه چه چیزی باعث ایجاد یک تغییر خوب می‌شود، موقعیت بهتری دارند و همچنین احتمالاً بررسی را سریع‌تر انجام می‌دهند (بیشتر در این مورد به زودی). با این حال، یک بررسی خارجی همیشه با مشکلات بیشتری همراه است.
   از آنجایی که فرد خارج از تیم شما است، آنها احتمالاً تغییر را بر اساس لیستی از معیارهایی که ممکن است منطقی باشد یا نباشد، ارزیابی می‌کنند، و از آنجایی که آنها در یک تیم جداگانه هستند، ممکن است مدتی طول بکشد تا به تغییرات شما برسند. همانطور که نویسندگان <em>Accelerate</em> اشاره می‌کنند:</p>
<p>چه احتمالی وجود دارد که یک نهاد خارجی، که از داخل یک سیستم آشنایی ندارد، بتواند ده‌ها هزار خط تغییر کد را توسط صدها مهندس بالقوه بررسی کند و به درستی تأثیر آن را بر یک سیستم تولیدی پیچیده تعیین کند؟</p>
<p>بنابراین، به طور کلی، ما می‌خواهیم از بررسی‌های تغییر همتا استفاده کنیم و از نیاز به بررسی کدهای خارجی اجتناب کنیم.</p>
<h4>بررسی‌های کد همزمان در مقابل ناهمزمان</h4>
<p>با <em>pair programming</em>، بررسی کد، در لحظه‌ای که کد در حال نوشتن است، <em>inline</em> رخ می‌دهد. در واقع، این بیشتر از این است. هنگام <em>pairing</em>، شما <em>driver</em> (فرد پشت کیبورد) و <em>navigator</em> (که به عنوان یک جفت چشم دوم عمل می‌کند) را دارید. هر دو شرکت‌کننده در مورد تغییراتی که ایجاد می‌کنند، در یک گفتگوی مداوم هستند—عمل بررسی و عمل ایجاد تغییرات در یک زمان اتفاق می‌افتد. بررسی به یک جنبه ضمنی و مداوم از رابطه <em>pairing</em> تبدیل می‌شود. این بدان معناست که با مشاهده چیزها، بلافاصله آنها را اصلاح می‌کنید.</p>
<p>اگر <em>pairing</em> ندارید، حالت ایده‌آل این است که بررسی بلافاصله پس از نوشتن کد انجام شود. سپس شما دوست دارید که خود بررسی تا حد امکان همزمان باشد. شما می‌خواهید بتوانید مستقیماً با بازبین در مورد هر مشکلی که دارند بحث کنید، با هم بر سر یک راه به توافق برسید، تغییرات را ایجاد کنید، و به کار خود ادامه دهید.</p>
<p>هرچه سریع‌تر بازخورد را در مورد یک تغییر کد دریافت کنید، سریع‌تر می‌توانید به بازخورد نگاه کنید، آن را ارزیابی کنید، درخواست توضیح کنید، در صورت نیاز بحث را بیشتر کنید و در نهایت هر تغییری را که لازم است، ایجاد کنید. هرچه مدت زمان بین ارسال تغییر کد برای</p>
<p>516 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0542</div>
            </div>
        </div>
        <!-- Page 0543 -->
        <div class="chapter" id="page-0543">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>بررسی تغییرات</h4>
<p>و بررسی در واقع، سخت‌تر و دشوارتر می‌شوند.
   اگر شما یک تغییر کد را برای بررسی ارسال می‌کنید و بازخورد در مورد آن تغییر را تا چند روز بعد دریافت نمی‌کنید، احتمالاً به کارهای دیگری رفته‌اید. برای پردازش بازخورد، شما باید زمینه را تغییر دهید و دوباره با کاری که قبلاً انجام داده‌اید، درگیر شوید.
   شما ممکن است با تغییرات بازبین موافقت کنید (در صورت نیاز)، که در این صورت می‌توانید آنها را ایجاد کنید و تغییر را برای تأیید دوباره ارسال کنید. در بدترین حالت، ممکن است شما نیاز به بحث بیشتر در مورد نکات مطرح شده داشته باشید. این رفت و برگشت ناهمزمان بین ارسال‌کننده و بازبین می‌تواند روزها به روند ایجاد تغییرات اضافه کند.</p>
<p>بررسی کدهای خود را به سرعت انجام دهید!</p>
<p>اگر می‌خواهید بررسی کد را انجام دهید و <em>pair programming</em> نمی‌کنید، بررسی را در اسرع وقت پس از ارسال تغییر انجام دهید، و بازخورد را تا حد امکان همزمان، ایده‌آل در روبرو با بازبین، پیگیری کنید.</p>
<h4>برنامه‌نویسی گروهی</h4>
<p>برنامه‌نویسی گروهی (همچنین به نام <em>mob programming</em>14) گاهی اوقات به عنوان راهی برای انجام بررسی کد <em>inline</em> مورد بحث قرار می‌گیرد. با برنامه‌نویسی گروهی، گروه بزرگی از افراد (شاید کل تیم) با هم روی یک تغییر کار می‌کنند. این در درجه اول در مورد کار جمعی بر روی یک مشکل و دریافت ورودی از تعداد زیادی از افراد است.</p>
<p>از میان تیم‌هایی که من با آنها صحبت کردم و از برنامه‌نویسی گروهی استفاده می‌کنند، بیشتر آنها فقط گه‌گاه از آن برای مشکلات خاص و پیچیده یا تغییرات مهم استفاده می‌کنند، اما کارهای زیادی نیز خارج از تمرین گروهی انجام می‌شود. به این ترتیب، در حالی که تمرین برنامه‌نویسی گروهی احتمالاً بررسی کافی از تغییرات ایجاد شده در طول خود گروه و به روشی بسیار همزمان ارائه می‌کند، شما همچنان به روشی نیاز دارید تا از بررسی تغییرات ایجاد شده در خارج از <em>mob</em> اطمینان حاصل کنید.</p>
<p>برخی استدلال می‌کنند که شما فقط نیاز به انجام یک بررسی از تغییرات پرخطر دارید، و بنابراین انجام بررسی فقط به عنوان بخشی از یک گروه کافی است. لازم به ذکر است که نویسندگان <em>Accelerate</em> به‌طور شگفت‌انگیزی هیچ ارتباطی بین عملکرد تحویل <strong>software</strong> و بررسی تنها تغییرات پرخطر، در مقایسه با یک همبستگی مثبت زمانی که تمام تغییرات توسط همتایان بررسی می‌شود، پیدا نکردند. بنابراین اگر شما می‌خواهید برنامه‌نویسی گروهی انجام دهید، ادامه دهید! اما ممکن است بخواهید سایر تغییرات ایجاد شده در خارج از گروه را نیز در نظر بگیرید.</p>
<p>14 اگرچه اصطلاح <em>mob programming</em> رایج‌تر است، من عکس این را دوست ندارم، و در عوض اصطلاح <em>ensemble</em> را ترجیح می‌دهم، زیرا مشخص می‌کند که ما مجموعه‌ای از افراد را داریم که با هم کار می‌کنند، نه مجموعه‌ای از افرادی که کوکتل مولوتف پرتاب می‌کنند و پنجره‌ها را می‌شکنند. من 100٪ مطمئن نیستم که چه کسی این تغییر نام را ابداع کرده است، اما فکر می‌کنم این <em>Maaret Pyhäjärvi</em> بود.</p>
<p><strong>Microservices</strong> مدولار و قابل اتصال | 517</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 543" src="page_0543/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0543</div>
            </div>
        </div>
        <!-- Page 0544 -->
        <div class="chapter" id="page-0544">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>برنامه‌نویسی گروهی (ادامه)</h4>
<p>15 <em>Maaret Pyhäjärvi</em>, <em>Ensemble Programming Guidebook</em> (خود منتشر شده، 2015–2020)، <a href="https://ensembleprogramming.xyz">https://ensembleprogramming.xyz</a>.</p>
<p>شخصاً، من در مورد برخی از جنبه‌های برنامه‌نویسی گروهی تردیدهای عمیقی دارم. شما متوجه خواهید شد که تیم شما در واقع یک دسته <em>neurodiverse</em> است، و عدم تعادل قدرت در گروه می‌تواند بیشتر هدف حل مسئله جمعی را تضعیف کند. همه در کار کردن در یک گروه راحت نیستند، و یک گروه قطعاً اینطور است. برخی از افراد در چنین محیطی پیشرفت می‌کنند، در حالی که دیگران کاملاً قادر به مشارکت نخواهند بود. وقتی این موضوع را با برخی از طرفداران برنامه‌نویسی گروهی مطرح کردم، پاسخ‌های مختلفی دریافت کردم، که بسیاری از آنها به این باور ختم می‌شود که اگر شما محیط مناسبی را برای گروه ایجاد کنید، هرکسی می‌تواند "از لاک خود بیرون بیاید و مشارکت کند". بگذارید فقط بگویم که پس از آن مجموعه‌ای از مکالمات خاص، من آنقدر چشم‌هایم را چرخیدم که تقریباً نابینا شدم. منصفانه است که این نگرانی‌ها را می‌توان در مورد <em>pair programming</em> نیز مطرح کرد!</p>
<p>در حالی که من شکی ندارم که بسیاری از طرفداران برنامه‌نویسی گروهی به اندازه اینها بی‌اطلاع یا <em>tone-deaf</em> نخواهند بود، مهم است که به یاد داشته باشید که ایجاد یک فضای کاری فراگیر تا حدی در مورد درک چگونگی ایجاد محیطی است که در آن همه اعضای تیم بتوانند به طور کامل به روشی ایمن و راحت برای آنها مشارکت کنند. و خودتان را گول نزنید که فقط به این دلیل که شما همه را در یک اتاق دارید، همه واقعاً در حال مشارکت هستند. اگر می‌خواهید نکاتی در مورد برنامه‌نویسی گروهی داشته باشید، پیشنهاد می‌کنم <em>Ensemble Programming Guidebook</em> مختصر و خودمنتشر شده <em>Maaret Pyhäjärvi</em> را مطالعه کنید.15</p>
<h4>سرویس یتیم</h4>
<p>پس در مورد سرویس‌هایی که دیگر فعالانه نگهداری نمی‌شوند، چه؟ با حرکت به سمت معماری‌های <em>finer-grained</em>، خود <strong>microservices</strong> کوچکتر می‌شوند. یکی از مزایای <strong>microservices</strong> کوچکتر، همانطور که ما بحث کردیم، این است که آنها ساده‌تر هستند. <strong>Microservices</strong> ساده‌تر با عملکردهای کمتر ممکن است برای مدتی نیازی به تغییر نداشته باشند. <strong>microservice</strong> سبد خرید فروتن را در نظر بگیرید، که برخی از قابلیت‌های نسبتاً متوسط را ارائه می‌دهد: افزودن به سبد، حذف از سبد، و غیره. کاملاً قابل تصور است که این <strong>microservice</strong> ممکن است ماه‌ها پس از اولین نوشته شدن، حتی اگر توسعه فعال همچنان ادامه داشته باشد، نیازی به تغییر نداشته باشد. در اینجا چه اتفاقی می‌افتد؟
   چه کسی مالک این <strong>microservice</strong> است؟</p>
<p>اگر ساختار تیم شما در امتداد <em>bounded contexts</em> سازمان شما همسو باشد، حتی سرویس‌هایی که اغلب تغییر نمی‌کنند، هنوز هم یک مالک <em>de facto</em> دارند. یک تیم را تصور کنید که با زمینه فروش وب مصرف‌کننده همسو شده است. این تیم ممکن است رابط کاربری مبتنی بر وب و <strong>microservices</strong> سبد خرید و توصیه را مدیریت کند. حتی اگر سرویس سبد خرید ماه‌ها تغییر نکرده باشد، به طور طبیعی به این تیم تعلق می‌گیرد که در صورت نیاز تغییراتی ایجاد کند. البته، یکی از مزایای <strong>microservices</strong>،</p>
<p>518 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0544</div>
            </div>
        </div>
        <!-- Page 0545 -->
        <div class="chapter" id="page-0545">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>سرویس یتیم (ادامه)</h4>
<p>این است که اگر تیم نیاز به تغییر <strong>microservice</strong> برای افزودن یک ویژگی جدید داشته باشد و ویژگی را به دلخواه خود پیدا نکند، بازنویسی آن نباید زمان زیادی ببرد.
   با این حال، اگر شما یک رویکرد واقعاً <em>polyglot</em> را اتخاذ کرده‌اید و از <em>technology stacks</em> متعدد استفاده می‌کنید، در این صورت چالش‌های ایجاد تغییرات در یک سرویس یتیم می‌تواند پیچیده شود، اگر تیم شما دیگر <em>technology stack</em> را نمی‌داند.</p>
<h4>مطالعه موردی: <em>realestate.com.au</em></h4>
<p>برای نسخه اول این کتاب، من مدتی را صرف گفتگو با <em>realestate.com.au</em> (<em>REA</em>) در مورد استفاده از <strong>microservices</strong> آن کردم، و بسیاری از آنچه آموختم در به اشتراک گذاشتن نمونه‌های دنیای واقعی <strong>microservices</strong> در عمل بسیار کمک کرد. من همچنین تعامل <em>REA</em> با ساختار سازمانی و معماری را به‌ویژه جذاب یافتم.
   این نمای کلی از ساختار سازمانی آن بر اساس بحث‌های ما در سال 2014 است.
   من مطمئن هستم که آنچه <em>REA</em> امروز به نظر می‌رسد کاملاً متفاوت است. این نمای کلی یک عکس فوری، یک نقطه در زمان را نشان می‌دهد. من این را پیشنهاد نمی‌کنم که این بهترین راه برای ساختاردهی یک سازمان است—فقط این چیزی است که در آن زمان برای <em>REA</em> بهترین عملکرد را داشت. یادگیری از سازمان‌های دیگر منطقی است. کپی کردن آنچه آنها انجام می‌دهند بدون درک دلیل انجام آن، احمقانه است.</p>
<p>همانطور که امروز انجام می‌دهد، کسب‌وکار اصلی <em>REA</em>، املاک و مستغلات شامل جنبه‌های مختلفی بود. در سال 2014، <em>REA</em> به خطوط تجاری مستقل (<em>LOBs</em>) تقسیم شد. به عنوان مثال، یک خط تجاری با املاک مسکونی در استرالیا سروکار داشت، دیگری با املاک تجاری، و خط دیگری یکی از مشاغل خارج از کشور <em>REA</em> را مدیریت می‌کرد. این خطوط تجاری دارای تیم‌های تحویل <em>IT</em> (یا "جوخه‌ها") مرتبط با آنها بودند. فقط برخی از آنها یک جوخه واحد داشتند، در حالی که بزرگترین خط، چهار جوخه داشت. بنابراین برای املاک مسکونی، چندین تیم در ایجاد وب‌سایت و لیست خدمات برای اجازه دادن به مردم برای مرور املاک درگیر بودند. افراد هر از چند گاهی بین این تیم‌ها می‌چرخیدند اما تمایل داشتند برای مدت طولانی در آن خط تجاری بمانند، و اطمینان حاصل کنند که اعضای تیم می‌توانند آگاهی زیادی از آن بخش از دامنه ایجاد کنند. این به نوبه خود به ارتباط بین ذینفعان مختلف کسب‌وکار و تیم ارائه ویژگی‌ها برای آنها کمک کرد.</p>
<p>انتظار می‌رفت که هر جوخه در یک خط تجاری، کل چرخه عمر هر سرویسی را که ایجاد می‌کرد، از جمله ساخت، آزمایش و انتشار، پشتیبانی، و حتی از رده خارج کردن، داشته باشد. تیم خدمات تحویل اصلی وظیفه ارائه مشاوره، راهنمایی و ابزار به جوخه‌ها در <em>LOBs</em> را بر عهده داشت، و به این جوخه‌ها کمک می‌کرد تا به طور مؤثرتری تحویل دهند. با استفاده از اصطلاحات جدیدتر ما، تیم خدمات تحویل اصلی نقش یک تیم فعال‌کننده را ایفا می‌کرد. یک فرهنگ قوی از اتوماسیون کلیدی بود، و <em>REA</em> از <em>AWS</em> به عنوان یک بخش مهم برای توانمندسازی تیم‌ها برای خودکارتر شدن، استفاده زیادی کرد. شکل 15-6 نشان می‌دهد که چگونه همه اینها کار می‌کرد.</p>
<p>مطالعه موردی: <em>realestate.com.au</em> | 519</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0545</div>
            </div>
        </div>
        <!-- Page 0546 -->
        <div class="chapter" id="page-0546">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مطالعه موردی: <em>realestate.com.au</em> (ادامه)</h4>
<p>شکل 15-6. مروری بر ساختار سازمانی و تیمی و همسویی آن با معماری <em>realestate.com.au</em></p>
<p>فقط سازمان تحویل نبود که با نحوه عملکرد کسب‌وکار همسو شده بود. این مدل به معماری نیز گسترش یافت. یک نمونه از این روش‌ها، روش‌های ادغام بود. در داخل یک <em>LOB</em>، همه سرویس‌ها آزاد بودند که به هر روشی که مناسب می‌دانستند، با یکدیگر صحبت کنند، همانطور که توسط جوخه‌هایی که به عنوان متولی آنها عمل می‌کنند، تصمیم گرفته شد. اما ارتباط بین <em>LOBs</em> به صورت <em>asynchronous batch</em> اجباری بود، یکی از معدود قوانین <em>cast-iron</em> تیم معماری بسیار کوچک. این ارتباط <em>coarse-grained</em> با آنچه که بین بخش‌های مختلف کسب‌وکار نیز وجود داشت، مطابقت داشت. با اصرار بر این که <em>batch</em> باشد، هر <em>LOB</em> آزادی زیادی در نحوه عملکرد و نحوه مدیریت خود داشت. این تیم می‌توانست سرویس‌های خود را هر زمان که می‌خواستند، از کار بیاندازد، با دانستن اینکه تا زمانی که بتواند ادغام <em>batch</em> را با سایر بخش‌های کسب‌وکار و ذینفعان کسب‌وکار خود برآورده کند، هیچ‌کس اهمیت نخواهد داد.</p>
<p>این ساختار به خودمختاری قابل توجهی نه تنها در میان تیم‌ها، بلکه در بین بخش‌های مختلف کسب‌وکار نیز اجازه داد، و توانایی ارائه تغییر به شرکت کمک کرد تا به موفقیت قابل توجهی در بازار محلی دست یابد. این ساختار خودمختارتر همچنین به رشد شرکت از تعداد کمی سرویس در سال 2010 به صدها سرویس تا سال 2014 کمک کرد و توانایی ارائه تغییرات سریع‌تر را تسهیل کرد.</p>
<p>آن سازمان‌هایی که به اندازه کافی سازگار هستند تا نه تنها معماری سیستم خود، بلکه ساختار سازمانی خود را نیز تغییر دهند، می‌توانند از نظر بهبود خودمختاری تیم‌ها و زمان سریع‌تر برای ورود به بازار برای ویژگی‌ها و عملکرد جدید، مزایای زیادی کسب کنند. <em>REA</em> فقط یکی از تعدادی از سازمان‌ها است که متوجه شده‌اند که معماری سیستم در خلاء وجود ندارد.</p>
<p>520 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 546" src="page_0546/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0546</div>
            </div>
        </div>
        <!-- Page 0547 -->
        <div class="chapter" id="page-0547">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>توزیع جغرافیایی</h4>
<p>تیم‌های <em>colocated</em>، ارتباط همزمان را بسیار ساده خواهند یافت، به‌ویژه از آنجایی که آنها معمولاً در یک مکان و در یک زمان هستند. اگر تیم شما توزیع شده است، ارتباط همزمان می‌تواند دشوارتر باشد، اما هنوز هم قابل دستیابی است اگر اعضای تیم در یک منطقه زمانی یکسان یا مشابه باشند. هنگام برقراری ارتباط با افراد در مناطق زمانی مختلف، هزینه هماهنگی می‌تواند به شدت افزایش یابد. در یکی از نقش‌های قبلی‌ام به عنوان معمار کار می‌کردم، و به تیم‌هایی که در هند، بریتانیا، برزیل و ایالات متحده مستقر بودند، کمک می‌کردم، در حالی که خودم در استرالیا مستقر بودم. تنظیم یک جلسه بین من و سرپرستان تیم‌های مختلف بسیار دشوار بود. این بدان معنا بود که ما این جلسات را به ندرت برگزار می‌کردیم (معمولاً ماهانه)، و ما همچنین باید اطمینان حاصل می‌کردیم که فقط مهم‌ترین مسائل را در طول این جلسات مورد بحث قرار می‌دهیم، زیرا اغلب بیش از نیمی از شرکت‌کنندگان خارج از ساعات کاری اصلی خود کار می‌کردند.
   خارج از این جلسات، ما ارتباطات ناهمزمان، عمدتاً از طریق ایمیل، در مورد سایر مسائل کم‌اهمیت‌تر در زمان، خواهیم داشت. اما با حضور من در استرالیا، تأخیر در این شکل از ارتباط قابل توجه بود. من صبح دوشنبه از خواب بیدار می‌شدم تا هفته را نسبتاً آرام شروع کنم، زیرا بیشتر دنیا بیدار نشده بود—این به من این امکان را می‌داد که ایمیل‌هایی را که از تیم‌هایی در بریتانیا، برزیل و ایالات متحده در بعد از ظهر جمعه دریافت کرده‌ام، پردازش کنم، که صبح شنبه من بود.</p>
<p>من به یاد می‌آورم یک پروژه <em>client</em> که روی آن کار می‌کردم که در آن مالکیت یک <strong>microservice</strong> واحد بین دو مکان جغرافیایی به اشتراک گذاشته شده بود. در نهایت، هر سایت شروع به تخصصی کردن کاری کرد که مدیریت می‌کرد. این به آن اجازه می‌داد تا مالکیت بخشی از کدبیس را بر عهده بگیرد، که در آن می‌توانست هزینه تغییر آسان‌تری داشته باشد. سپس تیم‌ها ارتباط <em>coarse-grained</em> بیشتری در مورد نحوه ارتباط دو بخش با هم داشتند. در واقع، مسیرهای ارتباطی که در ساختار سازمانی امکان‌پذیر شد با <strong>API</strong> <em>coarse-grained</em> که مرز بین دو نیمه کدبیس را تشکیل می‌داد، مطابقت داشت.</p>
<p>بنابراین وقتی در مورد تکامل طراحی سرویس خود فکر می‌کنیم، این ما را به کجا می‌رساند؟ خوب، من پیشنهاد می‌کنم که مرزهای جغرافیایی بین افرادی که درگیر توسعه هستند باید یک ملاحظه قوی هنگام تعیین مرزهای تیم و مرزهای <strong>software</strong> باشد. تشکیل یک تیم واحد بسیار آسان‌تر است، زمانی که اعضای آن <em>colocated</em> هستند. اگر <em>colocation</em> امکان‌پذیر نیست، و شما به دنبال تشکیل یک تیم توزیع شده هستید، در این صورت اطمینان از اینکه اعضای تیم در یک منطقه زمانی یکسان یا بسیار مشابه هستند، به ارتباطات در داخل آن تیم کمک می‌کند، زیرا نیاز به ارتباط ناهمزمان را کاهش می‌دهد.
   شاید سازمان شما تصمیم بگیرد که می‌خواهد تعداد افرادی را که روی پروژه شما کار می‌کنند با افتتاح یک دفتر در کشور دیگری افزایش دهد. در این مرحله، شما باید فعالانه در مورد اینکه کدام بخش از سیستم شما می‌تواند منتقل شود، فکر کنید. شاید این چیزی است که تصمیمات شما را در مورد اینکه چه عملکردی را در مرحله بعد جدا کنید، هدایت می‌کند.</p>
<p>توزیع جغرافیایی | 521</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0547</div>
            </div>
        </div>
        <!-- Page 0548 -->
        <div class="chapter" id="page-0548">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>توزیع جغرافیایی (ادامه)</h4>
<p>در این مرحله نیز شایان ذکر است که، حداقل بر اساس مشاهدات نویسندگان گزارش "بررسی دوگانگی بین محصولات و معماری‌های سازمانی" که قبلاً به آن اشاره کردم، اگر سازمانی که سیستم را می‌سازد، <strong>loosely coupled</strong>تر باشد (به عنوان مثال، از تیم‌های پراکنده جغرافیایی تشکیل شده باشد)، سیستم‌هایی که ساخته می‌شوند، تمایل بیشتری به <em>modular</em>تر بودن دارند، و بنابراین امیدواریم که کمتر <em>coupled</em> باشند. تمایل یک تیم واحد که مالک سرویس‌های زیادی است به سمت ادغام تنگاتنگ‌تر، در یک سازمان توزیع‌شده‌تر بسیار دشوار است.
  قانون <em>Conway</em> در حالت معکوس</p>
<p>تاکنون، ما در مورد چگونگی تأثیر سازمان بر طراحی سیستم صحبت کرده‌ایم. اما در مورد برعکس چطور؟ یعنی آیا یک طراحی سیستم می‌تواند سازمان را تغییر دهد؟ در حالی که من نتوانسته‌ام شواهد با همان کیفیت برای تأیید این ایده که قانون <em>Conway</em> در جهت معکوس کار می‌کند، پیدا کنم، اما از نظر حکایتی آن را دیده‌ام.
   شاید بهترین مثال، یک <em>client</em> بود که من سال‌ها پیش با آن کار کردم. در روزهایی که وب نسبتاً تازه بود، و اینترنت به عنوان چیزی که از طریق دیسک‌های فلاپی <em>AOL</em> وارد می‌شد، دیده می‌شد، این شرکت یک شرکت چاپ بزرگ با یک وب‌سایت کوچک و متوسط بود. این شرکت یک وب‌سایت داشت زیرا این کاری بود که باید انجام می‌داد، اما در طرح بزرگ‌تر، وب‌سایت برای نحوه عملکرد کسب‌وکار نسبتاً بی‌اهمیت بود. وقتی سیستم اصلی ایجاد شد، یک تصمیم فنی نسبتاً خودسرانه در مورد نحوه عملکرد سیستم اتخاذ شد.
   محتوای این سیستم به روش‌های متعددی به‌دست می‌آمد، اما بیشتر آن از اشخاص ثالثی می‌آمد که تبلیغات را برای مشاهده توسط عموم مردم قرار می‌دادند. یک سیستم ورودی وجود داشت که به اشخاص ثالث پرداخت‌کننده اجازه می‌داد تا محتوا ایجاد کنند، یک سیستم مرکزی که آن داده‌ها را دریافت و به روش‌های مختلفی آن را غنی می‌کرد، و یک سیستم خروجی که وب‌سایت نهایی را ایجاد می‌کرد که عموم مردم می‌توانستند آن را مرور کنند.</p>
<p>اینکه آیا تصمیمات طراحی اصلی در آن زمان درست بود یا خیر، بحثی برای مورخان است، اما سال‌های زیادی که گذشت شرکت تغییرات زیادی کرد، و من و بسیاری از همکارانم شروع به تعجب کردیم که آیا طراحی سیستم برای وضعیت فعلی شرکت مناسب است یا خیر. تجارت چاپ فیزیکی آن به طور قابل توجهی کاهش یافته بود، و درآمد و در نتیجه عملیات تجاری سازمان اکنون تحت سلطه حضور آنلاین آن بود.
   آنچه در آن زمان دیدیم، سازمانی بود که با این سیستم سه‌بخشی کاملاً همسو شده بود. سه کانال یا بخش در بخش <em>IT</em> کسب‌وکار با هر یک از بخش‌های ورودی، اصلی و خروجی کسب‌وکار همسو شده بودند. در داخل آن کانال‌ها، تیم‌های تحویل جداگانه وجود داشت. آنچه در آن زمان متوجه نشدم این بود که این ساختارهای سازمانی، قبل از طراحی سیستم وجود نداشتند، بلکه در واقع در اطراف آن رشد کردند. با کاهش بخش چاپ کسب‌وکار و رشد بخش دیجیتال کسب‌وکار، طراحی سیستم ناخواسته راه را برای رشد سازمان هموار کرد.</p>
<p>522 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0548</div>
            </div>
        </div>
        <!-- Page 0549 -->
        <div class="chapter" id="page-0549">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>قانون <em>Conway</em> در حالت معکوس (ادامه)</h4>
<p>در نهایت متوجه شدیم که صرف نظر از کاستی‌های طراحی سیستم، ما باید تغییراتی در ساختار سازمانی ایجاد کنیم تا تغییری ایجاد شود. شرکت در حال حاضر بسیار تغییر کرده است، اما این اتفاق در طول سال‌های زیادی رخ داد.</p>
<p>مردم</p>
<p>مهم نیست در ابتدا چگونه به نظر می‌رسد، همیشه یک مشکل مردمی است.</p>
<p>—<em>Gerry Weinberg</em>، قانون دوم مشاوره</p>
<p>ما باید بپذیریم که در یک محیط <em>microservice</em>، برای یک توسعه‌دهنده دشوارتر است که به نوشتن کد در دنیای کوچک خود فکر کند. آنها باید از پیامدهای چیزهایی مانند تماس‌ها در سراسر مرزهای شبکه یا پیامدهای شکست بیشتر آگاه باشند. ما همچنین در مورد توانایی <strong>microservices</strong> برای آسان‌تر کردن امتحان فناوری‌های جدید، از فروشگاه‌های داده تا زبان‌ها، صحبت کرده‌ایم. اما اگر شما از جهانی حرکت می‌کنید که در آن یک سیستم <strong>monolithic</strong> دارید، که در آن اکثر توسعه‌دهندگان شما فقط مجبور بوده‌اند از یک زبان استفاده کنند و کاملاً از نگرانی‌های عملیاتی بی‌اطلاع بوده‌اند، پرتاب کردن آنها به دنیای <strong>microservices</strong> ممکن است یک بیداری ناگهانی برای آنها باشد.</p>
<p>به همین ترتیب، انتقال قدرت به تیم‌های توسعه برای افزایش خودمختاری می‌تواند با مشکلاتی همراه باشد. افرادی که در گذشته کار را به شخص دیگری واگذار کرده‌اند، به این عادت کرده‌اند که فرد دیگری را سرزنش کنند و ممکن است در قبال کار خود احساس راحتی نکنند. شما حتی ممکن است موانع قراردادی برای داشتن توسعه‌دهندگان خود که برای سیستم‌هایی که پشتیبانی می‌کنند، <em>pager</em> حمل می‌کنند، پیدا کنید! این تغییرات را می‌توان به روشی تدریجی انجام داد، و در ابتدا منطقی خواهد بود که به دنبال تغییر مسئولیت‌های افرادی باشید که تمایل و توانایی بیشتری برای ایجاد تغییر دارند.
   اگرچه این کتاب بیشتر در مورد فناوری بوده است، اما مردم فقط یک ملاحظات جانبی نیستند. آنها مردمی هستند که آنچه را که اکنون دارید ساخته‌اند و آنچه را که در آینده اتفاق می‌افتد، خواهند ساخت. ارائه یک دیدگاه در مورد چگونگی انجام کارها بدون در نظر گرفتن اینکه کارکنان فعلی شما چه احساسی در مورد آن خواهند داشت و بدون در نظر گرفتن چه توانایی‌هایی دارند، احتمالاً منجر به یک مکان بد خواهد شد.</p>
<p>هر سازمان، مجموعه‌ای از پویایی‌های خود را در مورد این موضوع دارد. اشتهای کارکنان خود را برای تغییر درک کنید. آنها را خیلی سریع تحت فشار قرار ندهید! شاید شما بتوانید یک تیم جداگانه داشته باشید که پشتیبانی یا استقرار خط مقدم را برای مدت کوتاهی انجام دهد، و به توسعه‌دهندگان شما فرصتی برای سازگاری با شیوه‌های جدید بدهید. با این حال، شما ممکن است مجبور شوید بپذیرید که برای اینکه همه اینها کار کند، به انواع مختلفی از افراد در سازمان خود نیاز دارید. شما احتمالاً نیاز خواهید داشت که نحوه استخدام خود را تغییر دهید—در واقع، ممکن است آسان‌تر باشد که با آوردن افراد جدید از بیرون که قبلاً در کار به روشی که شما می‌خواهید، تجربه دارند، نشان دهید که چه چیزی ممکن است. استخدام‌های جدید مناسب ممکن است راه درازی را به سمت نشان دادن آنچه امکان‌پذیر است، داشته باشد.</p>
<p>صرف نظر از رویکرد شما، درک کنید که شما باید در بیان مسئولیت‌های افراد خود در دنیای <strong>microservices</strong> روشن باشید، و همچنین در مورد اینکه چرا</p>
<p>مردم | 523</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0549</div>
            </div>
        </div>
        <!-- Page 0550 -->
        <div class="chapter" id="page-0550">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>به‌طور خلاصه‌ی،</h4>
<p>در پایان، اگر شما می‌خواهید که در یک <strong>world microservices</strong> کار کنید، درک کنید که باید در بیان مسئولیت‌های افراد خود روشن باشید، و همچنین در مورد اینکه چرا آن مسئولیت‌ها برای شما مهم هستند. این می‌تواند به شما کمک کند تا نقاط ضعف مهارت‌های خود را ببینید و در مورد چگونگی رفع آنها فکر کنید. برای بسیاری از شما، این یک سفر بسیار ترسناک خواهد بود. فقط به یاد داشته باشید که بدون حضور مردم، هر تغییری که بخواهید ایجاد کنید، می‌تواند از ابتدا محکوم به فنا شود.</p>
<p>خلاصه</p>
<p>قانون <em>Conway</em>، خطرات تلاش برای اجرای یک طراحی سیستم را که با سازمان مطابقت ندارد، برجسته می‌کند. این امر ما را، حداقل برای <strong>microservices</strong>، به سمت مدلی هدایت می‌کند که در آن مالکیت قوی <strong>microservices</strong>، هنجار است. به اشتراک گذاشتن <strong>microservices</strong> یا تلاش برای تمرین مالکیت جمعی در مقیاس می‌تواند اغلب منجر به تضعیف مزایای <strong>microservices</strong> شود.
   وقتی سازمان و معماری همسو نیستند، ما نقاط تنش را دریافت می‌کنیم، همانطور که در سراسر این فصل توضیح داده شد. با تشخیص ارتباط بین این دو، ما اطمینان خواهیم داد که سیستمی که در تلاش برای ساختن آن هستیم، برای سازمانی که برای آن می‌سازیم، منطقی است.</p>
<p>اگر می‌خواهید این موضوع را بیشتر بررسی کنید، علاوه بر <em>Team Topologies</em> که قبلاً ذکر شد، من همچنین به‌طور کامل سخنرانی "مقیاس، <strong>Microservices</strong> و جریان" اثر <em>James Lewis</em>16 را توصیه می‌کنم، که از آن بینش‌های زیادی به‌دست آوردم که به شکل‌گیری این فصل کمک کرد. اگر شما علاقه‌مند به بررسی عمیق‌تر برخی از ایده‌هایی هستید که در این فصل پوشش داده‌ام، ارزش دیدن دارد.</p>
<p>در فصل بعدی، ما موضوعی را که قبلاً به آن اشاره کردم—نقش معمار—با عمق بیشتری بررسی خواهیم کرد.</p>
<p>16 <em>James Lewis</em>, “Scale, Microservices and Flow,” <em>YOW! Conferences</em>, February 10, 2020, <a href="https://oreil.ly/ON81J">https://oreil.ly/ON81J</a>.</p>
<p>524 | فصل 15: ساختارهای سازمانی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0550</div>
            </div>
        </div>
        <!-- Page 0551 -->
        <div class="chapter" id="page-0551">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>فصل 16</h3>
<h3>معمار تکاملی</h3>
<p>همانطور که تا به حال دیده‌ایم، <strong>microservices</strong> انتخاب‌های زیادی به ما می‌دهند، و بر این اساس تصمیمات زیادی باید اتخاذ کنیم. به عنوان مثال، ما باید از چه تعداد فناوری مختلف استفاده کنیم، آیا باید به تیم‌های مختلف اجازه دهیم از اصطلاحات برنامه‌نویسی متفاوتی استفاده کنند، و آیا باید یک <strong>microservice</strong> را تقسیم یا ادغام کنیم؟ چگونه باید این تصمیمات را اتخاذ کنیم؟ با سرعت تغییر بیشتر و محیط سیال‌تری که این معماری‌ها اجازه می‌دهند، نقش معمار نیز باید تغییر کند. در این فصل، من یک دیدگاه نسبتاً <em>opinionated</em> از اینکه نقش معمار چیست، خواهم داشت و امیدوارم یک حمله نهایی به برج عاج را آغاز کنم.</p>
<h4>نام چیست؟</h4>
<p>تو همچنان از آن کلمه استفاده می‌کنی. من فکر نمی‌کنم آن چیزی را که تو فکر می‌کنی، معنا بدهد.</p>
<p>—<em>Inigo Montoya</em>، از <em>The Princess Bride</em></p>
<p>معماران یک کار مهم دارند. آنها مسئول اطمینان از داشتن یک چشم‌انداز فنی مشترک در سیستم هستند، چشم‌اندازی که باید به ارائه <strong>software</strong> مورد نیاز مشتریان کمک کند. در برخی از مکان‌ها، آنها ممکن است مجبور شوند فقط با یک تیم کار کنند، که در این صورت نقش معمار و رهبر فنی اغلب یکسان است. در مکان‌های دیگر، آنها ممکن است در حال تعریف چشم‌انداز برای کل برنامه کار، هماهنگی با چندین تیم در سراسر جهان، یا شاید حتی یک سازمان کامل باشند.
   در هر سطحی که معماران فعالیت می‌کنند، نقش آنها، نقش دشواری است که باید مشخص شود، و با وجود اینکه اغلب پیشرفت شغلی آشکاری برای توسعه‌دهندگان در سازمان‌های سازمانی است، این نقشی است که بیش از هر نقش دیگری در زمینه ما مورد انتقاد قرار می‌گیرد. معماران بیش از هر نقش دیگری، می‌توانند تأثیر مستقیمی بر کیفیت سیستم‌های ساخته شده، بر شرایط کاری همکاران خود، و بر توانایی سازمان خود در پاسخگویی به تغییرات داشته باشند، و با این حال، نقش آنها بسیار بد فهمیده می‌شود.
   چرا اینطور است؟</p>
<p>525</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0551</div>
            </div>
        </div>
        <!-- Page 0552 -->
        <div class="chapter" id="page-0552">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>چرا معماران مورد انتقاد قرار می‌گیرند؟</h4>
<p>1 به دلایل متعددی، که کمترین آنها این نیست که من مدرک مهندسی <strong>software</strong> دارم...</p>
<p>صنعت ما جوان است. به نظر می‌رسد که ما گاهی اوقات فراموش می‌کنیم که فقط تقریباً 75 سال است که در حال ایجاد برنامه‌هایی هستیم که روی آنچه به عنوان رایانه می‌شناسیم، اجرا می‌شوند.
   حرفه ما در یک جعبه مرتب و منظمی که جامعه به طور کلی درک می‌کند، قرار نمی‌گیرد. ما مانند برقکاران، لوله‌کش‌ها، پزشکان یا مهندسان نیستیم. چند بار در یک مهمانی به کسی گفته‌اید که چه می‌کنید، فقط برای اینکه مکالمه متوقف شود؟ جهانیان در کل در تلاشند تا توسعه <strong>software</strong> را درک کنند—همانطور که من بارها در طول این کتاب توضیح داده‌ام، ما اغلب خودمان هم آن را درک نمی‌کنیم.</p>
<p>بنابراین ما از سایر مشاغل قرض می‌گیریم. ما خود را "مهندسان" <strong>software</strong>، یا "معماران" می‌نامیم. اما ما معمار یا مهندس نیستیم به همان شیوه‌ای که جامعه این مشاغل را درک می‌کند. معماران و مهندسان دارای دقت و انضباطی هستند که ما فقط می‌توانیم آرزوی آن را داشته باشیم، و اهمیت آنها در جامعه به خوبی درک شده است. من به یاد دارم که روز قبل از اینکه یکی از دوستانم معمار واجد شرایط شود، با او صحبت می‌کردم. او گفت: "فردا، اگر من در کافه به شما در مورد نحوه ساختن چیزی مشاوره بدهم و اشتباه باشد، من مسئول خواهم بود. من ممکن است مورد پیگرد قانونی قرار گیرم، زیرا در نظر قانون، من اکنون یک معمار واجد شرایط هستم و اگر آن را اشتباه انجام دهم، باید پاسخگو باشم." اهمیت این مشاغل برای جامعه به این معنی است که صلاحیت‌های مورد نیازی وجود دارد که افراد باید آنها را داشته باشند. به عنوان مثال، در بریتانیا، حداقل هفت سال تحصیل قبل از اینکه بتوانید معمار نامیده شوید، لازم است. اما این مشاغل نیز مبتنی بر مجموعه‌ای از دانش هستند که هزاران سال قدمت دارد. و معماران <strong>software</strong>؟ دقیقاً نه. که تا حدی به همین دلیل است که من بسیاری از انواع گواهی <em>IT</em> را بی‌ارزش می‌دانم، زیرا ما چیزهای کمی در مورد اینکه "خوب" چگونه به نظر می‌رسد، می‌دانیم.</p>
<p>من این را نمی‌گویم که اصطلاح مهندسی <strong>software</strong> را کوچک بشمارم،1 که در دهه 1960 توسط <em>Margaret Hamilton</em> ابداع شد، اما به همان اندازه که آرزومندانه بود، مربوط به واقعیت فعلی نیز بود. این اصطلاح به عنوان دعوتی برای بهبود کیفیت <strong>software</strong> در حال ایجاد پدیدار شد، و در به رسمیت شناختن این واقعیت که پروژه‌های <strong>software</strong> اغلب شکست می‌خوردند، و با این وجود به طور فزاینده‌ای در زمینه‌های حیاتی مأموریت و ایمنی مورد استفاده قرار می‌گرفتند. از آن زمان کارهای زیادی برای بهبود این وضعیت انجام شده است، اما نظر من پس از 20 سال در این صنعت این است که ما هنوز چیزهای زیادی برای یادگیری در مورد انجام یک کار خوب (یا حداقل بهتر) داریم.
   بخشی از ما خواهان شناخت است، بنابراین ما از نام‌های مشاغل دیگری قرض می‌گیریم که قبلاً شناختی را که آرزویش را داریم، دارند. اما این می‌تواند مشکل‌ساز باشد، اگر ما شیوه‌های کاری را از آن مشاغل قرض بگیریم بدون اینکه ذهنیت پشت آنها را درک کنیم یا در نظر بگیریم که توسعه <strong>software</strong> چگونه با، به عنوان مثال، مهندسی عمران متفاوت است. هیچ یک از اینها نباید به عنوان این استدلال تلقی شود که ما نباید به دنبال دقت بیشتر در کار خود باشیم—فقط اینکه ما نمی‌توانیم به سادگی ایده‌هایی را از جای دیگر قرض بگیریم و فرض کنیم که برای ما کار خواهند کرد. صنعت ما بسیار جوان است، و چالش این است که ما قطعیت‌های بسیار کمتری در اطراف آن داریم که به عنوان یک صنعت در مورد آنها توافق نظر داریم.</p>
<p>526 | فصل 16: معمار تکاملی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0552</div>
            </div>
        </div>
        <!-- Page 0553 -->
        <div class="chapter" id="page-0553">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>چرا معماران مورد انتقاد قرار می‌گیرند؟ (ادامه)</h4>
<p>2 این از یک تبادل ایمیل در لیست پستی <em>extreme programming</em> است، که سپس <em>Martin Fowler</em> آن را در مقاله خود با عنوان "چه کسی به یک معمار نیاز دارد؟" به اشتراک گذاشت.</p>
<p>شاید اصطلاح معمار، یا حداقل درک مشترک از آنچه معماران انجام می‌دهند، بیشترین آسیب را به این روش وارد کرده باشد: ایده شخصی که برنامه‌های دقیقی را برای تفسیر دیگران ترسیم می‌کند و انتظار دارد که آنها اجرا شوند. تعادل بین بخشی از هنرمند، بخشی از مهندس، نظارت بر ایجاد چیزی که اغلب یک دیدگاه واحد است، با تمام دیدگاه‌های دیگر که مطیع هستند، به جز اعتراض‌های گاه و بی‌گاه مهندس سازه در مورد قوانین فیزیک. در صنعت ما، این دیدگاه از معمار منجر به برخی از رویه‌های وحشتناک می‌شود، با معمارانی که نمودار پس از نمودار، صفحه پس از صفحه مستندات ایجاد می‌کنند، با این دید که ساخت سیستم کامل را اطلاع‌رسانی کنند، در حالی که به آینده اساساً ناشناخته توجه نمی‌کنند، و کاملاً عاری از هرگونه درک از اینکه برنامه‌های آنها چقدر سخت اجرا خواهند شد، یا اینکه آیا آنها واقعاً کار خواهند کرد یا نه، چه رسد به داشتن توانایی برای تغییر با یادگیری بیشتر.</p>
<p>اما معماران محیط ساخته‌شده در قلمرویی متفاوت از معماران <strong>software</strong> فعالیت می‌کنند. محدودیت‌های آنها متفاوت است، محصول نهایی متفاوت است. هزینه تغییر در ساخت و ساز بسیار بیشتر از توسعه <strong>software</strong> است. شما نمی‌توانید بتن را بردارید، اما می‌توانید کد را تغییر دهید، و حتی زیرساختی که ما کد خود را روی آن اجرا می‌کنیم، به لطف مجازی‌سازی بسیار شکل‌پذیرتر از قبل است. ساختمان‌ها پس از ساخت نسبتاً ثابت هستند—آنها می‌توانند تغییر کنند، یا گسترش یابند، یا خراب شوند، اما هزینه‌های مرتبط بسیار زیاد است. اما ما انتظار داریم که <strong>software</strong> ما به طور مداوم برای پاسخگویی به نیازهای ما تغییر کند.</p>
<p>بنابراین اگر معماری <strong>software</strong> با معماری محیط ساخته‌شده متفاوت است، شاید باید در مورد اینکه معماری <strong>software</strong> در واقع چیست، کمی روشن‌تر باشیم.</p>
<h4>معماری <strong>Software</strong> چیست؟</h4>
<p>یکی از معروف‌ترین تعاریف معماری <strong>software</strong> از طریق ایمیلی از <em>Ralph Johnson</em> می‌آید: "معماری مربوط به چیزهای مهم است. هر چه که هست."2 بنابراین آیا این بدان معناست که هر چیز مهمی توسط معمار انجام می‌شود؟ آیا این بدان معناست که تمام کارهای دیگری که انجام می‌شود، مهم نیستند؟ مشکل این اظهارنظر که اغلب نقل می‌شود این است که اغلب به طور مجزا، بدون هیچ درکی از پاسخ گسترده‌تری که <em>Ralph</em> در آن به اشتراک گذاشت، استفاده می‌شود. اولاً، واضح است که او از دیدگاه یک توسعه‌دهنده <strong>software</strong> صحبت می‌کند. او در ادامه می‌گوید:</p>
<p>معماری <strong>Software</strong> چیست؟ | 527</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0553</div>
            </div>
        </div>
        <!-- Page 0554 -->
        <div class="chapter" id="page-0554">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>معمار <em>software</em> تکاملی</h4>
<p>بنابراین، تعریف بهتری این خواهد بود: "در موفق‌ترین پروژه‌های <strong>software</strong>، توسعه‌دهندگان خبره که روی آن پروژه کار می‌کنند، درک مشترکی از طراحی سیستم دارند. این درک مشترک، "معماری" نامیده می‌شود. این درک شامل چگونگی تقسیم سیستم به اجزا و نحوه تعامل اجزا از طریق رابط‌ها است. این اجزا معمولاً از اجزای کوچکتر تشکیل شده‌اند، اما معماری فقط شامل اجزا و رابط‌هایی است که توسط همه توسعه‌دهندگان درک شده‌اند."</p>
<p>این یک تعریف بهتر خواهد بود، زیرا مشخص می‌کند که معماری یک ساختار اجتماعی است (خوب، <strong>software</strong> نیز همینطور است، اما معماری حتی بیشتر از این هم هست) زیرا فقط به <strong>software</strong> بستگی ندارد، بلکه به این بستگی دارد که چه بخشی از <strong>software</strong>، اجماع گروهی مهم تلقی می‌شود.
   در اینجا <em>Ralph</em> از اصطلاح اجزا در گسترده‌ترین معنای آن استفاده می‌کند. در زمینه این کتاب، ما می‌توانیم به اجزا به عنوان <strong>microservices</strong> خود، و شاید ماژول‌ها در داخل آن <strong>microservices</strong> فکر کنیم.</p>
<p>معماری <strong>software</strong> شکل سیستم است. معماری، چه با طراحی و چه تصادفی، اتفاق می‌افتد. ما مجموعه‌ای از تصمیمات موقت می‌گیریم، و در نهایت به نتایج می‌رسیم—بدون فکر کردن به چیزها از نظر معماری، در نهایت به هر حال معماری را می‌بینیم. معماری گاهی اوقات می‌تواند همان چیزی باشد که در حالی اتفاق می‌افتد که ما در حال برنامه‌ریزی‌های دیگری هستیم.</p>
<p>یک معمار اختصاصی، کسی است که باید کل آن سیستم را ببیند و درک کند، نیروهایی را که بر آن تأثیر می‌گذارند، درک کند. آنها باید اطمینان حاصل کنند که یک چشم‌انداز برای معماری وجود دارد که برای هدف مناسب است و به وضوح درک شده است—یک چشم‌انداز معماری که نیازهای سیستم و کاربران آن و همچنین نیازهای افرادی که خودشان روی سیستم کار می‌کنند را برآورده می‌کند. نگاه کردن به تنها یک جنبه—به عنوان مثال، منطقی اما نه فیزیکی، شکل اما نه تجربه توسعه‌دهنده—کارایی یک معمار را محدود می‌کند. اگر شما می‌پذیرید که معماری در مورد درک سیستم است، پس محدود کردن دامنه آنچه به آن اهمیت می‌دهید، توانایی شما را در استدلال و ایجاد تغییرات محدود می‌کند.
   معماری می‌تواند برای افرادی که با آن زندگی می‌کنند، نامرئی باشد. می‌تواند آنقدر ناچیز باشد که واقعاً وجود نداشته باشد. می‌تواند چیزی باشد که راهنمایی می‌کند و به دستیابی به نتیجه صحیح کمک می‌کند. این می‌تواند خفه‌کننده و سلطه‌گر باشد. این می‌تواند شما را خوشحال کند، بدون اینکه متوجه شوید که حتی یک چیز است، و روح را از شما بگیرد بدون اینکه هیچ سوء نیتی در نظر گرفته شده باشد. بنابراین، خواه معماری "درباره چیزهای مهم" باشد یا نه، مطمئناً مهم است.</p>
<p>نقل قول مختصر دیگری که اغلب برای تعریف معماری <strong>software</strong> استفاده می‌شود، از همان مقاله‌ای می‌آید که در آن <em>Martin</em> نظرات <em>Ralph</em> را به اشتراک می‌گذارد: "بنابراین شما ممکن است در نهایت معماری را به عنوان چیزهایی تعریف کنید که مردم تغییر دادن آنها را دشوار می‌دانند." ایده <em>Martin</em> مبنی بر اینکه معماری چیزی است که تغییر دادن آن سخت است، در سطحی منطقی است و ما را به مفهوم معماری در محیط ساخته شده باز می‌گرداند. جایی که تغییر دادن چیزها سخت‌تر است، آنها به فکر قبلی بیشتری نیاز دارند تا واقعاً مطمئن شوند که ما در مسیر درست قرار داریم. اما یک مشکل با اتخاذ یک تعریف ساده از یک ایده پیچیده و اجرای آن به عنوان یک تعریف کاری وجود دارد—اگر این بیانیه کاملاً</p>
<p>528 | فصل 16: معمار تکاملی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0554</div>
            </div>
        </div>
        <!-- Page 0555 -->
        <div class="chapter" id="page-0555">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>معماری <em>software</em> تکاملی (ادامه)</h4>
<p>اگر شما به این فکر می‌کنید که معماری <strong>software</strong> چگونه است، چیزهای زیادی را از دست خواهید داد. بله، مقدار زیادی از معماری <strong>software</strong> در مورد فکر کردن در مورد چیزهایی است که تغییر دادن آنها دشوار خواهد بود، اما همچنین در مورد ایجاد فضا برای اجازه دادن به تغییر در طراحی است.</p>
<h4>ایجاد تغییر ممکن است</h4>
<p>بازگشت به دنیای ساختمان‌ها به جای سیستم‌های <strong>software</strong>: معمار <em>Mies van der Rohe</em>، به طور قطع، برای پیشگامی در آنچه ما اکنون به عنوان آسمان‌خراش مدرن فکر می‌کنیم، بیشتر از هر معمار دیگری کار انجام داد—ساختمان معروف <em>Seagram</em> او، به عنوان طرحی برای بسیاری از آنچه بعداً آمد، تبدیل شد. ساختمان <em>Seagram</em> با بسیاری از آنچه که قبلاً آمده بود، متفاوت است. دیوارهای بیرونی ساختمان، غیرساختاری هستند—آنها یک قاب بیرونی فولادی را احاطه کرده‌اند. خدمات اصلی ساختمان—آسانسور،3 راه‌پله‌ها، تهویه مطبوع، آب و فاضلاب، و سیستم برق—از طریق یک هسته مرکزی بتنی اجرا می‌شوند. ساخت یک آسمان‌خراش مدرن امروزی را تماشا کنید، و این هسته بتنی مرکزی است که ابتدا ساخته می‌شود، یک جرثقیل غول‌پیکر که اغلب در بالای آن دیده می‌شود. هر طبقه از ساختمان <em>Seagram</em> دارای دیوارهای ساختاری داخلی نیست—این بدان معناست که شما در مورد نحوه استفاده از فضا انعطاف‌پذیری کامل دارید. شما می‌توانید فضا را آنطور که صلاح می‌دانید، دوباره پیکربندی کنید، سیم‌کشی برق و تهویه مطبوع را به قسمت‌های مختلف هر طبقه از طریق سقف‌های معلق و مجراها در خود کف، هدایت کنید.</p>
<p>جالب است که توجه داشته باشید که ساختمان <em>Seagram</em> با استفاده از فرآیندی توسعه یافت که در آن طراحی ساختمان در حین ساخت‌وساز تکامل یافت. حالا ما این ایده را کجا دیده‌ایم؟
   ایده این طرح این بود که آنچه <em>Mies van der Rohe</em> آن را "فضای جهانی" می‌نامید ارائه کند—یک حجم بزرگ با یک دهانه که می‌تواند برای پاسخگویی به نیازهای مختلف دوباره پیکربندی شود. استفاده از ساختمان‌ها تغییر می‌کند، بنابراین ایده این بود که فضایی را ارائه دهیم که تا حد امکان از نظر نحوه استفاده انعطاف‌پذیر باشد. به این ترتیب، <em>Mies van der Rohe</em> نه تنها مجبور بود بر زیبایی‌شناسی اساسی ساختمان تمرکز کند، و فضایی را برای خدمات اصلی پیدا کند که تغییر آن بعداً دشوار یا غیرممکن خواهد بود، بلکه او همچنین مجبور بود اطمینان حاصل کند که می‌توان از ساختمان به روش‌های مختلفی نسبت به آنچه در ابتدا پیش‌بینی شده بود، استفاده کرد.
   به زودی، ما به این موضوع نگاه خواهیم کرد که چگونه در فضای یک معماری <strong>microservice</strong>، امکان تغییر را فراهم می‌کنیم.</p>
<h4>یک چشم‌انداز تکاملی برای معمار</h4>
<p>الزامات ما به عنوان معماران <strong>software</strong>، سریع‌تر از افرادی که ساختمان‌ها را طراحی و می‌سازند، تغییر می‌کند—همانند ابزارها و تکنیک‌هایی که در اختیار داریم. چیزهایی که ما ایجاد می‌کنیم، نقاط ثابتی در زمان نیستند. <strong>Software</strong> ما پس از راه‌اندازی در تولید، همچنان با تغییر نحوه استفاده از آن تکامل می‌یابد. برای اکثر چیزهایی که ما</p>
<p>ایجاد تغییر ممکن است | 529</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0555</div>
            </div>
        </div>
        <!-- Page 0556 -->
        <div class="chapter" id="page-0556">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>معمار <em>software</em> تکاملی (ادامه)</h4>
<p><em>architecture</em> است، ما باید بپذیریم که پس از اینکه <strong>software</strong> به دست کاربران ما رسید، ما باید واکنش نشان دهیم و سازگار شویم، نه اینکه انتظار یک <em>artifact</em> بدون تغییر را داشته باشیم. بنابراین، معماران <strong>software</strong> باید تفکر خود را از ایجاد محصول نهایی عالی تغییر دهند و در عوض بر کمک به ایجاد چارچوبی تمرکز کنند که در آن سیستم‌های مناسب بتوانند ظهور کرده و با یادگیری بیشتر به رشد خود ادامه دهند.</p>
<p>اگرچه من بخش زیادی از این فصل را صرف دلسرد کردن مقایسه‌ها با سایر مشاغل کرده‌ام، اما یک تشبیه وجود دارد که در مورد نقش معمار <em>IT</em> دوست دارم و فکر می‌کنم این جنبه از نقش را به خوبی در بر می‌گیرد. <em>Erik Doernenburg</em> در <em>Thoughtworks</em>، اولین بار این ایده را با من در میان گذاشت که ما باید به نقش معمار بیشتر به عنوان برنامه‌ریز شهری فکر کنیم تا معمار محیط ساخته‌شده. نقش برنامه‌ریز شهری باید برای هر یک از شما که قبلاً <em>SimCity</em> یا <em>Cities: Skylines</em> بازی کرده‌اید، آشنا باشد. نقش یک برنامه‌ریز شهری این است که به انبوهی از منابع اطلاعاتی نگاه کند و سپس تلاش کند تا طرح یک شهر را به بهترین وجه برای نیازهای شهروندان امروزی بهینه کند، در حالی که استفاده‌های آینده را نیز در نظر می‌گیرد. با این حال، نحوه تأثیر آنها بر نحوه تکامل شهر جالب است. آنها نمی‌گویند، "این ساختمان خاص را در آنجا بسازید"؛ در عوض، آنها مناطقی را تعریف می‌کنند که امکان تصمیم‌گیری محلی را در محدودیت‌های معینی فراهم می‌کند. بنابراین، همانطور که در <em>SimCity</em>، شما ممکن است بخشی از شهر خود را به عنوان یک منطقه صنعتی، و بخش دیگری را به عنوان یک منطقه مسکونی تعیین کنید. سپس به دیگران بستگی دارد که تصمیم بگیرند چه ساختمان‌هایی ایجاد شوند، اما محدودیت‌هایی وجود دارد: اگر می‌خواهید یک کارخانه بسازید، باید در یک منطقه صنعتی باشد. به جای اینکه بیش از حد در مورد آنچه در یک منطقه اتفاق می‌افتد، نگران باشید، برنامه‌ریز شهری زمان بسیار بیشتری را صرف این می‌کند که چگونه مردم و تأسیسات از یک منطقه به منطقه دیگر منتقل می‌شوند.</p>
<p>بیش از یک نفر، یک شهر را به یک موجود زنده تشبیه کرده است. شهر در طول زمان تغییر می‌کند. همانطور که ساکنان آن به روش‌های مختلف از آن استفاده می‌کنند، یا نیروهای خارجی آن را شکل می‌دهند، این شهر تغییر می‌کند و تکامل می‌یابد. برنامه‌ریز شهری تمام تلاش خود را برای پیش‌بینی این تغییرات انجام می‌دهد، اما می‌پذیرد که تلاش برای اعمال کنترل مستقیم بر تمام جنبه‌های آنچه اتفاق می‌افتد، بی‌فایده است. بنابراین معماران ما به عنوان برنامه‌ریزان شهری باید جهت‌گیری را در ضربات گسترده تعیین کنند و فقط در موارد محدود در جزئیات پیاده‌سازی بسیار خاص دخالت کنند. آنها باید اطمینان حاصل کنند که سیستم در حال حاضر برای هدف مناسب است، اما همچنین بستری برای آینده است.
   مقایسه با <strong>software</strong> باید آشکار باشد. همانطور که کاربران ما از <strong>software</strong> ما استفاده می‌کنند، ما باید واکنش نشان دهیم و تغییر کنیم. ما نمی‌توانیم همه چیزهایی را که اتفاق می‌افتد پیش‌بینی کنیم، و بنابراین به جای برنامه‌ریزی برای هر احتمال، ما باید برنامه‌ریزی کنیم تا با اجتناب از میل به <em>overspecify</em> کردن هر چیز آخر، به تغییر اجازه دهیم. شهر ما—سیستم—باید مکان خوبی برای همه کسانی باشد که از آن استفاده می‌کنند.</p>
<h4>تعریف مرزهای سیستم</h4>
<p>برای ادامه استعاره از معمار به عنوان برنامه‌ریز شهری برای لحظه‌ای، مناطق ما چه هستند؟ اینها مرزهای <strong>microservice</strong> ما هستند، یا شاید گروه‌های <strong>microservices</strong> <em>coarse-grained</em>. به عنوان معمار، ما باید بسیار کمتر نگران این باشیم که</p>
<p>معمار <strong>software</strong> تکاملی | 530</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0556</div>
            </div>
        </div>
        <!-- Page 0557 -->
        <div class="chapter" id="page-0557">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تعریف مرزهای سیستم (ادامه)</h4>
<p>در داخل یک منطقه اتفاق می‌افتد و بیشتر در مورد آنچه بین مناطق اتفاق می‌افتد. این بدان معناست که ما باید زمان خود را صرف فکر کردن در مورد نحوه صحبت <strong>microservices</strong> ما با یکدیگر و اطمینان از اینکه می‌توانیم به درستی سلامت کلی سیستم خود را نظارت کنیم، کنیم. از فضای معماری، این است که چگونه ما فضای جهانی خود را ایجاد می‌کنیم—با تعریف برخی از مرزهای خاص، ما به همکاران خود که سیستم را می‌سازند، مناطقی را که در آنها تغییرات می‌تواند آزادانه‌تر بدون شکستن جنبه اساسی معماری ما ایجاد شود، برجسته می‌کنیم.</p>
<p>برای نگاهی به یک مثال بسیار ساده، در شکل 16-1 <strong>microservice</strong> توصیه‌ها را می‌بینیم که به اطلاعاتی از <strong>microservices</strong> تبلیغات و فروش دسترسی دارد. همانطور که ما قبلاً به طور گسترده پوشش داده‌ایم، ما می‌توانیم عملکرد پنهان شده در داخل این سه <strong>microservices</strong> را تغییر دهیم، بدون نگرانی در مورد شکستن سیستم کلی—من می‌توانم هر چیزی را که می‌خواهم در فروش یا تبلیغات تغییر دهم تا زمانی که همچنان انتظاراتی را که توصیه‌ها در مورد چگونگی تعامل با این <strong>microservices</strong> پایین‌دستی دارند، حفظ کنم.</p>
<p>شکل 16-1. تغییرات در داخل مرز <strong>microservice</strong> آسان است، تا زمانی که تعاملات بین <strong>microservices</strong> تغییر نکند</p>
<p>ما می‌توانیم فضا را برای تغییر در سطوح بزرگ‌تر نیز ایجاد کنیم. در شکل 16-2، ما <strong>microservices</strong> را از شکل 16-1 می‌بینیم که در واقع در یک منطقه بازاریابی وجود دارند که به مسئولیت یک تیم خاص متصل می‌شود. ما یک رفتار مورد انتظار را از نظر نحوه تعامل عملکرد بازاریابی با سیستم بزرگتر تعریف کرده‌ایم. در داخل منطقه بازاریابی، ما می‌توانیم هر تغییری را که می‌خواهیم ایجاد کنیم، تا زمانی که سازگاری با سیستم بزرگتر حفظ شود. با بازگشت به ایده درک اینکه چه چیزهایی تغییر دادن آنها دشوار است، ساختارهای سازمانی اغلب در این دسته قرار می‌گیرند، و به این ترتیب ساختارهای تیم موجود می‌توانند به شما در تعریف این مناطق کمک کنند. هماهنگی تغییرات در یک</p>
<p>تعریف مرزهای سیستم | 531</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 557" src="page_0557/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0557</div>
            </div>
        </div>
        <!-- Page 0558 -->
        <div class="chapter" id="page-0558">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تعریف مرزهای سیستم (ادامه)</h4>
<p>تیمی در <strong>microservices</strong>، متعلق به آن تیم، آسان‌تر از تغییر تعاملاتی خواهد بود که در معرض دید سایر تیم‌ها قرار می‌گیرد.
   شکل 16-2. ایجاد تغییرات در داخل یک منطقه آسان‌تر از تغییرات بین مناطق است</p>
<p>این موضوع به خوبی با مفهوم <strong>API</strong> تیم مرتبط است، که ما در "تیم‌های کوچک، سازمان بزرگ" در صفحه 496 در مورد آن بحث کردیم. یک معمار می‌تواند به تسهیل ایجاد یک <strong>API</strong> تیم کمک کند، و اطمینان حاصل کند که <strong>microservices</strong> و شیوه‌های کاری تیم با سازمان گسترده‌تر مطابقت دارد.
   با تعریف فضاهایی که در آنها می‌توان این تغییرات را بدون به خطر انداختن کل سیستم ایجاد کرد، ما زندگی توسعه‌دهندگان را آسان‌تر می‌کنیم و همچنین توجه خود را بر روی بخش‌هایی از سیستم متمرکز می‌کنیم که تغییر دادن آنها دشوارتر است. مفهوم پنهان کردن اطلاعات را به یاد دارید که در فصل 2 بررسی کردیم؟ همانطور که در آنجا بررسی کردیم، پنهان کردن اطلاعات در داخل مرزهای <strong>microservice</strong>، ایجاد یک رابط پایدار را برای مصرف‌کنندگان بسیار آسان‌تر می‌کند. هنگامی که ما تغییراتی در <strong>microservice</strong> ایجاد می‌کنیم، اطمینان از اینکه ما سازگاری را با مصرف‌کنندگان خارجی از بین نبرده‌ایم، آسان‌تر است. در اینجا، ما می‌توانیم معماری را تعریف کنیم تا پنهان کردن اطلاعات را در سطح تیم ارائه دهیم، نه فقط در سطح <strong>microservice</strong>. این به ما یک سطح دیگر از پنهان کردن اطلاعات می‌دهد و یک فضای امن بزرگتر ایجاد می‌کند که در آن یک تیم می‌تواند تغییرات محلی را بدون از بین بردن سیستم گسترده‌تر ایجاد کند.</p>
<p>در داخل هر <strong>microservice</strong> یا منطقه بزرگتر، شما ممکن است با تیمی که مالک آن منطقه است، موافق باشید که یک <em>technology stack</em> یا <em>data store</em> متفاوت را انتخاب کند. نگرانی‌های دیگر ممکن است شروع شود</p>
<p>532 | فصل 16: معمار تکاملی</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 558" src="page_0558/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0558</div>
            </div>
        </div>
        <!-- Page 0559 -->
        <div class="chapter" id="page-0559">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>یک رویکرد ترکیبی (ادامه)</h4>
<p>در اینجا، البته. تمایل شما برای اینکه به تیم‌ها اجازه دهید ابزار مناسب را برای کار انتخاب کنند، ممکن است با این واقعیت تعدیل شود که اگر 10 <em>technology stacks</em> مختلف برای پشتیبانی داشته باشید، استخدام افراد یا انتقال آنها بین تیم‌ها سخت‌تر می‌شود. به طور مشابه، اگر هر تیم یک <em>data store</em> کاملاً متفاوت را انتخاب کند، ممکن است خود را فاقد تجربه کافی برای اجرای هر یک از آنها در مقیاس بدانید. به عنوان مثال، <em>Netflix</em> عمدتاً در <em>Cassandra</em> به عنوان یک فناوری <em>data-store</em> استاندارد شده است. اگرچه ممکن است بهترین گزینه برای همه موارد نباشد، <em>Netflix</em> احساس می‌کند که ارزش به دست آمده با ایجاد ابزار و تخصص در اطراف <em>Cassandra</em> مهم‌تر از این است که مجبور شود از چندین پلتفرم دیگر که ممکن است برای وظایف خاص مناسب‌تر باشند، پشتیبانی و اداره کند. <em>Netflix</em> یک مثال افراطی است، جایی که مقیاس احتمالاً قوی‌ترین عامل غالب است، اما شما ایده را دریافت می‌کنید.</p>
<p>با این حال، جایی که کارها می‌تواند آشفته شود، بین <strong>microservices</strong> است. اگر یک <strong>microservice</strong> تصمیم بگیرد که <em>REST</em> را از طریق <em>HTTP</em> ارائه دهد، دیگری از <em>gRPC</em> استفاده می‌کند، و سومی از <em>Java RMI</em> استفاده می‌کند، در این صورت ادغام می‌تواند به یک کابوس تبدیل شود، زیرا <strong>microservices</strong> مصرف‌کننده باید چندین سبک مبادله را درک و پشتیبانی کنند. به همین دلیل است که من سعی می‌کنم به این دستورالعمل پایبند باشم که ما باید "نگران آنچه در داخل <strong>boxes</strong> اتفاق می‌افتد باشیم، و در مورد آنچه در داخل اتفاق می‌افتد، آزاد باشیم."</p>
<p>بنابراین یک معماری موفق، به همان اندازه در مورد اجازه دادن به تغییر برای پاسخگویی به نیازهای کاربران ما است. اما یک چیز که مردم اغلب فراموش می‌کنند این است که سیستم ما فقط از کاربران استقبال نمی‌کند. این سیستم همچنین افرادی را که در واقع <strong>software</strong> را خودشان می‌سازند، در خود جای می‌دهد. یک معماری موفق همچنین به ایجاد یک محیط مناسب برای انجام کار ما کمک می‌کند.</p>
<h4>یک ساختار اجتماعی</h4>
<p>هیچ برنامه‌ای با تماس با دشمن زنده نمی‌ماند.</p>
<p>—<em>Helmuth von Moltke</em> (به شدت <em>paraphrased</em> شده)</p>
<p>بنابراین شما در مورد چشم‌انداز، در مورد محدودیت‌ها، و در مورد آنچه که باید انجام دهید، فکر کرده‌اید. شما فکر می‌کنید که می‌دانید چه چیزی تغییر دادن آن سخت خواهد بود، و فضاهایی که در آنها باید تغییر ایجاد کنید. حالا چه؟ خوب، معماری همان چیزی است که اتفاق می‌افتد، نه آنچه شما فکر می‌کنید باید اتفاق بیفتد—این تفاوت بین چشم‌انداز و واقعیت است. معماران محیط ساخته‌شده باید با افرادی که ساختمان را می‌سازند کار کنند تا به آنها کمک کنند که چشم‌انداز چیست را درک کنند، بلکه همچنین برنامه را زمانی که واقعیت، آن چشم‌انداز را به چالش می‌کشد، تغییر دهند. این امکان وجود دارد که آنچه شما فکر می‌کنید امکان‌پذیر است، اساساً امکان‌پذیر نباشد. اگر یک معمار تا حدودی در کنار افرادی که سیستم را ایجاد می‌کنند، تعبیه نشده باشد، در این صورت آنها نمی‌توانند به برقراری ارتباط چشم‌انداز با افرادی که کار را انجام می‌دهند کمک کنند، و نه معمار درک خواهد کرد که کجا این چشم‌انداز دیگر برای هدف مناسب نیست. گروه ساخت‌وساز ممکن است در زمین با چیزهایی مواجه شوند که پیش‌بینی نشده بودند، یا شاید کمبود عرضه باعث شود که از نظر طراحی تجدیدنظر شود.</p>
<p>یک ساختار اجتماعی | 533</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0559</div>
            </div>
        </div>
        <!-- Page 0560 -->
        <div class="chapter" id="page-0560">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>یک ساختار اجتماعی (ادامه)</h4>
<p>معماری، آنچه اتفاق می‌افتد، نه آنچه که برنامه‌ریزی شده است. اگر به عنوان یک معمار، خود را از فرآیند قرار دادن این چشم‌انداز در جای خود حذف کنید، در این صورت شما یک معمار نیستید—شما یک رویاپرداز هستید. معماری که ظهور خواهد کرد، ممکن است هیچ ارتباطی با آنچه شما می‌خواهید، نداشته باشد. این اتفاق با شما یا بدون شما خواهد افتاد. پیاده‌سازی یک معماری نیازمند کار افراد زیادی و مجموعه‌ای از تصمیمات، بزرگ و کوچک است.
   همانطور که <em>Grady Booch</em> بیان کرد:4</p>
<p>در ابتدا، معماری یک سیستم فشرده <strong>software</strong>، بیانیه‌ای از چشم‌انداز است. در پایان، معماری هر یک از این سیستم‌ها، بازتابی از میلیاردها تصمیمات طراحی کوچک و بزرگ، عمدی و تصادفی است که در طول مسیر گرفته شده است.</p>
<p>این بدان معناست که حتی اگر شما یک فرد اختصاصی داشته باشید که در نهایت مسئول معماری است، افراد زیادی مسئول اجرای این چشم‌انداز هستند. پیاده‌سازی یک معماری موفق، یک تلاش تیمی خواهد بود. با بازگشت به نقل قول <em>Ralph Johnson</em> که قبلاً ذکر شد، "معماری یک ساختار اجتماعی است." یک مثال عالی از این موضوع از <em>Comcast</em> می‌آید، که تجربیات خود را در مورد چگونگی غیرمتمرکز کردن تصمیم‌گیری از طریق استفاده از یک صنف معماری به اشتراک گذاشته است.5 با توجه به مقیاس آن، <em>Comcast</em> تصمیم گرفت از تجربیات گروه‌های هدایتگر صنعت استفاده کند، که در آن تصمیم‌گیری جمعی کلیدی است:</p>
<p>در <em>Comcast</em> ما متوجه شدیم که این مشکل بسیار شبیه به نحوه عملکرد نهادهای استانداردهای باز است: متقاعد کردن چندین گروه خودمختار برای توافق بر سر رویکردهای فنی.
   ما یک صنف معماری داخلی را طراحی کردیم که صریحاً بر اساس یک نهاد استاندارد بسیار موفق، <em>Internet Engineering Task Force (IETF)</em>، که بسیاری از پروتکل‌های مهم اینترنت را تعریف می‌کند، مدل‌سازی شده است.</p>
<p>—<em>Jon Moore</em>، معمار ارشد <strong>software</strong> در <em>Comcast Cable</em></p>
<p>رویکرد <em>Comcast</em> دارای درجه‌ای از رسمیت است که برخی از سازمان‌ها ممکن است آن را دشوار بدانند، اما به نظر می‌رسد برای این شرکت با توجه به اندازه و توزیع آن، خوب کار می‌کند.</p>
<h4>سکونت‌پذیری</h4>
<p>یکی دیگر از مفاهیمی که از محیط ساخته شده می‌آید و در زمینه توسعه <strong>software</strong> طنین‌انداز می‌شود، سکونت‌پذیری است. من برای اولین بار این اصطلاح را از <em>Frank Buschmann</em> آموختم—او توضیح داد که یک معمار مسئول اطمینان از این است که محیطی که ایجاد می‌کنند، برای کار کردن خوب است. اگر معماری، چارچوب سیستم باشد، که نحوه قرار گرفتن چیزهای سخت برای تغییر را در کنار هم توصیف می‌کند، در این صورت</p>
<p>524 | فصل 16: معمار تکاملی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0560</div>
            </div>
        </div>
        <!-- Page 0561 -->
        <div class="chapter" id="page-0561">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>سکونت‌پذیری (ادامه)</h4>
<p>6 <em>Richard Gabriel</em>, <em>Patterns of Software: Tales from the Software Community</em> (New York: <em>Oxford University Press</em>، 1996).</p>
<p>همچنین زمان‌هایی وجود دارد که محدودیت‌هایی ممکن است لازم باشد اعمال شود. با این حال، اگر این را اشتباه انجام دهید، کار در سیستم می‌تواند دردناک و مستعد خطا شود.
   همانطور که <em>Richard Gabriel</em>، نویسنده <em>Patterns of Software</em>، توضیح می‌دهد:</p>
<p>سکونت‌پذیری، ویژگی کد منبع است که برنامه‌نویسانی را که در اواخر عمر خود به کد می‌رسند، قادر می‌سازد تا ساختار و مقاصد آن را درک کنند و با راحتی و اطمینان آن را تغییر دهند.</p>
<p>با این حال، یک اکوسیستم توسعه <strong>software</strong> مدرن، چیزی بیش از کد را شامل می‌شود—این فراتر از این به فناوری‌هایی که استفاده می‌کنیم و شیوه‌های کاری که اتخاذ می‌کنیم، گسترش می‌یابد. من اغلب دیده‌ام که توسعه‌دهندگان، فناوری را که به آنها گفته می‌شود استفاده کنند را لعنت می‌کنند—اغلب فناوری‌ای که توسط افرادی انتخاب می‌شود که هرگز مجبور نیستند از آن استفاده کنند. هرچه تکامل معماری و انتخاب ابزارها و فناوری که استفاده می‌کنید را به یک فرآیند مشارکتی تبدیل کنید، اطمینان از اینکه نتیجه نهایی یک محیط قابل سکونت است که در آن افرادی که سیستم را می‌سازند، در کار خود احساس شادی و بهره‌وری می‌کنند، آسان‌تر خواهد بود.
   اگر قرار است اطمینان حاصل کنیم که سیستم‌هایی که ایجاد می‌کنیم برای توسعه‌دهندگان ما قابل سکونت هستند، پس معماران و سایر تصمیم‌گیرندگان ما باید تأثیر تصمیمات خود را درک کنند. حداقل، این بدان معناست که زمان را با تیم سپری کنید، و در حالت ایده‌آل، زمان را صرف کدنویسی با تیم کنید. برای کسانی از شما که <em>pair programming</em> را تمرین می‌کنید، پیوستن یک معمار به یک تیم برای مدت کوتاهی به عنوان یک عضو از یک جفت، یک موضوع ساده می‌شود. مشارکت در تمرینات برنامه‌نویسی گروهی نیز می‌تواند مزایای قابل توجهی را به همراه داشته باشد، اگرچه یک معمار که در چنین فعالیت گروهی شرکت می‌کند، باید از این آگاه باشد که حضور آنها چگونه می‌تواند پویایی گروه را تغییر دهد.
   در حالت ایده‌آل، شما باید روی وظایف عادی کار کنید تا واقعاً درک کنید که کار "عادی" چگونه است. من نمی‌توانم تأکید کنم که چقدر مهم است که معمار واقعاً زمان خود را با تیم‌هایی که سیستم را می‌سازند، سپری کند! این امر به‌طور قابل‌توجهی مؤثرتر از داشتن یک تماس یا فقط نگاه کردن به کد آنها است. در مورد اینکه چند وقت یک‌بار باید این کار را انجام دهید، این تا حد زیادی به اندازه تیم(هایی) که با آنها کار می‌کنید، بستگی دارد. اما نکته کلیدی این است که این یک فعالیت روتین باشد. به عنوان مثال، اگر شما با چهار تیم کار می‌کنید، شاید اطمینان حاصل کنید که هر چهار هفته نیم روز را با هر تیم سپری می‌کنید، و با آنها روی وظایف تحویل خود کار می‌کنید تا اطمینان حاصل کنید که آگاهی و ارتباطات بهبود یافته را با تیم‌هایی که با آنها کار می‌کنید، ایجاد می‌کنید.</p>
<p>سکونت‌پذیری | 535</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0561</div>
            </div>
        </div>
        <!-- Page 0562 -->
        <div class="chapter" id="page-0562">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>یک رویکرد اصولی</h4>
<p>قوانین برای اطاعت از احمق‌ها و هدایت خردمندان هستند.</p>
<p>—<em>Generally attributed to Douglas Bader</em></p>
<p>تصمیم‌گیری در طراحی سیستم، همه چیز در مورد مبادلات است، و معماری‌های <strong>microservice</strong>، مبادلات زیادی را برای ایجاد در اختیار ما می‌گذارند! هنگام انتخاب یک <em>data store</em>، آیا ما پلتفرمی را انتخاب می‌کنیم که تجربه کمتری با آن داریم اما مقیاس‌بندی بهتری به ما می‌دهد؟ آیا اشکالی ندارد که ما دو <em>technology stacks</em> مختلف در سیستم خود داشته باشیم؟ در مورد سه چطور؟ برخی از تصمیمات را می‌توان کاملاً در لحظه با اطلاعات موجود برای ما اتخاذ کرد، و اینها آسان‌ترین تصمیمات برای اتخاذ هستند. اما در مورد آن تصمیماتی که ممکن است با اطلاعات ناقص گرفته شوند، چطور؟</p>
<p><em>Framing</em> می‌تواند در اینجا کمک کند، و یک راه عالی برای کمک به <em>frame</em> کردن تصمیم‌گیری ما این است که مجموعه‌ای از اصول و رویه‌ها را که آن را هدایت می‌کنند، بر اساس اهدافی که در تلاش برای دستیابی به آنها هستیم، تعریف کنیم. بیایید به هر یک از این جنبه‌های <em>framing</em> به نوبت نگاهی بیندازیم.</p>
<h4>اهداف استراتژیک</h4>
<p>نقش معمار در حال حاضر به اندازه کافی دلهره‌آور است، بنابراین خوشبختانه ما معمولاً مجبور نیستیم اهداف استراتژیک را نیز تعریف کنیم! اهداف استراتژیک باید در مورد جایی که شرکت شما در حال رفتن به آن است و چگونگی دیدگاه خود در مورد بهترین راه‌ها برای خوشحال کردن مشتریانش، صحبت کنند. اینها اهداف سطح بالا خواهند بود و ممکن است اصلاً شامل فناوری نباشند. آنها می‌توانند در سطح شرکت یا سطح یک بخش تعریف شوند. آنها ممکن است مواردی مانند "توسعه در جنوب شرقی آسیا برای باز کردن بازارهای جدید" یا "اجازه دهید مشتری تا حد امکان با استفاده از خود-سرویس به اهداف خود برسد" باشند. نکته کلیدی این است که آنها مشخص می‌کنند سازمان شما به کجا می‌رود، بنابراین شما باید اطمینان حاصل کنید که فناوری با آن همسو شده است.</p>
<p>اگر شما شخصی هستید که چشم‌انداز فنی شرکت را تعریف می‌کنید، این ممکن است به این معنی باشد که شما باید زمان بیشتری را با بخش‌های غیرفنی سازمان خود (یا "کسب‌وکار"، همانطور که اغلب نامیده می‌شود) سپری کنید. چشم‌انداز محرک برای کسب‌وکار چیست؟ و چگونه تغییر می‌کند؟</p>
<h4>اصول</h4>
<p>اصول، قوانینی هستند که شما برای هم‌راستایی آنچه انجام می‌دهید با برخی از اهداف بزرگتر ایجاد کرده‌اید، و آنها گاهی اوقات تغییر خواهند کرد. به عنوان مثال، اگر یکی از اهداف استراتژیک شما به عنوان یک سازمان، کاهش زمان ورود به بازار برای ویژگی‌های جدید است، شما ممکن است اصلی را تعریف کنید که می‌گوید تیم‌های تحویل، کنترل کاملی در طول چرخه حیات <strong>software</strong> خود برای ارائه در هر زمان که آماده هستند، به طور مستقل از هر تیم دیگری دارند. اگر هدف دیگری این است که سازمان شما به طور تهاجمی پیشنهادات خود را در کشورهای دیگر توسعه دهد، شما ممکن است تصمیم بگیرید که اصلی را پیاده‌سازی کنید که کل سیستم باید قابل حمل باشد تا اجازه داده شود که به صورت محلی مستقر شود تا به حاکمیت داده احترام گذاشته شود.</p>
<p>536 | فصل 16: معمار تکاملی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0562</div>
            </div>
        </div>
        <!-- Page 0563 -->
        <div class="chapter" id="page-0563">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>یک رویکرد اصولی (ادامه)</h4>
<p>شما احتمالاً به تعداد زیادی از اینها نیاز ندارید. کمتر از 10 اصل یک عدد خوب است—به اندازه کافی کوچک است تا مردم آنها را به خاطر بسپارند، یا در پوسترهای کوچک جا شوند. هرچه اصول بیشتری داشته باشید، احتمال اینکه آنها با یکدیگر همپوشانی داشته باشند یا با هم در تناقض باشند، بیشتر می‌شود.</p>
<p><em>Twelve Factors</em> <em>Heroku</em> مجموعه‌ای از اصول طراحی است که حول هدف کمک به شما در ایجاد برنامه‌هایی که به خوبی روی پلتفرم <em>Heroku</em> کار می‌کنند، ساختار یافته‌اند. این اصول ممکن است در زمینه‌های دیگر نیز منطقی باشند. برخی از آنها در واقع محدودیت‌هایی هستند که بر اساس رفتارهایی که برنامه شما برای کار کردن در <em>Heroku</em> باید نشان دهد، اعمال می‌شود. یک محدودیت واقعاً چیزی است که تغییر دادن آن بسیار سخت (یا تقریباً غیرممکن) است، در حالی که اصول، چیزهایی هستند که ما تصمیم می‌گیریم انتخاب کنیم. شما ممکن است تصمیم بگیرید که به صراحت آن چیزهایی را که اصول هستند در مقابل آنهایی که محدودیت هستند، مشخص کنید تا به برجسته کردن آن چیزهایی که واقعاً نمی‌توانید تغییر دهید، کمک کنید. شخصاً، فکر می‌کنم ممکن است ارزش داشته باشد که آنها را در یک لیست نگه دارید، تا گاهی اوقات محدودیت‌ها را به چالش بکشید و ببینید که آیا واقعاً غیرقابل‌تغییر هستند یا خیر!</p>
<h4>عملکردها</h4>
<p>عملکردها، این هستند که چگونه ما اطمینان حاصل می‌کنیم که اصول ما اجرا می‌شوند. آنها مجموعه‌ای از دستورالعمل‌های عملی و دقیق برای انجام کارها هستند. آنها اغلب مختص فناوری خواهند بود و باید به اندازه‌ای سطح پایین باشند که هر توسعه‌دهنده‌ای بتواند آنها را درک کند.
   عملکردها می‌توانند شامل دستورالعمل‌های کدنویسی، این واقعیت باشند که تمام داده‌های <em>log</em> باید به صورت مرکزی ثبت شوند، یا این واقعیت که <em>HTTP/REST</em> سبک ادغام استاندارد است. به دلیل ماهیت فنی آنها، عملکردها معمولاً بیشتر از اصول تغییر می‌کنند.
   همانند اصول، گاهی اوقات عملکردها، محدودیت‌هایی را در سازمان شما منعکس می‌کنند. به عنوان مثال، اگر شما تصمیم به انتخاب <em>Azure</em> به عنوان پلتفرم <strong>cloud</strong> خود دارید، این موضوع باید در عملکردهای شما منعکس شود.</p>
<p>عملکردها باید مبنای اصول شما باشند. یک اصل که بیان می‌کند تیم‌های تحویل، کل چرخه حیات سیستم‌های خود را کنترل می‌کنند، ممکن است به این معنی باشد که شما یک عملکرد دارید که بیان می‌کند که همه <strong>microservices</strong> در حساب‌های <em>AWS</em> مجزا مستقر می‌شوند، و مدیریت خودکار منابع و جداسازی از سایر تیم‌ها را ارائه می‌دهند.</p>
<h4>ترکیب اصول و عملکردها</h4>
<p>اصول یک فرد، عملکردهای فرد دیگر است. شما ممکن است تصمیم بگیرید که به عنوان مثال، استفاده از <em>HTTP/REST</em> را یک اصل بنامید، نه یک عمل. و این خوب خواهد بود.
   نکته کلیدی این است که داشتن ایده‌های کلی که نحوه تکامل سیستم را هدایت می‌کنند، و داشتن جزئیات کافی به طوری که مردم بدانند چگونه آن ایده‌ها را پیاده‌سازی کنند، ارزش دارد. برای یک گروه به اندازه کافی کوچک، شاید یک تیم واحد، ترکیب اصول و عملکردها ممکن است خوب باشد. با این حال، برای سازمان‌های بزرگتر، جایی که فناوری و شیوه‌های کاری ممکن است از مکانی به مکان دیگر متفاوت باشد، شما ممکن است یک مجموعه متفاوت از عملکردها را در مکان‌های مختلف بخواهید، تا زمانی که همه آنها به مجموعه‌ای از اصول مشترک نگاشت شوند.
   به عنوان مثال، یک تیم <em>.NET</em> ممکن است یک مجموعه از عملکردها داشته باشد، و یک تیم <em>Java</em> دیگری. با این حال، اصول می‌توانند برای هر دو یکسان باشند.</p>
<p>یک رویکرد اصولی | 537</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0563</div>
            </div>
        </div>
        <!-- Page 0564 -->
        <div class="chapter" id="page-0564">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>یک مثال دنیای واقعی</h4>
<p>یک همکار قدیمی من، <em>Evan Bottcher</em>، نمودار نشان داده شده در شکل 16-3 را در طول کار با یکی از مشتریان خود توسعه داد. این شکل تعامل اهداف، اصول و عملکردها را در یک قالب بسیار واضح نشان می‌دهد. در طول چند سال، عملکردها در سمت راست دور، نسبتاً منظم تغییر می‌کنند، در حالی که اصول نسبتاً ثابت باقی می‌مانند. یک نمودار مانند این را می‌توان به خوبی روی یک ورق کاغذ واحد چاپ و به اشتراک گذاشت، و هر ایده به اندازه کافی ساده است که توسعه‌دهنده متوسط بتواند آن را به خاطر بسپارد. البته، جزئیات بیشتری پشت هر نکته وجود دارد، اما توانایی بیان این موضوع در قالب خلاصه بسیار مفید است.</p>
<p>شکل 16-3. یک مثال دنیای واقعی از اصول و عملکردها</p>
<p>منطقی است که مستنداتی برای پشتیبانی از برخی از این موارد وجود داشته باشد، و حتی بهتر از آن داشتن کد عملی است که نشان می‌دهد چگونه می‌توان این عملکردها را پیاده‌سازی کرد. در "پلتفرم" در صفحه 506، ما به این موضوع نگاه کردیم که چگونه ایجاد مجموعه‌ای مشترک از ابزارها می‌تواند انجام کار درست را برای توسعه‌دهندگان آسان کند—در حالت ایده‌آل، پلتفرم باید پیروی از این عملکردها را تا حد امکان آسان کند، و با تغییر عملکردها، پلتفرم باید بر این اساس تغییر کند.</p>
<p>538 | فصل 16: معمار تکاملی</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 564" src="page_0564/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0564</div>
            </div>
        </div>
        <!-- Page 0565 -->
        <div class="chapter" id="page-0565">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>معماری تکاملی</h4>
<p>7 <em>Neal Ford, Rebecca Parsons, and Patrick Kua</em>, <em>Building Evolutionary Architectures</em> (<em>Sebastopol</em>: <em>O’Reilly</em>, 2017).</p>
<h4>هدایت یک معماری تکاملی</h4>
<p>بنابراین اگر معماری ما ایستا نیست، بلکه همیشه در حال تغییر و تکامل است، چگونه مطمئن می‌شویم که به روشی که می‌خواهیم رشد و تغییر می‌کند، نه اینکه فقط به یک <em>blob</em> عظیم غیرقابل مدیریت از درد، رنج و سرزنش تبدیل شود؟ در <em>Building Evolutionary Architectures</em>،7 نویسندگان، <em>fitness functions</em> را برای کمک به جمع‌آوری اطلاعات در مورد "تناسب" نسبی معماری تشریح می‌کنند تا به معماران کمک کنند تا تصمیم بگیرند که آیا نیاز به اقدام دارند یا خیر. از کتاب:</p>
<p>محاسبات تکاملی شامل تعدادی از مکانیسم‌ها است که به یک راه‌حل اجازه می‌دهد تا به تدریج از طریق تغییرات کوچک در هر نسل از <strong>software</strong> ظهور کند. در هر نسل از راه‌حل، مهندس وضعیت فعلی را ارزیابی می‌کند: آیا به هدف نهایی نزدیک‌تر است یا دورتر؟ به عنوان مثال، هنگام استفاده از یک الگوریتم ژنتیکی برای بهینه‌سازی طراحی بال، <em>fitness function</em>، مقاومت در برابر باد، وزن، جریان هوا، و سایر ویژگی‌های مطلوب برای طراحی بال خوب را ارزیابی می‌کند. معماران، یک <em>fitness function</em> را تعریف می‌کنند تا توضیح دهند که بهتر چیست و به اندازه‌گیری زمان رسیدن به هدف کمک می‌کند. در <strong>software</strong>، <em>fitness functions</em> بررسی می‌کنند که آیا توسعه‌دهندگان ویژگی‌های معماری مهم را حفظ می‌کنند یا خیر.</p>
<p>ایده یک <em>fitness function</em> این است که از آن برای درک وضعیت فعلی برخی از ویژگی‌های مهم استفاده شود، به طوری که اگر آن ویژگی از برخی از محدودیت‌های مجاز خارج شود، در این صورت باید به تغییر آن رسیدگی شود. معمولاً، <em>fitness functions</em> برای اطمینان از اینکه معماری برای پیروی از اصول و محدودیت‌هایی که تعیین شده است، استفاده خواهد شد.</p>
<p>برای قرض گرفتن یک مثال از <em>Building Evolutionary Architectures</em>، نیاز به دریافت پاسخ از یک سرویس معین را در 100 میلی‌ثانیه یا کمتر در نظر بگیرید. شما می‌توانید یک <em>fitness function</em> را برای جمع‌آوری داده‌های عملکرد از این سرویس پیاده‌سازی کنید، شاید یا در یک محیط تست عملکرد یا از یک سیستم در حال اجرا در دنیای واقعی برای اطمینان از اینکه رفتار واقعی سیستم، الزامات را برآورده می‌کند.
   <em>Building Evolutionary Architectures</em> در مورد این موضوع، جزئیات بیشتری ارائه می‌دهد، و من اگر می‌خواهید این مفهوم را بیشتر بررسی کنید، آن را به طور کامل توصیه می‌کنم.
   <em>Fitness functions</em> برای معماری می‌توانند در اشکال و فرم‌های زیادی وجود داشته باشند. با این حال، مفهوم اساسی این است که شما داده‌های دنیای واقعی را جمع‌آوری می‌کنید تا درک کنید که آیا معماری شما "تناسب" را در برابر آن معیار به دست می‌آورد یا خیر. این می‌تواند مربوط به عملکرد سیستم، <strong>code coupling</strong>، زمان چرخه یا مجموعه‌ای از جنبه‌های دیگر باشد. این <em>fitness functions</em> به عنوان منبع دیگری از اطلاعات عمل می‌کنند تا به یک معمار کمک کنند تا درک کند که در کجا ممکن است نیاز به مشارکت داشته باشند. با این حال، لطفاً توجه داشته باشید که برای من، <em>fitness functions</em> زمانی بهترین عملکرد را دارند که با همکاری نزدیک با افرادی که سیستم را می‌سازند، ترکیب شوند. <em>Fitness functions</em> باید یک راه مفید برای کمک به شما در درک این باشد که آیا معماری در جهت درست حرکت می‌کند، اما آنها جایگزین نیاز به</p>
<p>هدایت یک معماری تکاملی | 539</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0565</div>
            </div>
        </div>
        <!-- Page 0566 -->
        <div class="chapter" id="page-0566">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>هدایت یک معماری تکاملی (ادامه)</h4>
<p>واقعاً با افراد حاضر در محل صحبت کنید. در واقع، من پیشنهاد می‌کنم که تعریف <em>fitness functions</em> مناسب، نیازمند همکاری نزدیک باشد.
   معماری در یک سازمان <strong>Stream-Aligned</strong></p>
<p>در فصل 15، ما به این موضوع نگاه کردیم که چگونه سازمان‌های تحویل <strong>software</strong> مدرن به سمت یک مدل <strong>stream-aligned</strong> بیشتر تغییر می‌کنند که در آن تیم‌های مستقل خودمختار بر تحویل <strong>end-to-end</strong> عملکرد تمرکز می‌کنند، و اولویت‌های آنها محصول‌محور است. ما همچنین در مورد تیم‌های <em>cross-cutting</em> صحبت کردیم—تیم‌های فعال‌کننده‌ای که از تیم‌های <strong>stream-aligned</strong> پشتیبانی می‌کنند. معمار در این دنیا کجا قرار می‌گیرد؟ خوب، گاهی اوقات دامنه یک تیم <strong>stream-aligned</strong> به اندازه‌ای پیچیده است که نیاز به یک معمار اختصاصی دارد (در اینجا ما اغلب یک تاری از مرزها را بین نقش‌های رهبر فنی سنتی و معمار می‌بینیم). با این حال، در بسیاری از موارد، از معماران خواسته می‌شود که در چندین تیم کار کنند.</p>
<p>بسیاری از مسئولیت‌های معمار را می‌توان به عنوان مسئولیت‌های فعال‌کننده دید—به‌وضوح چشم‌انداز فنی را منتقل کردن، درک چالش‌ها همانطور که ظاهر می‌شوند، و کمک به انطباق چشم‌انداز فنی بر این اساس. معمار به ارتباط افراد کمک می‌کند، به تصویر بزرگتر توجه دارد و به تیم‌ها کمک می‌کند تا درک کنند که آنچه انجام می‌دهند چگونه با کل بزرگتر مطابقت دارد. این به خوبی با ایده یک معمار که بخشی از یک تیم فعال‌کننده است، مطابقت دارد، همانطور که در شکل 16-4 می‌بینیم. چنین تیم فعالی ممکن است از ترکیبی از افراد تشکیل شود—شاید افرادی که به صورت تمام وقت به تیم اختصاص داده شده‌اند، و دیگرانی که هر از چند گاهی برای کمک می‌آیند.</p>
<p>شکل 16-4. عملکرد معماری به عنوان یک تیم فعال‌کننده</p>
<p>مدلی که من بسیار به آن علاقه دارم این است که تعداد کمی از معماران اختصاصی را در این تیم داشته باشیم (شاید فقط یک یا دو نفر در بسیاری از موارد)، اما این تیم را با <em>technologists</em> از هر تیم تحویل—<em>technical leads</em> هر تیم در حداقل—در طول زمان تقویت می‌کنیم. معمار مسئول اطمینان از عملکرد گروه است. این</p>
<p>540 | فصل 16: معمار تکاملی</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 566" src="page_0566/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0566</div>
            </div>
        </div>
        <!-- Page 0567 -->
        <div class="chapter" id="page-0567">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>معمار تکاملی (ادامه)</h4>
<p>کار را توزیع می‌کند و اطمینان حاصل می‌کند که سطح بالاتری از خرید وجود دارد. همچنین اطمینان حاصل می‌کند که اطلاعات آزادانه از تیم‌ها به گروه جریان می‌یابد، و در نتیجه، تصمیم‌گیری بسیار منطقی‌تر و آگاهانه‌تر است.
   گاهی اوقات، این گروه ممکن است تصمیماتی بگیرد که معمار با آن مخالف است. در این مرحله، معمار باید چه کار کند؟ با توجه به اینکه قبلاً در این موقعیت قرار گرفته‌ام، می‌توانم به شما بگویم که این یکی از چالش‌برانگیزترین موقعیت‌هایی است که باید با آن روبرو شوید. من اغلب رویکردی را در پیش می‌گیرم که باید با تصمیم گروه همراه شوم. من این دیدگاه را دارم که تمام تلاشم را برای متقاعد کردن مردم انجام داده‌ام، اما در نهایت به اندازه کافی متقاعدکننده نبوده‌ام. گروه اغلب بسیار عاقل‌تر از فرد است، و من بیش از یک بار اشتباه کردم! و تصور کنید که چقدر می‌تواند برای یک گروه خلع قدرت‌کننده باشد که به آنها فضا داده شده تا تصمیمی بگیرند و در نهایت نادیده گرفته شوند. اما گاهی اوقات من گروه را رد کرده‌ام. اما چرا و چه زمانی؟ چگونه خطوط را ترسیم می‌کنید؟</p>
<p>به آموزش دوچرخه‌سواری به یک کودک فکر کنید. شما نمی‌توانید برای آنها دوچرخه سواری کنید. شما تلوتلو خوردن آنها را تماشا می‌کنید، اما اگر هر بار که به نظر می‌رسد ممکن است بیفتند، وارد عمل شوید، در این صورت آنها هرگز یاد نمی‌گیرند، و در هر صورت آنها بسیار کمتر از آنچه فکر می‌کنید، سقوط می‌کنند! اما اگر آنها را در حال حرکت به سمت ترافیک یا یک حوض اردک در نزدیکی می‌بینید، در این صورت شما باید وارد عمل شوید. البته، من اغلب در چنین شرایطی اشتباه ثابت شده‌ام—من اجازه داده‌ام که تیم به سمت چیزی برود که احساس می‌کردم اشتباه است، و آنچه آنها انجام دادند، جواب داد! به همین ترتیب، شما به عنوان یک معمار، باید درک درستی از این داشته باشید که چه زمانی، به طور مجازی، تیم شما به سمت یک حوض اردک می‌رود. شما همچنین باید آگاه باشید که حتی اگر می‌دانید که حق با شماست و تیم را رد می‌کنید، این می‌تواند موقعیت شما را تضعیف کند و همچنین باعث شود تیم احساس کند که آنها در این امر نقشی ندارند. گاهی اوقات، کار درست این است که با تصمیمی که با آن موافق نیستید، همراه شوید. دانستن زمان انجام این کار و چه زمانی انجام ندادن آن دشوار است اما گاهی اوقات حیاتی است.</p>
<p>جایی که کارها جالب می‌شوند، همانطور که به زودی در مورد آن بحث خواهیم کرد، این است که وقتی یک معمار همچنین باید در فعالیت‌های حاکمیتی مشارکت داشته باشد. این می‌تواند باعث ایجاد مقداری سردرگمی در مورد نقش هر تیم معماری <em>cross-cutting</em> شود. وقتی یک تیم از استراتژی فنی منحرف می‌شود، چه اتفاقی می‌افتد؟ آیا این خوب است؟ شاید این یک استثنای معقول باشد، اما ممکن است مسائل اساسی‌تری را نیز ایجاد کند. یک تصمیم کوتاه‌مدت که به نام مصلحت اندیشی گرفته شده است، ممکن است تغییرات بزرگ‌تری را که در تلاش برای ایجاد آن هستید، به خطر بیندازد. تصور کنید که گروه معماری در تلاش است تا سازمان را از استفاده از داده‌های متمرکز، به دلیل مشکلات <strong>coupling</strong> و عملیاتی که ایجاد می‌کند، دور کند، اما یکی از تیم‌ها تصمیم می‌گیرد که فقط مقداری داده جدید را در یک پایگاه داده مشترک وارد کند، زیرا تحت فشار است که سریع تحویل دهد. در این صورت چه اتفاقی می‌افتد؟</p>
<p>طبق تجربه من، همه اینها به ارتباط خوب و روشن و درک مسئولیت‌ها برمی‌گردد. اگر من یک مالک محصول را می‌دیدم که تصمیماتی می‌گرفت که احساس می‌کردم فعالیت‌های <em>cross-cutting</em> را که برای آنها کار می‌کردم، تضعیف می‌کند، با آنها صحبت می‌کردم. شاید پاسخ این باشد که تصمیم کوتاه‌مدت درست است (و می‌توان استدلال کرد که این در نهایت به نوعی <em>technical debt</em> ختم می‌شود که ما آگاهانه آن را پذیرفته‌ایم). در موارد دیگر، شاید مالک محصول بتواند</p>
<p>معماری در یک سازمان <strong>Stream-Aligned</strong> | 541</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0567</div>
            </div>
        </div>
        <!-- Page 0568 -->
        <div class="chapter" id="page-0568">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>یک ساختار اجتماعی (ادامه)</h4>
<p>همانطور که در حال برنامه‌ریزی برای کمک به کار با استراتژی کلی هستند. در بدترین حالت، ممکن است لازم باشد که این موضوع تشدید شود.
   در <em>REA</em>، شرکت املاک و مستغلات آنلاینی که در چند فصل قبل در مورد آن صحبت کردم، مالکان محصول گه‌گاه تصمیماتی را برای اولویت‌بندی کار به گونه‌ای می‌گرفتند که باعث ایجاد <em>technical debt</em> می‌شد، که منجر به مشکلات بعدی می‌شد. مشکل این بود که مالکان محصول، در درجه اول در مورد توانایی خود در ارائه ویژگی‌ها و خوشحال کردن مشتریان پاسخگو بودند—در حالی که اغلب مسائل مربوط به <em>technical debt</em> در پای فنی رهبران فنی قرار می‌گرفت. تغییری ایجاد شد تا مالکان محصول نیز مسئول جنبه‌های <strong>software</strong> باشند که از نظر ماهیت فنی بوده‌اند—این بدان معنا بود که آنها باید نقش فعال‌تری در درک جنبه‌های فنی‌تر سیستم (به عنوان مثال، امنیت یا عملکرد) داشته باشند و از نظر اولویت‌بندی کارهایی که باید انجام شود، با متخصصان فنی بیشتر کار کنند. عمل مسئول کردن مالکان محصول غیرفنی برای اولویت‌بندی در مورد فعالیت‌های فنی، بی‌اهمیت نیست، اما طبق تجربه من، کاملاً ارزشش را دارد.</p>
<h4>ساختن یک تیم</h4>
<p>شخص اصلی برای چشم‌انداز فنی سیستم خود بودن و اطمینان از اجرای این چشم‌انداز، فقط در مورد اطمینان از درست بودن تصمیمات فناوری نیست. این افرادی هستند که با آنها کار می‌کنید که کار را انجام خواهند داد. این نقش هر رهبر فنی است که به این افراد در رشد خود کمک کند—به آنها کمک کند تا بخشی از ایجاد این چشم‌انداز باشند—و اطمینان حاصل شود که آنها می‌توانند شرکت‌کنندگان فعالی در شکل دادن و پیاده‌سازی این چشم‌انداز باشند.
   کمک به افرادی که در اطرافتان هستند در رشد شغلی خود، می‌تواند اشکال مختلفی داشته باشد، که اکثر آنها خارج از محدوده این کتاب هستند. با این حال، یک جنبه وجود دارد که در آن معماری <strong>microservice</strong>، به‌ویژه مرتبط است. با سیستم‌های بزرگتر و <strong>monolithic</strong>، فرصت‌های کمتری برای افراد وجود دارد تا وارد عمل شوند و صاحب چیزی شوند. از سوی دیگر، با <strong>microservices</strong>، ما کدبیس‌های خود مختار متعددی داریم که چرخه عمر مستقل خود را خواهند داشت. کمک به افراد برای پذیرش مالکیت <strong>microservices</strong> فردی قبل از پذیرفتن مسئولیت بیشتر می‌تواند یک راه عالی برای کمک به آنها در دستیابی به اهداف شغلی خود باشد، و در عین حال بار را بر دوش هر کسی که مسئول است، سبک‌تر می‌کند!</p>
<p>من قویاً معتقدم که <strong>software</strong> عالی از افراد عالی ناشی می‌شود. اگر شما فقط در مورد جنبه فناوری معادله نگران هستید، شما بیش از نیمی از تصویر را از دست می‌دهید.</p>
<p>542 | فصل 16: معمار تکاملی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0568</div>
            </div>
        </div>
        <!-- Page 0569 -->
        <div class="chapter" id="page-0569">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>ساختار سازمانی</h4>
<p>7 <em>Paul Ingles</em>, “Convergence to Kubernetes,” <em>Medium</em>, June 18, 2018, <a href="https://oreil.ly/ON81J">https://oreil.ly/ON81J</a>.</p>
<p>داشتن یک معماری <strong>microservice</strong> مشترک، آسان‌تر خواهد بود، و همچنین، ممکن است مشکلات را کاهش دهد.
   برای کمک به هماهنگی بین تمام اعضای یک تیم، در اینجا دو اصل وجود دارد:</p>
<ul>
<li>نقطه تماس، یعنی فردی که می‌تواند در مورد عملکردها و درخواست‌های تیم مشاوره دهد.</li>
<li>مدرک کتبی یا <strong>API</strong> برای نحوه انجام کارها.</li>
</ul>
<p>هر دو این اصول نیز در ساختار سازمانی مفید هستند. (<em>API</em> تیمی می‌تواند به عنوان یک <strong>guideline</strong> عمل کند.)</p>
<p>برای این منظور، <em>REA</em> از تیم‌های <strong>cross-functional</strong> استفاده می‌کند. این بدان معناست که هر تیم <em>full stack</em> است—معمار، <strong>frontend</strong>، <strong>backend</strong>، <em>testers</em> و <em>product owner</em>ها در داخل تیم‌ها فعالیت می‌کنند. این امر به تیم‌های <em>REA</em> اجازه می‌دهد تا با سرعت بیشتری کار کنند، با حداقل تعامل با تیم‌های دیگر—به طور مشابه، برای همه <strong>microservices</strong> آنها، تیم‌ها از یک <em>code repository</em> استفاده می‌کنند.</p>
<p>به منظور ایجاد یک ساختار عالی و پایدار، از <strong>APIs</strong> استفاده کنید. این به شما کمک می‌کند تا بدانید که آیا شما یک <strong>API</strong> خوب را پیاده‌سازی کرده‌اید یا خیر. در این مورد، <em>REA</em> استفاده از یک <strong>API</strong> برای دسترسی به اطلاعات را تشویق می‌کند. این به شما کمک می‌کند تا دریابید آیا شما به طور مؤثر این <strong>API</strong> را ساخته‌اید یا خیر.</p>
<p>به نظر می‌رسد که مزایای اصلی از ساختار <strong>stream-aligned</strong> که <em>REA</em> از آن استفاده می‌کند، این است که به شما اجازه می‌دهد تا <strong>CI/CD</strong> را به درستی انجام دهید. <em>CI/CD</em>، شامل:
   • اجرای تست‌های واحد خودکار
   • استقرار تغییرات به صورت خودکار
   • ارائه بازخورد فوری به توسعه‌دهندگان در مورد هر تغییری که انجام داده‌اند.</p>
<p>مزیت کلیدی معماری <strong>microservices</strong> در سطح سازمانی، این است که توسعه‌دهندگان می‌توانند بر روی یک مؤلفه متمرکز شوند، در حالی که بقیه، روی بخش‌های دیگر کار می‌کنند.</p>
<p>با این حال، هم‌افزایی می‌تواند مشکل‌ساز باشد. زمانی که <strong>teams</strong> سعی می‌کنند راه‌حل‌های مشترک را مجدداً استفاده کنند، مشکلات ممکن است ظاهر شوند—به عنوان مثال، اگر <em>teams</em> در حال تلاش برای به اشتراک گذاشتن کد منبع باشند، ممکن است به <em>coupling</em> بیشتر منجر شود.</p>
<p>این موضوع را می‌توان به عنوان "بازگشت به جاده" تصور کرد. برای حل مشکلات پیچیده، شما معمولاً به <em>guidelines</em> و فرآیندها نیاز دارید، که آنها را به سمت همسویی سوق می‌دهد. این بدان معناست که شما باید مطمئن باشید که افراد در حال استفاده از شیوه‌های مشترک در داخل تیم هستند.</p>
<p>این رویکرد توسط <em>Netflix</em> در آغوش گرفته شده است. "قانون <em>Conway</em>" می‌گوید که معماری شما، معماری است که تیم‌ها با آن ارتباط برقرار می‌کنند، و همچنین به این معناست که برای ایجاد بهترین معماری، باید به چگونگی ساختار تیم‌ها توجه کنید.</p>
<h4>استاندارد مورد نیاز</h4>
<p>هنگامی که شما در حال کار بر روی عملکردهای خود هستید و در مورد مبادلاتی که باید انجام دهید فکر می‌کنید، یکی از مهم‌ترین تعادل‌هایی که باید پیدا کنید این است که چه مقدار تغییرپذیری باید در سیستم خود مجاز کنید. یکی از راه‌های کلیدی برای شناسایی آنچه باید از <strong>microservice</strong> به <strong>microservice</strong> ثابت باشد، تعریف این است که یک <strong>microservice</strong> خوش رفتار و خوب چگونه به نظر می‌رسد. یک <strong>microservice</strong> "شهروند خوب" در سیستم شما چیست؟ چه قابلیت‌هایی باید داشته باشد تا اطمینان حاصل شود که سیستم شما قابل مدیریت است و یک <strong>microservice</strong> بد، کل سیستم را از کار نمی‌اندازد؟ همانطور که در مورد افراد نیز صدق می‌کند، آنچه یک <strong>microservice</strong> "شهروند خوب" است در یک زمینه، منعکس‌کننده آنچه در جای دیگری به نظر می‌رسد، نیست. با این وجود، برخی از ویژگی‌های مشترک <strong>microservices</strong> خوش رفتار وجود دارد که فکر می‌کنم مشاهده آنها نسبتاً مهم است. اینها چند مورد از حوزه‌های کلیدی هستند که در آنها اجازه دادن به واگرایی زیاد می‌تواند منجر به یک زمان بسیار وحشتناک شود. همانطور که <em>Ben Christensen</em> از <em>Facebook</em> بیان می‌کند، وقتی به تصویر بزرگتر فکر می‌کنید، "باید یک سیستم منسجم باشد که از بخش‌های کوچک بسیاری تشکیل شده باشد، اما همه در کنار هم قرار می‌گیرند." بنابراین شما باید تعادلی پیدا کنید که در آن خودمختاری <strong>microservices</strong> فردی را بهینه کنید بدون اینکه از تصویر بزرگتر غافل شوید. تعریف ویژگی‌های واضحی که هر <strong>microservice</strong> باید داشته باشد، یک راه برای روشن بودن در مورد محل قرارگیری این تعادل است. بیایید به برخی از آن ویژگی‌ها بپردازیم.</p>
<h4>نظارت</h4>
<p>ضروری است که ما بتوانیم دیدگاه‌های منسجم و متقابل سرویسی از سلامت سیستم خود ترسیم کنیم. این باید یک دیدگاه در سطح سیستم باشد، نه یک دیدگاه مختص <strong>microservice</strong>. همانطور که در فصل 10 بحث کردیم، دانستن سلامت یک <strong>microservice</strong> فردی مفید است، اما اغلب فقط زمانی که شما در تلاش هستید تا یک مشکل گسترده‌تر را تشخیص دهید یا یک روند بزرگ‌تر را درک کنید. برای آسان کردن این کار تا حد امکان، من پیشنهاد می‌کنم که اطمینان حاصل کنید که همه <strong>microservices</strong>، معیارهای مرتبط با سلامت و پایش عمومی را به روشی یکسان منتشر می‌کنند.
   شما ممکن است یک مکانیزم <strong>push</strong> را انتخاب کنید، که در آن هر <strong>microservice</strong> نیاز به فشار دادن این داده‌ها به یک مکان مرکزی دارد. هر چه را انتخاب می‌کنید، سعی کنید آن را استاندارد نگه دارید. فناوری داخل <strong>box</strong> را <em>opaque</em> کنید، و از سیستم‌های نظارتی خود نخواهید که برای پشتیبانی از آن تغییر کنند. <em>Logging</em> در اینجا در همان دسته قرار می‌گیرد: ما به آن در یک مکان نیاز داریم.
   رابط‌ها</p>
<p>انتخاب تعداد کمی از فناوری‌های رابط تعریف‌شده به یکپارچه‌سازی مصرف‌کنندگان جدید کمک می‌کند. داشتن یک استاندارد خوب است. دوتا هم خیلی بد نیست. داشتن بیست سبک مختلف ادغام خوب نیست. این فقط در مورد انتخاب فناوری و پروتکل نیست. به عنوان مثال، اگر <em>HTTP/REST</em> را انتخاب کنید، آیا از فعل‌ها یا اسم‌ها استفاده می‌کنید؟ چگونه صفحه بندی منابع را مدیریت خواهید کرد؟ چگونه نسخه‌سازی <em>endpoints</em> را مدیریت خواهید کرد؟</p>
<p>استاندارد مورد نیاز | 543</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0569</div>
            </div>
        </div>
        <!-- Page 0570 -->
        <div class="chapter" id="page-0570">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>امنیت معماری</h4>
<p>ما نمی‌توانیم تحمل کنیم که یک <strong>microservice</strong> بد، مهمانی را برای همه خراب کند.
   ما باید اطمینان حاصل کنیم که <strong>microservices</strong> ما به همین ترتیب از تماس‌های ناسالم و پایین‌دستی محافظت می‌کنند. هرچه <strong>microservices</strong> بیشتری داشته باشیم که خرابی احتمالی تماس‌های پایین‌دستی را به درستی مدیریت نکنند، سیستم‌های ما شکننده‌تر خواهند بود. به عنوان مثال، این ممکن است به این معنی باشد که شما می‌خواهید برخی از عملکردها را در مورد ارتباط بین سرویس‌ها، مانند نیاز به استفاده از <strong>circuit breakers</strong> (موضوعی که ما در "<em>Stability Patterns</em>" در صفحه 395 بررسی کردیم)، تصویب کنید.</p>
<p>پیروی از قوانین در مورد کدهای پاسخ نیز مهم است. اگر <em>circuit breakers</em> شما به کدهای <em>HTTP</em> متکی هستند، و یک <strong>microservice</strong> تصمیم می‌گیرد که کدهای 2<em>XX</em> را برای خطاها برگرداند یا کدهای 4<em>XX</em> را با کدهای 5<em>XX</em> اشتباه بگیرد، در این صورت این اقدامات ایمنی می‌توانند از هم بپاشند. نگرانی‌های مشابهی حتی در صورتی که از <em>HTTP</em> استفاده نمی‌کنید، اعمال می‌شود. ما باید تفاوت بین درخواستی را که درست و به درستی پردازش شده است، درخواستی که بد بوده است و در نتیجه از انجام هر کاری با آن توسط <strong>microservice</strong> جلوگیری شده است، و درخواستی که ممکن است خوب باشد اما ما نمی‌توانیم آن را تشخیص دهیم، زیرا سرور از کار افتاده است، بدانیم. دانستن این موضوع برای اطمینان از اینکه ما می‌توانیم سریع شکست بخوریم و مشکلات را ردیابی کنیم، کلیدی است. اگر <strong>microservices</strong> ما در این قوانین عجولانه عمل کنند، ما در نهایت یک سیستم آسیب‌پذیرتر خواهیم داشت.</p>
<h4>حاکمیت و جاده آسفالت شده</h4>
<p>بخشی از آنچه معماران باید مدیریت کنند، حاکمیت است. منظور من از حاکمیت چیست؟
   به نظر می‌رسد که چارچوب <em>COBIT</em> (اهداف کنترل برای فناوری‌های اطلاعات) تعریف خوبی دارد:8</p>
<p>حاکمیت تضمین می‌کند که اهداف سازمانی با ارزیابی نیازها، شرایط و گزینه‌های ذینفعان، تعیین جهت از طریق اولویت‌بندی و تصمیم‌گیری، و نظارت بر عملکرد، انطباق و پیشرفت در برابر جهت و اهداف توافق شده، به دست می‌آیند.</p>
<p>به طور خلاصه، ما می‌توانیم حاکمیت را به عنوان توافق در مورد نحوه انجام کارها، اطمینان از اینکه مردم می‌دانند چگونه باید کارها را انجام دهند، و اطمینان از انجام کارها به این روش در نظر بگیریم. در برخی محیط‌ها، حاکمیت فقط به صورت غیررسمی، به عنوان بخشی از فعالیت‌های عادی توسعه <strong>software</strong> رخ می‌دهد. در محیط‌های دیگر، به‌ویژه در سازمان‌های بزرگ‌تر، این ممکن است نیاز به یک عملکرد ملموس‌تر داشته باشد.
   حاکمیت می‌تواند برای موارد متعددی در انجمن <em>IT</em> اعمال شود. ما می‌خواهیم بر جنبه حاکمیت فنی تمرکز کنیم، چیزی که من احساس می‌کنم کار معمار است. اگر یکی از مشاغل معمار اطمینان از وجود یک چشم‌انداز فنی باشد، در این صورت حاکمیت در مورد</p>
<p>8 <em>COBIT 5: A Business Framework for the Governance and Management of Enterprise IT</em> (<em>Rolling Meadows</em>, <em>IL</em>: <em>ISACA</em>, 2012).</p>
<p>544 | فصل 16: معمار تکاملی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0570</div>
            </div>
        </div>
        <!-- Page 0571 -->
        <div class="chapter" id="page-0571">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>حاکمیت و جاده آسفالت شده (ادامه)</h4>
<p>تضمین اینکه ما در حال ساخت چیزی هستیم که با این دیدگاه مطابقت دارد، و در صورت نیاز، چشم‌انداز را توسعه می‌دهیم.
   اساساً، حاکمیت باید یک فعالیت گروهی باشد. یک گروه حاکمیتی که به درستی کار می‌کند، می‌تواند با هم کار کند تا کار را به اشتراک بگذارد و دیدگاه را شکل دهد. این می‌تواند یک گپ غیررسمی با یک تیم به اندازه کافی کوچک باشد، یا یک جلسه منظم‌تر ساختاریافته با عضویت رسمی گروه برای یک دامنه بزرگتر. این همان جایی است که من فکر می‌کنم اصول پوشش داده شده قبلی ما باید مورد بحث قرار گیرند و در صورت نیاز تغییر کنند. اگر یک گروه رسمی مورد نیاز است، این گروه باید عمدتاً از افرادی تشکیل شود که در حال اجرای کاری هستند که مورد حاکمیت قرار می‌گیرد. این گروه همچنین باید مسئول پیگیری و مدیریت ریسک‌های فنی باشد.
   جمع شدن و توافق در مورد نحوه انجام کارها ایده خوبی است. اما صرف زمان برای اطمینان از اینکه افراد از این <em>guidelines</em> پیروی می‌کنند، چندان سرگرم‌کننده نیست، همانطور که بار قرار دادن بر توسعه‌دهندگان برای پیاده‌سازی همه این چیزهای استاندارد که از هر <strong>microservice</strong> انتظار دارید، هم همینطور است. من معتقدم که آسان کردن انجام کار درست—و همانطور که در فصل 15 بحث کردیم، جاده آسفالت شده در اینجا یک مفهوم واقعاً مفید است. معمار نقشی دارد که به وضوح چشم‌انداز را بیان کند—به کجا می‌روید—و رسیدن به آنجا را آسان کند. به این ترتیب، آنها باید در کمک به شکل دادن به الزامات هر جاده آسفالت‌شده‌ای که می‌سازید، مشارکت داشته باشند. برای بسیاری، پلتفرم بزرگترین نمونه از این خواهد بود—معمار در نهایت یک ذینفع مهم برای تیم پلتفرم می‌شود.
   ما قبلاً نقش پلتفرم را با عمق زیادی بررسی کرده‌ایم، بنابراین اجازه دهید به چند تکنیک دیگر نگاه کنیم که می‌توانیم از آنها استفاده کنیم تا انجام کار درست را برای مردم تا حد امکان آسان کنیم.</p>
<h4>نمونه‌ها</h4>
<p>مستندات مکتوب خوب و مفید است. من به وضوح ارزش آن را می‌بینم. به هر حال، من این کتاب را نوشته‌ام. اما توسعه‌دهندگان، کد را نیز دوست دارند—کدی که می‌توانند آن را اجرا و بررسی کنند. اگر شما مجموعه‌ای از استانداردها یا بهترین روش‌ها را دارید که می‌خواهید آنها را تشویق کنید، داشتن نمونه‌هایی که می‌توانید مردم را به آنها ارجاع دهید، مفید است. ایده این است که مردم نمی‌توانند با تقلید از برخی از بخش‌های بهتر سیستم شما، از مسیر درست دور شوند.
   در حالت ایده‌آل، اینها باید <strong>microservices</strong> واقعی باشند که در سیستم شما در حال اجرا هستند و کارها را درست انجام می‌دهند، نه صرفاً <strong>microservices</strong> منزوی که فقط به عنوان "نمونه‌های عالی" پیاده‌سازی می‌شوند. با اطمینان از اینکه نمونه‌های شما واقعاً در حال استفاده هستند، شما اطمینان حاصل می‌کنید که همه اصولی که واقعاً دارید، منطقی هستند.</p>
<h4>قالب <strong>Microservice</strong> سفارشی</h4>
<p>آیا عالی نمی‌شد اگر شما می‌توانید واقعاً کار را برای همه توسعه‌دهندگان آسان کنید تا بیشتر دستورالعمل‌هایی را که شما با کار بسیار کمی دارید، دنبال کنند؟ اگر، به محض ورود، توسعه‌دهندگان اکثر کدهای خود را برای پیاده‌سازی ویژگی‌های اصلی که هر <strong>microservice</strong> نیاز دارد، داشته باشند، چه؟</p>
<p>حاکمیت و جاده آسفالت شده | 545</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0571</div>
            </div>
        </div>
        <!-- Page 0572 -->
        <div class="chapter" id="page-0572">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>قالب <strong>Microservice</strong> سفارشی (ادامه)</h4>
<p>بسیاری از فریم‌ورک‌ها برای زبان‌های برنامه‌نویسی مختلف وجود دارند که تلاش می‌کنند بلوک‌های سازنده را برای قالب <strong>microservice</strong> خود به شما ارائه دهند. <em>Spring Boot</em> احتمالاً موفق‌ترین نمونه از چنین فریم‌ورکی برای <em>JVM</em> است. فریم‌ورک اصلی <em>Spring Boot</em> نسبتاً سبک است، اما شما می‌توانید تصمیم بگیرید که مجموعه‌ای از کتابخانه‌ها را برای ارائه ویژگی‌هایی مانند بررسی سلامت، ارائه <em>HTTP</em>، یا افشای <em>metrics</em> جمع‌آوری کنید. بنابراین درست از ابتدا، شما یک <strong>microservice</strong> "<em>Hello World</em>" ساده دارید که می‌تواند از خط فرمان راه‌اندازی شود.</p>
<p>بسیاری از افراد سپس این فریم‌ورک‌ها را می‌گیرند و این تنظیمات را برای شرکت خود استاندارد می‌کنند. به عنوان مثال، هنگام راه‌اندازی یک <strong>microservice</strong> جدید، ممکن است مواردی را به گونه‌ای اسکریپت‌نویسی کنند که یک قالب <em>Spring Boot</em> با کتابخانه‌های اصلی که سازمان آنها در حال حاضر استفاده می‌کند، دریافت کنند. این ممکن است از قبل کتابخانه‌هایی را برای مدیریت <em>circuit breakers</em> و پیکربندی برای مدیریت <strong>JWT authentication</strong> برای تماس‌های ورودی <em>pull in</em> کند. به طور معمول، چنین ایجاد قالب خودکاری، یک <strong>pipeline</strong> ساخت منطبق را نیز ایجاد می‌کند.</p>
<h4>احتیاط لازم است</h4>
<p>انتخاب و پیکربندی این قالب‌های <strong>microservices</strong> سفارشی معمولاً یک کار برای تیم پلتفرم است. آنها ممکن است، به عنوان مثال، یک قالب برای هر زبان پشتیبانی شده ارائه دهند، و اطمینان حاصل کنند که هنگام استفاده از قالب، <strong>microservices</strong> حاصل به خوبی با خود پلتفرم کار می‌کنند. با این حال، این می‌تواند چالش‌هایی ایجاد کند.
   من روحیه و بهره‌وری بسیاری از تیم‌ها را دیده‌ام که با داشتن یک فریم‌ورک اجباری که به آنها تحمیل شده است، نابود شده است. در تلاش برای بهبود استفاده مجدد از کد، کار بیشتر و بیشتری در یک فریم‌ورک متمرکز قرار می‌گیرد تا اینکه به یک هیولای طاقت‌فرسا تبدیل شود.
   اگر شما تصمیم به استفاده از یک قالب <strong>microservice</strong> سفارشی می‌گیرید، با دقت زیادی در مورد اینکه کار آن چیست، فکر کنید. در حالت ایده‌آل، استفاده از آن باید صرفاً اختیاری باشد، اما اگر قصد دارید در اتخاذ آن، قدرتمندتر باشید، باید درک کنید که سهولت استفاده برای توسعه‌دهندگان باید یک نیروی راهنمای اصلی باشد. اجازه دادن به توسعه‌دهندگانی که از قالب استفاده می‌کنند تا تغییرات را توصیه کنند و حتی در فریم‌ورک سهیم شوند، شاید به عنوان بخشی از یک مدل <em>open source</em> داخلی، می‌تواند در اینجا بسیار کمک کند.</p>
<p>همانطور که ما در "<em>DRY</em> و خطرات استفاده مجدد از کد در دنیای <strong>Microservice</strong>" در صفحه 154 بحث کردیم، ما باید از خطرات کد مشترک آگاه باشیم. در تمایل خود برای ایجاد کد قابل استفاده مجدد، ما می‌توانیم منابع <strong>coupling</strong> را بین <strong>microservices</strong> معرفی کنیم. حداقل یک سازمان که من با آن صحبت کردم، آنقدر در این مورد نگران است که در واقع کد قالب <strong>microservice</strong> خود را به صورت دستی در هر <strong>microservice</strong> کپی می‌کند. این بدان معناست که به‌روزرسانی قالب <strong>microservice</strong> اصلی، زمان بیشتری برای اعمال در سراسر سیستم آن طول می‌کشد، اما این برای سازمان کمتر نگران‌کننده است تا خطر <strong>coupling</strong>. تیم‌های دیگری که من با آنها صحبت کرده‌ام، به‌سادگی با قالب <strong>microservice</strong> به عنوان یک وابستگی باینری مشترک رفتار کرده‌اند، اگرچه آنها باید در مورد عدم اجازه به تمایل به <em>DRY</em> (خودتان را تکرار نکنید) که منجر به یک سیستم بیش از حد <em>coupled</em> شود، بسیار کوشا باشند!</p>
<p>546 | فصل 16: معمار تکاملی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0572</div>
            </div>
        </div>
        <!-- Page 0573 -->
        <div class="chapter" id="page-0573">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>پلتفرم در مقیاس بزرگ</h4>
<p>استفاده از قالب‌ها و فریم‌ورک‌های <strong>microservice</strong> داخلی، اغلب در سازمان‌هایی یافت می‌شود که تعداد زیادی <strong>microservices</strong> دارند. <em>Netflix</em> و <em>Monzo</em> دو نمونه از این سازمان‌ها هستند. هر کدام تصمیم گرفته‌اند که <em>technology stack</em> خود را تا حدودی استاندارد کنند (<em>JVM</em> در مورد <em>Netflix</em>، <em>Go</em> از نظر <em>Monzo</em>)، که به آنها اجازه می‌دهد تا ایجاد یک <strong>microservice</strong> جدید با رفتار استاندارد و مورد انتظار با استفاده از یک مجموعه ابزار مشترک را سرعت بخشند. با یک <em>technology stack</em> متنوع‌تر، داشتن یک قالب <strong>microservice</strong> استاندارد برای نیازهای خودتان دشوارتر می‌شود.</p>
<p>اگر شما می‌خواهید <em>technology stacks</em> متعدد و متفاوتی را بپذیرید، شما به یک قالب <strong>microservice</strong> منطبق برای هر کدام نیاز دارید. این می‌تواند راهی برای محدود کردن ظریف انتخاب زبان در تیم‌های شما باشد. اگر قالب <strong>microservice</strong> داخلی فقط از <em>JVM</em> پشتیبانی می‌کند، در این صورت ممکن است افراد از انتخاب <em>stacks</em> جایگزین منصرف شوند، اگر مجبور باشند کارهای بیشتری را خودشان انجام دهند. به عنوان مثال، <em>Netflix</em> به‌ویژه نگران جنبه‌هایی مانند تحمل خطا است تا اطمینان حاصل شود که از کار افتادن یک بخش از سیستم آن نمی‌تواند همه چیز را از بین ببرد. برای رسیدگی به این موضوع، کارهای زیادی انجام شده است تا اطمینان حاصل شود که کتابخانه‌های <strong>client</strong> در <em>JVM</em> وجود دارد تا ابزارهایی را که تیم‌ها برای حفظ رفتار خوب <strong>microservice</strong> خود نیاز دارند، در اختیار آنها قرار دهد. معرفی یک <em>technology stack</em> جدید به معنای نیاز به بازتولید تمام این تلاش‌ها است. نگرانی اصلی <em>Netflix</em> کمتر در مورد تلاش تکراری است و بیشتر در مورد این واقعیت است که اشتباه گرفتن این موضوع بسیار آسان است.
   اگر <strong>microservice</strong> خطای تحمل <em>newly implemented</em> را اشتباه بگیرد، خطر زیادی وجود دارد اگر بتواند بر بخش‌های بیشتری از سیستم تأثیر بگذارد. <em>Netflix</em> با استفاده از "سرویس‌های <em>sidecar</em>" این موضوع را کاهش می‌دهد، که به صورت محلی با یک <em>JVM</em> ارتباط برقرار می‌کنند که از کتابخانه‌های مناسب استفاده می‌کند.</p>
<p><em>Service meshes</em> یک راه بالقوه دیگر برای حذف رفتار مشترک به ما داده‌اند. برخی از عملکردهایی که معمولاً به عنوان مسئولیت یک <strong>microservice</strong> داخلی دیده می‌شد، اکنون می‌تواند به یک <em>microservice mesh</em> منتقل شود. این می‌تواند ثبات بیشتری را در رفتار در سراسر <strong>microservices</strong> نوشته شده در زبان‌های برنامه‌نویسی مختلف تضمین کند و همچنین مسئولیت‌های این قالب‌های <strong>microservice</strong> را کاهش دهد.</p>
<h4><em>Technical Debt</em></h4>
<p>ما اغلب در موقعیت‌هایی قرار می‌گیریم که نمی‌توانیم حرف به حرف از چشم‌انداز فنی خود پیروی کنیم. اغلب، ما باید انتخابی برای کوتاه کردن برخی از گوشه‌ها برای دریافت برخی از ویژگی‌های فوری داشته باشیم. این فقط یک مبادله دیگر است که ما خود را مجبور به انجام آن می‌دانیم. چشم‌انداز فنی ما به یک دلیل وجود دارد. اگر ما از این دلیل منحرف شویم، ممکن است یک مزیت کوتاه‌مدت داشته باشد اما هزینه‌ای بلندمدت داشته باشد. مفهومی که به ما در درک این مبادله کمک می‌کند، <em>technical debt</em> است. هنگامی که ما <em>technical debt</em> جمع می‌کنیم، درست مانند بدهی در دنیای واقعی، هزینه‌ای مداوم دارد و چیزی است که ما می‌خواهیم آن را پرداخت کنیم.</p>
<p>گاهی اوقات <em>technical debt</em>، چیزی نیست که ما فقط با میانبر زدن ایجاد می‌کنیم. اگر دیدگاه ما برای سیستم تغییر کند، اما تمام سیستم ما مطابقت نداشته باشد، چه اتفاقی می‌افتد؟ در این شرایط نیز ما منابع جدیدی از <em>technical debt</em> ایجاد کرده‌ایم.</p>
<p><em>Technical Debt</em> | 547</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0573</div>
            </div>
        </div>
        <!-- Page 0574 -->
        <div class="chapter" id="page-0574">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4><em>Technical Debt</em> (ادامه)</h4>
<p>وظیفه معمار این است که به تصویر بزرگتر نگاه کند و این تعادل را درک کند. داشتن دیدگاهی در مورد میزان بدهی و جایی که باید در آن مشارکت کرد، مهم است. بسته به سازمان شما، شما ممکن است بتوانید راهنمایی‌های ملایمی ارائه دهید، اما اجازه دهید خود تیم‌ها در مورد نحوه ردیابی و پرداخت بدهی تصمیم بگیرند. برای سایر سازمان‌ها، شما ممکن است نیاز داشته باشید که ساختار بیشتری داشته باشید، شاید یک <em>debt log</em> را حفظ کنید که به طور منظم بررسی می‌شود.</p>
<h4>مدیریت استثنائات</h4>
<p>بنابراین اصول و عملکرد ما، نحوه ساخت سیستم‌های ما را هدایت می‌کند. اما چه اتفاقی می‌افتد وقتی سیستم ما از آن منحرف می‌شود؟ گاهی اوقات ما تصمیماتی می‌گیریم که فقط یک استثنا برای قانون است. در این موارد، ممکن است ارزش داشته باشد که چنین تصمیمی را در جایی برای مراجعه‌های بعدی ثبت کنیم. اگر استثنائات کافی یافت شود، ممکن است در نهایت منطقی باشد که اصل یا عملکرد قابل اجرا را تغییر دهیم تا درک جدیدی از جهان را منعکس کند. به عنوان مثال، ما ممکن است یک عملکرد داشته باشیم که بیان می‌کند ما همیشه از <em>MySQL</em> برای ذخیره داده‌ها استفاده خواهیم کرد. اما سپس ما دلایل قانع‌کننده‌ای برای استفاده از <em>Cassandra</em> برای ذخیره‌سازی با قابلیت مقیاس‌پذیری بالا می‌بینیم، که در این مرحله ما عملکرد خود را تغییر می‌دهیم تا بگوییم، "از <em>MySQL</em> برای اکثر الزامات ذخیره‌سازی استفاده کنید، مگر اینکه انتظار رشد زیادی در حجم داشته باشید، که در این صورت از <em>Cassandra</em> استفاده کنید."</p>
<p>با این حال، تکرار این نکته مهم است که هر سازمان متفاوت است. من با برخی از شرکت‌ها کار کرده‌ام که در آن تیم‌های توسعه از درجه بالایی از اعتماد و خودمختاری برخوردارند، و اصول سبک هستند (و در این صورت، نیاز به مدیریت استثنائات آشکار به شدت کاهش می‌یابد، اگر نه حذف می‌شود). در سازمان‌های ساختاریافته‌تر که در آن توسعه‌دهندگان آزادی کمتری دارند، ردیابی استثنائات ممکن است برای اطمینان از اینکه قوانین در نظر گرفته شده به درستی چالش‌هایی را که مردم با آنها روبرو هستند، منعکس می‌کنند، حیاتی باشد. با تمام اینها، من طرفدار <strong>microservices</strong> به عنوان راهی برای بهینه‌سازی برای خودمختاری تیم‌ها هستم، و به آنها تا حد امکان آزادی می‌دهم تا مشکل موجود را حل کنند. اگر شما در سازمانی کار می‌کنید که محدودیت‌های زیادی را برای نحوه انجام کار توسعه‌دهندگان اعمال می‌کند، در این صورت <strong>microservices</strong> ممکن است برای شما مناسب نباشد.</p>
<h4>خلاصه</h4>
<p>برای جمع‌بندی این فصل، در اینجا آنچه من به عنوان مسئولیت‌های اصلی معمار تکاملی می‌بینم، آورده شده است:</p>
<ul>
<li>چشم‌انداز</li>
<p>اطمینان حاصل کنید که یک چشم‌انداز فنی به‌وضوح منتقل شده برای سیستم وجود دارد که به آن کمک می‌کند تا الزامات مشتریان و سازمان شما را برآورده کند.</p>
<li>همدلی</li>
<p>تأثیر تصمیمات خود را بر مشتریان و همکاران خود درک کنید.</p>
</ul>
<p>معماری در یک سازمان <strong>Stream-Aligned</strong> | 541</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0574</div>
            </div>
        </div>
        <!-- Page 0575 -->
        <div class="chapter" id="page-0575">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>معمار تکاملی (ادامه)</h4>
<ul>
<li>همکاری</li>
<p>تا حد امکان با همتایان و همکاران خود تعامل داشته باشید تا به تعریف، اصلاح، و اجرای دیدگاه کمک کنید</p>
<li>قابلیت انطباق</li>
<p>مطمئن شوید که دیدگاه فنی با توجه به نیازهای مشتریان یا سازمان شما تغییر می‌کند.</p>
<li>خودمختاری</li>
<p>تعادل مناسبی بین استانداردسازی و فعال کردن خودمختاری برای تیم‌های خود پیدا کنید.</p>
<li>حاکمیت</li>
<p>اطمینان حاصل کنید که سیستمی که در حال پیاده‌سازی آن هستید، با چشم‌انداز فنی مطابقت دارد، و اطمینان حاصل کنید که انجام کار درست برای مردم آسان است.</p>
</ul>
<p>معمار تکاملی کسی است که درک می‌کند که نشان دادن این مسئولیت‌های اصلی یک عمل متعادل‌کننده همیشگی است. نیروها همیشه ما را به یک سمت یا سمت دیگر سوق می‌دهند، و درک اینکه کجا باید مقاومت کنیم یا با جریان پیش برویم، اغلب چیزی است که فقط با تجربه حاصل می‌شود. اما بدترین واکنش به همه این نیروها که ما را به سمت تغییر سوق می‌دهند، این است که در تفکر خود، سفت و سخت یا ثابت شویم.</p>
<p>در حالی که بسیاری از توصیه‌های موجود در این فصل، می‌تواند برای هر معمار سیستمی اعمال شود، <strong>microservices</strong> تصمیمات بیشتری را برای اتخاذ در اختیار ما قرار می‌دهند. بنابراین، توانایی بهتر برای تعادل تمام این مبادلات، ضروری است. اگر می‌خواهید این موضوع را با عمق بیشتری بررسی کنید، من می‌توانم <em>Building Evolutionary Architectures</em> که قبلاً به آن اشاره شد، و همچنین <em>The Software Architect Elevator</em> نوشته <em>Gregor Hohpe</em> را توصیه کنم،9 که به معماران کمک می‌کند تا درک کنند که چگونه می‌توانند شکاف بین تفکر استراتژیک سطح بالا و تحویل در محل را پر کنند.
   ما تقریباً به پایان کتاب رسیده‌ایم، و ما مطالب زیادی را پوشش داده‌ایم. در مؤخره، ما اکنون آنچه را که آموخته‌ایم، خلاصه می‌کنیم.</p>
<p>9 <em>Gregor Hohpe</em>, <em>The Software Architect Elevator</em> (<em>Sebastopol</em>: <em>O’Reilly</em>, 2020).</p>
<p>خلاصه | 549</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0575</div>
            </div>
        </div>
        <!-- Page 0577 -->
        <div class="chapter" id="page-0577">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مؤخره: جمع‌بندی همه چیز</h4>
<p>همانطور که امیدوارم نشان داده باشم، <strong>software</strong>های شما، یک معماری خوب نیازمند مدیریت است. در اینجا یک دسته از وظایف وجود دارد که یک معمار <strong>software</strong> باید در مورد آنها تصمیم بگیرد، که در این کتاب نیز شرح داده شد. ما در تلاش برای ایجاد یک ساختار ساده‌ای هستیم که به ما این امکان را بدهد تا <strong>software</strong> را با سرعت بیشتر ارائه دهیم و در عین حال قابلیت اطمینان سیستم را بهبود بخشیم. در اینجا یک نمای کلی از آنچه یاد گرفتیم، ارائه شده است.</p>
<h4><strong>Microservices</strong> چیستند؟</h4>
<p>همانطور که در فصل 1 معرفی شد، <strong>microservices</strong> نوعی معماری سرویس‌گرا هستند که بر استقرار مستقل تمرکز دارد. استقرار مستقل به این معنی است که شما می‌توانید تغییری در یک <strong>microservice</strong> ایجاد کنید، آن <strong>microservice</strong> را مستقر کنید، و عملکرد آن را برای کاربران نهایی منتشر کنید، بدون اینکه نیازی به تغییر سایر <strong>microservices</strong> داشته باشید. برای به دست آوردن بیشترین بهره از یک معماری <strong>microservice</strong>، به معنای پذیرش این مفهوم است. معمولاً، هر <strong>microservice</strong> به عنوان یک فرآیند مستقر می‌شود، که ارتباط با سایر <strong>microservices</strong> از طریق نوعی پروتکل شبکه انجام می‌شود. استقرار چندین نمونه از یک <strong>microservice</strong> رایج است، شاید برای اینکه شما بتوانید مقیاس بیشتری را ارائه دهید، یا برای بهبود <strong>robustness</strong> با داشتن افزونگی.</p>
<p>برای ارائه استقرار مستقل، ما باید مطمئن شویم که هنگام تغییر یک <strong>microservice</strong>، تعامل با سایر <strong>microservices</strong> را خراب نمی‌کنیم. این امر مستلزم آن است که رابط‌های ما با سایر <strong>microservices</strong> پایدار باشند، و تغییرات به روشی <em>backward-compatible</em> ایجاد شوند. پنهان کردن اطلاعات، که من در فصل 2 آن را گسترش دادم، رویکردی را توصیف می‌کند که در آن تا حد امکان اطلاعات (کد، داده‌ها) در پشت یک رابط پنهان می‌شوند. شما باید فقط حداقل اطلاعات را از طریق رابط‌های سرویس خود در معرض دید قرار دهید تا مصرف‌کنندگان خود را راضی نگه دارید. هرچه کمتر در معرض دید قرار دهید، اطمینان از اینکه تغییراتی که ایجاد می‌کنید، <em>backward compatible</em> خواهند بود، آسان‌تر می‌شود. اطلاعات</p>
<p><em>Afterword: Bringing It All Together</em> | 551</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0577</div>
            </div>
        </div>
        <!-- Page 0578 -->
        <div class="chapter" id="page-0578">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مؤخره: جمع‌بندی همه چیز (ادامه)</h4>
<p>پنهان کردن اطلاعات همچنین به ما اجازه می‌دهد تا تغییرات فناوری را در مرزهای <strong>microservice</strong> به گونه‌ای ایجاد کنیم که بر مصرف‌کنندگان تأثیر نگذارد.
   یکی از راه‌های اصلی ما برای پیاده‌سازی استقرار مستقل، پنهان کردن پایگاه داده است. اگر یک <strong>microservice</strong> نیاز به ذخیره وضعیت در یک پایگاه داده داشته باشد، این باید به طور کامل از دنیای بیرون پنهان شود. پایگاه‌های داده داخلی نباید مستقیماً در معرض دید مصرف‌کنندگان خارجی قرار گیرند، زیرا این امر باعث <strong>coupling</strong> بیش از حد بین آن دو می‌شود، که استقرار مستقل را تضعیف می‌کند. به طور کلی، از موقعیت‌هایی که در آنها چندین <strong>microservices</strong> همگی به یک پایگاه داده یکسان دسترسی دارند، اجتناب کنید.</p>
<p><strong>Microservices</strong> با طراحی <em>domain-driven</em> (<em>DDD</em>) بسیار خوب کار می‌کنند. <em>DDD</em> مفاهیمی را به ما می‌دهد که به ما کمک می‌کند تا مرزهای <strong>microservice</strong> خود را پیدا کنیم، با معماری حاصل که حول دامنه کسب‌وکار همسو شده است. این در شرایطی که سازمان‌ها در حال ایجاد تیم‌های <em>IT</em> بیشتر <em>business-centric</em> هستند، بسیار مفید است. با تیمی که بر یک بخش از دامنه کسب‌وکار متمرکز است، اکنون می‌تواند مالکیت <strong>microservices</strong> را که با این بخش از کسب‌وکار مطابقت دارد، بر عهده بگیرد.</p>
<h4>حرکت به سمت <strong>Microservices</strong></h4>
<p><strong>Microservices</strong>، پیچیدگی‌های زیادی را به همراه دارند—به اندازه کافی پیچیدگی که دلایل استفاده از آنها باید به طور جدی مورد توجه قرار گیرد. من همچنان متقاعد شده‌ام که یک <em>monolith</em> ساده با یک فرآیند واحد، یک نقطه شروع کاملاً منطقی برای یک سیستم جدید است. با گذشت زمان، ما چیزهایی را یاد می‌گیریم، و شروع به دیدن راه‌هایی می‌کنیم که در آن معماری سیستم فعلی ما دیگر برای هدف مناسب نیست. در آن مرحله، نگاه کردن به تغییر، مناسب است.
   مهم است که درک کنید که شما در تلاش برای خارج کردن یک معماری <strong>microservice</strong> هستید. هدف چیست؟ چه نتیجه مثبتی را از تغییر به <strong>microservices</strong> انتظار دارید؟ نتیجه‌ای که شما به دنبال آن هستید، مستقیماً بر نحوه جدا کردن <strong>monolith</strong> شما تأثیر می‌گذارد. اگر شما در تلاش برای تغییر معماری سیستم خود برای مدیریت بهتر مقیاس هستید، در نهایت تغییرات متفاوتی را نسبت به این که محرک اصلی شما، بهبود خودمختاری سازمانی باشد، ایجاد می‌کنید. من این موضوع را بیشتر در فصل 3 و با جزئیات بیشتر در کتاب <em>Monolith to Microservices</em> خود پوشش می‌دهم.</p>
<p>بسیاری از مشکلات مربوط به <strong>microservices</strong> فقط پس از رسیدن به تولید، مشهود می‌شوند. بنابراین، من قویاً یک تجزیه تدریجی و تکاملی از یک <strong>monolith</strong> موجود را به جای یک بازنویسی "<em>big bang</em>" توصیه می‌کنم. یک <strong>microservice</strong> را که می‌خواهید ایجاد کنید، شناسایی کنید، عملکرد مناسب را از <strong>monolith</strong> استخراج کنید، <strong>microservice</strong> جدید را به تولید منتقل کنید، و شروع به استفاده از آن کنید. بر این اساس، شما خواهید دید که آیا شما در حال کمک به حرکت به سمت هدف خود هستید، اما همچنین چیزهای زیادی یاد خواهید گرفت که استخراج <strong>microservice</strong> بعدی را آسان‌تر می‌کند—یا شاید به شما نشان دهد که <strong>microservices</strong> ممکن است به هر حال راه پیش رو نباشد!</p>
<p>552 | فصل 16: معمار تکاملی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0578</div>
            </div>
        </div>
        <!-- Page 0579 -->
        <div class="chapter" id="page-0579">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مؤخره: جمع‌بندی همه چیز (ادامه)</h4>
<p>سبک‌های ارتباطی</p>
<p>ما در فصل 4، اصلی‌ترین اشکال ارتباط بین <strong>microservice</strong>ها را خلاصه کردیم، که دوباره در شکل A-1 به اشتراک گذاشته شده است. این به عنوان یک مدل جهانی در نظر گرفته نشده است، بلکه فقط برای ارائه یک نمای کلی از انواع مختلف ارتباطات که رایج‌ترین هستند، در نظر گرفته شده است.</p>
<p>شکل A-1. سبک‌های مختلف ارتباط بین <strong>microservice</strong>ها در کنار فناوری‌های پیاده‌سازی مثال</p>
<p>با ارتباط <em>request-response</em>، یک <strong>microservice</strong> یک درخواست به یک <strong>microservice</strong> پایین‌دستی ارسال می‌کند و انتظار پاسخ دارد. با <em>synchronous request-response</em>، ما انتظار داریم که پاسخ به نمونه <strong>microservice</strong> که درخواست را ارسال کرده است، برگردد. با <em>asynchronous request-response</em>، امکان بازگشت پاسخ به یک نمونه متفاوت از <strong>microservices</strong> بالادستی وجود دارد.</p>
<p>با ارتباط مبتنی بر رویداد، یک <strong>microservice</strong>، یک رویداد را منتشر می‌کند، و سایر <strong>microservices</strong>، اگر به آن رویداد علاقه‌مند باشند، می‌توانند به آن واکنش نشان دهند. رویدادها فقط اظهارات واقعی هستند—اطلاعاتی که در مورد چیزی که اتفاق افتاده است، به اشتراک گذاشته می‌شود. با ارتباط مبتنی بر رویداد، یک <strong>microservice</strong> به یک <strong>microservice</strong> دیگر نمی‌گوید چه کاری انجام دهد. این فقط رویدادها را به اشتراک می‌گذارد. این به <strong>microservices</strong> پایین‌دستی بستگی دارد که در مورد کاری که با آن اطلاعات انجام می‌دهند، قضاوت کنند. ارتباط مبتنی بر رویداد به طور پیش‌فرض از نظر ماهیت ناهمزمان است.</p>
<p>یک <strong>microservice</strong> ممکن است از طریق بیش از یک پروتکل ارتباط برقرار کند. به عنوان مثال، در شکل A-2، ما یک <strong>microservice</strong> حمل‌ونقل را می‌بینیم که یک رابط <em>REST</em> را برای تعامل <em>request-response</em> ارائه می‌کند، که همچنین رویدادهایی را در هنگام ایجاد تغییرات منتشر می‌کند.</p>
<p><em>Afterword: Bringing It All Together</em> | 553</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 579" src="page_0579/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0579</div>
            </div>
        </div>
        <!-- Page 0580 -->
        <div class="chapter" id="page-0580">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>سبک‌های ارتباطی (ادامه)</h4>
<p>شکل A-2. یک <strong>microservice</strong> که عملکرد خود را از طریق یک <strong>REST API</strong> و یک موضوع ارائه می‌دهد</p>
<p>همکاری مبتنی بر رویداد می‌تواند ایجاد معماری‌های <em>loosely coupled</em>تر را آسان‌تر کند، اما می‌تواند به کار بیشتری برای درک نحوه عملکرد سیستم نیاز داشته باشد. این نوع ارتباط اغلب مستلزم استفاده از فناوری‌های تخصصی مانند <em>message brokers</em> است، که می‌تواند مسائل را پیچیده‌تر کند. اگر شما می‌توانید از یک <em>message broker</em> کاملاً مدیریت شده استفاده کنید، که این امر می‌تواند به کاهش هزینه این نوع سیستم‌ها کمک کند.</p>
<p>مدل‌های تعاملی <em>request-response</em> و مبتنی بر رویداد هر دو جایگاه خود را دارند، و اغلب اینکه شما از کدام یک استفاده می‌کنید، یک ترجیح شخصی خواهد بود. برخی از مشکلات فقط به یک مدل بیشتر از دیگری می‌پردازند، و برای یک معماری <strong>microservice</strong> رایج است که ترکیبی از سبک‌ها را داشته باشد.</p>
<h4>جریان کار</h4>
<p>هنگامی که به دنبال این هستید که چندین <strong>microservices</strong> را برای انجام یک عملیات فراگیر با هم همکاری کنید، به صراحت فرآیند را با استفاده از <em>sagas</em>، موضوعی که در فصل 6 بررسی کردیم، مدل‌سازی کنید.</p>
<p>به طور کلی، باید از تراکنش‌های توزیع‌شده در موقعیت‌هایی که می‌توانید به جای آن از یک <em>saga</em> استفاده کنید، اجتناب کنید. تراکنش‌های توزیع‌شده، پیچیدگی قابل توجهی را به سیستم‌ها اضافه می‌کنند، دارای حالت‌های شکست‌خورده مشکل‌سازی هستند، و اغلب آنچه را که انتظار دارید، حتی زمانی که</p>
<p><em>Afterword: Bringing It All Together</em> | 554</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 580" src="page_0580/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0580</div>
            </div>
        </div>
        <!-- Page 0581 -->
        <div class="chapter" id="page-0581">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>جریان کار (ادامه)</h4>
<p><em>Sagas</em> در تقریباً در تمام موارد، برای پیاده‌سازی فرآیندهای تجاری که <strong>microservices</strong> متعددی را در بر می‌گیرند، مناسب‌تر هستند.</p>
<p>دو سبک مختلف از <em>sagas</em> وجود دارد که باید در نظر گرفت: <em>orchestrated sagas</em> و <em>choreographed sagas</em>. <em>Orchestrated sagas</em> از یک <em>orchestrator</em> متمرکز برای هماهنگی با سایر <strong>microservices</strong> استفاده می‌کند و اطمینان حاصل می‌کند که کارها انجام می‌شوند. به طور کلی، این یک رویکرد ساده و سرراست است، اما اگر مراقب نباشید، <em>orchestrator</em> مرکزی می‌تواند بیش از حد کار انجام دهد، و می‌تواند به منبعی برای اختلاف نظر تبدیل شود، زمانی که چندین تیم روی یک فرآیند تجاری یکسان کار می‌کنند. با <em>choreographed sagas</em>، هیچ هماهنگ‌کننده مرکزی وجود ندارد. در عوض، مسئولیت فرآیند تجاری در تعدادی از <strong>microservices</strong> همکار توزیع می‌شود. این می‌تواند یک معماری پیچیده‌تر برای پیاده‌سازی باشد، و برای اطمینان از اینکه کارهای درستی در حال انجام است، به تلاش بیشتری نیاز دارد، اما از سوی دیگر، کمتر مستعد <strong>coupling</strong> است و برای تیم‌های متعدد خوب عمل می‌کند.</p>
<p>شخصاً، من عاشق <em>choreographed sagas</em> هستم، اما من آنها را زیاد استفاده کرده‌ام و اشتباهات زیادی در پیاده‌سازی آنها مرتکب شده‌ام. توصیه کلی من این است که <em>orchestrated sagas</em> زمانی خوب کار می‌کنند که یک تیم واحد، مسئولیت کل فرآیند را بر عهده دارد، اما با چندین تیم، آنها مشکل‌سازتر می‌شوند. <em>Choreographed sagas</em> می‌توانند پیچیدگی افزایش‌یافته خود را در موقعیت‌هایی که از چندین تیم انتظار می‌رود که در یک فرآیند همکاری کنند، توجیه کنند.</p>
<h4>ساخت</h4>
<p>هر <strong>microservice</strong> باید <strong>build</strong> خود و <strong>CI pipeline</strong> خود را داشته باشد. وقتی من تغییری در یک <strong>microservice</strong> ایجاد می‌کنم، انتظار دارم که بتوانم آن <strong>microservice</strong> را به تنهایی <em>build</em> کنم.
   از موقعیت‌هایی که در آنها مجبور به <em>build</em> کردن همه <strong>microservices</strong> خود با هم هستید، خودداری کنید، زیرا این امر استقرار مستقل را بسیار دشوارتر می‌کند.</p>
<p>به دلایلی که در فصل 7 توضیح داده شد، من طرفدار <em>monorepos</em> نیستم. اگر واقعاً می‌خواهید از آنها استفاده کنید، لطفاً چالش‌هایی را که در مورد مرزهای واضح مالکیت و پیچیدگی‌های بالقوه <em>builds</em> ایجاد می‌کنند، درک کنید. اما قطعاً اطمینان حاصل کنید که، چه از یک رویکرد <em>monorepo</em> یا یک رویکرد <em>multirepo</em> استفاده می‌کنید، هر <strong>microservice</strong> دارای فرآیند <strong>build CI</strong> خود است که می‌تواند به طور مستقل از هر <strong>build</strong> دیگری فعال شود.</p>
<h4>استقرار</h4>
<p><strong>Microservices</strong> معمولاً به عنوان یک فرآیند مستقر می‌شوند. این فرآیند می‌تواند بر روی یک ماشین فیزیکی، یک ماشین مجازی، یک کانتینر، یا یک پلتفرم <em>FaaS</em> مستقر شود. در حالت ایده‌آل، ما می‌خواهیم <strong>microservices</strong> تا حد امکان در یک محیط مستقر از یکدیگر جدا شوند. ما یک موقعیت را نمی‌خواهیم که در آن یک <strong>microservice</strong> با استفاده از منابع محاسباتی زیاد، بتواند بر یک <strong>microservice</strong> متفاوت تأثیر بگذارد. به طور کلی، این بدان معناست که ما می‌خواهیم هر <strong>microservice</strong> از سیستم عامل و مجموعه منابع محاسباتی خود استفاده کند. کانتینرها به‌ویژه در ارائه هر <strong>microservice</strong></p>
<p><em>Afterword: Bringing It All Together</em> | 555</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0581</div>
            </div>
        </div>
        <!-- Page 0582 -->
        <div class="chapter" id="page-0582">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>پلتفرم (ادامه)</h4>
<p>نمونه خود را حلقه-<em>fenced</em> شده از منابع خود قرار می‌دهد، که آنها را به یک انتخاب عالی برای استقرار <strong>microservice</strong>ها تبدیل می‌کند.
   <em>Kubernetes</em> می‌تواند اگر شما به دنبال اجرای <em>container workloads</em> در چندین دستگاه هستید، بسیار مفید باشد. این چیزی نیست که من آن را فقط برای چند <strong>microservices</strong> توصیه کنم، زیرا منابع پیچیدگی خود را به همراه دارد. در صورت امکان، از یک خوشه <em>Kubernetes</em> مدیریت شده استفاده کنید، زیرا این امر به شما امکان می‌دهد از برخی از این پیچیدگی‌ها اجتناب کنید.
   <strong>FaaS</strong> یک الگوی در حال ظهور جالب در استقرار کد است. به جای اینکه مجبور شوید مشخص کنید که به چه تعداد نسخه از چیزی نیاز دارید، شما فقط کد خود را به پلتفرم <em>FaaS</em> می‌دهید و می‌گویید، "وقتی این اتفاق افتاد، این کد را اجرا کن." این از نظر توسعه‌دهنده واقعاً خوب است، و من فکر می‌کنم یک انتزاع مانند این، احتمالاً آینده مقدار زیادی از توسعه سمت سرور است. با این حال، پیاده‌سازی‌های فعلی بدون مشکل نیستند. از نظر <strong>microservices</strong>، استقرار یک <strong>microservice</strong> کامل به عنوان یک "تابع" واحد در یک پلتفرم <em>FaaS</em>، یک راه کاملاً خوب برای شروع است.
   یک یادداشت نهایی: مفاهیم استقرار و انتشار را در ذهن خود از هم جدا کنید. فقط به این دلیل که شما چیزی را در تولید مستقر کرده‌اید، به این معنی نیست که باید آن را برای کاربران خود منتشر کنید. با جدا کردن این مفاهیم، شما فرصتی برای راه‌اندازی <strong>software</strong> خود به روش‌های مختلف باز می‌کنید—به عنوان مثال، با استفاده از انتشارهای <em>canary</em> یا اجراهای موازی. همه اینها و موارد دیگر به طور کامل در فصل 8 پوشش داده شده است.</p>
<h4>تست</h4>
<p>منطقی است که یک مجموعه از تست‌های عملکردی خودکار داشته باشید تا بازخورد سریعی در مورد کیفیت <strong>software</strong> خود قبل از دیدن آن توسط کاربران دریافت کنید، و این قطعاً چیزی است که شما باید انجام دهید. <strong>Microservices</strong> گزینه‌های زیادی را از نظر انواع مختلف تست‌هایی که می‌توانید بنویسید، در اختیار شما قرار می‌دهد، همانطور که ما در فصل 9 بررسی کردیم.
   با این حال، هنگامی که با سایر انواع معماری‌ها مقایسه می‌شود، تست‌های <em>end-to-end</em> می‌توانند به‌ویژه برای معماری‌های <strong>microservice</strong> مشکل‌ساز باشند. آنها می‌توانند پرهزینه‌تر شوند تا برای معماری‌های <strong>microservice</strong> نسبت به معماری‌های ساده‌تر و غیرتوزیع‌شده نوشته و نگهداری شوند، و خود تست‌ها می‌توانند خطاهای بیشتری را به همراه داشته باشند که لزوماً به یک مشکل در کد شما اشاره ندارند. تست‌های <em>end-to-end</em> که چندین تیم را در بر می‌گیرند، به‌ویژه چالش‌برانگیز هستند.
   با گذشت زمان، به دنبال کاهش اتکای خود به تست‌های <em>end-to-end</em> باشید. در نظر بگیرید که مقداری از تلاش انجام شده در این شکل از تست را با قراردادهای <em>consumer-driven</em>، بررسی سازگاری <em>schema</em>، و تست در تولید جایگزین کنید. این فعالیت‌ها می‌توانند بسیار مؤثرتر از تست‌های <em>end-to-end</em> در گرفتن سریع مسائل در سیستم‌های توزیع‌شده‌تر، ارائه شوند.</p>
<p><em>Afterword: Bringing It All Together</em> | 555</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0582</div>
            </div>
        </div>
        <!-- Page 0583 -->
        <div class="chapter" id="page-0583">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>پایش و قابلیت مشاهده</h4>
<p>در فصل 10، من توضیح دادم که چگونه پایش یک فعالیت است، چیزی که ما برای یک سیستم انجام می‌دهیم، اما تمرکز بر روی یک فعالیت به جای یک نتیجه مشکل‌ساز است، موضوعی که در این کتاب به آن پرداخته شده است. در عوض، ما باید بر روی قابلیت مشاهده سیستم‌های خود تمرکز کنیم. قابلیت مشاهده، میزان درک ما از آنچه یک سیستم با بررسی خروجی‌های خارجی انجام می‌دهد، است. ساختن سیستمی که قابلیت مشاهده خوبی داشته باشد، مستلزم این است که ما این تفکر را در <strong>software</strong> خود ایجاد کنیم و اطمینان حاصل کنیم که انواع مناسبی از خروجی‌های خارجی در دسترس هستند.</p>
<p>سیستم‌های توزیع‌شده می‌توانند به روش‌های عجیبی شکست بخورند، و <strong>microservices</strong> نیز تفاوتی ندارند. ما نمی‌توانیم تمام علل خرابی سیستم را پیش‌بینی کنیم، بنابراین ممکن است سخت باشد که بدانیم از قبل به چه اطلاعاتی برای تشخیص و رفع مشکلات نیاز داریم. استفاده از ابزارهایی که می‌تواند به شما در بررسی این خروجی‌های خارجی به روش‌هایی که نمی‌توانید انتظار داشته باشید، کمک کند، به طور فزاینده‌ای مهم می‌شود. من پیشنهاد می‌کنم که شما به ابزارهایی مانند <em>Lightstep</em> و <em>Honeycomb</em> نگاهی بیندازید که با این تفکر ساخته شده‌اند.</p>
<p>در نهایت، با افزایش مقیاس سیستم شما، این احتمال بیشتر می‌شود که همیشه یک خطا در جایی وجود داشته باشد. اما در یک سیستم با مقیاس بزرگ، داشتن یک مشکل در یک دستگاه لزوماً دلیلی برای اینکه همه وارد عمل شوند نیست، و نه لزوماً باید منجر به یک بیداری ناگهانی برای کسی در ساعت 3 صبح شود. استفاده از تکنیک‌های "آزمایش در تولید" مانند <em>parallel runs</em> و تراکنش‌های مصنوعی می‌تواند برای شناسایی مشکلاتی که ممکن است واقعاً بر کاربران نهایی تأثیر بگذارند، بسیار مؤثرتر باشد.</p>
<h4>امنیت</h4>
<p><strong>Microservices</strong> به ما فرصت بیشتری برای دفاع از برنامه خود با عمق بیشتر می‌دهند، که به نوبه خود می‌تواند منجر به سیستم‌های امن‌تر شود. از سوی دیگر، آنها اغلب یک <em>attack surface area</em> بزرگتر دارند، که می‌تواند ما را در معرض حمله قرار دهد! این عمل متعادل‌کننده به همین دلیل است که داشتن درک جامع از امنیت بسیار مهم است، چیزی که من در فصل 11 به اشتراک گذاشتم.
   با جریان یافتن اطلاعات بیشتر در شبکه‌ها، در نظر گرفتن محافظت از داده‌ها در حال انتقال، مهم‌تر می‌شود. افزایش تعداد قطعات متحرک نیز به این معنی است که اتوماسیون یک بخش حیاتی از امنیت <strong>microservice</strong> است. مدیریت <em>patching</em>، گواهی‌نامه‌ها، و <em>secrets</em> با استفاده از فرآیندهای دستی و مستعد خطا می‌تواند شما را در برابر حمله آسیب‌پذیر کند. بنابراین از ابزارهایی استفاده کنید که امکان اتوماسیون را فراهم می‌کنند.
   <em>JWTs</em> را می‌توان برای غیرمتمرکز کردن منطق <strong>authorization</strong> به گونه‌ای استفاده کرد که از نیاز به <em>round trips</em> اضافی نیز اجتناب می‌شود. این می‌تواند به شما در محافظت از مشکلاتی مانند مشکل <em>confused deputy</em> کمک کند، در حالی که در عین حال اطمینان حاصل می‌شود که <strong>microservice</strong> شما می‌تواند به روشی مستقل‌تر اجرا شود.
   در نهایت، تعداد فزاینده‌ای از افراد، یک ذهنیت عدم اعتماد را اتخاذ می‌کنند. با عدم اعتماد، شما طوری عمل می‌کنید که گویی سیستم شما قبلاً به خطر افتاده است و شما</p>
<p><em>Afterword: Bringing It All Together</em> | 557</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0583</div>
            </div>
        </div>
        <!-- Page 0584 -->
        <div class="chapter" id="page-0584">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>امنیت (ادامه)</h4>
<p>باید <strong>microservices</strong> خود را متناسب با آن بسازید. ممکن است یک موضع پارانوید به نظر برسد، اما من به طور فزاینده‌ای معتقدم که پذیرفتن این اصل می‌تواند در واقع نحوه مشاهده امنیت سیستم شما را ساده کند.</p>
<h4>انعطاف‌پذیری</h4>
<p>در فصل 12، ما به طور کلی به <strong>resiliency</strong> نگاه کردیم، و من چهار مفهوم کلیدی را با شما در میان گذاشتم که هنگام فکر کردن در مورد <strong>resiliency</strong> باید در نظر گرفته شوند:</p>
<ul>
<li><strong>Robustness</strong></li>
<p>توانایی جذب اختلالات مورد انتظار</p>
<li><strong>Rebound</strong></li>
<p>توانایی بازیابی پس از یک رویداد آسیب‌زا</p>
<li><strong>Graceful extensibility</strong></li>
<p>اینکه چقدر خوب با موقعیتی که غیرمنتظره است، برخورد می‌کنیم</p>
<li><strong>Sustained adaptability</strong></li>
<p>توانایی انطباق مداوم با محیط‌های در حال تغییر، ذینفعان، و مطالبات</p>
</ul>
<p>در کل، معماری‌های <strong>microservice</strong> می‌توانند به برخی از این موارد کمک کنند (یعنی <strong>robustness</strong> و <strong>rebound</strong>)، اما همانطور که از این لیست می‌بینیم، این به خودی خود شما را انعطاف‌پذیر نمی‌کند. بخش زیادی از انعطاف‌پذیری در مورد رفتار و فرهنگ تیم و سازمان است.</p>
<p>اساساً، شما باید صریحاً کارهایی را انجام دهید تا برنامه خود را <strong>robust</strong>تر کنید. <strong>Robustness</strong> رایگان نیست—<strong>microservices</strong> به ما این امکان را می‌دهند که <strong>resiliency</strong> سیستم‌های خود را بهبود بخشیم، اما ما باید این انتخاب را انجام دهیم. به عنوان مثال، ما باید درک کنیم که هر تماسی که با یک <strong>microservice</strong> دیگر برقرار می‌کنیم ممکن است شکست بخورد، که ماشین‌ها ممکن است از بین بروند، و چیزهای بدی برای بسته‌های شبکه خوب اتفاق می‌افتد. الگوهای پایداری مانند <em>bulkheads</em>، <em>circuit breakers</em>، و <em>time-outs</em> به‌درستی پیکربندی شده می‌توانند بسیار کمک کنند.</p>
<h4>مقیاس‌پذیری</h4>
<p><strong>Microservices</strong> راه‌های مختلفی را برای مقیاس‌بندی یک برنامه به ما ارائه می‌دهند. در فصل 13، من چهار محور مقیاس‌پذیری را بررسی می‌کنم، که در زیر با شما به اشتراک می‌گذارم:</p>
<ul>
<li>مقیاس‌پذیری عمودی</li>
<p>به طور خلاصه، این به معنای داشتن یک ماشین بزرگتر است.</p>
<li>تکثیر افقی</li>
<p>داشتن چندین چیز که قادر به انجام کار مشابهی هستند.</p>
</ul>
<p><em>Afterword: Bringing It All Together</em> | 555</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0584</div>
            </div>
        </div>
        <!-- Page 0585 -->
        <div class="chapter" id="page-0585">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مقیاس‌پذیری (ادامه)</h4>
<ul>
<li>تقسیم داده‌ها</li>
<p>تقسیم کار بر اساس برخی از ویژگی‌های داده‌ها، به عنوان مثال، گروه مشتری.</p>
<li>تجزیه عملکردی</li>
<p>جداسازی کار بر اساس نوع، به عنوان مثال، تجزیه <strong>microservice</strong>.</p>
</ul>
<p>با مقیاس‌پذیری، ابتدا کارهای آسان را انجام دهید. مقیاس‌پذیری عمودی و تکثیر افقی در مقایسه با دو محور دیگری که در اینجا ارائه شده‌اند، سریع و آسان هستند. اگر آنها کار کردند، عالی است! اگر نه، شما می‌توانید به مکانیسم‌های دیگر نگاهی بیندازید. همچنین رایج است که انواع مختلف مقیاس‌بندی را با هم ترکیب کنید—به عنوان مثال، تقسیم ترافیک خود بر اساس مشتریان، و سپس داشتن هر پارتیشن که به صورت افقی مقیاس‌بندی شده است.</p>
<h4>رابط‌های کاربری</h4>
<p>بسیار دیده می‌شود که رابط کاربری، یک مسئله فرعی در هنگام تجزیه سیستم است—ما <strong>microservices</strong> خود را از هم جدا می‌کنیم اما یک رابط کاربری <strong>monolithic</strong> را رها می‌کنیم. این به نوبه خود منجر به مشکلات داشتن تیم‌های <strong>frontend</strong> و <strong>backend</strong> جداگانه می‌شود.
   در عوض، ما تیم‌های <strong>stream-aligned</strong> را می‌خواهیم، که در آن یک تیم، مالک تمام عملکردهای مرتبط با یک بخش <strong>end-to-end</strong> از عملکرد کاربر است. برای ایجاد این تغییر و خلاص شدن از شر تیم‌های <strong>frontend</strong> و <strong>backend siloed</strong>، ما باید رابط‌های کاربری خود را از هم جدا کنیم.
   در فصل 14، من به اشتراک گذاشتم که چگونه می‌توانیم از <strong>micro frontends</strong> برای ارائه رابط‌های کاربری تجزیه‌شده با استفاده از فریم‌ورک‌های برنامه تک صفحه‌ای مانند <em>React</em> استفاده کنیم. رابط‌های کاربری اغلب با مشکلاتی از نظر تعداد تماس‌هایی که باید برقرار کنند، یا به این دلیل که باید <strong>call aggregation</strong> و فیلتر کردن را برای مطابقت با دستگاه‌های تلفن همراه انجام دهند، مواجه هستند. الگوی <strong>backend for frontend (BFF)</strong> می‌تواند در این شرایط به ارائه تجمیع و فیلتر کردن در سمت سرور کمک کند، اگرچه اگر شما قادر به استفاده از <em>GraphQL</em> هستید، ممکن است بتوانید از استفاده از <strong>BFFs</strong> اجتناب کنید.</p>
<h4>سازمان</h4>
<p>در فصل 15، ما به تغییر از تیم‌های <em>siloed</em> همسو شده به ساختارهای تیمی که حول بخش‌های <strong>end-to-end</strong> عملکرد سازماندهی شده‌اند، نگاه کردیم. این تیم‌های <strong>stream-aligned</strong>، همانطور که نویسندگان <em>Team Topologies</em> آنها را توصیف می‌کنند، توسط تیم‌های فعال‌کننده پشتیبانی می‌شوند، همانطور که شکل A-3 نشان می‌دهد. تیم‌های فعال‌کننده اغلب یک تمرکز خاص <em>cross-cutting</em>، مانند تمرکز بر امنیت یا قابلیت استفاده، خواهند داشت، و از تیم‌های <strong>stream-aligned</strong> در این جنبه‌ها پشتیبانی می‌کنند.</p>
<p><em>Afterword: Bringing It All Together</em> | 559</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0585</div>
            </div>
        </div>
        <!-- Page 0586 -->
        <div class="chapter" id="page-0586">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>تیم‌های فعال‌کننده (ادامه)</h4>
<p>شکل A-3. تیم‌های فعال‌کننده، از تیم‌های <strong>stream-aligned</strong> متعدد پشتیبانی می‌کنند</p>
<p>به حداکثر رساندن استقلال این تیم‌های <strong>stream-aligned</strong>، به این معنی است که آنها به ابزارهای <em>self-service</em> نیاز دارند تا از اینکه دائماً از تیم‌های دیگر بخواهند کارهایی را برای آنها انجام دهند، جلوگیری کنند.
   به عنوان بخشی از این، یک پلتفرم می‌تواند فوق‌العاده مفید باشد. با این حال، مهم است که ما یک پلتفرم را به عنوان نوعی جاده آسفالت شده در نظر بگیریم—یعنی، چیزی که انجام کار درست را آسان می‌کند، بدون نیاز به استفاده از آن. اختیاری کردن پلتفرم تضمین می‌کند که آسان کردن استفاده از پلتفرم همچنان یک تمرکز اصلی برای تیمی است که آن را در اختیار دارد، و در عین حال به تیم‌ها اجازه می‌دهد در صورت لزوم، یک انتخاب متفاوت داشته باشند.</p>
<h4>معماری</h4>
<p>مهم است که ما معماری سیستم خود را ثابت و بدون تغییر نبینیم. در عوض، ما باید معماری سیستم خود را چیزی بدانیم که باید بتواند با توجه به شرایط، به‌طور مداوم تغییر کند. برای اینکه شما بیشترین بهره را از معماری‌های <strong>microservice</strong> ببرید، حرکت به سمت سازمانی که در آن خودمختاری بیشتری به تیم‌ها منتقل می‌شود، به این معنی است که مسئولیت چشم‌انداز فنی باید به یک فرآیند مشارکتی‌تر تبدیل شود. معماری که در یک برج عاج نشسته است، یا یک مسدودکننده قابل توجه برای معماری <strong>microservice</strong> خواهد بود یا به یک بی‌ربطی نادیده گرفته شده تبدیل می‌شود.</p>
<p>نقش هدایت معماری یک سیستم می‌تواند کاملاً در تیم‌ها توزیع شود، و در یک سطح معین از مقیاس، این می‌تواند به خوبی کار کند. با این حال، با رشد سازمان، داشتن افرادی که زمان اختصاصی برای نگاه کردن به کل سیستم دارند، ضروری می‌شود. آنها را مهندسان اصلی، صاحبان محصول فنی، یا معماران بنامید، واقعاً مهم نیست—نقشی که آنها باید ایفا کنند، یکسان است. همانطور که در فصل 16 نشان دادم، معماران در یک سازمان <strong>microservice</strong> باید از تیم‌ها پشتیبانی کنند، افراد را به هم متصل کنند، الگوهای در حال ظهور را شناسایی کنند، و زمان کافی را با تیم‌ها سپری کنند تا ببینند که چگونه چیزهای بزرگ در واقعیت عمل می‌کنند.</p>
<p><em>Afterword: Bringing It All Together</em> | 557</p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 586" src="page_0586/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0586</div>
            </div>
        </div>
        <!-- Page 0587 -->
        <div class="chapter" id="page-0587">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>مطالعه بیشتر</h4>
<p>در سراسر این کتاب، من به مقالات، ارائه‌ها و کتاب‌های زیادی ارجاع داده‌ام که چیزهای زیادی از آنها آموخته‌ام، و من اطمینان حاصل کرده‌ام که آنها را در کتاب‌شناسی فهرست کنم.
   با این حال، از زمان انتشار اولین نسخه، دو کتابی که بیشترین تأثیر را بر تفکر من داشته‌اند، و در نتیجه در این نسخه جدید به‌طور گسترده به آنها ارجاع داده شده است، ارزش این را دارند که در اینجا به عنوان "باید خوانده شوند" معرفی شوند. اولی، <em>Accelerate</em> اثر <em>Nicole Forsgren</em>، <em>Jez Humble</em> و <em>Gene Kim</em> است. دومی، <em>Team Topologies</em> اثر <em>Matthew Skelton</em> و <em>Manuel Pais</em> است. به نظر من، این دو کتاب، دو کتاب مفید در مورد توسعه <strong>software</strong> هستند که در ده سال گذشته نوشته شده‌اند، و من آنها را خواندن ضروری می‌دانم، چه شما به <strong>microservices</strong> علاقه‌مند باشید و چه نباشید.</p>
<p>به عنوان همراهی برای این کتاب، کتاب <em>Monolith to Microservices</em> من، به عمق بیشتری در مورد چگونگی جدا کردن معماری‌های سیستم موجود می‌پردازد.</p>
<h4>نگاهی به آینده</h4>
<p>در آینده، من گمان می‌کنم فناوری که ساخت و اجرای <strong>microservices</strong> را آسان‌تر می‌کند، همچنان بهبود خواهد یافت، و من به‌ویژه مشتاق هستم که ببینم محصولات نسل دوم (و سوم) <em>FaaS</em> چگونه به نظر می‌رسند. چه <em>FaaS</em> موفق شود و چه نشود، <em>Kubernetes</em> حتی گسترده‌تر خواهد شد، حتی اگر به طور فزاینده‌ای پشت لایه‌های انتزاعی <em>developer-friendly</em> بیشتر پنهان شود. <em>Kubernetes</em> برنده شده است، اما به روشی که فکر می‌کنم اکثر توسعه‌دهندگان برنامه نباید نگران آن باشند. من همچنان بسیار علاقه‌مند به دیدن این هستم که چگونه <em>Wasm</em>، نحوه تفکر ما در مورد استقرار را تغییر می‌دهد، و من هنوز هم این گمان را دارم که <em>unikernels</em> ممکن است یک بازگشت دوباره داشته باشند.</p>
<p>از زمان انتشار اولین نسخه این کتاب، <strong>microservices</strong>ها واقعاً و به درستی به جریان اصلی وارد شده‌اند که من را شگفت‌زده کرده است، و این نیز مرا نگران کرده است. به نظر می‌رسد که بسیاری از افرادی که <strong>microservices</strong> را اتخاذ می‌کنند، این کار را بیشتر به این دلیل انجام می‌دهند که همه دیگران این کار را انجام می‌دهند، تا اینکه <strong>microservices</strong> برای آنها مناسب باشد. به این ترتیب، من کاملاً انتظار دارم که در مورد پیاده‌سازی‌های <strong>microservice</strong> شکست‌خورده، داستان‌های وحشتناک بیشتری بشنویم، که من با لذت آنها را هضم خواهم کرد تا ببینم چه چیزی می‌توان از آنها آموخت. من همچنین کاملاً انتظار دارم که در مقطعی، یک واکنش گسترده صنعتی در برابر <strong>microservices</strong> وجود داشته باشد، زمانی که مطالعات موردی فاجعه <strong>microservice</strong> به <em>critical mass</em> برسد. اعمال تفکر انتقادی برای یافتن اینکه چه رویکردی در هر موقعیت معینی منطقی‌تر است، چندان جذاب یا قابل بازاریابی نیست، و من انتظار ندارم که این در جهانی که فروش فناوری سودآورتر از فروش ایده‌ها است، تغییری کند.</p>
<p>من قصد ندارم بدبین به نظر برسم! ما، به عنوان یک صنعت، هنوز هم بسیار جوان هستیم، و هنوز هم در حال یافتن جایگاه خود در جهان هستیم. مقدار انرژی و نبوغی که در توسعه <strong>software</strong> قرار می‌گیرد، همچنان مرا علاقه‌مند نگه می‌دارد، و من بی‌صبرانه منتظر هستم تا ببینم دهه آینده چه چیزی به ارمغان می‌آورد.</p>
<p><em>Afterword: Bringing It All Together</em> | 557</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0587</div>
            </div>
        </div>
        <!-- Page 0588 -->
        <div class="chapter" id="page-0588">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>سخن پایانی</h4>
<p>معماری‌های <strong>Microservice</strong> گزینه‌های بیشتری را در اختیار شما قرار می‌دهند، و تصمیمات بیشتری برای اتخاذ. تصمیم‌گیری در این دنیا، یک فعالیت بسیار رایج‌تر از سیستم‌های ساده‌تر و <strong>monolithic</strong> است. من می‌توانم تضمین کنم که شما همه این تصمیمات را درست نخواهید گرفت. بنابراین، با دانستن اینکه شما قرار است برخی از چیزها را اشتباه انجام دهید، گزینه‌های شما چیست؟ خوب، من پیشنهاد می‌کنم راه‌هایی برای کوچک کردن دامنه هر تصمیم پیدا کنید. به این ترتیب، اگر در یک مورد اشتباه کنید، فقط بر بخش کوچکی از سیستم خود تأثیر می‌گذارید. یاد بگیرید که مفهوم معماری تکاملی را بپذیرید، که در آن سیستم شما در طول زمان خم می‌شود، انعطاف‌پذیر می‌شود و تغییر می‌کند، زیرا شما چیزهای جدیدی یاد می‌گیرید. به جای آن که به بازنویسی‌های <em>big-bang</em> فکر کنید، در عوض به مجموعه‌ای از تغییرات ایجاد شده در سیستم خود در طول زمان فکر کنید تا آن را منعطف نگه دارید.</p>
<p>امیدوارم که تاکنون، اطلاعات و تجربیات کافی را با شما به اشتراک گذاشته باشم تا به شما در تصمیم‌گیری در مورد اینکه آیا <strong>microservices</strong> برای شما مناسب هستند یا خیر، کمک کنم. اگر اینطور است، امیدوارم که این را به عنوان یک سفر در نظر بگیرید، نه یک مقصد. به صورت افزایشی پیش بروید. سیستم خود را قطعه به قطعه جدا کنید، و در طول مسیر یاد بگیرید. و به آن عادت کنید: از بسیاری جهات، انضباط برای تغییر و تکامل مداوم سیستم‌های ما، یک درس بسیار مهم‌تر از هر درس دیگری است که من از طریق این کتاب با شما به اشتراک گذاشته‌ام. تغییر اجتناب‌ناپذیر است. آن را بپذیرید.</p>
<p><em>Afterword: Bringing It All Together</em> | 557</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0588</div>
            </div>
        </div>
        <!-- Page 0589 -->
        <div class="chapter" id="page-0589">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>کتاب‌شناسی</h4>
<p><em>2020 Data Breach Investigations Report</em>. <em>Verizon</em>, 2020. <a href="https://oreil.ly/ps0Cx">https://oreil.ly/ps0Cx</a>.</p>
<p><em>Abbott, Martin L., and Michael T. Fisher</em>. <em>The Art of Scalability: Scalable Web Architecture, Processes, and Organizations for the Modern Enterprise</em>. 2nd ed. <em>Boston</em>: <em>Addison-Wesley</em>, 2015.</p>
<p><em>Allspaw, John</em>. “Blameless Post-Mortems and a Just Culture.” <em>Code as Craft</em> (blog). <em>Etsy</em>, May 22, 2012. <a href="https://oreil.ly/P1BcX">https://oreil.ly/P1BcX</a>.</p>
<p><em>Bache, Emily</em>. “End-to-End Automated Testing in a Microservice Architecture.” <em>NDC Conferences</em>. July 5, 2017. YouTube video, 56:48. <a href="https://oreil.ly/DbFdR">https://oreil.ly/DbFdR</a>.</p>
<p><em>Bell, Laura, Michael Brunton-Spall, Rich Smith, and Jim Bird</em>. <em>Agile Application Security</em>. <em>Sebastopol</em>: <em>O’Reilly</em>, 2017.</p>
<p><em>Beyer, Betsy, Chris Jones, Jennifer Petoff, and Niall Richard Murphy, eds. Site Reliability Engineering: How Google Runs Production Systems</em>. <em>Sebastopol</em>: <em>O’Reilly</em>, 2016.</p>
<p><em>Beyer, Betsy, Niall Richard Murphy, David K. Rensin, Kent Kawahara, and Stephen Thorne, eds. The Site Reliability Workbook: Practical Ways to Implement SRE</em>. <em>Sebastopol</em>: <em>O’Reilly</em>, 2018.</p>
<p><em>Bird, Christian, Nachi Nagappan, Brendan Murphy, Harald Gall, and Premkumar Devanbu</em>. “Don’t Touch My Code! Examining the Effects of Ownership on Software Quality.” In <em>ESEC/FSE ’11: Proceedings of the 19th ACM SIGSOFT Symposium and the 13th European Conference on Foundations of Software Engineering</em>, 4–14. <em>New York</em>: <em>ACM</em>, 2011. doi.org/10.1145/2025113.2025119.</p>
<p><em>Brandolini, Alberto</em>. <em>EventStorming</em>. <em>Victoria</em>, <em>BC</em>: <em>Leanpub</em>, forthcoming.</p>
<p><em>Brooks, Frederick P., Jr. The Mythical Man-Month: Essays on Software Engineering, Anniversary ed</em>. <em>Boston</em>: <em>Addison-Wesley</em>, 1995.</p>
<p><em>Brown, Alanna, Nicole Forsgren, Jez Humble, Nigel Kersten, and Gene Kim</em>. 2016 <em>State of DevOps Report</em>. <a href="https://oreil.ly/WJjhA">https://oreil.ly/WJjhA</a>.</p>
<p>کتاب‌شناسی | 563</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0589</div>
            </div>
        </div>
        <!-- Page 0590 -->
        <div class="chapter" id="page-0590">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>کتاب‌شناسی (ادامه)</h4>
<p><em>Bryant, Daniel</em>. “Apple Rebuilds Siri Backend Services Using Apache Mesos.” <em>InfoQ</em>, May 3, 2015. <a href="https://oreil.ly/NsjEQ">https://oreil.ly/NsjEQ</a>.</p>
<p><em>Burns, Brendan, Brian Grant, David Oppenheimer, Eric Brewer, and John Wilkes</em>. “Borg, Omega, and Kubernetes.” <em>acmqueue</em> 14, no. 1 (2016). <a href="https://oreil.ly/2TlYG">https://oreil.ly/2TlYG</a>.</p>
<p><em>Calçado, Phil</em>. “Pattern: Using Pseudo-URIs with Microservices.” May 22, 2017. <a href="https://oreil.ly/uZuto">https://oreil.ly/uZuto</a>.</p>
<p><em>Cockburn, Alistair</em>. “Hexagonal Architecture.” <em>alistair.cockburn.us</em>, January 4, 2005. <a href="https://oreil.ly/0JeIm">https://oreil.ly/0JeIm</a>.</p>
<p><em>Cohn, Mike</em>. <em>Succeeding with Agile</em>. <em>Upper Saddle River</em>, <em>NJ</em>: <em>Addison-Wesley</em>, 2009.</p>
<p><em>Colyer, Adrian</em>. “Information Distribution Aspects of Design Methodology.” <em>The Morning Paper</em> (blog), October 17, 2016. <a href="https://oreil.ly/qxj2m">https://oreil.ly/qxj2m</a>.</p>
<p><em>Crispin, Lisa, and Janet Gregory. Agile Testing: A Practical Guide for Testers and Agile Teams</em>. <em>Upper Saddle River</em>, <em>NJ</em>: <em>Addison-Wesley</em>, 2008.</p>
<p><em>Evans, Eric. Domain-Driven Design: Tackling Complexity in the Heart of Software</em>. <em>Boston</em>: <em>Addison-Wesley</em>, 2004.</p>
<p><em>Ford, Neal, Rebecca Parsons, and Patrick Kua. Building Evolutionary Architectures</em>. <em>Sebastopol</em>: <em>O’Reilly</em>, 2017.</p>
<p><em>Forsgren, Nicole, Dustin Smith, Jez Humble, and Jessie Frazelle. Accelerate: State of DevOps Report 2019</em>. <a href="https://oreil.ly/A3zGn">https://oreil.ly/A3zGn</a>.</p>
<p><em>Forsgren, Nicole, Jez Humble, and Gene Kim. Accelerate: The Science of Building and Scaling High Performing Technology Organizations</em>. <em>Portland</em>, <em>OR</em>: <em>IT Revolution</em>, 2018.</p>
<p><em>Fowler, Martin</em>. “CodeOwnership.” <em>martinfowler.com</em>, May 12, 2006. <a href="https://oreil.ly/a42c7">https://oreil.ly/a42c7</a>.</p>
<p><em>Fowler, Martin</em>. “Eradicating Non-Determinism in Tests.” <em>martinfowler.com</em>, April 14, 2011. <a href="https://oreil.ly/sqPOD">https://oreil.ly/sqPOD</a>.</p>
<p><em>Fowler, Martin</em>. “StranglerFigApplication.” <em>martinfowler.com</em>, June 29, 2004. <a href="https://oreil.ly/foti0">https://oreil.ly/foti0</a>.</p>
<p><em>Freeman, Steve, and Nat Pryce. Growing Object-Oriented Software, Guided by Tests</em>. <em>Upper Saddle River</em>, <em>NJ</em>: <em>Addison-Wesley</em>, 2009.</p>
<p><em>Friedrichsen, Uwe</em>. “The Limits of the Saga Pattern.” <em>ufried.com</em> (blog). February 19, 2021. <a href="https://oreil.ly/X1BfK">https://oreil.ly/X1BfK</a>.</p>
<p><em>Garcia-Molina, Hector, Dieter Gawlick, Johannes Klein, and Karl Kleissner</em>. “Modeling Long-Running Activities as Nested Sagas.” <em>Data Engineering</em> 14, no. 1 (March 1991): 14–18. <a href="https://oreil.ly/RVp7A1">https://oreil.ly/RVp7A1</a>.</p>
<p>564 | فصل 16: معمار تکاملی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0590</div>
            </div>
        </div>
        <!-- Page 0591 -->
        <div class="chapter" id="page-0591">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>کتاب‌شناسی (ادامه)</h4>
<p><em>Garcia-Molina, Hector, and Kenneth Salem</em>. “Sagas.” <em>ACM Sigmod Record</em> 16, no. 3 (1987): 249–59.</p>
<p><em>Governor, James</em>. “Towards Progressive Delivery.” <em>James Governor’s MonkChips</em> (blog). <em>RedMonk</em>, August 6, 2018. <a href="https://oreil.ly/OlkEY">https://oreil.ly/OlkEY</a>.</p>
<p><em>Heinemeier Hansson, David</em>. “The Majestic Monolith.” <em>Signal v. Noise</em>, February 29, 2016. <a href="https://oreil.ly/fN5CR">https://oreil.ly/fN5CR</a>.</p>
<p><em>Hodgson, Pete</em>. “Feature Toggles (aka Feature Flags).” <em>martinfowler.com</em>, October 9, 2017. <a href="https://oreil.ly/pSPrd">https://oreil.ly/pSPrd</a>.</p>
<p><em>Hohpe, Gregor</em>. <em>The Software Architect Elevator: Redefining the Architect’s Role in the Digital Enterprise</em>. <em>Sebastopol</em>: <em>O’Reilly</em>, 2020.</p>
<p><em>Hohpe, Gregor, and Bobby Woolf</em>. <em>Enterprise Integration Patterns</em>. <em>Boston</em>: <em>Addison-Wesley</em>, 2003.</p>
<p><em>Humble, Jez, and David Farley. Continuous Delivery: Reliable Software Releases Through Build, Test, and Deployment Automation</em>. <em>Upper Saddle River</em>, <em>NJ</em>: <em>Addison-Wesley</em>, 2010.</p>
<p><em>Hunt, Troy</em>. “Passwords Evolved: Authentication Guidance for the Modern Era.” <em>troyhunt.com</em>, July 26, 2017. <a href="https://oreil.ly/r4ava">https://oreil.ly/r4ava</a>.</p>
<p><em>Ingles, Paul</em>. “Convergence to Kubernetes.” Medium, June 18, 2018. <a href="https://oreil.ly/oB2FI">https://oreil.ly/oB2FI</a>.</p>
<p><em>Ishmael, Johnathan</em>. “Optimising Serverless for BBC Online.” <em>Technology and Creativity at the BBC</em> (blog), <em>BBC</em>, January 26, 2021. <a href="https://oreil.ly/mPp2L">https://oreil.ly/mPp2L</a>.</p>
<p><em>Jackson, Cam</em>. “Micro Frontends.” <em>martinfowler.com</em>, June 19, 2019. <a href="https://oreil.ly/nYu15">https://oreil.ly/nYu15</a>.</p>
<p><em>Kingsbury, Kyle</em>. “Jepsen: Elasticsearch.” <em>Aphyr</em>, June 15, 2014. <a href="https://oreil.ly/6l2sR">https://oreil.ly/6l2sR</a>.</p>
<p><em>Kingsbury, Kyle</em>. “Jepsen: Elasticsearch 1.5.0.” <em>Aphyr</em>, April 27, 2015. <a href="https://oreil.ly/jlu8p">https://oreil.ly/jlu8p</a>.</p>
<p><em>Kleppmann, Martin</em>. <em>Designing Data-Intensive Applications</em>. <em>Sebastopol</em>: <em>O’Reilly</em>, 2017.</p>
<p><em>Krishnan, Kripa</em>. “Weathering the Unexpected.” <em>acmqueue</em> 10, no. 9 (2012). <a href="https://oreil.ly/BN2Ek">https://oreil.ly/BN2Ek</a>.</p>
<p><em>Kubis, Robert</em>. “Google Cloud Spanner: Global Consistency at Scale by Robert Kubis.” <em>Devoxx</em>. November 7, 2017. YouTube video, 33:22. <a href="https://oreil.ly/fwbMD">https://oreil.ly/fwbMD</a>.</p>
<p><em>Lamport, Leslie</em>. “Time, Clocks, and the Ordering of Events in a Distributed System.” <em>Communications of the ACM</em>. 21, no. 7 (July 1978): 558–65. <a href="https://oreil.ly/Y07gU">https://oreil.ly/Y07gU</a>.</p>
<p>کتاب‌شناسی | 565</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0591</div>
            </div>
        </div>
        <!-- Page 0592 -->
        <div class="chapter" id="page-0592">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>کتاب‌شناسی (ادامه)</h4>
<p><em>Lewis, James</em>. “Scale, Microservices and Flow.” <em>YOW! Conferences</em>. February 10, 2020. YouTube video, 51:03. <a href="https://oreil.ly/nzXqX">https://oreil.ly/nzXqX</a>.</p>
<p><em>Losio, Renato</em>. “Elastic Changes Licences for Elasticsearch and Kibana: AWS Forks Both.” <em>InfoQ</em>, January 25, 2021. <a href="https://oreil.ly/PClFv">https://oreil.ly/PClFv</a>.</p>
<p><em>MacCormack, Alan, Carliss Y. Baldwin, and John Rusnak</em>. “Exploring the Duality Between Product and Organizational Architectures: A Test of the Mirroring Hypothesis.” <em>Research Policy</em> 41, no. 8 (October 2012): 1309–24.</p>
<p><em>Majors, Charity</em>. “Metrics: Not the Observability Droids You’re Looking For.” <em>Honeycomb</em> (blog), October 24, 2017. <a href="https://oreil.ly/RpZaZ">https://oreil.ly/RpZaZ</a>.</p>
<p><em>Majors, Charity, Liz Fong-Jones, and George Miranda. Observability Engineering</em>. <em>Sebastopol</em>: <em>O’Reilly</em>, 2022.</p>
<p><em>McAllister, Neil</em>. “Code Spaces Goes Titsup FOREVER After Attacker NUKES Its Amazon-Hosted Data.” <em>The Register</em>, June 18, 2014. <a href="https://oreil.ly/IUOD0">https://oreil.ly/IUOD0</a>.</p>
<p><em>Miles, Russ. Learning Chaos Engineering</em>. <em>Sebastopol</em>: <em>O’Reilly</em>, 2019.</p>
<p><em>Moore, Jon</em>. “Architecture with 800 of My Closest Friends: The Evolution of Comcast’s Architecture Guild.” <em>InfoQ</em>, May 14, 2019. <a href="https://oreil.ly/dVfhi">https://oreil.ly/dVfhi</a>.</p>
<p><em>Morris, Kief. Infrastructure as Code</em>. 2nd ed. <em>Sebastopol</em>: <em>O’Reilly</em>, 2016.</p>
<p><em>Nagappan, Nachiappan, Brendan Murphy, and Victor Basili</em>. “The Influence of Organizational Structure on Software Quality: An Empirical Case Study.” <em>ICSE ’08: Proceedings of the 30th International Conference on Software Engineering</em>. <em>New York</em>: <em>ACM</em>, 2008.</p>
<p><em>Newman, Sam</em>. <em>Monolith to Microservices</em>. <em>Sebastopol</em>: <em>O’Reilly</em>, 2019.</p>
<p><em>Noursalehi, Saeed</em>. “Git Virtual File System Design History.” <a href="https://t.co/mIQR4uzWKS?amp=1">https://t.co/mIQR4uzWKS?amp=1</a>.</p>
<p><em>Nygard, Michael. Release It!</em> 2nd ed. <em>Raleigh</em>: <em>Pragmatic Bookshelf</em>, 2018.</p>
<p><em>Oberlehner, Markus</em>. “Monorepos in the Wild.” Medium, June 12, 2017. <a href="https://oreil.ly/Sk6am">https://oreil.ly/Sk6am</a>.</p>
<p><em>Padmanabhan, Senthil, and Pranav Jha</em>. “WebAssembly at eBay: A Real-World Use Case.” <em>eBay</em>, May 22, 2019. <a href="https://oreil.ly/rlr7d">https://oreil.ly/rlr7d</a>.</p>
<p><em>Page-Jones, Meilir</em>. <em>Practical Guide to Structured Systems Design</em>, 2nd ed. <em>New York</em>: <em>Yourdon Press</em>, 1980.</p>
<p><em>Palino, Todd, Neha Narkhede, and Gwen Shapira</em>. <em>Kafka: The Definitive Guide</em>. <em>Sebastopol</em>: <em>O’Reilly</em>, 2017.</p>
<p>566 | فصل 16: معمار تکاملی</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0592</div>
            </div>
        </div>
        <!-- Page 0593 -->
        <div class="chapter" id="page-0593">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>کتاب‌شناسی (ادامه)</h4>
<p><em>Parnas, David</em>. “Information Distribution Aspects of Design Methodology.” In <em>Information Processing: Proceedings of the IFIP Congress</em>, 339–44. Vol. 1. <em>Amsterdam</em>: <em>North Holland</em>, 1972.</p>
<p><em>Parnas, David</em>. “On the Criteria to Be Used in Decomposing Systems into Modules.” Journal contribution, <em>Carnegie Mellon University</em>, 1971. <a href="https://oreil.ly/nWtQA">https://oreil.ly/nWtQA</a>.</p>
<p><em>Plotnicki, Lukasz</em>. “BFF @ Soundcloud.” <em>ThoughtWorks</em>, December 9, 2015. <a href="https://oreil.ly/ZyR0l">https://oreil.ly/ZyR0l</a>.</p>
<p><em>Potvin, Rachel, and Josh Levenberg</em>. “Why Google Stores Billions of Lines of Code in a Single Repository.” <em>Communications of the ACM</em> 59, no. 7 (July 2016): 78–87. <a href="https://oreil.ly/Eupyi">https://oreil.ly/Eupyi</a>.</p>
<p><em>Pyhäjärvi, Maaret. Ensemble Programming Guidebook</em>. Self-published, 2015–2020. <a href="https://ensembleprogramming.xyz">https://ensembleprogramming.xyz</a>.</p>
<p><em>Riggins, Jennifer</em>. “The Rise of Progressive Delivery for Systems Resilience.” <em>The New Stack</em>, April 1, 2019. <a href="https://oreil.ly/merIs">https://oreil.ly/merIs</a>.</p>
<p><em>Rodriguez, Daniel, M. Ángel Sicilia, Elena García Barriocanal, and Rachel Harrison</em>. “Empirical Findings on Team Size and Productivity in Software Development.” <em>Journal of Systems and Software</em> 85, no. 3 (2012). doi.org/10.1016/j.jss.2011.09.009.</p>
<p><em>Rossman, John</em>. <em>Think Like Amazon: 50 1/2 Ideas to Become a Digital Leader</em>. <em>New York</em>: <em>McGraw-Hill</em>, 2019.</p>
<p><em>Ruecker, Bernd</em>. <em>Practical Process Automation</em>. <em>Sebastopol</em>: <em>O’Reilly</em>, 2021.</p>
<p><em>Sadalage, Pramod, and Martin Fowler</em>. <em>NoSQL Distilled: A Brief Guide to the Emerging World of Polyglot Persistence</em>. <em>Upper Saddle River</em>, <em>NJ</em>: <em>Addison-Wesley</em>, 2012.</p>
<p><em>Schneider, Jonny. Understanding Design Thinking, Lean, and Agile</em>. <em>Sebastopol</em>: <em>O’Reilly</em>, 2017.</p>
<p><em>Shankland, Stephen</em>. “Google Uncloaks Once-Secret Server.” <em>CNET</em>, December 11, 2009. <a href="https://oreil.ly/hHKvE">https://oreil.ly/hHKvE</a>.</p>
<p><em>Shorrock, Steven</em>. “Alarm Design: From Nuclear Power to WebOps.” <em>Humanistic Systems</em> (blog), October 16, 2015. <a href="https://oreil.ly/AiJ5i">https://oreil.ly/AiJ5i</a>.</p>
<p><em>Shostack, Adam</em>. <em>Threat Modeling: Designing for Security</em>. <em>Indianapolis</em>: <em>Wiley</em>, 2014.</p>
<p><em>Sigelman, Ben</em>. “Three Pillars with Zero Answers—Towards a New Scorecard for Observability.” <em>Lightstep</em> (blog post), December 5, 2018. <a href="https://oreil.ly/qdtSS">https://oreil.ly/qdtSS</a>.</p>
<p><em>Skelton, Matthew, and Manuel Pais. Team Topologies</em>. <em>Portland</em>, <em>OR</em>: <em>IT Revolution</em>, 2019.</p>
<p><em>Steen, Maarten van, and Andrew Tanenbaum. Distributed Systems</em>. 3rd ed. <em>Scotts Valley</em>, <em>CA</em>: <em>CreateSpace Independent Publishing Platform</em>, 2017.</p>
<p>کتاب‌شناسی | 565</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0593</div>
            </div>
        </div>
        <!-- Page 0594 -->
        <div class="chapter" id="page-0594">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>کتاب‌شناسی (ادامه)</h4>
<p><em>Stopford, Ben</em>. <em>Designing Event-Driven Systems</em>. <em>Sebastopol</em>: <em>O’Reilly</em>, 2017.</p>
<p><em>Valentino, Jason D.</em> “Moving One of Capital One’s Largest Customer-Facing Apps to AWS.” <em>Medium/Capital One Tech</em>, May 24, 2017. <a href="https://oreil.ly/IEIC3">https://oreil.ly/IEIC3</a>.</p>
<p><em>Vaughan, Diane</em>. <em>The Challenger Launch Decision: Risky Technology, Culture, and Deviance at NASA</em>. <em>Chicago</em>: <em>University of Chicago Press</em>, 1996.</p>
<p><em>Vernon, Vaughn</em>. <em>Domain-Driven Design Distilled</em>. <em>Boston</em>: <em>Addison-Wesley</em>, 2016.</p>
<p><em>Vernon, Vaughn</em>. <em>Implementing Domain-Driven Design</em>. <em>Upper Saddle River</em>, <em>NJ</em>: <em>Addison-Wesley</em>, 2013.</p>
<p><em>Vocke, Ham</em>. “The Practical Test Pyramid.” <em>martinfowler.com</em>, February 26, 2018. <a href="https://oreil.ly/6rRoU">https://oreil.ly/6rRoU</a>.</p>
<p><em>Webber, Emily</em>. <em>Building Successful Communities of Practice</em>. <em>San Francisco</em>: <em>Blurb</em>, 2016.</p>
<p><em>Webber, Jim, Savas Parastatidis, and Ian Robinson</em>. <em>REST in Practice: Hypermedia and Systems Architecture</em>. <em>Sebastopol</em>: <em>O’Reilly</em>, 2010.</p>
<p><em>Woods, David D</em>. “Four Concepts for Resilience and the Implications for the Future of Resilience Engineering.” <em>Reliability Engineering &amp; System Safety</em> 141 (September 2015): 5–9. doi.org/10.1016/j.ress.2015.03.018.</p>
<p><em>Yourdon, Edward, and Larry L. Constantine</em>. <em>Structured Design</em>. <em>New York</em>: <em>Yourdon Press</em>, 1976.</p>
<p><em>Zimman, Adam</em>. “Progressive Delivery, a History…Condensed.” <em>Industry Insights</em> (blog). <em>LaunchDarkly</em>, August 6, 2018. <a href="https://oreil.ly/4pVY7">https://oreil.ly/4pVY7</a>.</p>
<p>کتاب‌شناسی | 565</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0594</div>
            </div>
        </div>
        <!-- Page 0595 -->
        <div class="chapter" id="page-0595">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>واژه‌نامه</h4>
<p><em>aggregate</em></p>
<p>مجموعه‌ای از اشیا که به عنوان یک موجودیت واحد مدیریت می‌شوند، که معمولاً به مفاهیم دنیای واقعی اشاره دارد. مفهومی از <em>DDD</em>.</p>
<p><em>Amazon Web Services (AWS)</em></p>
<p>ارائه <em>public cloud</em> از <em>Amazon</em>.</p>
<p><em>API gateway</em></p>
<p>یک مؤلفه که معمولاً در محیط یک سیستم قرار دارد و تماس‌ها را از منابع خارجی (مانند رابط‌های کاربری) به <strong>microservices</strong>، در میان بسیاری از موارد دیگر، مسیریابی می‌کند.</p>
<p><em>authentication</em></p>
<p>فرآیندی که توسط آن یک شخص ثابت می‌کند که همان کسی است که ادعا می‌کند. این می‌تواند به سادگی ارائه نام کاربری و رمز عبور یک فرد باشد.</p>
<p><em>authorization</em></p>
<p>فرآیندی که تعیین می‌کند آیا به یک شخص مجاز اجازه دسترسی به یک قطعه عملکرد داده شده داده می‌شود یا خیر.</p>
<p><em>Azure</em></p>
<p>ارائه <em>public cloud</em> از <em>Microsoft</em>.</p>
<p><em>backend for frontend (BFF)</em></p>
<p>یک مؤلفه سمت سرور که تجمیع و فیلتر کردن را برای یک رابط کاربری خاص ارائه می‌دهد. جایگزینی برای یک <em>API gateway</em> با هدف عمومی.</p>
<p><em>bounded context</em></p>
<p>یک مرز صریح در یک حوزه کسب‌وکار که عملکردی را برای سیستم گسترده‌تر ارائه می‌دهد، اما پیچیدگی را نیز پنهان می‌کند. اغلب به مرزهای سازمانی نگاشت می‌شود. مفهومی از <em>DDD</em>.</p>
<p><em>bulkhead</em></p>
<p>بخشی از سیستم که در آن می‌توان یک شکست را ایزوله کرد، به طوری که بقیه سیستم حتی در صورت بروز شکست، می‌تواند به کار خود ادامه دهد.</p>
<p><em>choreography</em></p>
<p>یک سبک از <em>saga</em>، که در آن مسئولیت آنچه باید در هنگام توزیع در چندین <strong>microservices</strong> اتفاق بیفتد، به جای مدیریت توسط یک موجودیت واحد است.</p>
<p><em>circuit breaker</em></p>
<p>یک مکانیسم که در اطراف یک اتصال به یک سرویس پایین‌دستی قرار داده می‌شود که می‌تواند به شما اجازه دهد در صورت بروز مشکل در سرویس پایین‌دستی، سریع شکست بخورید.</p>
<p><em>cohesion</em></p>
<p>میزانی که کدی که با هم تغییر می‌کند، در کنار هم باقی می‌ماند.</p>
<p><em>collective ownership</em></p>
<p>یک سبک از مالکیت که در آن به هر توسعه‌دهنده‌ای اجازه داده می‌شود هر بخشی از سیستم را تغییر دهد.</p>
<p>واژه‌نامه | 569</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0595</div>
            </div>
        </div>
        <!-- Page 0596 -->
        <div class="chapter" id="page-0596">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>واژه‌نامه (ادامه)</h4>
<p><em>container</em></p>
<p>بسته‌ای از کد و وابستگی‌ها که می‌تواند به صورت ایزوله بر روی یک ماشین اجرا شود. از نظر مفهومی شبیه ماشین‌های مجازی، اگرچه بسیار سبکتر است.</p>
<p><em>continuous delivery (CD)</em></p>
<p>یک رویکرد تحویل که در آن شما به صراحت مسیر رسیدن به تولید را مدل می‌کنید، هر <em>check-in</em> را به عنوان یک نامزد انتشار در نظر می‌گیرید، و می‌توانید به راحتی مناسب بودن هر نامزد انتشار را برای استقرار در تولید ارزیابی کنید.</p>
<p><em>continuous deployment</em></p>
<p>رویکردی که در آن هر <em>build</em> که از تمام مراحل خودکار عبور می‌کند، به طور خودکار در تولید مستقر می‌شود.</p>
<p><em>continuous integration (CI)</em></p>
<p>ادغام منظم (روزانه) تغییرات با بقیه کدبیس، همراه با مجموعه‌ای از آزمایش‌ها برای تأیید اینکه ادغام انجام شده است.</p>
<p>قانون <em>Conway</em></p>
<p>این مشاهده که ساختارهای ارتباطی سازمان‌ها در نهایت، طراحی سیستم‌های کامپیوتری را که این سازمان‌ها می‌سازند، هدایت می‌کنند.</p>
<p><em>coupling</em></p>
<p>میزانی که تغییر یک بخش از سیستم، نیازمند تغییری در بخش دیگر است. <em>Low coupling</em> معمولاً مطلوب است.</p>
<p><em>cross-functional requirement (CFR)</em></p>
<p>یک ویژگی عمومی از سیستم، مانند <strong>latency</strong> مورد نیاز برای عملیات، امنیت داده‌ها در حالت استراحت، و غیره. همچنین به عنوان <em>nonfunctional requirement</em> شناخته می‌شود (اما من این را به عنوان یک توصیف بسیار ترجیح می‌دهم).</p>
<p><em>customizable off the shelf software (COTS)</em></p>
<p><strong>software</strong> شخص ثالث که توسط کاربر نهایی به‌شدت سفارشی می‌شود و همچنین معمولاً بر روی زیرساخت‌های خودشان اجرا می‌شود.
   نمونه‌های معمولی شامل سیستم‌های مدیریت محتوا و پلتفرم‌های مدیریت ارتباط با مشتری است.</p>
<p><em>data partitioning</em></p>
<p>مقیاس‌بندی یک سیستم با توزیع بار بر اساس برخی از جنبه‌های داده‌ها. به عنوان مثال، تقسیم بار بر اساس نوع مشتری یا محصول.</p>
<p><em>detective controls</em></p>
<p>یک کنترل امنیتی که به شما کمک می‌کند اگر حمله‌ای در حال انجام است/اتفاق افتاده است، شناسایی کنید.</p>
<p><em>domain coupling</em></p>
<p>نوعی از <em>coupling</em> که در آن یک <strong>microservice</strong> به پروتکل دامنه ارائه شده توسط <strong>microservice</strong> دیگری "متصل" است.</p>
<p><em>domain-driven design (DDD)</em></p>
<p>مفهومی که به موجب آن، مشکل/حوزه کسب‌وکار اساسی به صراحت در <strong>software</strong> مدل‌سازی می‌شود.</p>
<p><em>Docker</em></p>
<p>مجموعه‌ای از ابزارها برای کمک به ساخت و مدیریت <em>containers</em>.</p>
<p><em>enabling team</em></p>
<p>تیمی که از تیم‌های <strong>stream-aligned</strong> در انجام کارشان پشتیبانی می‌کند. معمولاً، یک تیم فعال‌کننده دارای یک تمرکز خاص است—به عنوان مثال، قابلیت استفاده، معماری، امنیت.</p>
<p><em>error budget</em></p>
<p>مربوط به سطح قابل قبولی است که یک <em>SLO</em> می‌تواند خارج از محدوده باشد، که معمولاً در درجه‌ای از <em>downtime</em> قابل قبول برای یک سرویس تعریف می‌شود.</p>
<p><em>event</em></p>
<p>چیزی که در سیستم اتفاق می‌افتد که ممکن است سایر قسمت‌های سیستم به آن اهمیت دهند—به عنوان مثال "سفارش ثبت شد" یا "ورود کاربر."</p>
<p><em>feature branching</em></p>
<p>ایجاد یک <strong>branch</strong> جدید برای هر ویژگی که روی آن کار می‌شود، ادغام آن <strong>branch</strong> به <em>mainline</em> پس از تکمیل ویژگی. چیزی که من آن را دلسرد می‌کنم.</p>
<p><em>Function as a Service (FaaS)</em></p>
<p>نوعی پلتفرم <em>serverless</em> که کد دلخواه را بر اساس انواع خاصی از <em>triggers</em> فراخوانی می‌کند—به عنوان مثال، راه‌اندازی کد در</p>
<p>واژه‌نامه | 567</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0596</div>
            </div>
        </div>
        <!-- Page 0597 -->
        <div class="chapter" id="page-0597">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>واژه‌نامه (ادامه)</h4>
<p>واکنش به یک تماس <em>HTTP</em>، یا دریافت یک پیام.</p>
<p>حاکمیت</p>
<p>توافق در مورد نحوه انجام کارها، و اطمینان از انجام آنها به این روش.</p>
<p><em>graceful extensibility</em></p>
<p>اینکه چقدر خوب با موقعیتی که غیرمنتظره است، برخورد می‌کنیم.</p>
<p><em>GraphQL</em></p>
<p>یک پروتکل که به <em>client</em> اجازه می‌دهد تا <strong>queries</strong> سفارشی را صادر کند که می‌تواند منجر به برقراری تماس با چندین <strong>microservices</strong> پایین‌دستی شود. برای کمک به تجمیع و فیلتر کردن تماس برای <strong>clients</strong> خارجی بدون نیاز به استفاده از <strong>BFF</strong> یا <em>API gateways</em>، مفید است.</p>
<p>تکثیر افقی</p>
<p>مقیاس‌بندی یک سیستم با داشتن چندین نسخه از یک چیز.</p>
<p><em>idempotency</em></p>
<p>ویژگی یک تابع که در آن حتی اگر چندین بار فراخوانی شود، نتیجه یکسان است. برای اجازه دادن به عملیات در <strong>microservices</strong> برای تکرار ایمن، مفید است.</p>
<p>استقرار مستقل</p>
<p>امکان ایجاد تغییر در یک <strong>microservice</strong> و استقرار آن در تولید، بدون نیاز به تغییر یا استقرار هر چیز دیگری.</p>
<p>پنهان کردن اطلاعات</p>
<p>رویکردی که در آن همه اطلاعات به طور پیش‌فرض در داخل یک مرز پنهان می‌شود، و فقط حداقل اطلاعات لازم برای راضی کردن مصرف‌کنندگان خارجی، ارائه می‌شود.</p>
<p>زیرساخت به عنوان کد</p>
<p>مدل‌سازی زیرساخت‌های شما به صورت کد، که امکان مدیریت زیرساخت‌ها را فراهم می‌کند و کد را نسخه کنترل‌شده می‌سازد.</p>
<p><em>JSON Web Token</em></p>
<p>یک استاندارد برای ایجاد یک ساختار داده <em>JSON</em> که می‌تواند به صورت اختیاری رمزگذاری شود. معمولاً برای انتقال اطلاعات در مورد <em>principals</em> تأیید شده استفاده می‌شود.</p>
<p><em>Kubernetes</em></p>
<p>یک پلتفرم <em>open source</em> که <em>workloads</em> <em>container</em> را در سراسر چندین ماشین زیربنایی مدیریت می‌کند.</p>
<p>کتابخانه</p>
<p>مجموعه‌ای از کد که به گونه‌ای بسته‌بندی شده است که می‌تواند در چندین برنامه مورد استفاده مجدد قرار گیرد.</p>
<p>استقرار <em>lockstep</em></p>
<p>نیاز به استقرار دو یا چند چیز در یک زمان، زیرا تغییری رخ داده است که این امر را ایجاب می‌کند. متضاد استقرار مستقل. به طور کلی، اجتناب کنید.</p>
<p>پیام</p>
<p>چیزی که از طریق یک مکانیسم ارتباطی ناهمزمان مانند یک <em>broker</em> به یک یا چند <strong>microservices</strong> پایین‌دستی ارسال می‌شود. می‌تواند شامل انواع مختلفی از <em>payloads</em>، مانند یک درخواست، پاسخ، یا یک رویداد باشد.</p>
<p><em>message broker</em></p>
<p><strong>software</strong> اختصاصی که ارتباط ناهمزمان بین فرآیندها را مدیریت می‌کند، که معمولاً قابلیت‌هایی مانند تحویل تضمین‌شده (برای برخی از تعاریف کلمه تضمین شده) را ارائه می‌دهد.</p>
<p><em>microservice</em></p>
<p>یک سرویس که به طور مستقل قابل استقرار است که از طریق یک یا چند پروتکل ارتباطی با سایر <strong>microservices</strong> ارتباط برقرار می‌کند.</p>
<p><em>monorepo</em></p>
<p>یک <em>repository</em> واحد که شامل تمام کد منبع برای همه <strong>microservices</strong> شما می‌شود.</p>
<p><em>multirepo</em></p>
<p>رویکردی که در آن هر <strong>microservice</strong>، <em>repository</em> کد منبع خود را دارد.</p>
<p><em>orchestration</em></p>
<p>سبکی از <em>saga</em> که در آن یک واحد مرکزی (همچنین به نام <em>orchestrator</em>) عملیات <strong>microservices</strong> دیگر را مدیریت می‌کند تا یک فرآیند تجاری را انجام دهد.</p>
<p><em>orchestration</em></p>
<p>واژه‌نامه | 567</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0597</div>
            </div>
        </div>
        <!-- Page 0598 -->
        <div class="chapter" id="page-0598">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>واژه‌نامه (ادامه)</h4>
<p><em>personally identifiable information (PII)</em></p>
<p>داده‌هایی که وقتی به تنهایی یا علاوه بر اطلاعات دیگر استفاده می‌شوند، می‌توانند برای شناسایی یک فرد استفاده شوند.</p>
<p><em>preventative control</em></p>
<p>یک کنترل امنیتی که هدف آن، متوقف کردن وقوع حمله است.</p>
<p><em>principal</em></p>
<p>چیزی—معمولاً یک شخص، اگرچه می‌تواند یک برنامه نیز باشد—که درخواست <em>authenticated</em> و <em>authorized</em> شدن برای دسترسی دارد.</p>
<p><em>request</em></p>
<p>توسط یک <strong>microservice</strong> به یک <strong>microservice</strong> پایین‌دستی ارسال می‌شود و انتظار دارد که <strong>microservice</strong> پایین‌دستی کاری را انجام دهد.</p>
<p><em>response</em></p>
<p>به عنوان نتیجه یک <strong>request</strong>، دوباره منتقل می‌شود.</p>
<p><em>responsive control</em></p>
<p>یک کنترل امنیتی که به شما کمک می‌کند در طول/پس از یک حمله پاسخ دهید.</p>
<p><em>robustness</em></p>
<p>توانایی یک سیستم برای ادامه عملیات، حتی زمانی که اتفاق بدی رخ می‌دهد.</p>
<p><em>saga</em></p>
<p>راهی برای مدل‌سازی عملیات‌های طولانی مدت به گونه‌ای که نیازی به قفل کردن منابع برای مدت زمان طولانی وجود ندارد. در هنگام پیاده‌سازی فرآیندهای تجاری، نسبت به تراکنش‌های توزیع‌شده، ترجیح داده می‌شود.</p>
<p><em>serverless</em></p>
<p>یک اصطلاح جامع برای محصولات <strong>cloud</strong> که از دیدگاه کاربر، رایانه‌های زیربنایی را انتزاع می‌کند، تا جایی که کاربر دیگر نیازی به نگرانی در مورد آنها ندارد. نمونه‌هایی از این محصولات عبارتند از <em>AWS Lambda</em>، <em>AWS S3</em>، و <em>Azure Cosmos</em>.</p>
<p><em>service-level agreement (SLA)</em></p>
<p>توافقی بین یک کاربر نهایی و یک ارائه‌دهنده خدمات (به عنوان مثال، مشتری و فروشنده) که حداقل خدمات قابل قبول را تعریف می‌کند، و مجازات‌هایی که در صورت عدم رعایت توافق اعمال می‌شوند.</p>
<p><em>service-level indicator (SLI)</em></p>
<p>معیاری از نحوه رفتار سیستم شما—به عنوان مثال، زمان پاسخ‌گویی.</p>
<p><em>service-level objective (SLO)</em></p>
<p>توافقی در مورد اینکه دامنه قابل قبول یک <em>SLI</em> داده شده چقدر است.</p>
<p><em>service mesh</em></p>
<p>نوعی از <em>middleware</em> توزیع شده که عملکرد <em>cross-cutting</em> را در درجه اول برای تماس‌های <em>point-to-point</em> همزمان ارائه می‌دهد—به عنوان مثال، <em>mutual TLS</em>، کشف سرویس، یا <em>circuit breakers</em>.</p>
<p><em>service-oriented architecture (SOA)</em></p>
<p>نوعی معماری که در آن سیستم به سرویس‌هایی تقسیم می‌شود که می‌توانند روی ماشین‌های مختلف اجرا شوند. <strong>Microservices</strong> یک نوع از <strong>SOA</strong> هستند که استقرار مستقل را در اولویت قرار می‌دهند.</p>
<p><em>single-page application (SPA)</em></p>
<p>نوعی رابط کاربری گرافیکی که در آن <strong>UI</strong> در یک صفحه مرورگر واحد ارائه می‌شود، بدون نیاز به ناوبری به صفحات وب دیگر.</p>
<p>تیم <strong>stream-aligned</strong></p>
<p>تیمی که بر ارائه <strong>end-to-end</strong> یک جریان کاری با ارزش متمرکز است. این یک تیم طولانی‌مدت است که به طور معمول مستقیماً بر مشتری متمرکز خواهد بود و کدهای <strong>data</strong>، <strong>backend</strong> و <strong>frontend</strong> را در بر می‌گیرد.</p>
<p>مالکیت قوی</p>
<p>سبکی از مالکیت که در آن بخش‌هایی از سیستم متعلق به تیم‌های خاص هستند، و تغییرات در یک بخش خاص از سیستم فقط می‌تواند توسط تیمی که مالک آن است، ایجاد شود.</p>
<p><em>sustained adaptability</em></p>
<p>توانایی انطباق مداوم با محیط‌های در حال تغییر، ذینفعان، و مطالبات.</p>
<p><em>threat modeling</em></p>
<p>فرآیندی که در آن شما تهدیداتی را که ممکن است بر</p>
<p>واژه‌نامه | 567</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0598</div>
            </div>
        </div>
        <!-- Page 0599 -->
        <div class="chapter" id="page-0599">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>واژه‌نامه (ادامه)</h4>
<p><em>your system</em> و اولویت‌بندی تهدیداتی که باید به آنها رسیدگی شود.</p>
<p><em>trunk-based development</em></p>
<p>سبکی از توسعه که در آن تمام تغییرات، مستقیماً در <em>trunk</em> اصلی سیستم کنترل منبع، از جمله تغییراتی که هنوز کامل نشده‌اند، ایجاد می‌شوند.</p>
<p><em>ubiquitous language</em></p>
<p>تعریف و اتخاذ یک زبان مشترک برای استفاده در کد و در توصیف دامنه، برای کمک به برقراری ارتباط. مفهومی از <em>DDD</em>.</p>
<p>مقیاس‌پذیری عمودی</p>
<p>بهبود مقیاس سیستم با دریافت یک ماشین قدرتمندتر.</p>
<p>ماشین مجازی (<em>VM</em>)</p>
<p>شبیه‌سازی یک ماشین که در آن ماشین به نظر می‌رسد که برای همه اهداف و مقاصد، یک ماشین فیزیکی اختصاصی است.</p>
<p><strong>widget</strong></p>
<p>یک مؤلفه از یک رابط کاربری گرافیکی.</p>
<p><em>widget</em></p>
<p>واژه‌نامه | 573</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0599</div>
            </div>
        </div>
        <!-- Page 0601 -->
        <div class="chapter" id="page-0601">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>شاخص</h4>
<p>علائم</p>
<p><em>2PC</em> (الگوریتم‌های <em>two-phase commit</em>)، 179-181</p>
<p><em>A</em></p>
<p>تست‌های <em>A/B</em>، 336</p>
<p><em>ACID</em> (<em>atomicity</em>، <em>consistency</em>، <em>isolation</em>، و <em>durability</em>)، 176</p>
<p><em>Active Directory</em>، 377</p>
<p>انطباق‌پذیری، 390، 413، 418، 549</p>
<p><em>aggregate</em>، 53-55، 58، 569</p>
<p>آلارم‌ها، در مقابل هشدارها، 331</p>
<p>خستگی هشدار، 330</p>
<p>پایش، 329-333</p>
<p><em>Amazon Web Services (AWS)</em></p>
<p><strong>API gateways</strong>، 162</p>
<p>تیم‌های خودگردان محصول‌محور، 462</p>
<p><strong>autoscaling</strong> در، 236، 449-450</p>
<p><em>availability zones</em>، 408</p>
<p><em>AWS Lambda</em>، 245</p>
<p><em>AWS Secrets Manager</em>، 357</p>
<p><em>Beanstalk</em>، 238</p>
<p>کتابخانه‌های <strong>client</strong>، 156</p>
<p><em>CloudWatch</em>، 320</p>
<p><em>containers</em> و، 243</p>
<p>اعتبارنامه‌ها و امنیت، 355، 357، 364</p>
<p>تعریف شده، 569</p>
<p>مدیریت وضعیت دلخواه و، 235</p>
<p>ثبت‌های سرویس پویا، 161</p>
<p><em>Elasticsearch</em> و، 319</p>
<p>پذیرش شکست، 415</p>
<p>سرویس‌های <em>FaaS</em>، 238، 252</p>
<p>توسعه در <strong>cloud</strong>، 296</p>
<p>اجرای ایزوله، 231</p>
<p>محدودیت‌های، 250</p>
<p><em>managed VMs</em> در، 241</p>
<p>سهم بازار از، 264</p>
<p><em>message brokers</em>، 139</p>
<p>پلتفرم‌های خاص پلتفرم، 233</p>
<p><em>Relational Database Service (RDS)</em>، 224</p>
<p>انتخاب، 268</p>
<p><em>SLA availability</em>، 221، 328، 405</p>
<p>مجازی‌سازی نوع 2، 240</p>
<p>مقیاس‌پذیری عمودی، 421</p>
<p><em>anomaly detection</em>، 340</p>
<p><em>Ansible</em>، 258</p>
<p><em>antifragility</em>، 413</p>
<p><em>Apache Flink</em>، 21</p>
<p><em>Apache Kafka</em>، 21</p>
<p><strong>API gateways</strong>، 122، 162-166، 569</p>
<p>ظروف برنامه، 247</p>
<p>امنیت برنامه (همچنین به <em>security</em> مراجعه کنید)</p>
<p>توانایی بازسازی، 364</p>
<p><em>backups</em>، 363</p>
<p>اعتبارنامه‌ها، 354-360</p>
<p><em>patching</em>، 360-363</p>
<p>وضعیت برنامه، <em>hypermedia</em> به عنوان موتور، 129</p>
<p>معماران، 526</p>
<p>(همچنین به معماران تکاملی مراجعه کنید)</p>
<p>اصول معماری</p>
<p>تعریف استانداردها برای <strong>microservices</strong>، 543-544</p>
<p>هدایت معماری تکاملی، 539</p>
<p>معماری ناهمگن، 22</p>
<p>لایه بندی در داخل و خارج، 68</p>
<p>اصول و رویه‌ها، 536-538</p>
<p>سیستم‌های خودکفا (<em>SCSs</em>)، 466</p>
<p><em>A</em></p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0601</div>
            </div>
        </div>
        <!-- Page 0602 -->
        <div class="chapter" id="page-0602">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>فهرست مطالب</h4>
<p><em>architecture</em> <strong>software</strong> تعریف شده، 527</p>
<p>معماری سه‌لایه، 10-12</p>
<p>معماری عمودی، 12</p>
<p>امنیت معماری، 544</p>
<p>ایجاد <em>artifact</em>، 204</p>
<p>ساخت <em>async/await</em>، 100</p>
<p><em>AsyncAPI</em>، 147</p>
<p>تماس‌های ناهمزمان <em>nonblocking</em>، 98-101</p>
<p>تراکنش‌های اتمی، در مقابل استقرار اتمی، 211</p>
<p><em>atomicity</em>، <em>consistency</em>، <em>isolation</em>، و <em>durability</em> (<em>ACID</em>)، 176</p>
<p><strong>authentication</strong> و <strong>authorization</strong></p>
<p><strong>authorization</strong> متمرکز و بالادستی، 381</p>
<p><strong>single sign-on</strong> مشترک (<em>SSO</em>)، 376</p>
<p>مشکل <em>confused deputy</em>، 380-381</p>
<p><strong>authorization</strong> غیرمتمرکز، 382</p>
<p>تعریف شده، 375، 569</p>
<p><strong>authorization</strong> <em>fine-grained</em>، 379</p>
<p><em>Authentication</em> انسانی، 376</p>
<p><em>JSON Web Token (JWT)</em>، 382-386</p>
<p><em>authentication</em> متقابل، 371</p>
<p><em>gateways</em> <em>single sign-on</em>، 377-379</p>
<p>اتوماسیون</p>
<p>در تشخیص ناهنجاری، 340</p>
<p>به عنوان یک عنصر ضروری برای امنیت، 349</p>
<p>در طول استقرار، 231</p>
<p>خودمختاری، 498، 549</p>
<p><strong>autoscaling</strong>، 449</p>
<p>در دسترس بودن، 393، 410</p>
<p><em>Azure</em></p>
<p><em>Application Insights</em>، 320</p>
<p><em>Azure Functions</em>، 238، 250</p>
<p><em>Azure Web Apps</em>، 268</p>
<p><em>Azure’s Key Vault</em>، 357</p>
<p>مزایای، 268</p>
<p>تعریف شده، 569</p>
<p>مدیریت وضعیت دلخواه، 235</p>
<p>محصول <em>event grid</em>، 147</p>
<p>محدودیت‌های، 250-251</p>
<p><em>managed VMs</em> در، 241</p>
<p>سهم بازار، 264</p>
<p>ابزاری برای <strong>API gateway</strong>، 162</p>
<p>متریال بازگشت‌پذیر، 184</p>
<p><em>B</em></p>
<p><em>backend for frontend (BFF)</em> الگوی، 480-488</p>
<p>ابزار <em>Backstage</em>، 172</p>
<p>پشتیبان‌گیری، 363، 375</p>
<p><em>backward compatibility</em>، 121 (همچنین به تغییرات <em>breaking</em> مراجعه کنید)</p>
<p>آزمایش‌های شکننده، 286</p>
<p>شکنندگی، 125</p>
<p><em>build pipelines</em>، 201-201</p>
<p><em>bulkheads</em>، 397، 400، 569</p>
<p>عملکرد کسب‌وکار، همسو کردن معماری با، 10-14</p>
<p>ابزار <em>BPM</em> (مدل‌سازی فرآیند کسب‌وکار)، 191</p>
<p>آزمایش‌های <em>business-facing</em>، 276</p>
<p><em>C</em></p>
<p><strong>caching</strong></p>
<p>اصول <strong>caching</strong>، 435</p>
<p>مسمومیت <strong>cache</strong>، 448</p>
<p><em>invalidation</em>، 442-447</p>
<p>مزایای عملکرد، 436</p>
<p>مزایای <strong>robustness</strong>، 436</p>
<p>مزایای مقیاس‌پذیری، 436</p>
<p>معاوضات بین تازگی و بهینه‌سازی، 447-448</p>
<p>جایی که <strong>cache</strong> کنیم، 437-442</p>
<p>انتشارهای <em>canary</em>، 271، 337</p>
<p><em>CAP</em> <em>theorem</em></p>
<p>در دسترس بودن، 410</p>
<p>رویکرد ترکیبی، 412</p>
<p>اجزای، 408-410</p>
<p>سازگاری، 410</p>
<p><em>partition tolerance</em>، 411</p>
<p>576 | فهرست مطالب</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0602</div>
            </div>
        </div>
        <!-- Page 0603 -->
        <div class="chapter" id="page-0603">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>فهرست مطالب (ادامه)</h4>
<p>کاربرد دنیای واقعی از، 412</p>
<p>انتخاب رویکرد خود، 411</p>
<p><em>cardinality</em>، کم در مقابل زیاد، 322</p>
<p><em>CDCs</em> (<em>consumer-driven contracts</em>)، 148، 293-295</p>
<p>الگوی <strong>central aggregating gateway</strong>، 475-479</p>
<p><em>CFR</em> (<em>cross-functional requirements</em>)، 300، 392، 570</p>
<p>بررسی تغییرات، 515</p>
<p><em>chaos engineering</em>، 337، 413-415</p>
<p><em>Chaos Monkey</em>، 415</p>
<p>ابزار <em>Chaos Toolkit</em>، 415</p>
<p><em>Chef</em>، 258</p>
<p><em>choreographed sagas</em>، 189، 192-195، 555</p>
<p><em>choreography</em>، 569</p>
<p><em>circuit breakers</em>، 397، 401-404، 569</p>
<p>انسجام</p>
<p><em>coupling</em> و، 39</p>
<p>تعریف شده، 38، 569</p>
<p>مالکیت جمعی، 501-502، 569</p>
<p><em>Command Query Responsibility Segregation (CQRS) pattern</em>، 434</p>
<p>دستورات، در مقابل درخواست‌ها، 106</p>
<p>نظرات و سوالات، 22</p>
<p><em>coupling</em> مشترک، 46-49</p>
<p>فریم‌ورک <em>Confluent Schema Registry</em>، 148</p>
<p>مشکل <em>confused deputy</em>، 380-381</p>
<p>ثبات، 410، 461</p>
<p><em>Consul</em>، 159</p>
<p>قراردادهای <em>consumer-driven</em> (<em>CDCs</em>)، 148، 293-296</p>
<p>رویکرد <em>consumer-first</em>، 153</p>
<p><strong>container orchestration</strong>، 259 (به <em>Kubernetes</em> نیز مراجعه کنید)</p>
<p>مجازی‌سازی مبتنی بر <em>container</em>، 240</p>
<p><em>containers</em> (همچنین به <em>application containers</em> مراجعه کنید)</p>
<p>اصول <em>containers</em>، 242-243</p>
<p>تعریف شده، 570</p>
<p><em>Docker</em>، 246</p>
<p>معایب، 244</p>
<p>تناسب برای <strong>microservices</strong>، 246</p>
<p>نقش در <strong>microservices</strong>، 20، 241</p>
<p>نگرانی‌های امنیتی، 362</p>
<p>کدنویسی، 49-51</p>
<p><em>Parnas, David</em>. “Information Distribution Aspects of Design Methodology.” In <em>Information Processing: Proceedings of the IFIP Congress</em>, 339–44. Vol. 1. <em>Amsterdam</em>: <em>North Holland</em>, 1972.</p>
<p><i>Parnas, David</i>. “On the Criteria to Be Used in Decomposing Systems into Modules.” Journal contribution, <i>Carnegie Mellon University</i>, 1971. <a href="https://oreil.ly/nWtQA">https://oreil.ly/nWtQA</a>.</p>
<p><i>Plotnicki, Lukasz</i>. “BFF @ Soundcloud.” <i>ThoughtWorks</i>, December 9, 2015. <a href="https://oreil.ly/ZyR0l">https://oreil.ly/ZyR0l</a>.</p>
<p><i>Potvin, Rachel, and Josh Levenberg</i>. “Why Google Stores Billions of Lines of Code in a Single Repository.” <i>Communications of the ACM</i> 59, no. 7 (July 2016): 78–87. <a href="https://oreil.ly/Eupyi">https://oreil.ly/Eupyi</a>.</p>
<p><i>Pyhäjärvi, Maaret</i>. <i>Ensemble Programming Guidebook</i>. Self-published, 2015–2020. <a href="https://ensembleprogramming.xyz">https://ensembleprogramming.xyz</a>.</p>
<p><i>Riggins, Jennifer</i>. “The Rise of Progressive Delivery for Systems Resilience.” <i>The New Stack</i>, April 1, 2019. <a href="https://oreil.ly/merIs">https://oreil.ly/merIs</a>.</p>
<p><i>Rodriguez, Daniel, M. Ángel Sicilia, Elena García Barriocanal, and Rachel Harrison</i>. “Empirical Findings on Team Size and Productivity in Software Development.” <i>Journal of Systems and Software</i> 85, no. 3 (2012). doi.org/10.1016/j.jss.2011.09.009.</p>
<p><i>Rossman, John</i>. <i>Think Like Amazon: 50 1/2 Ideas to Become a Digital Leader</i>. <i>New York</i>: <i>McGraw-Hill</i>, 2019.</p>
<p><i>Ruecker, Bernd</i>. <i>Practical Process Automation</i>. <i>Sebastopol</i>: <i>O’Reilly</i>, 2021.</p>
<p><i>Sadalage, Pramod, and Martin Fowler</i>. <i>NoSQL Distilled: A Brief Guide to the Emerging World of Polyglot Persistence</i>. <i>Upper Saddle River</i>, <i>NJ</i>: <i>Addison-Wesley</i>, 2012.</p>
<p><i>Schneider, Jonny. Understanding Design Thinking, Lean, and Agile</i>. <i>Sebastopol</i>: <i>O’Reilly</i>, 2017.</p>
<p><i>Shankland, Stephen</i>. “Google Uncloaks Once-Secret Server.” <i>CNET</i>, December 11, 2009. <a href="https://oreil.ly/hHKvE">https://oreil.ly/hHKvE</a>.</p>
<p><i>Shorrock, Steven</i>. “Alarm Design: From Nuclear Power to WebOps.” <i>Humanistic Systems</i> (blog), October 16, 2015. <a href="https://oreil.ly/AiJ5i">https://oreil.ly/AiJ5i</a>.</p>
<p><i>Shostack, Adam</i>. <i>Threat Modeling: Designing for Security</i>. <i>Indianapolis</i>: <i>Wiley</i>, 2014.</p>
<p><i>Sigelman, Ben</i>. “Three Pillars with Zero Answers—Towards a New Scorecard for Observability.” <i>Lightstep</i> (blog post), December 5, 2018. <a href="https://oreil.ly/qdtSS">https://oreil.ly/qdtSS</a>.</p>
<p><i>Skelton, Matthew, and Manuel Pais. Team Topologies</i>. <i>Portland</i>, <i>OR</i>: <i>IT Revolution</i>, 2019.</p>
<p><i>Steen, Maarten van, and Andrew Tanenbaum. Distributed Systems</i>. 3rd ed. <i>Scotts Valley</i>, <i>CA</i>: <i>CreateSpace Independent Publishing Platform</i>, 2017.</p>
<p>واژه‌نامه | 567</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0603</div>
            </div>
        </div>
        <!-- Page 0604 -->
        <div class="chapter" id="page-0604">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>فهرست مطالب (ادامه)</h4>
<p><em>core committers</em>، 511-512</p>
<p>هزینه‌ها، 28</p>
<p><em>COTS</em> (<em>customizable off the shelf software</em>)، 103، 570</p>
<p><strong>coupling</strong></p>
<p>انسجام و، 39</p>
<p><strong>coupling</strong> مشترک، 46-49</p>
<p><em>content coupling</em>، 49-51</p>
<p>تعریف شده، 570</p>
<p><em>domain coupling</em>، 41</p>
<p>شل در مقابل سفت، 38</p>
<p><em>pass-through coupling</em>، 43-46</p>
<p><em>pathological coupling</em>، 51</p>
<p><em>technology coupling</em>، 124</p>
<p><em>temporal coupling</em>، 42</p>
<p>انواع، 39</p>
<p>الگوی <strong>CQRS</strong> (<em>Command Query Responsibility Segregation</em>)، 434</p>
<p>اعتبارنامه‌ها</p>
<p>به‌طور تصادفی شامل <em>keys</em> در کد منبع، 358</p>
<p>چالش‌های <strong>microservices</strong>، 354</p>
<p>محدود کردن دامنه، 359-360</p>
<p><em>revoking</em>، 358</p>
<p>چرخش مکرر، 357</p>
<p><em>secrets</em>، 356-357</p>
<p>اعتبارنامه‌های کاربری، 355</p>
<p><em>cross-functional requirements (CFR)</em>، 300، 392، 570</p>
<p>تست‌های <em>cross-functional</em>، 300-302</p>
<p><em>customizable off the shelf software (COTS)</em>، 103، 570</p>
<p>امنیت سایبری، پنج عملکرد، 350-354</p>
<p>(همچنین به <em>security</em> مراجعه کنید)</p>
<p><em>D</em></p>
<p>داده</p>
<p>ارتباط از طریق داده‌های مشترک، 101-104</p>
<p>نگرانی‌های تجزیه، 81-86</p>
<p>ماندگاری، 393</p>
<p>داده با <em>high-cardinality</em>، 322</p>
<p>تأثیر بر تجزیه، 64</p>
<p>حفظ ثبات، 31</p>
<p>تأمین امنیت، 369-375</p>
<p>تقسیم داده‌ها، 426-430، 570</p>
<p>تراکنش‌های پایگاه داده</p>
<p>تراکنش‌های <em>ACID</em>، 176</p>
<p>تعریف شده، 175</p>
<p>فاقد <em>atomicity</em>، 177-178</p>
<p>پایگاه‌های داده</p>
<p>نگرانی‌های استقرار، 222-225</p>
<p>پنهان کردن، 552</p>
<p>نگرانی‌های یکپارچگی، 84</p>
<p>پایگاه‌های داده گزارش‌دهی، 85</p>
<p>مشترک، 8</p>
<p>نگرانی‌های تراکنش، 84</p>
<p><em>Debezium</em>، 21</p>
<p><strong>authorization</strong> غیرمتمرکز، 382</p>
<p>تجزیه (همچنین به <em>user interfaces (UIs)</em> مراجعه کنید)</p>
<p>رویکرد ترکیبی، 73</p>
<p>خطرات تجزیه زودرس، 73</p>
<p>نگرانی‌های داده، 81-86</p>
<p>تنظیم هدف، 71، 536</p>
<p>مهاجرت‌های افزایشی، 72</p>
<p>تأثیر داده‌ها بر، 64</p>
<p>لایه‌های، 76-78</p>
<p>الگوها برای، 79</p>
<p>انتخاب یک نقطه شروع، 74-76</p>
<p>مبتنی بر نوسان‌پذیری، 62</p>
<p>دفاع در عمق، 347</p>
<p>گلوگاه‌های تحویل، 510، 513</p>
<p>استقرار</p>
<p>ظروف برنامه، 247</p>
<p>استقرار <em>blue-green</em>، 273</p>
<p><em>container orchestration</em> و <em>Kubernetes</em>، 259-269</p>
<p><em>containers</em>، 241-247</p>
<p>تعریف شده، 570</p>
<p><em>Docker</em>، 246</p>
<p>معایب، 244</p>
<p>تناسب برای <strong>microservices</strong>، 246</p>
<p>نقش در <strong>microservices</strong>، 20، 241</p>
<p>نگرانی‌های امنیتی، 362</p>
<p>ماشین‌های فیزیکی، 238</p>
<p>پلتفرم‌ها، 248</p>
<p>اصول، 228-237، 273</p>
<p>578 | فهرست مطالب</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0604</div>
            </div>
        </div>
        <!-- Page 0605 -->
        <div class="chapter" id="page-0605">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>فهرست مطالب (ادامه)</h4>
<p><strong>progressive delivery</strong>، 269-273</p>
<p>نقش <em>Puppet</em>، <em>Chef</em>، و سایر ابزارها، 258</p>
<p>انتخاب پلتفرم استقرار مناسب، 257، 273</p>
<p>ماشین‌های مجازی (<em>VMs</em>)، 239-241</p>
<p>استقرار <em>zero-downtime</em>، 233</p>
<p>مدیریت وضعیت دلخواه، 234-237</p>
<p>کنترل‌های <em>detective</em>، 348، 570</p>
<p>توسعه</p>
<p>ایجاد <em>artifact</em>، 204</p>
<p><em>build pipelines</em>، 201-201</p>
<p>ایجاد امنیت در تحویل <strong>software</strong>، 349</p>
<p>چالش‌های، 26</p>
<p>سازمان‌دهی کد، 205-217</p>
<p>تحویل پیوسته (<em>CD</em>)، 201-203، 570</p>
<p>ادغام پیوسته (<em>CI</em>)، 197-200، 570</p>
<p>ابزارها، 203</p>
<p>مبادلات و محیط‌ها، 203</p>
<p>سرویس‌های دایرکتوری، 377</p>
<p><strong>monoliths</strong> توزیع‌شده، 17</p>
<p>ردیابی توزیع‌شده، 19، 324-326</p>
<p>تراکنش‌های توزیع‌شده</p>
<p>اجتناب از، 181</p>
<p>در مقابل <em>sagas</em>، 195</p>
<p>تراکنش‌های دو فاز، 179-181</p>
<p><em>DNS</em> (<em>Domain Name System</em>)، 157</p>
<p><em>Docker</em>، 246، 570</p>
<p><em>Dockerfiles</em>، 258</p>
<p>مستندات، از سرویس‌ها، 169-173</p>
<p><em>domain coupling</em>، 41، 570</p>
<p>رویدادهای دامنه، 60</p>
<p>طراحی <em>domain-driven</em> (<em>DDD</em>)، 7، 51-62، 552، 570</p>
<p><em>DRY (don’t repeat yourself)</em>، 154</p>
<p><em>dynamic service registries</em>، 159-161</p>
<p><em>E</em></p>
<p>آسانی استقرار، 25</p>
<p><em>EEMUA</em> (<em>Engineering Equipment and Materials Users Association</em>)، 332</p>
<p><em>Elasticsearch</em>، 319</p>
<p>همدلی، 548</p>
<p>تیم‌های فعال‌کننده، 461، 503-509، 540</p>
<p>تست‌های <em>end-to-end</em></p>
<p>جایگزین‌ها برای، 292-296</p>
<p>پیاده‌سازی، 285-292</p>
<p>دامنه، 281</p>
<p><em>Engineering Equipment and Materials Users Association (EEMUA)</em>، 332</p>
<p>مهندسان، 526</p>
<p>(همچنین به <em>evolutionary architects</em> مراجعه کنید)</p>
<p>فصل 16: معمار تکاملی | 577</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0605</div>
            </div>
        </div>
        <!-- Page 0606 -->
        <div class="chapter" id="page-0606">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>فهرست مطالب (ادامه)</h4>
<p>تست‌های <em>flaky</em>، 286</p>
<p>انعطاف‌پذیری، 10</p>
<p><em>Fluentd</em>، 319</p>
<p>تمرکز بر اتوماسیون، 231</p>
<p>بازگشت به عقب، در مقابل جلو، 184</p>
<p>شکنندگی، 413</p>
<p>فریم‌ورک‌ها، 545</p>
<p>تیم‌های <strong>frontend</strong>، 458</p>
<p>تیم‌های <em>full stack</em>، 459</p>
<p><em>Function as a Service (FaaS)</em>، 22، 249-256، 570</p>
<p>تجزیه عملکردی، 430-432</p>
<p><em>G</em></p>
<p>تست‌های <em>game day</em>، 414</p>
<p><em>GitFlow</em> مدل توسعه، 200</p>
<p><em>GitOps</em>، 237</p>
<p>ثبات جهانی، 502</p>
<p>قانون طلایی <strong>caching</strong>، 447</p>
<p>حاکمیت، 544-547، 549، 571</p>
<p><em>graceful extensibility</em>، 390، 571</p>
<p><em>Graphite</em>، 323</p>
<p><em>GraphQL</em>، 133-135، 488-489، 571</p>
<p><em>H</em></p>
<p><em>HATEOAS (hypermedia as the engine of application state)</em>، 129</p>
<p><em>Helm</em>، 266</p>
<p><em>Heroku’s Twelve Factors</em>، 537</p>
<p>معماری ناهمگن، 22</p>
<p>پنهان کردن مدل‌ها، 56</p>
<p>داده با <em>high-cardinality</em>، 322</p>
<p>کد <em>HMAC</em> (<em>hash-based message authentication code</em>)، 372</p>
<p><em>Honeycomb</em>، 20، 323</p>
<p>مقیاس‌پذیری افقی، 422-426، 571</p>
<p><em>HTTP (Hyper Text Transfer Protocol)</em></p>
<p><em>REST</em> و، 128</p>
<p><em>authentication</em> انسانی، 376</p>
<p><em>humane registry</em>، 170</p>
<p><em>Hyper-V containers</em>، 245</p>
<p><em>I</em></p>
<p><em>idempotency</em>، 406، 571</p>
<p>هویت ارائه‌دهندگان، 376</p>
<p>پیاده‌سازی</p>
<p><strong>API gateways</strong>، 162-166</p>
<p>استفاده مجدد از کد، 154-156</p>
<p>مستندسازی سرویس‌ها، 169-173</p>
<p>تنظیم هدف، 121-123، 536</p>
<p>مدیریت تغییرات بین <strong>microservices</strong>، 144</p>
<p><strong>schemas</strong>، 141-143</p>
<p>فرمت‌های <em>serialization</em>، 140</p>
<p>کشف سرویس، 157-161</p>
<p><em>service meshes</em>، 162-163، 166-169</p>
<p>انتزاع ضمنی، 366</p>
<p>تماس‌های درونی-فرآیندی در مقابل تماس‌های بین فرآیندی، 89-92</p>
<p>تست‌های درون تولیدی، 298، 335-337</p>
<p>استقرار مستقل، 6، 8، 291، 551، 571</p>
<p>اطلاعات پنهان، 4، 8، 36، 551، 571</p>
<p>زیرساخت به عنوان کد (<em>IAC</em>)، 232، 571</p>
<p>تست‌های یکپارچه‌سازی، 282</p>
<p>رابط‌ها، در معرض قرار دادن صریح، 122، 143، 146، 169</p>
<p>سازمان داخلی <em>open source</em>، 511-512</p>
<p>invalidation</p>
<p><em>conditional GETs</em>، 444</p>
<p>مبتنی بر اعلان، 444</p>
<p>زمان حیات (<em>TTL</em>)، 443</p>
<p><strong>caches write-behind</strong>، 446</p>
<p><strong>caches write-through</strong>، 446</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0606</div>
            </div>
        </div>
        <!-- Page 0607 -->
        <div class="chapter" id="page-0607">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>scanning for</em>، 358</p>
<p>ذخیره‌سازی امن، 374</p>
<p><em>Kibana</em>، 319</p>
<p><em>Kinesis</em>، 139</p>
<p><em>Knative</em>، 267</p>
<p><em>KSQLDB</em>، 21</p>
<p><em>Kubernetes</em></p>
<p>پیش‌زمینه، 264</p>
<p>اصول، 260-262</p>
<p>مزایا و معایب، 268</p>
<p><em>Cloud Native Computing Foundation (CNCF)</em>، 265</p>
<p>مدیریت پیکربندی در، 160</p>
<p>تعریف شده، 571</p>
<p>توسعه آینده، 268</p>
<p><em>Knative</em> و، 267</p>
<p>مدیریت برنامه‌های شخص ثالث، 266</p>
<p>ساختار و قابلیت حمل پلتفرم، 265</p>
<p>نقش در <strong>microservices</strong>، 20</p>
<p>مدیریت <em>secrets</em> با، 356</p>
<p><em>L</em></p>
<p><strong>latency</strong>، 30، 393</p>
<p>کتابخانه‌ها</p>
<p>کتابخانه‌های <strong>client</strong>، 156</p>
<p>تعریف شده، 571</p>
<p>مشارکت‌های خارجی از طریق، 514</p>
<p>اشتراک‌گذاری کد از طریق، 155</p>
<p>استقرار <em>lockstep</em>، 149، 571</p>
<p><em>log aggregation</em></p>
<p>اصول، 312-314</p>
<p>قالب رایج برای، 314</p>
<p>همبستگی خطوط <em>log</em>، 315-317</p>
<p>پیاده‌سازی‌ها، 319</p>
<p>نقش در <strong>microservices</strong>، 19</p>
<p>نقایص، 320</p>
<p>زمان‌بندی، 318</p>
<p>تراکنش‌های طولانی مدت (<em>LLTs</em>)، 182</p>
<p>سازمان‌های <strong>loosely coupled</strong>، 491، 493</p>
<p><em>M</em></p>
<p><em>managed brokers</em>، 139</p>
<p>آزمایش اکتشافی دستی، 277</p>
<p>میانگین زمان بین خرابی‌ها (<em>MTBF</em>)، 299</p>
<p>متوسط زمان برای تعمیر (<em>MTTR</em>)، 299</p>
<p><em>MELT</em> (<em>metrics</em>، <em>event</em>، <em>logs</em>، و <em>traces</em>)، 310</p>
<p><em>message brokers</em>، 135-140، 571</p>
<p>پیام‌ها، 571</p>
<p>تجمیع معیارها، 321-324</p>
<p><strong>micro frontend</strong> الگوی، 464-466</p>
<p><strong>microservices</strong> (همچنین به <em>modeling microservi</em>ces مراجعه کنید)</p>
<p>رویکرد به یادگیری، <em>xix-xxi</em></p>
<p>مزایای، <em>xvii</em>، 22-26، 391</p>
<p>بهترین کاربردها برای، 31-33</p>
<p>چالش‌های، 26-31</p>
<p>تعریف شده، 551، 571</p>
<p>تعیین استاندارها برای، 543-544</p>
<p>چشم‌انداز اهداف، 552</p>
<p>مفاهیم کلیدی، 6-14</p>
<p>سیستم‌های <strong>monolithic</strong>، 14-18</p>
<p>بررسی اجمالی، 3-6</p>
<p>نقش فناوری در، 18-22</p>
<p><em>middleware</em>، 405</p>
<p>برنامه‌نویسی گروهی، 517</p>
<p><em>mocking</em> همکاران پایین‌دستی، 283</p>
<p>مدل‌سازی <strong>microservices</strong> (همچنین به توسعه; <strong>microservices</strong> مراجعه کنید)</p>
<p>جایگزین‌ها برای مرزهای دامنه کسب‌وکار، 62-67</p>
<p>دامنه-<em>driven design</em>، 51-62</p>
<p>مرزهای <strong>microservice</strong>، 36-39</p>
<p>ترکیب مدل‌ها و استثناها، 68</p>
<p>انواع <em>coupling</em>، 39-51</p>
<p>579</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0607</div>
            </div>
        </div>
        <!-- Page 0608 -->
        <div class="chapter" id="page-0608">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>فهرست مطالب (ادامه)</h4>
<p><em>real-world application of</em>، 412</p>
<p>انتخاب رویکرد خود، 411</p>
<p><em>cardinality</em>، کم در مقابل زیاد، 322</p>
<p><em>CDCs</em> (<em>consumer-driven contracts</em>)، 148، 293-295</p>
<p><strong>API gateway</strong>، 162</p>
<p>تیم‌های خودگردان محصول‌محور، 462</p>
<p><em>autoscaling</em> در، 236، 449-450</p>
<p><em>availability zones</em>، 408</p>
<p><em>AWS Lambda</em>، 245</p>
<p><em>AWS Secrets Manager</em>، 357</p>
<p>همدیگر، 128</p>
<p>انحراف از قانون <em>Conway</em>، 493</p>
<p>ایجاد خود را برای آن در نظر بگیرید</p>
<p>تست‌های <em>flaky</em>، 286</p>
<p>انعطاف‌پذیری، 10</p>
<p><em>Fluentd</em>، 319</p>
<p>تمرکز بر اتوماسیون، 231</p>
<p>هماهنگی را می‌پوشاند.</p>
<p>جذابیت برای هر سیستم را آسان می‌کند.</p>
<p>گرافیک، 133-135، 488-489</p>
<p>در دسترس بودن، 393، 410</p>
<p>ساختمان‌ها، 175</p>
<p>هویت‌های دیگر</p>
<p>پلتفرم <em>(platform)</em></p>
<p>مقیاس‌پذیری عمودی، 421</p>
<p>ماشین‌های مجازی (<em>VMs</em>)، 239-241</p>
<p>منوی فرعی</p>
<p>مترجم.<sup>1</sup>, 502</p>
<p>مدل‌های <em>BFF</em>, 463</p>
<p><em>NIST</em>، 350</p>
<p>هوشمندی (<em>intelligence</em>)</p>
<p>در حال یادگیری هستند.</p>
<p>آشکار سازی.</p>
<p>داده‌های <strong>microservices</strong> مشترک، 509-511</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0608</div>
            </div>
        </div>
        <!-- Page 0609 -->
        <div class="chapter" id="page-0609">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p><em>preproduction validation</em>، 276</p>
<p><em>preventative control</em>، 348، 572</p>
<p><em>principal</em>، 375، 572</p>
<p>اصل دفاع در عمق، 347</p>
<p>اصل کمترین امتیاز، 347</p>
<p><em>private keys</em>، 358</p>
<p>آزمایش‌های در تولید، 335-337</p>
<p>رویکردهای برنامه‌نویسی</p>
<p>برنامه‌نویسی گروهی، 517</p>
<p>برنامه‌نویسی <em>mob</em>، 517</p>
<p>برنامه‌نویسی ساخت‌یافته، 40</p>
<p>تحویل تدریجی، 269-273</p>
<p><em>Prometheus</em>، 323</p>
<p><em>Protolock</em>، 148</p>
<p><em>Puppet</em>، 258</p>
<p><em>Q</em></p>
<p>سوالات و نظرات، <em>xxii</em></p>
<p>سیستم‌های مبتنی بر صف، 136</p>
<p><em>R</em></p>
<p>پایش کاربران واقعی، 334</p>
<p>پایش زمان واقعی، 339</p>
<p>قابلیت بازیابی، 389</p>
<p>افزونگی، 405</p>
<p>تماس‌های از راه دور (<em>RPCs</em>)، 123-127</p>
<p>نسخه‌های <em>replica</em> (<em>Kubernetes</em>)، 261</p>
<p>پایگاه‌های داده گزارش‌دهی، 85</p>
<p><em>Representational State Transfer (REST)</em>، 127-133</p>
<p><strong>request caches</strong>، 442</p>
<p>ارتباط <em>request-response</em>، 104-108، 553</p>
<p>درخواست‌ها</p>
<p>در مقابل دستورات، 106</p>
<p>تعریف شده، 572</p>
<p><em>resiliency</em></p>
<p><em>blameless post-mortems</em>، 415</p>
<p>قضیه <em>CAP</em>، 408-413</p>
<p>چالش‌های، 391</p>
<p>مهندسی هر بخش، 387-391</p>
<p>نیازمند <em>cross-functional requirements</em> و، 392</p>
<p>تأثیر بر عملکرد، 394</p>
<p>مروری بر، 558</p>
<p>مدیریت ریسک، 407</p>
<p>الگوهای پایداری، 395-407</p>
<p>زمان پاسخ‌گویی، 393</p>
<p>پاسخ‌ها، 572</p>
<p>مسئولیت‌ها، درک، 541</p>
<p>کنترل‌های واکنشی، 348، 572</p>
<p><em>REST</em> بر مبنای <em>APIs</em>، 132</p>
<p>تلاش دوباره، 399</p>
<p>مدیریت ریسک، 407</p>
<p>پایداری</p>
<p>تضمین، 23</p>
<p>مزایای <strong>caching</strong>، 436</p>
<p>چالش‌های بهبود، 388</p>
<p>مهندسی <strong>chaos</strong> و، 413</p>
<p>تعریف شده، 572</p>
<p>تعیین اینکه کدام گزینه‌ها را باید استفاده کرد، 417</p>
<p>اصل، 146</p>
<p>تست‌های استحکام، 302</p>
<p>استقرار <em>rollbacks</em>، 188</p>
<p><em>semantic rollbacks</em>، 187</p>
<p>هنگام استفاده از <em>sagas</em>، 185-189</p>
<p>نقش در <strong>microservices</strong>، 183، 554</p>
<p><em>Salt</em>، 258</p>
<p><em>salted password hashing</em>، 373</p>
<p>مقیاس‌پذیری</p>
<p><strong>autoscaling</strong>، 449</p>
<p>اجتناب از بهینه‌سازی زودرس، 433</p>
<p>مزایای، 24</p>
<p><strong>caching</strong>، 435-449</p>
<p><em>CQRS</em> و <em>event sourcing</em>، 434</p>
<p>تقسیم داده‌ها، 426-430</p>
<p>پایگاه‌های داده در طول استقرار، 223</p>
<p>چهار محور، 419</p>
<p>تجزیه عملکردی، 430-432</p>
<p>تکثیر افقی، 422-426</p>
<p>فهرست مطالب | 579</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0609</div>
            </div>
        </div>
        <!-- Page 0610 -->
        <div class="chapter" id="page-0610">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>فهرست مطالب (ادامه)</h4>
<p>مروری بر، 558</p>
<p>معماری <strong>software</strong> تعریف شده، 527</p>
<p>معماری سه‌لایه، 10-12</p>
<p>تیم‌های <strong>API</strong> مبتنی بر <em>REST</em>، 132</p>
<p><em>SRE</em> (<em>Site Reliability Engineering</em>)، 328</p>
<p>مقیاس‌پذیری، 419-420</p>
<p>بهبود (<em>IMPROVEMENT</em>)</p>
<p>از دست دادن، 388</p>
<p>اهمیت داده‌ها</p>
<p>از پاشنه تاندون از دست می‌رود</p>
<p>بهبود (<em>IMPROVEMENT</em>)</p>
<p>داده‌های داده، 374</p>
<p>معماری‌گری، 183</p>
<p>تست‌های جامع، 283-285</p>
<p>تحول</p>
<p>کمیاب و کمبود، 240</p>
<p>کمک در این کتاب، 202، 570</p>
<p><em>Microservices</em>، 6، 459</p>
<p><strong>Monoliths</strong>، 15</p>
<p><em>SOAP</em>، 132</p>
<p>در نظر گرفتن همه اجزای، 466</p>
<p>همه‌چیز برای هر چیز.</p>
<p>اجرای این عملکرد.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0610</div>
            </div>
        </div>
        <!-- Page 0611 -->
        <div class="chapter" id="page-0611">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>فهرست مطالب (ادامه)</h4>
<p><em>community of practice (CoP) groups</em>، 505</p>
<p>تیم‌های فعال‌کننده، 461، 503-509، 540</p>
<p>اطمینان از ثبات در طول، 461</p>
<p>تیم‌های <em>full stack</em>، 459</p>
<p>توزیع جغرافیایی، 521</p>
<p>پلتفرم، 507</p>
<p>اندازه تیم، 495</p>
<p><em>stream-aligned teams</em>، 459-463، 492، 540-542</p>
<p>مالکیت قوی در مقابل مالکیت جمعی، 499-503</p>
<p>تیم‌های دو پیتزایی، 494</p>
<p><em>کد</em></p>
<p>با خطاهای ناهمگونی مواجه می‌شوند،</p>
<p>داده، 375</p>
<p>داده‌ها را به اشتراک بگذارید. در سیستم‌های جداگانه.</p>
<p>بهبود است.</p>
<p>ارتباط.</p>
<p>مقیاس‌پذیری، 419-420</p>
<p>نقطه پایانی، 125</p>
<p>از <strong>API</strong> استفاده می‌کنید.</p>
<p>استراتژی.<sup>3</sup></p>
<p>همچنین به آن اشاره شده است (به عنوان مثال، خطاهای <strong>API</strong>، 380، 381، 543، 569</p>
<p>کاهش سرعت و مقیاس‌پذیری.</p>
<p>سیستم (<em>system</em>)، 527</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0611</div>
            </div>
        </div>
        <!-- Page 0612 -->
        <div class="chapter" id="page-0612">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>شاخص (ادامه)</h4>
<p><em>V</em></p>
<p>تنوع، اجرای چندگانه، 513</p>
<p><em>Vault</em>، 356</p>
<p>نسخه‌سازی، 144، 147، 149، 233</p>
<p>مقیاس‌پذیری عمودی، 420-422، 573</p>
<p><em>VFS for Git</em>، 215</p>
<p>ماشین‌های مجازی (<em>VMs</em>)، 239-241، 573</p>
<p>تجزیه مبتنی بر نوسان‌پذیری، 62</p>
<p>مرحله رأی‌گیری، 179</p>
<p><em>W</em></p>
<p><em>Wasm (WebAssembly)</em>، 251</p>
<p><em>Web Component Standard</em>، 473</p>
<p><em>WebAssembly System Interface (WASI)</em>، 251</p>
<p>تجزیه مبتنی بر <strong>widget</strong>، 469-474</p>
<p><strong>widgets</strong>، 573</p>
<p><em>Windows containers</em>، 244</p>
<p>جریان کار</p>
<p>تراکنش‌های پایگاه داده، 175-178</p>
<p>اجتناب از تراکنش‌های توزیع‌شده، 181</p>
<p>تراکنش‌های توزیع‌شده، <em>two-phase commits</em>، 179-181</p>
<p>مروری بر، 554</p>
<p><em>sagas</em>، 182-196</p>
<p><strong>caches write-behind</strong>، 446</p>
<p><strong>caches write-through</strong>، 446</p>
<p><em>Z</em></p>
<p><em>Zed Attack Proxy (ZAP)</em>، 350</p>
<p>عدم اعتماد، 366</p>
<p><em>ZooKeeper</em>، 159</p>
<p>فهرست مطالب | 567</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0612</div>
            </div>
        </div>
        <!-- Page 0613 -->
        <div class="chapter" id="page-0613">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h4>درباره نویسنده</h4>
<p><em>Sam Newman</em> یک مشاور مستقل، نویسنده، و سخنران است. در بیش از 20 سال در این صنعت، او در سراسر <em>technology stacks</em> مختلف و در <em>domains</em> مختلف با شرکت‌هایی در سراسر جهان کار کرده است. تمرکز اصلی او کمک به سازمان‌ها برای ارائه <strong>software</strong> به تولید با سرعت و ایمنی بیشتر، و کمک به آنها برای پیمایش پیچیدگی‌های <strong>microservices</strong> است. او همچنین نویسنده کتاب <em>Monolith to Microservices</em>، که توسط <em>O’Reilly</em> منتشر شده، می‌باشد.</p>
<h4><em>Colophon</em></h4>
<p>حیوانات روی جلد <em>Building Microservices</em>، <em>Second Edition</em>، زنبورهای عسل هستند (از جنس <em>Apis</em>). از بین بیش از 20000 گونه زنبور، تنها هشت گونه زنبور عسل وجود دارد. این زنبورهای لانه‌ساز اجتماعی، در نحوه تولید و ذخیره جمعی عسل، و همچنین ساخت کندوها از موم، منحصربه‌فرد هستند. زنبورداری برای جمع‌آوری عسل، هزاران سال است که یک هدف انسانی در سراسر جهان بوده است.</p>
<p>کندوهای زنبور عسل، هزاران فرد را در خود جای می‌دهند و دارای ساختار اجتماعی بسیار منظمی هستند که شامل یک ملکه، نرها، و کارگران است. هر کندو یک ملکه دارد، که پس از پرواز جفت‌گیری خود، برای 3 تا 5 سال بارور باقی می‌ماند و تا 2000 تخم در روز می‌گذارد. زنبورهای نر، زنبورهای نر هستند که با ملکه جفت می‌شوند (و در این عمل می‌میرند، به دلیل اندام‌های جنسی خاردارشان). زنبورهای کارگر، ماده‌های عقیم هستند که نقش‌های زیادی را در طول زندگی خود ایفا می‌کنند، مانند پرستار، کارگر ساختمانی، خواربارفروش، نگهبان، متصدی کفن و دفن، و جمع‌آوری‌کننده غذا. زنبورهای کارگر که پر از گرده هستند و به کندو بازمی‌گردند، با الگوهای مشخصی "رقص" می‌کنند تا اطلاعاتی را در مورد غذای مجاور منتقل کنند.
   اگرچه ملکه‌ها کمی بزرگتر هستند، اما زنبورهای عسل از نظر ظاهری مشابه هستند، با بال‌های شفاف، شش پا، و بدنی که به سر، سینه و شکم تقسیم می‌شود. آنها موهای کرک‌دار کوتاهی با الگوی راه‌راه زرد و سیاه دارند. رژیم غذایی بزرگسالان، منحصراً از عسل تشکیل شده است، که با فرآیندی از هضم جزئی و سپس بالا آوردن شهد گل غنی از قند، ایجاد می‌شود.
   زنبورها برای کشاورزی حیاتی هستند. هنگامی که آنها غذای خود را جمع‌آوری می‌کنند، محصولات را گرده‌افشانی می‌کنند. کندوهای زنبور عسل تجاری توسط زنبورداران به جایی که محصولات باید گرده‌افشانی شوند، منتقل می‌شوند.
   به‌طور متوسط، هر کندو از زنبورها سالانه 66 پوند گرده جمع‌آوری می‌کند. با این حال، در سال‌های اخیر، اختلال فروپاشی کلونی، ناشی از انواع بیماری‌ها و سایر عوامل استرس‌زا، باعث کاهش هشداردهنده در میان گونه‌های زنبور عسل شده است.
   زنبورهای عسل در برابر همان آفت‌کش‌ها و انگل‌ها و بیماری‌های معرفی‌شده آسیب‌پذیر هستند که تعداد زنبورهای وحشی و سایر گرده‌افشان‌ها را کاهش داده‌اند، اما زنبورهای عسل به دلیل اینکه در کشاورزی کلیدی هستند، از حمایت و محافظت انسانی برخوردارند.
   بسیاری از حیوانات روی جلد کتاب‌های <em>O’Reilly</em> در معرض خطر هستند. همه آنها برای جهان مهم هستند.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0613</div>
            </div>
        </div>
        <!-- Page 0614 -->
        <div class="chapter" id="page-0614">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<p>تصویر رنگی روی جلد، اثر <em>Karen Montgomery</em> است، که بر اساس یک حکاکی سیاه و سفید از <em>The Pictorial Museum of Animated Nature</em> ایجاد شده است. فونت‌های روی جلد، <em>Gilroy</em> و <em>Guardian Sans</em> هستند. فونت متن، <em>Adobe Minion Pro</em> است. فونت عنوان، <em>Adobe Myriad Condensed</em> است و فونت کد، <em>Ubuntu Mono</em> اثر <em>Dalton Maag</em> است.</p>
</div>
</div>
                <div class="page-images">
</div>
                <div class="page-number">صفحه 0614</div>
            </div>
        </div>
        <!-- Page 0615 -->
        <div class="chapter" id="page-0615">
            <div class="chapter-content">
                <div class="translated-content">
<div>
<h3>بسیار بیشتر از اینها در دسترس است.</h3>
<p>
    تجربه ی کتاب ها، ویدئوها، دوره های آموزشی زنده آنلاین و موارد دیگر از <strong>O’Reilly</strong>
     و بیش از 200 شریک ما—همه در یک مکان.
  </p>
<p>
<em>برای کسب اطلاعات بیشتر به oreilly.com/online-learning مراجعه کنید.</em>
</p>
<p>
    ©2019 <strong>O’Reilly Media, Inc.</strong>
<br/>
<strong>O’Reilly</strong> یک علامت تجاری ثبت شده از <strong>O’Reilly Media, Inc.</strong> است.
    | 175
  </p>
</div>
</div>
                <div class="page-images">
<div class="page-image"><img alt="Image from page 615" src="page_0615/image_1.png"/></div>
</div>
                <div class="page-number">صفحه 0615</div>
            </div>
        </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>