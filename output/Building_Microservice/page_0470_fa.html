<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 470</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4><strong>Invalidation</strong> (ادامه)</h4>

  <p>در چهار دقیقه و 59 ثانیه با داده‌های منسوخ شده عمل خواهیم کرد. بنابراین سادگی پیاده‌سازی باید با میزان تحمل شما در مورد عملکرد با داده‌های قدیمی متعادل شود.</p>

  <h4><strong>GET</strong>های مشروط</h4>

  <p>شایسته ذکر است، زیرا این نادیده گرفته می‌شود، توانایی صدور درخواست‌های <strong>GET</strong> مشروط با <strong>HTTP</strong> است. همانطور که ما به آن اشاره کردیم، <strong>HTTP</strong> این توانایی را فراهم می‌کند که هدرهای <strong>Cache-Control</strong> و <strong>Expires</strong> را در پاسخ‌ها مشخص کنید تا <strong>caching client-side</strong> هوشمندتر را فعال کنید. اما اگر ما مستقیماً با <strong>HTTP</strong> کار می‌کنیم، یک گزینه دیگر در زرادخانه چیزهای خوب <strong>HTTP</strong> ما وجود دارد: <strong>entity tags</strong>، یا <strong>ETags</strong>. یک <strong>Etag</strong> برای تعیین اینکه آیا مقدار یک منبع تغییر کرده است یا خیر استفاده می‌شود. اگر من یک رکورد مشتری را به‌روزرسانی کنم، <strong>URI</strong> منبع یکسان است اما مقدار متفاوت است، بنابراین انتظار دارم <strong>Etag</strong> تغییر کند.
   این زمانی قدرتمند می‌شود که ما از چیزی به نام <strong>conditional GET</strong> استفاده می‌کنیم. هنگام ایجاد یک درخواست <strong>GET</strong>، می‌توانیم <strong>headers</strong> اضافی را مشخص کنیم، و به سرویس بگوییم که منبع را فقط در صورت برآورده شدن معیارهای خاص برای ما ارسال کند.</p>

  <p>به عنوان مثال، بیایید تصور کنیم که یک رکورد مشتری را واکشی می‌کنیم، و <strong>Etag</strong> آن به عنوان o5t6fkd2sa برمی‌گردد. بعداً، شاید به این دلیل که یک دستورالعمل <strong>Cache-Control</strong> به ما گفته است که باید منبع را منسوخ شده در نظر بگیریم، ما می‌خواهیم مطمئن شویم که آخرین نسخه را دریافت می‌کنیم. هنگام صدور درخواست <strong>GET</strong> بعدی، می‌توانیم در If-None-Match: o5t6fkd2sa را منتقل کنیم. این به سرور می‌گوید که ما منبع را در <strong>URI</strong> مشخص شده می‌خواهیم، مگر اینکه قبلاً با این مقدار <strong>Etag</strong> مطابقت داشته باشد. اگر در حال حاضر نسخه به‌روز را داریم، سرویس یک پاسخ 304 Not Modified را برای ما ارسال می‌کند و به ما می‌گوید که ما آخرین نسخه را داریم. اگر نسخه جدیدتری در دسترس باشد، ما یک 200 OK با منبع تغییر یافته و یک <strong>Etag</strong> جدید برای منبع دریافت می‌کنیم.</p>

  <p>البته، با یک <strong>conditional GET</strong>، ما همچنان درخواست را از <strong>client</strong> به سرور انجام می‌دهیم. اگر <strong>caching</strong> را برای کاهش <strong>network round trips</strong> انجام می‌دهید، این ممکن است به شما کمکی نکند. جایی که مفید است در اجتناب از هزینه بازسازی بی‌مورد منابع است. با <strong>invalidation</strong> مبتنی بر <strong>TTL</strong>، <strong>client</strong> یک کپی جدید از منبع را درخواست می‌کند، حتی اگر منبع تغییر نکرده باشد—سرویس <strong>microservice</strong> که این درخواست را دریافت می‌کند سپس باید آن منبع را دوباره تولید کند، حتی اگر دقیقاً همان چیزی باشد که <strong>client</strong> قبلاً دارد. اگر هزینه ایجاد پاسخ زیاد باشد، شاید نیاز به مجموعه‌ای گران‌قیمت از <strong>database queries</strong> داشته باشد، سپس درخواست‌های <strong>GET</strong> مشروط می‌توانند یک مکانیسم مؤثر باشند.</p>

  <h4>مبتنی بر اعلان</h4>

  <p>با <strong>invalidation</strong> مبتنی بر اعلان، ما از رویدادها برای کمک به مشترکین در دانستن اینکه آیا ورودی‌های <strong>cache</strong> محلی آنها نیاز به <strong>invalidated</strong> دارند یا خیر، استفاده می‌کنیم. به نظر من، این ظریف‌ترین مکانیسم برای <strong>invalidation</strong> است، اگرچه این با پیچیدگی نسبی آن نسبت به <strong>invalidation</strong> مبتنی بر <strong>TTL</strong> متعادل است.</p>

  <p>در شکل 13-14، <strong>microservice</strong> توصیه‌های ما در حال حفظ یک <strong>cache client-side</strong> است. ورودی‌های موجود در آن <strong>cache</strong> زمانی که <strong>microservice</strong> موجودی یک</p>

  <p>444 | فصل 13: مقیاس‌پذیری</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>