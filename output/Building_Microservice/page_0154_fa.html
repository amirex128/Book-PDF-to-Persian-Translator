<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 154</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p><em>server</em> <em>different representations</em> از این <em>Customer</em> را در <em>request</em> ایجاد می‌کند. نحوه نمایش یک <em>resource</em> در خارج، کاملاً از نحوه ذخیره آن در داخل، جدا شده است. برای مثال، یک <em>client</em> ممکن است یک <em>JSON representation</em> از یک <em>Customer</em> را درخواست کند، حتی اگر در یک <em>format</em> کاملاً متفاوت ذخیره شده باشد. هنگامی که یک <em>client</em> یک <em>representation</em> از این <em>Customer</em> را دارد، می‌تواند درخواست‌هایی را برای تغییر آن ایجاد کند، و <em>server</em> ممکن است با آن‌ها موافقت کند یا نکند.</p>
  <p>سبک‌های مختلفی از <em>REST</em> وجود دارد، و من فقط به طور خلاصه به آن‌ها اشاره می‌کنم. من به شدت توصیه می‌کنم نگاهی به <em>Richardson Maturity Model</em> بیندازید، که در آن سبک‌های مختلف <em>REST</em> مقایسه شده‌اند.</p>
  <p><em>REST</em> در واقع در مورد <em>underlying protocols</em> صحبت نمی‌کند، اگرچه معمولاً بیش از <em>HTTP</em> استفاده می‌شود. من قبلاً پیاده‌سازی‌هایی از <em>REST</em> را دیده‌ام که از <em>protocols</em> بسیار متفاوتی استفاده می‌کنند، اگرچه این می‌تواند به تلاش زیادی نیاز داشته باشد. برخی از ویژگی‌هایی که <em>HTTP</em> به عنوان بخشی از <em>specification</em> به ما می‌دهد، مانند <em>verbs</em>، پیاده‌سازی <em>REST</em> را بر روی <em>HTTP</em> آسان‌تر می‌کند، در حالی که با <em>protocols</em> دیگر، شما باید این ویژگی‌ها را خودتان مدیریت کنید.</p>
  <h4>REST و HTTP</h4>
  <p><em>HTTP</em> خود، برخی از قابلیت‌های مفیدی را تعریف می‌کند که با سبک <em>REST</em> بسیار خوب عمل می‌کنند. به عنوان مثال، <em>HTTP verbs</em> (مانند <em>GET</em>، <em>POST</em> و <em>PUT</em>) در حال حاضر در <em>HTTP specification</em> معانی مشخصی دارند در مورد نحوه عملکرد آن‌ها با <em>resources</em>. سبک معماری <em>REST</em> در واقع به ما می‌گوید که این <em>verbs</em> باید به یک روش در تمام <em>resources</em> رفتار کنند، و <em>HTTP specification</em> اتفاقاً مجموعه‌ای از <em>verbs</em> را تعریف می‌کند که می‌توانیم از آن‌ها استفاده کنیم. برای مثال، <em>GET</em> یک <em>resource</em> را به روشی <em>idempotent</em> بازیابی می‌کند، و <em>POST</em> یک <em>resource</em> جدید ایجاد می‌کند. این بدان معناست که می‌توانیم از بسیاری از <em>different</em> <code>createCustomer</code> یا <code>editCustomer</code> متدها اجتناب کنیم. در عوض، می‌توانیم به سادگی یک <em>customer representation</em> را <em>POST</em> کنیم تا از <em>server</em> درخواست کنیم که یک <em>resource</em> جدید ایجاد کند، و سپس می‌توانیم یک <em>GET request</em> را برای بازیابی یک <em>representation</em> از یک <em>resource</em> آغاز کنیم. از نظر مفهومی، در این موارد یک <em>endpoint</em> به شکل یک <em>Customer resource</em> وجود دارد، و عملیاتی که می‌توانیم روی آن انجام دهیم، در <em>HTTP protocol</em> تعبیه شده است.</p>
  <p><em>HTTP</em> همچنین یک اکوسیستم بزرگ از ابزارها و فناوری‌های پشتیبانی‌کننده را به ارمغان می‌آورد. ما می‌توانیم از <em>HTTP caching proxies</em> مانند <em>Varnish</em> و <em>load balancers</em> مانند <em>mod_proxy</em> استفاده کنیم، و بسیاری از ابزارهای <em>monitoring</em> در حال حاضر پشتیبانی زیادی از <em>HTTP out of the box</em> دارند. این <em>building blocks</em> به ما امکان می‌دهند تا حجم زیادی از ترافیک <em>HTTP</em> را مدیریت و آن‌ها را هوشمندانه و به روشی نسبتاً شفاف مسیریابی کنیم. ما همچنین می‌توانیم از تمام <em>security controls</em> موجود با <em>HTTP</em> برای ایمن‌سازی ارتباطات خود استفاده کنیم. از <em>basic auth</em> تا <em>client certs</em>، اکوسیستم <em>HTTP</em> ابزارهای زیادی را در اختیار ما قرار می‌دهد تا فرآیند امنیت را آسان‌تر کنیم، و ما این موضوع را در فصل 11 بیشتر بررسی خواهیم کرد. با این حال، برای به دست آوردن این مزایا، باید از <em>HTTP</em> به خوبی استفاده کنید. بد استفاده کنید، و می‌تواند به اندازه هر فناوری دیگری ناامن و مقیاس‌پذیری دشوار باشد. اگر درست استفاده کنید، کمک زیادی دریافت می‌کنید.</p>
 </div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>