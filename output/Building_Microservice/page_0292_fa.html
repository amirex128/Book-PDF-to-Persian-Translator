<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 292</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   با گزینه های بسیار زیاد. محصولاتی مانند <span style="color:blue">OpenShift</span> <span style="color:blue">Red Hat</span> تا حدودی این انتخاب را می گیرند
   از ما، زیرا آنها یک پلتفرم آماده با برخی از تصمیمات از قبل ساخته شده به ما می دهند
   برای ما
  </p>
  <p>
   آنچه این بدان معناست این است که اگرچه در سطح پایه <span style="color:blue">Kubernetes</span> یک
   انتزاع قابل حمل برای اجرای کانتینر، در عمل به سادگی گرفتن یک برنامه نیست
   که در یک خوشه کار می کند و انتظار می رود که در جای دیگری کار کند. برنامه شما،
   عملیات شما و گردش کار توسعه‌دهنده، ممکن است به پلتفرم سفارشی خود وابسته باشد.
   انتقال از یک خوشه <span style="color:blue">Kubernetes</span> به خوشه دیگر نیز ممکن است به شما نیاز داشته باشد
   آن پلتفرم را در مقصد جدید خود بازسازی کنید. من با بسیاری از سازمان‌ها صحبت کرده‌ام
   که <span style="color:blue">Kubernetes</span> را در درجه اول اتخاذ کرده اند زیرا نگران قفل شدن هستند
   در یک فروشنده واحد، اما این سازمان ها این تفاوت ظریف را درک نکرده اند
   برنامه های ساخته شده بر روی <span style="color:blue">Kubernetes</span> از نظر تئوری در سراسر خوشه های <span style="color:blue">Kubernetes</span> قابل حمل هستند، اما نه
   همیشه در عمل
  </p>
  <h4><span style="color:blue">Helm</span>، اپراتورها، و <span style="color:blue">CRD</span> ها، اوه من!</h4>
  <p>
   یکی از حوزه‌های سردرگمی مداوم در فضای <span style="color:blue">Kubernetes</span> این است که چگونه مدیریت کنیم
   استقرار و چرخه حیات برنامه ها و زیرسیستم های شخص ثالث. در نظر گرفتن
   نیاز به اجرای <span style="color:blue">Kafka</span> در خوشه <span style="color:blue">Kubernetes</span> شما. شما می توانید <span style="color:blue">pod</span>، <span style="color:blue">ser</span>- خود را ایجاد کنید
   <span style="color:blue">vice</span>، و مشخصات استقرار و اجرای آنها خودتان. اما در مورد مدیریت چه
   ارتقاء به تنظیمات <span style="color:blue">Kafka</span> شما؟ در مورد دیگر کارهای تعمیر و نگهداری مشترک شما چه می کنید
   ممکن است بخواهید با آن مقابله کنید، مانند ارتقاء نرم افزار با حالت <span style="color:blue">stateful</span> در حال اجرا؟
  </p>
  <p>
   تعدادی ابزار ظاهر شده اند که هدف آنها این است که به شما این توانایی را بدهند که این کار را مدیریت کنید
   انواع برنامه ها در سطح انتزاعی معقول تر. ایده این است که کسی
   چیزی شبیه یک بسته برای <span style="color:blue">Kafka</span> ایجاد می کند، و شما آن را در <span style="color:blue">Kubernetes</span> خود اجرا می کنید
   خوشه به روشی سیاه چال تر. دو مورد از شناخته شده ترین راه حل ها در این فضا
   هستند <span style="color:blue">Operator</span> و <span style="color:blue">Helm</span>. <span style="color:blue">Helm</span> خود را به عنوان "مدیر بسته گمشده" برای می شناسد
   <span style="color:blue">Kubernetes</span>، و در حالی که <span style="color:blue">Operator</span> می تواند نصب اولیه را مدیریت کند، به نظر می رسد
   بیشتر بر مدیریت مداوم برنامه متمرکز شده است. گیج کننده، در حالی که شما
   می‌توانید <span style="color:blue">Operator</span> و <span style="color:blue">Helm</span> را به عنوان جایگزین یکدیگر ببینید، در برخی شرایط نیز می‌توانید استفاده کنید
   هر دوی آنها را با هم ( <span style="color:blue">Helm</span> برای نصب اولیه، <span style="color:blue">Operator</span> برای عملیات چرخه عمر).
  </p>
  <p>
   یک تکامل اخیرتر در این فضا چیزی است که به نام تعریف منبع سفارشی نامیده می شود،
   یا <span style="color:blue">CRD</span> ها با <span style="color:blue">CRD</span> ها می توانید <span style="color:blue">API</span> های اصلی <span style="color:blue">Kubernetes</span> را گسترش دهید و به شما اجازه می دهد
   با خوشه خود رفتار جدیدی را وارد کنید. نکته خوب در مورد <span style="color:blue">CRD</span> ها این است که آنها <span style="color:blue">inte</span>- می شوند
   به طور نسبتاً یکپارچه در رابط خط فرمان موجود، کنترل دسترسی و
   بیشتر - بنابراین افزونه سفارشی شما احساس یک افزوده بیگانه را ندارد. آنها اساساً
   به شما اجازه می دهند تا انتزاع های <span style="color:blue">Kubernetes</span> خود را پیاده سازی کنید. به <span style="color:blue">pod</span>، <span style="color:blue">replica</span> فکر کنید
   مجموعه، سرویس، و انتزاع‌های استقرار که قبلاً بحث کردیم—با <span style="color:blue">CRD</span> ها، شما می توانید
   خود را به ترکیب اضافه کنید
  </p>
  <p>
   266
   |
   فصل 8: استقرار
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>