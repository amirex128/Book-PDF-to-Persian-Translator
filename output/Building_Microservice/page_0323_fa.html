<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 323</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        ممکن. با این حال، در حالی که چیزی شبیه به این ممکن است آینده توسعه باشد، مطمئناً در حال حاضر برای اکثریت قریب به اتفاق ما اینطور نیست.
    </p>
    <p>
        اساساً، من فکر می‌کنم که استفاده از محیط‌های <strong>cloud</strong> برای اجازه دادن به یک توسعه‌دهنده برای اجرای <strong>microservices</strong> بیشتر برای چرخه‌های توسعه و تست خود، نادیده گرفتن نکته است و در نتیجه، علاوه بر هزینه‌های بالاتر، پیچیدگی بیشتری نسبت به نیاز ایجاد می‌کند. در حالت ایده‌آل، شما می‌خواهید توسعه‌دهنده‌ای را هدف قرار دهید که فقط نیاز به اجرای <strong>microservices</strong>هایی دارد که واقعاً روی آنها کار می‌کند. اگر یک توسعه‌دهنده بخشی از تیمی است که مالک پنج <strong>microservices</strong> است، پس آن توسعه‌دهنده باید بتواند آن <strong>microservices</strong> را تا حد امکان مؤثر اجرا کند، و برای بازخورد سریع، ترجیح من همیشه این است که آنها را به صورت محلی اجرا کنند.
    </p>
    <p>
        اما اگر پنج <strong>microservices</strong> که تیم شما مالک آن است، بخواهند با سیستم‌ها و <strong>microservices</strong>های دیگری که متعلق به تیم‌های دیگر هستند، تماس بگیرند، چه؟ بدون آنها، محیط توسعه و تست محلی کار نخواهد کرد، درست است؟ در اینجا دوباره، <strong>stubbing</strong> وارد عمل می‌شود. من باید بتوانم <strong>stubs</strong>های محلی را راه‌اندازی کنم که از <strong>microservices</strong> که خارج از <strong>scope</strong> تیم من هستند، تقلید می‌کنند. تنها <strong>microservices</strong>های واقعی که باید به صورت محلی اجرا کنید، مواردی هستند که روی آنها کار می‌کنید. اگر شما در سازمانی کار می‌کنید که انتظار می‌رود روی صدها <strong>microservices</strong> مختلف کار کنید، پس، شما مشکلات بسیار بزرگ‌تری برای مقابله دارید—این موضوعی است که ما در "مالکیت قوی در مقابل جمعی" در صفحه 499 با عمق بیشتری به آن خواهیم پرداخت.
    </p>
    <h4>From Preproduction to In-Production Testing</h4>
    <p>
        از نظر تاریخی، بیشتر تمرکز تست‌ها بر روی تست سیستم‌های ما قبل از ورود به <strong>production</strong> بوده است. با تست‌های خود، ما در حال تعریف مجموعه‌ای از مدل‌ها هستیم که با استفاده از آنها امیدواریم ثابت کنیم که آیا سیستم ما به درستی کار می‌کند و همانطور که می‌خواهیم، هم از نظر عملکردی و هم غیرعملکردی رفتار می‌کند. اما اگر مدل‌های ما کامل نباشند، هنگام استفاده از سیستم‌هایمان با مشکلاتی مواجه خواهیم شد. باگ‌ها وارد <strong>production</strong> می‌شوند، حالت‌های شکست جدید کشف می‌شوند، و کاربران ما از سیستم به روش‌هایی استفاده می‌کنند که ما هرگز نمی‌توانیم انتظار داشته باشیم.
    </p>
    <p>
        یک واکنش به این امر اغلب تعریف تست‌های بیشتر و بیشتر، و اصلاح مدل‌های ما است، تا مشکلات بیشتری را زودتر شناسایی کنیم و تعداد مشکلاتی را که در سیستم <strong>production</strong> در حال اجرا با آن مواجه می‌شویم، کاهش دهیم. با این حال، در یک نقطه خاص، ما باید بپذیریم که با این رویکرد به بازدهی کاهشی می‌رسیم. با تست قبل از استقرار، ما نمی‌توانیم احتمال شکست را به صفر کاهش دهیم.
    </p>
    <p>
        پیچیدگی یک سیستم توزیع شده به گونه‌ای است که گرفتن تمام مشکلات احتمالی که ممکن است قبل از رسیدن به خود <strong>production</strong> رخ دهد، غیرممکن است.
    </p>
    <p>
        به طور کلی، هدف از یک تست این است که به ما بازخوردی در مورد اینکه آیا نرم‌افزار ما از کیفیت کافی برخوردار است یا خیر، ارائه دهد. در حالت ایده‌آل، ما می‌خواهیم آن بازخورد را در اسرع وقت داشته باشیم، و می‌خواهیم بتوانیم متوجه شویم که آیا مشکلی در نرم‌افزار ما وجود دارد یا خیر، قبل از اینکه یک کاربر نهایی آن مشکل را تجربه کند. به همین دلیل است که تست‌های زیادی قبل از انتشار نرم‌افزار ما انجام می‌شود.
    </p>
    <p>
        From Preproduction to In-Production Testing | 297
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>