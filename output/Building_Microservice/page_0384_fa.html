<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 384</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>جایی که سیستم‌ها با تغییر کلیدها از کار می‌افتند. این اغلب به این دلیل است که مشخص نیست چه چیزی از یک <em>credential</em> (اعتبارنامه) خاص استفاده می‌کند. اگر دامنه <em>credential</em> (اعتبارنامه) محدود باشد، تأثیر بالقوه چرخش به میزان قابل توجهی کاهش می‌یابد. اما اگر <em>credential</em> (اعتبارنامه) استفاده گسترده‌ای داشته باشد، فهمیدن تأثیر یک تغییر می‌تواند دشوار باشد. این به این دلیل نیست که شما را از چرخش منصرف کنم، بلکه فقط به این دلیل است که شما را از خطرات احتمالی آگاه کنم، و من همچنان متقاعد شده‌ام که این کار درستی است. معقول‌ترین راه پیش رو احتمالاً اتخاذ <em>tooling</em> (ابزارسازی) برای کمک به خودکارسازی این فرآیند و در عین حال محدود کردن دامنه هر مجموعه از <em>credentials</em> (اعتبارنامه‌ها) در همان زمان خواهد بود.</p>
    <h5>Revocation (لغو)</h5>
    <p>داشتن یک سیاست برای اطمینان از اینکه <em>key credentials</em> (اعتبارنامه‌های کلیدی) به طور منظم چرخیده می‌شوند، می‌تواند راهی منطقی برای محدود کردن تأثیر نشت <em>credential</em> (اعتبارنامه) باشد، اما اگر می‌دانید که یک <em>credential</em> (اعتبارنامه) معین به دست افراد اشتباه افتاده است، چه اتفاقی می‌افتد؟ آیا شما باید منتظر بمانید تا چرخش برنامه‌ریزی‌شده برای آن <em>credential</em> (اعتبارنامه) اجرا شود تا دیگر معتبر نباشد؟ این ممکن است عملی یا منطقی نباشد. در عوض، در حالت ایده‌آل، شما می‌خواهید بتوانید <em>credentials</em> (اعتبارنامه‌ها) را به طور خودکار لغو و احتمالاً بازسازی کنید، هنگامی که چیزی مانند این اتفاق می‌افتد.</p>
    <p>استفاده از ابزارهایی که امکان مدیریت متمرکز <em>secrets</em> (رازها) را فراهم می‌کنند، می‌تواند در اینجا کمک کند، اما این ممکن است مستلزم آن باشد که <em>microservices</em> (ریز سرویس‌های) شما قادر به خواندن مقادیر تازه تولید شده باشند. اگر <em>microservice</em> (ریز سرویس) شما مستقیماً <em>secrets</em> (رازها) را از چیزی مانند انبار <em>Kubernetes secrets</em> (رازهای کوبرنتیس) یا <em>Vault</em> می‌خواند، می‌تواند زمانی که این مقادیر تغییر کرده‌اند، مطلع شود، و به <em>microservice</em> (ریز سرویس) شما اجازه می‌دهد تا از مقادیر تغییر یافته استفاده کند. از طرف دیگر، اگر <em>microservice</em> (ریز سرویس) شما این <em>secrets</em> (رازها) را فقط در هنگام راه‌اندازی می‌خواند، در این صورت ممکن است نیاز داشته باشید که یک راه‌اندازی مجدد چرخشی از سیستم خود انجام دهید تا این <em>credentials</em> (اعتبارنامه‌ها) را دوباره بارگذاری کنید. اگر شما به طور منظم <em>credentials</em> (اعتبارنامه‌ها) را می‌چرخانید، احتمالاً قبلاً مجبور شده‌اید مشکل اینکه <em>microservices</em> (ریز سرویس‌های) شما بتوانند این اطلاعات را دوباره بخوانند را حل کنید. اگر شما با چرخش منظم <em>credentials</em> (اعتبارنامه‌ها) راحت هستید، احتمالاً از قبل برای رسیدگی به لغو اضطراری نیز تنظیم شده‌اید.</p>
    <h5>Scanning for Keys (اسکن برای کلیدها)</h5>
    <p><em>Accidentally checking in private keys</em> (به‌طور تصادفی وارد کردن کلیدهای خصوصی) به <em>source code repositories</em> (مخازن کد منبع) یک راه رایج برای نشت <em>credentials</em> (اعتبارنامه‌ها) به افراد غیرمجاز است—این اتفاق به طرز شگفت‌انگیزی رخ می‌دهد. <em>GitHub</em> به طور خودکار مخازن را برای برخی از انواع <em>secrets</em> (رازها) اسکن می‌کند، اما شما همچنین می‌توانید اسکن خود را نیز اجرا کنید. اگر بتوانید <em>secrets</em> (رازها) را قبل از <em>check in</em> (چک این) شناسایی کنید، عالی خواهد بود، و <em>git-secrets</em> به شما این امکان را می‌دهد. این می‌تواند <em>commits</em> (کامیت‌های) موجود را برای <em>secrets</em> (رازهای) احتمالی اسکن کند، اما با تنظیم آن به عنوان یک <em>commit hook</em> (هوک کامیت)، می‌تواند حتی از انجام <em>commits</em> (کامیت‌ها) جلوگیری کند. همچنین <em>gitleaks</em> مشابه وجود دارد، که علاوه بر پشتیبانی از <em>pre-commit hooks</em> (هوک‌های قبل از کامیت) و اسکن عمومی <em>commits</em> (کامیت‌ها)، دارای چند ویژگی است که آن را به طور بالقوه به عنوان یک ابزار عمومی‌تر برای اسکن فایل‌های محلی، مفیدتر می‌کند.</p>
    <p><em>358 | Chapter 11: Security</em></p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>