<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 349</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        این موضوع اساساً به <strong>metric</strong> برمی‌گردد. <strong>Metric</strong> یک نقطه از داده است، یک عدد واحد با یک نام و برخی از برچسب‌های شناسایی‌کننده. تمام زمینه‌ای که می‌توانید دریافت کنید باید در آن برچسب‌ها وارد شود. اما انفجار نوشتن همه آن برچسب‌ها به دلیل نحوه ذخیره <strong>metrics</strong> در دیسک، پرهزینه است. ذخیره یک <strong>metric</strong> بسیار ارزان است، اما ذخیره یک برچسب گران است. و ذخیره تعداد زیادی از برچسب‌ها در هر <strong>metric</strong> باعث توقف سریع موتور ذخیره‌سازی شما می‌شود.
    </p>
    <p>
        از نظر عملی، سیستم‌هایی که با در نظر گرفتن <strong>low cardinality</strong> ساخته شده‌اند، اگر سعی کنید داده‌های <strong>high-cardinality</strong> بیشتری را در آنها قرار دهید، با مشکل زیادی مواجه خواهند شد. به عنوان مثال، سیستم‌هایی مانند <strong>Prometheus</strong>، برای ذخیره قطعات نسبتاً ساده‌ای از اطلاعات، مانند نرخ <strong>CPU</strong> برای یک دستگاه داده شده، ساخته شده‌اند. از بسیاری جهات، ما می‌توانیم <strong>Prometheus</strong> و ابزارهای مشابه را به عنوان یک پیاده‌سازی عالی از ذخیره‌سازی و پرس‌وجوی <strong>metrics</strong> سنتی ببینیم. اما عدم توانایی در پشتیبانی از داده‌های با <strong>high-cardinality</strong> می‌تواند یک عامل محدودکننده باشد. توسعه‌دهندگان <strong>Prometheus</strong> در مورد این محدودیت کاملاً باز هستند:
    </p>
    <p>
        به یاد داشته باشید که هر ترکیب منحصربه‌فرد از جفت‌های برچسب کلید-مقدار نشان‌دهنده یک سری زمانی جدید است، که می‌تواند مقدار داده ذخیره‌شده را به طرز چشمگیری افزایش دهد. از برچسب‌ها برای ذخیره ابعاد با <strong>high cardinality</strong> (بسیاری از مقادیر برچسب مختلف)، مانند <strong>user ID</strong>ها، آدرس‌های ایمیل، یا سایر مجموعه‌های نامحدود از مقادیر استفاده نکنید.
    </p>
    <p>
        سیستم‌هایی که قادر به رسیدگی به <strong>high cardinality</strong> هستند، بیشتر می‌توانند به شما اجازه دهند که تعداد زیادی سؤال مختلف را از سیستم‌های خود بپرسید—اغلب سؤالاتی که قبلاً نمی‌دانستید که باید بپرسید. اکنون، این ممکن است یک مفهوم دشوار برای درک باشد، به‌ویژه اگر شما سیستم <strong>monolithic</strong> تک‌فرآیندی خود را با ابزارهای "متعارف‌تر" کاملاً مدیریت می‌کنید. حتی افرادی که سیستم‌های بزرگ‌تری دارند با سیستم‌های با <strong>low-cardinality</strong> کنار آمده‌اند، اغلب به این دلیل که چاره‌ای نداشتند. اما با افزایش پیچیدگی سیستم شما، شما نیاز خواهید داشت که کیفیت خروجی‌هایی را که سیستم شما ارائه می‌دهد، برای بهبود <strong>observability</strong> آن بهبود بخشید. این به معنای جمع‌آوری اطلاعات بیشتر و داشتن ابزارهایی است که به شما اجازه می‌دهد این داده‌ها را برش و تقسیم کنید.
    </p>
    <h4>Implementations</h4>
    <p>
        از زمان چاپ اول این کتاب، <strong>Prometheus</strong> به یک ابزار <strong>open source</strong> محبوب برای استفاده از جمع‌آوری و تجمیع <strong>metrics</strong> تبدیل شده است، و در مواردی که من قبلاً ممکن بود استفاده از <strong>Graphite</strong> را توصیه کنم (که در چاپ اول توصیه‌ام را دریافت کرد)، <strong>Prometheus</strong> می‌تواند جایگزینی معقول باشد. فضای تجاری نیز در این زمینه بسیار گسترش یافته است، و فروشندگان جدید و فروشندگان قدیمی به طور یکسان در حال ساخت یا بازسازی راه‌حل‌های موجود برای هدف قرار دادن کاربران <strong>microservice</strong> هستند.
    </p>
    <p>
        با این حال، نگرانی‌های من در مورد داده‌های با <strong>low-</strong> در مقابل <strong>high-cardinality</strong> را در نظر داشته باشید. سیستم‌هایی که برای مدیریت داده‌های با <strong>low-cardinality</strong> ساخته شده‌اند، بازسازی آنها برای پشتیبانی از ذخیره‌سازی و پردازش <strong>high-cardinality</strong> بسیار دشوار خواهد بود. اگر شما به دنبال سیستم‌هایی هستید که قادر به ذخیره و مدیریت داده‌های با <strong>high cardinality</strong> هستند، که امکان مشاهده (و پرسش) بسیار پیچیده‌تری از رفتار سیستم شما را فراهم می‌کنند، من قویاً پیشنهاد می‌کنم به <strong>Honeycomb</strong> یا <strong>Lightstep</strong> نگاه کنید. اگرچه این ابزارها اغلب به عنوان راه‌حل‌هایی برای...
    </p>
    <p>
        Building Blocks for Observability | 323
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>