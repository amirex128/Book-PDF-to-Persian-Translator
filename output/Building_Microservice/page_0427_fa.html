<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 427</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p><em>Separation of concerns</em> (تفکیک وظایف) همچنین می‌تواند راهی برای پیاده‌سازی <em>bulkheads</em> (دیواره‌ها) باشد. با جدا کردن عملکرد به <em>microservices</em> (ریز سرویس‌های) جداگانه، ما شانس تأثیر یک قطعی در یک حوزه بر حوزه دیگر را کاهش می‌دهیم.</p>
    <p>به تمام جنبه‌های سیستم خود که می‌توانند اشتباه پیش بروند، چه در داخل <em>microservices</em> (ریز سرویس‌های) شما و چه بین آنها، نگاه کنید. آیا شما <em>bulkheads</em> (دیواره‌ها) را در جای خود دارید؟ من پیشنهاد می‌کنم که حداقل با استخرهای اتصال جداگانه برای هر اتصال پایین‌دستی شروع کنید. با این حال، شما ممکن است بخواهید جلوتر بروید، و استفاده از <em>circuit breakers</em> (مدارشکن‌ها) را نیز در نظر بگیرید، که ما در یک لحظه به آن خواهیم پرداخت.</p>
    <p>از بسیاری جهات، <em>bulkheads</em> (دیواره‌ها) مهم‌ترین الگوهایی هستند که ما تاکنون به آنها نگاه کرده‌ایم. <em>Time-outs</em> (مهلت زمانی) و <em>circuit breakers</em> (مدارشکن‌ها) به شما کمک می‌کنند تا منابع را در زمانی که در حال محدود شدن هستند، آزاد کنید، اما <em>bulkheads</em> (دیواره‌ها) می‌توانند اطمینان حاصل کنند که آنها در وهله اول محدود نمی‌شوند. آنها همچنین می‌توانند به شما این امکان را بدهند که درخواست‌ها را در شرایط خاص رد کنید تا اطمینان حاصل شود که منابع حتی بیشتر اشباع نمی‌شوند؛ این امر به عنوان <em>load shedding</em> (ریزش بار) شناخته می‌شود. گاهی اوقات رد یک <em>request</em> (درخواست) بهترین راه برای جلوگیری از تحت فشار قرار گرفتن یک سیستم مهم و تبدیل شدن به یک گلوگاه برای چندین <em>service</em> (سرویس) بالادستی است.</p>
    <h5>Circuit Breakers (مدارشکن‌ها)</h5>
    <p>در خانه‌ خود، <em>circuit breakers</em> (مدارشکن‌ها) وجود دارند تا از دستگاه‌های الکتریکی شما در برابر <em>spikes</em> (افزایش ناگهانی) در توان، محافظت کنند. اگر یک <em>spike</em> (افزایش ناگهانی) رخ دهد، <em>circuit breaker</em> (مدارشکن) منفجر می‌شود، و از وسایل برقی گران‌قیمت خانگی شما محافظت می‌کند. شما همچنین می‌توانید به‌صورت دستی یک <em>circuit breaker</em> (مدارشکن) را غیرفعال کنید تا برق را به بخشی از خانه خود قطع کنید، و به شما اجازه می‌دهد تا با خیال راحت روی سیستم الکتریکی کار کنید. در الگوی دیگری از <em>Release It!</em>، <em>Nygard</em> نشان می‌دهد که چگونه همین ایده می‌تواند به عنوان یک مکانیسم حفاظتی برای نرم‌افزار ما شگفتی ایجاد کند.</p>
    <p>ما می‌توانیم به <em>circuit breakers</em> (مدارشکن‌ها) خود به عنوان یک مکانیسم خودکار برای مهر و موم کردن یک <em>bulkhead</em> (دیواره) فکر کنیم، نه تنها برای محافظت از مصرف‌کننده در برابر مشکل پایین‌دستی بلکه همچنین به‌طور بالقوه برای محافظت از <em>service</em> (سرویس) پایین‌دستی از تماس‌های بیشتری که ممکن است تأثیر نامطلوبی داشته باشند. با توجه به خطرات شکست آبشاری، من توصیه می‌کنم که <em>circuit breakers</em> (مدارشکن‌ها) را برای تمام فراخوانی‌های همزمان پایین‌دستی خود اجباری کنید. شما مجبور نیستید مال خود را بنویسید—در سال‌هایی که از زمان نوشتن ویرایش اول این کتاب گذشته است، پیاده‌سازی‌های <em>circuit breaker</em> (مدارشکن) به‌طور گسترده در دسترس قرار گرفته‌اند.</p>
    <p>با بازگشت به <em>AdvertCorp</em>، مشکل را که با سیستم شلغم داشتیم در نظر بگیرید، که قبل از اینکه در نهایت یک خطا برگرداند، بسیار کند پاسخ می‌داد. حتی اگر ما <em>time-outs</em> (مهلت زمانی) را درست دریافت کرده بودیم، ما زمان زیادی را منتظر می‌ماندیم قبل از اینکه خطا را دریافت کنیم. و سپس ما دوباره در <em>request</em> (درخواست) بعدی تلاش می‌کردیم، و منتظر می‌ماندیم. به اندازه کافی بد بود که <em>service</em> (سرویس) پایین‌دستی از کار افتاده بود، اما کل سیستم را نیز کند می‌کرد.</p>
    <p>با یک <em>circuit breaker</em> (مدارشکن)، پس از اینکه تعداد مشخصی از <em>requests</em> (درخواست‌ها) به منبع پایین‌دستی شکست خوردند (به دلیل خطا یا <em>time-out</em> (مهلت زمانی))، <em>circuit breaker</em> (مدارشکن) منفجر می‌شود. تمام درخواست‌های بیشتر که از آن <em>circuit breaker</em> (مدارشکن) عبور می‌کنند، به سرعت شکست می‌خورند در حالی که <em>breaker</em> (شکن) در وضعیت</p>
    <p><em>Stability Patterns | 401</em></p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>