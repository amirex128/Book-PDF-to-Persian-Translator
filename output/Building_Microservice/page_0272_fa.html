<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 272</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>داکر</h4>
  <p>
   کانتینرها قبل از ظهور <span style="color:blue">Docker</span> که مفهوم را به جلو برد، استفاده محدودی داشتند
   اصلی <span style="color:blue">.</span> زنجیره ابزار <span style="color:blue">Docker</span> بسیاری از کارهای اطراف کانتینرها را مدیریت می کند.
   <span style="color:blue">Docker</span> مدیریت تهیه کانتینر، برخی از مشکلات شبکه را برای شما مدیریت می کند، و حتی ارائه می دهد
   مفهوم رجیستری خود که به شما امکان می دهد برنامه های <span style="color:blue">Docker</span> را ذخیره کنید. قبل از <span style="color:blue">Docker</span>، ما مفهوم "تصویر" را نداشتیم.
   برای کانتینرها - این جنبه، همراه با مجموعه بسیار زیباتری از ابزارها برای کار با
   کانتینرها، به آسان‌تر شدن استفاده از کانتینرها کمک کرد.
  </p>
  <p>
   انتزاع تصویر <span style="color:blue">Docker</span> برای ما مفید است، زیرا جزئیات نحوه
   <span style="color:blue">microservice</span> پیاده سازی شده پنهان شده است. ما می سازد برای ایجاد <span style="color:blue">microservice</span> ما
   یک تصویر <span style="color:blue">Docker</span> به عنوان یک <span style="color:blue">artifact</span> ساخت و تصویر را در رجیستری <span style="color:blue">Docker</span> ذخیره می کنیم، و دور
   می رویم. هنگامی که شما یک نمونه از یک تصویر <span style="color:blue">Docker</span> را راه اندازی می کنید، مجموعه ای عمومی از
   ابزارها برای مدیریت آن نمونه، صرف نظر از فناوری اساسی مورد استفاده — <span style="color:blue">micro</span>-
   <span style="color:blue">services</span> نوشته شده در <span style="color:blue">Go</span>، <span style="color:blue">Python</span>، <span style="color:blue">NodeJS</span>، یا هر چیز دیگری را می توان یکسان در نظر گرفت.
  </p>
  <p>
   <span style="color:blue">Docker</span> همچنین می تواند برخی از جنبه های منفی اجرای تعداد زیادی سرویس را به صورت محلی کاهش دهد
   برای اهداف توسعه و آزمایش. قبلاً، ممکن بود از ابزاری مانند <span style="color:blue">Vagrant</span> استفاده کنم که اجازه می دهد
   من میزبان ماشین های مجازی مستقل متعدد در دستگاه توسعه خود هستم. این
   به من اجازه می دهد که یک <span style="color:blue">VM</span> شبیه تولید داشته باشم که نمونه های سرویس من را به صورت محلی اجرا می کند. این
   اگرچه رویکردی بسیار سنگین بود، و من در مورد تعداد <span style="color:blue">VM</span> هایی که می توانستم اجرا کنم، محدود می شدم. با <span style="color:blue">Docker</span>، آسان است
   فقط <span style="color:blue">Docker</span> را مستقیماً روی دستگاه توسعه‌دهنده خود اجرا کنید، احتمالاً از <span style="color:blue">Docker Desktop</span> استفاده می‌کنید. اکنون می توانم یک <span style="color:blue">Docker</span> بسازم
   تصویر برای نمونه <span style="color:blue">microservice</span> من، یا یک تصویر از قبل ساخته شده را پایین بکشید و آن را به صورت محلی اجرا کنید. اینها
   تصاویر <span style="color:blue">Docker</span> می توانند (و باید) با تصویر کانتینری که در نهایت اجرا خواهم کرد یکسان باشند
   در تولید
  </p>
  <p>
   وقتی <span style="color:blue">Docker</span> برای اولین بار ظهور کرد، دامنه آن به مدیریت کانتینرها در یک مورد محدود شد
   ماشین. این استفاده محدودی داشت—اگر می خواهید کانتینرها را در سراسر مدیریت کنید چه؟
   ماشین های متعدد؟ این چیزی است که برای حفظ سلامت سیستم ضروری است، اگر شما دارید
   یک دستگاه از بین می رود، یا اگر فقط می خواهید کانتینرهای کافی را اجرا کنید تا
   بار سیستم را مدیریت کنید. <span style="color:blue">Docker</span> با دو محصول کاملاً متفاوت از خود بیرون آمد
   برای حل این مشکل، که به طرز گیج کننده ای " <span style="color:blue">Docker Swarm</span> " و " <span style="color:blue">Docker Swarm</span> " نامیده می شود
   حالت" - چه کسی دوباره گفت نامگذاری سخت است؟ واقعاً، اگر به آن برسیم
   مدیریت تعداد زیادی کانتینر در سراسر ماشین های زیاد، <span style="color:blue">Kubernetes</span> در اینجا پادشاه است، حتی
   اگر ممکن است از زنجیره ابزار <span style="color:blue">Docker</span> برای ساخت و مدیریت فردی استفاده کنید
   کانتینرها
  </p>
  <h4>تناسب برای <span style="color:blue">microservice</span> ها</h4>
  <p>
   کانتینرها به عنوان یک مفهوم برای <span style="color:blue">microservice</span> ها به خوبی کار می کنند و <span style="color:blue">Docker</span> ساخت
   کانتینرها را به طور قابل توجهی به عنوان یک مفهوم بیشتر امکان پذیر کرد. ما انزوا خود را دریافت می کنیم اما در یک <span style="color:blue">man</span>-
   هزینه <span style="color:blue">ageable</span>. ما همچنین فناوری اساسی را پنهان می کنیم و به ما اجازه می دهد تا فناوری های مختلف را ترکیب کنیم
  </p>
  <p>
   گزینه های استقرار
   |
   246
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>