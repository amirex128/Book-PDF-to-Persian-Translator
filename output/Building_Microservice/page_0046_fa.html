<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 46</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   که نمی‌دانستید در وهله اول می‌خواهید بپرسید. ابزارهای <strong>open source</strong> می‌توانند برخی از این ویژگی‌ها را ارائه دهند. یک مثال <strong>Jaeger</strong> است که بر جنبه <strong>distributed tracing</strong> معادله متمرکز است.
  </p>
  <p>
   اما محصولاتی مانند <strong>Lightstep</strong> و <strong>Honeycomb</strong> (که در شکل 1-9 نشان داده شده است) این ایده‌ها را بیشتر پیش می‌برند. آنها نشان‌دهنده نسل جدیدی از ابزارها هستند که فراتر از رویکردهای نظارت سنتی می‌روند و کاوش در وضعیت سیستم در حال اجرا را بسیار آسان‌تر می‌کنند.
  </p>
  <p>
   شما ممکن است در حال حاضر ابزارهای متعارف‌تری در اختیار داشته باشید، اما واقعاً باید به قابلیت‌هایی که این محصولات ارائه می‌دهند نگاه کنید. آنها از ابتدا برای حل انواع مشکلاتی که <strong>operators</strong> معماری‌های microservice باید با آنها سروکار داشته باشند، ساخته شده‌اند.
  </p>
  <p>
   شکل 1-9. یک <strong>distributed trace</strong> که در <strong>Honeycomb</strong> نشان داده شده است، به شما امکان می‌دهد تا مشخص کنید که زمان برای عملیات‌هایی که می‌توانند چندین microservices را در بر گیرند، کجا صرف می‌شود
  </p>
  <h4>Containers و Kubernetes</h4>
  <p>
   در حالت ایده‌آل، شما می‌خواهید هر نمونه microservice را در انزوا اجرا کنید. این تضمین می‌کند که مشکلات در یک microservice نمی‌تواند بر microservice دیگری تأثیر بگذارد—به عنوان مثال، با بلعیدن تمام <strong>CPU</strong>. <strong>Virtualization</strong> یک راه برای ایجاد محیط‌های اجرایی ایزوله شده بر روی سخت‌افزار موجود است، اما تکنیک‌های مجازی‌سازی معمولی می‌توانند زمانی که اندازه microservicesهایمان را در نظر می‌گیریم، بسیار سنگین باشند. از طرف دیگر، <strong>Containers</strong> یک راه بسیار سبک‌تر برای تهیه اجرای ایزوله برای نمونه‌های <strong>service</strong> ارائه می‌دهند که منجر به زمان راه‌اندازی سریع‌تر برای نمونه‌های <strong>container</strong> جدید، و همچنین مقرون به صرفه‌تر برای بسیاری از معماری‌ها می‌شود.
  </p>
  <p>20 | Chapter 1: What Are Microservices?</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0046/image_1.png" alt="Image from page 46" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>