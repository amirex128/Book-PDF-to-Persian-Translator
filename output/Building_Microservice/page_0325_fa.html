<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 325</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        تست‌های <strong>smoke</strong> معمولاً ایمن هستند، زیرا عملیاتی که انجام می‌دهند اغلب بر روی نرم‌افزار قبل از انتشار آن انجام می‌شود. همانطور که در "جدا کردن استقرار از انتشار" در صفحه 270 بررسی کردیم، جدا کردن مفهوم استقرار از انتشار می‌تواند فوق‌العاده مفید باشد. وقتی صحبت از تست در <strong>production</strong> می‌شود، تست‌هایی که بر روی نرم‌افزاری که در <strong>production</strong> مستقر شده است، قبل از انتشار آن انجام می‌شود، باید ایمن باشند.
    </p>
    <p>
        مردم تمایل دارند که بیشتر نگران ایمنی چیزهایی مانند تزریق رفتار کاربر جعلی به سیستم باشند. ما واقعاً نمی‌خواهیم سفارش ارسال شود یا پرداخت انجام شود. این چیزی است که نیاز به مراقبت و توجه دارد، و علیرغم چالش‌ها، این نوع تست می‌تواند بسیار مفید باشد. ما در "نظارت معنایی" در صفحه 333 به این موضوع باز خواهیم گشت.
    </p>
    <h4>Mean Time to Repair over Mean Time Between Failures?</h4>
    <p>
        بنابراین با نگاهی به تکنیک‌هایی مانند <strong>blue-green deployment</strong> یا <strong>canary releasing</strong>، ما راهی برای تست نزدیک‌تر به (یا حتی در) <strong>production</strong> پیدا می‌کنیم، و همچنین ابزارهایی را برای کمک به مدیریت یک شکست در صورت وقوع ایجاد می‌کنیم. استفاده از این رویکردها، اذعان ضمنی به این است که ما نمی‌توانیم همه مشکلات را قبل از اینکه نرم‌افزار خود را واقعاً منتشر کنیم، شناسایی و برطرف کنیم.
    </p>
    <p>
        گاهی اوقات صرف تلاش یکسان برای بهتر شدن در رفع مشکلات در هنگام وقوع، می‌تواند به طور قابل توجهی مفیدتر از افزودن تست‌های <strong>functional</strong> خودکار بیشتر باشد. در دنیای عملیات وب، این اغلب به عنوان <strong>trade-off</strong> بین بهینه‌سازی برای میانگین زمان بین شکست‌ها (<strong>MTBF</strong>) و بهینه‌سازی برای میانگین زمان تعمیر (<strong>MTTR</strong>) نامیده می‌شود.
    </p>
    <p>
        تکنیک‌هایی برای کاهش زمان بازیابی می‌تواند به سادگی بازگشت‌های بسیار سریع همراه با نظارت خوب باشد (که ما در فصل 10 در مورد آن بحث خواهیم کرد). اگر بتوانیم یک مشکل را در <strong>production</strong> زود شناسایی کنیم و زودتر <strong>roll back</strong> کنیم، تأثیر آن بر مشتریان خود را کاهش می‌دهیم.
    </p>
    <p>
        برای سازمان‌های مختلف، <strong>trade-off</strong> بین <strong>MTBF</strong> و <strong>MTTR</strong> متفاوت خواهد بود، و بخش زیادی از این موضوع به درک تأثیر واقعی شکست در یک محیط <strong>production</strong> بستگی دارد. با این حال، اکثر سازمان‌هایی که من می‌بینم وقت خود را صرف ایجاد <strong>test suites functional</strong> می‌کنند، اغلب تلاش کمی برای نظارت بهتر یا بازیابی از شکست انجام می‌دهند. بنابراین در حالی که آنها ممکن است تعداد نقص‌هایی را که در وهله اول رخ می‌دهند کاهش دهند، نمی‌توانند همه آنها را از بین ببرند، و برای مقابله با آنها در صورت ظاهر شدن در <strong>production</strong> آماده نیستند.
    </p>
    <p>
        <strong>Trade-offs</strong> دیگری غیر از آنهایی که بین <strong>MTBF</strong> و <strong>MTTR</strong> وجود دارد. به عنوان مثال، چه بخواهید بفهمید که آیا کسی واقعاً از نرم‌افزار شما استفاده می‌کند یا خیر، ممکن است منطقی‌تر باشد که در حال حاضر چیزی را منتشر کنید، تا قبل از ساخت نرم‌افزار قوی، ایده یا مدل کسب‌وکار را اثبات کنید. در محیطی که اینطور است، تست ممکن است بیش از حد باشد، زیرا تأثیر ندانستن اینکه آیا ایده شما کار می‌کند یا خیر، بسیار بیشتر از داشتن یک نقص در <strong>production</strong> است. در این شرایط، اجتناب از تست قبل از <strong>production</strong> به طور کلی می‌تواند کاملاً منطقی باشد.
    </p>
    <p>
        From Preproduction to In-Production Testing | 299
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>