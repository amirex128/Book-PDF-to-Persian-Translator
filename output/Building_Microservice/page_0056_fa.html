<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 56</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>Testing</h4>
  <p>
   با هر نوع <strong>automated functional test</strong>، شما یک عمل متعادل‌سازی ظریف دارید. هر چه <strong>functionality</strong> بیشتری را یک <strong>test</strong> اجرا کند—یعنی، دامنه <strong>test</strong> گسترده‌تر باشد—شما اعتماد بیشتری به برنامه خود دارید. از سوی دیگر، هر چه دامنه <strong>test</strong> بزرگتر باشد، راه‌اندازی داده‌های <strong>test</strong> و <strong>supporting fixtures</strong> سخت‌تر است، اجرای <strong>test</strong> بیشتر طول می‌کشد، و مشخص کردن اینکه چه چیزی در صورت شکست خراب می‌شود، دشوارتر است. در فصل 9 من تعدادی از تکنیک‌ها را برای کارآمد کردن <strong>testing</strong> در این محیط چالش‌برانگیزتر به اشتراک خواهم گذاشت.
  </p>
  <p>
   <strong>End-to-end tests</strong> برای هر نوع سیستم در انتهای مقیاس از نظر <strong>functionality</strong> که پوشش می‌دهند، قرار دارند، و ما عادت کرده‌ایم که نوشتن و نگهداری آنها نسبت به <strong>unit tests</strong> با دامنه کوچکتر، مشکل‌سازتر باشد. اگرچه اغلب این ارزش دارد، زیرا ما می‌خواهیم به اعتمادی که از داشتن یک <strong>end-to-end test</strong> که از سیستم‌های ما به همان روشی که یک کاربر ممکن است استفاده کند، دست یابیم.
  </p>
  <p>
   اما با یک معماری microservice، دامنه <strong>end-to-end tests</strong> ما بسیار بزرگ می‌شود. اکنون باید <strong>tests</strong> را در چندین <strong>process</strong> اجرا کنیم، که همه آنها باید مستقر شوند و برای سناریوهای <strong>test</strong> به‌درستی پیکربندی شوند. ما همچنین باید برای <strong>false negatives</strong> که زمانی رخ می‌دهند که مسائل محیطی، مانند از بین رفتن نمونه‌های <strong>service</strong> یا <strong>network time-outs</strong> استقرار ناموفق، باعث شکست <strong>tests</strong> ما می‌شوند، آماده باشیم.
  </p>
  <p>
   این نیروها به این معنی است که با رشد معماری microservice شما، بازده سرمایه‌گذاری <em>(ROI)</em> کاهشی در مورد <strong>end-to-end testing</strong> دریافت خواهید کرد. <strong>Testing</strong> هزینه بیشتری خواهد داشت اما قادر نخواهد بود همان سطح اطمینان را که در گذشته داشت، به شما بدهد. این شما را به سمت اشکال جدیدی از <strong>testing</strong> سوق می‌دهد، مانند <strong>contract-driven testing</strong> یا <strong>testing in production</strong>، و همچنین بررسی تکنیک‌های <strong>progressive delivery</strong> مانند اجراهای موازی یا <strong>canary releases</strong>، که در فصل 8 به آنها خواهیم پرداخت.
  </p>
  <h4>Latency</h4>
  <p>
   با یک معماری microservice، پردازشی که قبلاً ممکن بود به صورت محلی بر روی یک پردازنده انجام شود، اکنون می‌تواند در چندین microservice جداگانه تقسیم شود. اطلاعاتی که قبلاً فقط در یک <strong>process</strong> واحد جریان داشت، اکنون باید <strong>serialized</strong>، منتقل و <strong>deserialized</strong> از طریق شبکه‌هایی شوند که ممکن است بیشتر از همیشه از آنها استفاده کنید. همه اینها می‌تواند منجر به بدتر شدن <strong>latency</strong> سیستم شما شود.
  </p>
  <p>
   اگرچه اندازه‌گیری تأثیر دقیق بر <strong>latency</strong> عملیات در مرحله طراحی یا کدنویسی می‌تواند دشوار باشد، این یکی دیگر از دلایلی است که انجام هر گونه مهاجرت microservice به روشی افزایشی مهم است. یک تغییر کوچک ایجاد کنید و سپس تأثیر آن را اندازه‌گیری کنید. این فرض می‌کند که شما به نوعی اندازه‌گیری <strong>end-to-end latency</strong> برای عملیاتی که به آنها اهمیت می‌دهید دارید—ابزارهای <strong>distributed tracing</strong> مانند <strong>Jaeger</strong> می‌توانند در اینجا کمک کنند. اما شما همچنین باید درک کنید که <strong>latency</strong> چیست
  </p>
  <p>30 | Chapter 1: What Are Microservices?</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>