<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 362</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>مزیت مقیاس‌بندی تدریجی یا اجرای سیستم برای چند ماه برای درک اینکه "خوب" از نظر معیارهای سطح پایین مانند نرخ <em>CPU</em> (پردازنده) یا زمان پاسخ، چگونه به نظر می‌رسید.</p>
    <p>رویکرد ما این بود که رویدادهای جعلی تولید کنیم تا بخشی از سبد سهام را که در سیستم‌های پایین‌دستی ثبت نشده بود، قیمت‌گذاری کنیم. تقریباً هر دقیقه، ما از ابزاری به نام <em>Nagios</em> برای اجرای یک <em>command-line job</em> (شغل خط فرمان) استفاده می‌کردیم که یک رویداد جعلی را به یکی از <em>queues</em> (صف)های ما وارد می‌کرد. سیستم ما آن را دریافت و تمام محاسبات مختلف را درست مانند هر شغل دیگری اجرا می‌کرد، با این تفاوت که نتایج در دفتر "<em>junk</em>" ظاهر می‌شد، که فقط برای تست استفاده می‌شد. اگر یک <em>repricing</em> (قیمت‌گذاری مجدد) در یک زمان معین مشاهده نمی‌شد، <em>Nagios</em> این را به عنوان یک مشکل گزارش می‌داد.</p>
    <p>در عمل، من استفاده از <em>synthetic transactions</em> (تراکنش‌های مصنوعی) برای انجام <em>semantic monitoring</em> (پایش معنایی) مانند این را یک شاخص بسیار بهتر از مشکلات در سیستم‌ها نسبت به هشدار دادن در مورد معیارهای سطح پایین‌تر، یافته‌ام. با این حال، آنها جایگزین نیاز به جزئیات سطح پایین‌تر نمی‌شوند—ما هنوز هم زمانی که نیاز به یافتن دلیل شکست یک <em>synthetic transaction</em> داریم، به آن اطلاعات نیاز خواهیم داشت.</p>
    <p><em>Implementing synthetic transactions</em> (پیاده‌سازی تراکنش‌های مصنوعی). در گذشته، پیاده‌سازی <em>synthetic transactions</em> یک کار نسبتاً دلهره‌آوری بود. اما جهان به جلو رفته است و ابزارهای پیاده‌سازی آنها در دسترس ماست! شما در حال انجام تست برای سیستم‌های خود هستید، درست است؟ اگر نه، فصل 9 را بخوانید و برگردید. همه کارها انجام شد؟ خوب!</p>
    <p>اگر به تست‌هایی نگاه کنیم که یک <em>service</em> (سرویس) معین را سرتاسر یا حتی کل سیستم خود را سرتاسر تست می‌کنند، ما بسیاری از آنچه برای پیاده‌سازی <em>semantic monitoring</em> نیاز داریم، در اختیار داریم. سیستم ما در حال حاضر <em>hooks</em> (قلاب‌هایی) را که برای راه‌اندازی تست و بررسی نتیجه مورد نیاز است، در معرض نمایش قرار می‌دهد. پس چرا فقط زیرمجموعه‌ای از این تست‌ها را، به طور مداوم، به عنوان راهی برای پایش سیستم خود اجرا نکنیم؟</p>
    <p>البته، کارهایی وجود دارد که باید انجام دهیم. اول، باید در مورد الزامات داده‌های تست‌هایمان محتاط باشیم. ممکن است لازم باشد راهی برای انطباق تست‌هایمان با داده‌های زنده مختلف، در صورت تغییر آنها در طول زمان، پیدا کنیم، یا منبع داده متفاوتی را تنظیم کنیم. به عنوان مثال، می‌توانیم مجموعه‌ای از کاربران جعلی داشته باشیم که در تولید با مجموعه داده‌های شناخته شده از آنها استفاده می‌کنیم.</p>
    <p>به همین ترتیب، ما باید اطمینان حاصل کنیم که به طور تصادفی، اثرات جانبی پیش‌بینی نشده را فعال نمی‌کنیم. یک دوست برای من داستانی در مورد یک شرکت <em>ecommerce</em> (تجارت الکترونیک) تعریف کرد که به طور تصادفی تست‌های خود را در برابر سیستم‌های سفارش‌دهی تولید خود اجرا کرد. آنها اشتباه خود را متوجه نشدند تا زمانی که تعداد زیادی ماشین لباسشویی به دفتر مرکزی رسید.</p>
    <h5>A/B testing (تست A/B)</h5>
    <p>با یک تست <em>A/B</em>، شما دو نسخه مختلف از یک عملکرد را مستقر می‌کنید، به طوری که کاربران یا عملکرد "A" یا "B" را می‌بینند. سپس می‌توانید ببینید کدام نسخه از عملکرد بهترین عملکرد را دارد. این معمولاً هنگام تلاش برای تصمیم‌گیری بین دو رویکرد مختلف برای چگونگی انجام یک کار استفاده می‌شود—به عنوان مثال، ممکن است دو فرم ثبت‌نام مشتری مختلف را امتحان کنید تا ببینید کدام یک در جذب ثبت‌نام‌ها مؤثرتر است.</p>
    <p><em>336 | Chapter 10: From Monitoring to Observability</em></p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>