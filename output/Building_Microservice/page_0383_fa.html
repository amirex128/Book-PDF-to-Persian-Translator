<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 383</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p><em>platforms</em> (پلتفرم‌ها). <em>Vault</em> این مزیت را دارد که ابزار <em>consul-template</em> پشتیبان‌کننده می‌تواند به صورت پویا <em>secrets</em> (رازها) را در یک فایل پیکربندی معمولی به‌روزرسانی کند. این بدان معناست که بخش‌هایی از سیستم شما که می‌خواهند <em>secrets</em> (رازها) را از یک فایل سیستم محلی بخوانند، نیازی به تغییر برای پشتیبانی از ابزار مدیریت <em>secrets</em> (رازها) ندارند. هنگامی که یک <em>secret</em> (راز) در <em>Vault</em> تغییر می‌کند، <em>consul-template</em> می‌تواند این ورودی را در فایل پیکربندی به‌روزرسانی کند، و به <em>microservices</em> (ریز سرویس‌های) شما اجازه می‌دهد <em>secrets</em> (رازهایی) را که استفاده می‌کنند، به‌طور پویا تغییر دهند. این برای مدیریت <em>credentials</em> (اعتبارنامه‌ها) در مقیاس عالی است.</p>
    <p>برخی از ارائه دهندگان <em>cloud</em> (ابری) عمومی نیز راه‌حل‌هایی را در این فضا ارائه می‌دهند؛ به عنوان مثال، <em>AWS Secrets Manager</em> یا <em>Azure’s Key Vault</em> به ذهن می‌رسد. با این حال، برخی از افراد از ایده ذخیره اطلاعات <em>secret</em> (راز) حیاتی در یک سرویس <em>cloud</em> (ابری) عمومی مانند این متنفرند. باز هم، این به مدل تهدید شما بستگی دارد. اگر این یک نگرانی جدی است، هیچ چیز شما را از اجرای <em>Vault</em> در ارائه‌دهنده <em>cloud</em> (ابری) مورد نظر خود و رسیدگی به آن سیستم به تنهایی متوقف نمی‌کند. حتی اگر داده‌ها در حالت <em>rest</em> (بیکاری) در ارائه‌دهنده <em>cloud</em> (ابری) ذخیره شوند، با <em>backend</em> (بک‌اند) ذخیره‌سازی مناسب، می‌توانید اطمینان حاصل کنید که داده‌ها به گونه‌ای رمزگذاری شده‌اند که حتی اگر یک شخص خارجی به داده‌ها دسترسی پیدا کند، نمی‌تواند با آن کاری انجام دهد.</p>
    <h5>Rotation (چرخش)</h5>
    <p>در حالت ایده‌آل، ما می‌خواهیم <em>credentials</em> (اعتبارنامه‌ها) را به طور مکرر بچرخانیم تا آسیب‌هایی را که کسی می‌تواند در صورت دسترسی به <em>credentials</em> (اعتبارنامه‌ها) وارد کند، محدود کنیم. اگر یک فرد مخرب به جفت کلید عمومی/خصوصی <em>API</em> شما در <em>AWS</em> دسترسی پیدا کند، اما آن <em>credential</em> (اعتبارنامه) یک بار در هفته تغییر کند، آنها فقط یک هفته فرصت دارند تا از <em>credentials</em> (اعتبارنامه‌ها) استفاده کنند. البته، آنها هنوز هم می‌توانند در یک هفته کارهای زیادی را انجام دهند، اما شما ایده را دریافت می‌کنید. برخی از انواع مهاجمان دوست دارند به سیستم‌ها دسترسی پیدا کنند و سپس شناسایی نشوند، و به آنها اجازه می‌دهند تا داده‌های باارزش‌تری را در طول زمان جمع‌آوری کنند و راه‌هایی برای ورود به سایر قسمت‌های سیستم شما پیدا کنند. اگر آنها از <em>credentials</em> (اعتبارنامه‌های) دزدیده شده برای دسترسی استفاده کردند، اگر <em>credentials</em> (اعتبارنامه‌هایی) که استفاده می‌کنند قبل از اینکه بتوانند از آنها استفاده زیادی بکنند، منقضی شوند، ممکن است بتوانید آنها را متوقف کنید.</p>
    <p>یک مثال عالی از چرخش برای <em>operator credentials</em> (اعتبارنامه‌های اپراتور) ایجاد کلیدهای <em>API</em> محدود به زمان برای استفاده از <em>AWS</em> است. بسیاری از سازمان‌ها اکنون کلیدهای <em>API</em> را برای کارکنان خود به صورت آنی تولید می‌کنند، با این حال جفت کلید عمومی و خصوصی فقط برای مدت زمان کوتاهی—معمولاً کمتر از یک ساعت—معتبر است. این به شما امکان می‌دهد کلیدهای <em>API</em> مورد نیاز برای انجام هر عملیاتی که لازم است، را تولید کنید، با این اطمینان که حتی اگر یک فرد مخرب متعاقباً به این کلیدها دسترسی پیدا کند، نمی‌تواند از آنها استفاده کند. حتی اگر شما به‌طور تصادفی آن جفت کلید را در <em>GitHub</em> عمومی <em>check</em> (چک) کردید، پس از انقضا برای هیچ‌کس فایده‌ای نخواهد داشت.</p>
    <p>استفاده از <em>credentials</em> (اعتبارنامه‌های) محدود به زمان می‌تواند برای سیستم‌ها نیز مفید باشد. <em>Vault Hashicorp’s</em> می‌تواند <em>credentials</em> (اعتبارنامه‌های) محدود به زمان را برای <em>databases</em> (پایگاه‌های داده) تولید کند. به‌جای اینکه نمونه <em>microservice</em> (ریز سرویس) شما جزئیات اتصال <em>database</em> (پایگاه داده) را از یک انبار پیکربندی یا یک فایل متنی بخواند، در عوض می‌توانند در حال پرواز برای یک نمونه خاص از <em>microservice</em> (ریز سرویس) شما ایجاد شوند.</p>
    <p>حرکت به سمت فرآیند چرخش مکرر <em>credentials</em> (اعتبارنامه‌ها) مانند کلیدها می‌تواند دردناک باشد. من با شرکت‌هایی صحبت کرده‌ام که در نتیجه چرخش کلید، حوادثی را تجربه کرده‌اند،</p>
    <p><em>Foundations of Application Security | 357</em></p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>