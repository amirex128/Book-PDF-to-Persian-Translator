<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 266</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>هزینه مجازی سازی</h4>
  <p>
   همانطور که ماشین‌های مجازی بیشتری را روی همان سخت‌افزار اساسی بسته‌بندی می‌کنید،
   متوجه خواهید شد که از نظر منابع محاسباتی، بازدهی کمتری دریافت می‌کنید
   موجود در خود <span style="color:blue">VM</span> ها. چرا اینطور است؟
  </p>
  <p>
   دستگاه فیزیکی خود را به عنوان یک کشوی جوراب در نظر بگیرید. اگر تقسیم‌کننده‌های چوبی زیادی را قرار دهیم
   وارد کشوی ما می شویم، آیا می توانیم جوراب های بیشتری را ذخیره کنیم یا کمتر؟ پاسخ کمتر است: تقسیم کننده ها
   خودشان هم جا می گیرند! ممکن است رسیدگی و سازماندهی کشوی ما آسان‌تر باشد،
   و شاید ما بتوانیم تصمیم بگیریم که اکنون پیراهن‌های تی شرت را در یکی از فضاها قرار دهیم تا اینکه فقط
   جوراب، اما تقسیم‌کننده‌های بیشتر به معنای فضای کلی کمتر است.
  </p>
  <p>
   در دنیای مجازی سازی، ما یک سربار مشابه به عنوان تقسیم کننده های کشوی جوراب خود داریم.
   برای درک منشاء این سربار، بیایید نگاهی به نحوه انجام اکثر مجازی سازی بیندازیم.
   شکل 8-14 مقایسه ای از دو نوع مجازی سازی را نشان می دهد. در سمت چپ،
   ما لایه‌های مختلف درگیر در چیزی به نام مجازی‌سازی نوع 2 را می‌بینیم و در
   در سمت راست ما مجازی سازی مبتنی بر کانتینر را می بینیم، که به زودی بیشتر بررسی خواهیم کرد.
  </p>
  <p>
   مجازی سازی نوع 2 نوعی است که توسط <span style="color:blue">AWS</span>، <span style="color:blue">VMware</span>، <span style="color:blue">vSphere</span>، <span style="color:blue">Xen</span>، و
   <span style="color:blue">KVM</span>. (مجازی سازی نوع 1 به فناوری اشاره دارد که در آن <span style="color:blue">VM</span> ها مستقیماً اجرا می شوند
   سخت افزار، نه در بالای سیستم عامل دیگر.) در زیرساخت فیزیکی ما
   ما یک سیستم عامل میزبان داریم. در این سیستم عامل ما چیزی به نام هایپروایزر را اجرا می کنیم،
   که دو کار کلیدی دارد. اول، منابعی مانند <span style="color:blue">CPU</span> و حافظه را از ویرایش می کند
   میزبان مجازی به میزبان فیزیکی. دوم، به عنوان یک لایه کنترل عمل می کند و به ما اجازه می دهد تا دستکاری کنیم
   خود ماشین های مجازی
  </p>
  <p>
   <strong>شکل 8-14.</strong> مقایسه مجازی سازی استاندارد نوع 2 و کانتینرهای سبک وزن
  </p>
  <p>
   در داخل <span style="color:blue">VM</span> ها، ما آنچه را که شبیه میزبان های کاملاً متفاوت هستند، دریافت می کنیم. آنها می توانند اجرا کنند
   سیستم عامل های خودشان، با هسته های خودشان. آنها تقریباً هرمتیک در نظر گرفته می شوند
   ماشین‌های مهر و موم شده، که توسط هایپروایزر از میزبان فیزیکی اساسی و
   ماشین های مجازی دیگر
  </p>
  <p>
   240
   |
   فصل 8: استقرار
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0266/image_1.png" alt="Image from page 266" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>