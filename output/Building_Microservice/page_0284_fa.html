<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 284</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   <span style="color:blue">more</span> تولیدی. همانطور که در فصل 16 بیشتر بحث خواهیم کرد، نگذارید ترس از
   <span style="color:blue">lock-in</span> شما را در آشفتگی های خودتان به دام اندازد.
  </p>
  <p>
   یک <span style="color:blue">PaaS</span> عالی مانند <span style="color:blue">Heroku</span> یا <span style="color:blue">Zeit</span> پیدا کردید، و برنامه ای دارید که مناسب است
   محدودیت های پلتفرم؟ تمام کار را به پلتفرم منتقل کنید و زمان بیشتری را صرف کنید
   کار کردن روی محصول شما. <span style="color:blue">Heroku</span> و <span style="color:blue">Zeit</span> هر دو پلتفرم بسیار فوق العاده ای با
   قابلیت استفاده عالی از دیدگاه توسعه دهنده. آیا توسعه دهندگان شما سزاوار هستند که
   به هر حال خوشحال باشید؟
  </p>
  <p>
   برای بقیه شما، <span style="color:blue">containerization</span> راهی است که باید بروید، به این معنی که ما باید صحبت کنیم
   درباره <span style="color:blue">Kubernetes</span>.
  </p>
  <h4>نقش <span style="color:blue">Puppet</span>، <span style="color:blue">Chef</span> و سایر ابزارها؟</h4>
  <p>
   این فصل از زمان انتشار نسخه اول به طور قابل توجهی تغییر کرده است. این است
   این تا حدی به دلیل تکامل صنعت به طور کلی، بلکه به فناوری جدیدی نیز بستگی دارد که به طور فزاینده ای
   مفید. ظهور فناوری جدید همچنین منجر به کاهش نقش دیگر شده است
   فناوری - و بنابراین ما شاهد ابزارهایی مانند <span style="color:blue">Puppet</span>، <span style="color:blue">Chef</span>، <span style="color:blue">Ansible</span> و <span style="color:blue">Salt</span> هستیم که نقش بسیار
   نقش کوچکتر در استقرار معماری های <span style="color:blue">microservice</span> نسبت به آنچه در سال 2014 انجام دادیم.
  </p>
  <p>
   دلیل اصلی این امر اساساً ظهور کانتینر است. قدرت
   ابزارهایی مانند <span style="color:blue">Puppet</span> و <span style="color:blue">Chef</span> این است که به شما راهی برای آوردن یک دستگاه به حالت دلخواه می دهند،
   با آن حالت دلخواه در برخی از فرم های کد تعریف شده است. شما می توانید اجرا را تعریف کنید
   <span style="color:blue">times</span> شما نیاز دارید، کجا فایل های پیکربندی باید باشند، و غیره، به گونه ای که می تواند تعیین کننده
   به طور قطعی در زمان و دوباره بر روی همان دستگاه اجرا می شود و اطمینان حاصل می شود که همیشه می تواند
   به همان حالت منتقل شد.
  </p>
  <p>
   اکثر مردم چگونه یک کانتینر را می سازند با تعریف <span style="color:blue">Dockerfile</span>. این به شما اجازه می دهد تا
   همان الزامات را همانطور که با <span style="color:blue">Puppet</span> یا <span style="color:blue">Chef</span> انجام می دهید، با برخی <span style="color:blue">differ</span>- تعریف کنید
   <span style="color:blue">ences</span>. یک کانتینر هنگامی که دوباره مستقر می شود از بین می رود، بنابراین هر ایجاد کانتینر انجام می شود
   از ابتدا (من در اینجا تا حدودی ساده سازی می کنم). این بدان معناست که بسیاری از
   پیچیدگی ذاتی در <span style="color:blue">Puppet</span> و <span style="color:blue">Chef</span> برای مدیریت آن ابزارها که اجرا می شوند و
   روی همان ماشین‌ها، لازم نیست.
  </p>
  <p>
   <span style="color:blue">Puppet</span>، <span style="color:blue">Chef</span>، و ابزارهای مشابه هنوز هم فوق العاده مفید هستند، اما نقش آنها اکنون بوده است
   از کانتینر و پایین تر در پشته بیرون رانده شد. مردم از ابزارهایی مانند این برای
   مدیریت برنامه ها و زیرساخت های قدیمی، یا برای ساخت خوشه هایی که
   بارهای کاری کانتینر اکنون در حال اجرا هستند. اما توسعه دهندگان حتی کمتر احتمال دارد که وارد شوند
   در گذشته با این ابزارها در تماس باشید.
  </p>
  <p>
   مفهوم زیرساخت به عنوان کد هنوز حیاتی است. فقط این است که نوع
   ابزارهایی که توسعه دهندگان احتمالاً از آنها استفاده می کنند تغییر کرده است. برای کسانی که با ابر کار می کنند، برای
   به عنوان مثال، چیزهایی مانند <span style="color:blue">Terraform</span> می توانند برای تهیه <span style="color:blue">infra</span>- ابر بسیار مفید باشند
   <span style="color:blue">structure</span>. اخیراً، من طرفدار بزرگی از <span style="color:blue">Pulumi</span> شده‌ام، که از استفاده از دامنه اجتناب می‌کند-
   زبان های خاص (<span style="color:blue">DSL</span>) به نفع استفاده از زبان های برنامه نویسی معمولی برای کمک
   توسعه دهندگان زیرساخت های ابری خود را مدیریت می کنند. من چیزهای بزرگی را پیش رو می بینم
   برای <span style="color:blue">Pulumi</span> همانطور که تیم های تحویل مالکیت بیشتری از دنیای عملیاتی می گیرند، و من مشکوکم
  </p>
  <p>
   258
   |
   فصل 8: استقرار
  </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>