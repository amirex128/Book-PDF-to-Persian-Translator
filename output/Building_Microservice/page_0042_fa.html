<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 42</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   6 برای کسب اطلاعات مفید در مورد تفکر پشت استفاده <strong>Shopify</strong> از یک <strong>modular monolith</strong> به جای microservices، “Deconstructing the Monolith” را توسط Kirsten Westeinde تماشا کنید.
  </p>
  <h4>The Modular Monolith</h4>
  <p>
   به عنوان زیرمجموعه‌ای از <strong>single-process monolith</strong>، <strong>modular monolith</strong> نوعی است که در آن <strong>single process</strong> از ماژول‌های جداگانه تشکیل شده است. هر ماژول را می‌توان به طور مستقل روی آن کار کرد، اما همه آنها همچنان باید برای استقرار با هم ترکیب شوند، همانطور که در شکل 1-7 نشان داده شده است. مفهوم تقسیم نرم‌افزار به ماژول‌ها چیز جدیدی نیست. نرم‌افزار ماژولار ریشه در کارهایی دارد که در دهه 1970 و حتی قبل از آن در اطراف برنامه‌نویسی ساختاریافته انجام شده است. با این وجود، این رویکردی است که هنوز هم نمی‌بینم سازمان‌های زیادی به درستی با آن درگیر شوند.
  </p>
  <p>
   شکل 1-7. در یک <strong>modular monolith</strong>، کد داخل <strong>process</strong> به ماژول‌ها تقسیم می‌شود
  </p>
  <p>
   برای بسیاری از سازمان‌ها، <strong>modular monolith</strong> می‌تواند یک انتخاب عالی باشد. اگر <strong>module boundaries</strong> به خوبی تعریف شده باشند، می‌تواند درجه بالایی از کار موازی را فراهم کند، در حالی که از چالش‌های معماری microservice توزیع‌شده‌تر با داشتن یک توپولوژی استقرار بسیار ساده‌تر اجتناب می‌کند. <strong>Shopify</strong> نمونه‌ای عالی از سازمانی است که از این تکنیک به عنوان جایگزینی برای <strong>microservice decomposition</strong> استفاده کرده است و به نظر می‌رسد که برای آن شرکت واقعاً خوب عمل می‌کند.6
  </p>
  <p>
   یکی از چالش‌های یک <strong>modular monolith</strong> این است که پایگاه داده تمایل دارد فاقد تجزیه‌ای باشد که ما در سطح کد پیدا می‌کنیم، که اگر بخواهید در آینده <strong>monolith</strong> را از هم جدا کنید، چالش‌های مهمی را به همراه دارد. من دیده‌ام که برخی از تیم‌ها سعی می‌کنند ایده <strong>modular monolith</strong> را با داشتن پایگاه داده که در امتداد همان خطوط ماژول‌ها تجزیه شده است، پیش ببرند، همانطور که در شکل 1-8 نشان داده شده است.
  </p>
  <p>16 | Chapter 1: What Are Microservices?</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0042/image_1.png" alt="Image from page 42" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>