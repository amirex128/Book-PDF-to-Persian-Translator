<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 80</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   12 من می‌دانم که برخی از افراد با استفاده از <strong>templated URIs</strong> در سیستم‌های <strong>REST</strong> مخالف هستند، و من می‌فهمم چرا—فقط می‌خواهم در این مثال، همه چیز را ساده نگه دارم.
  </p>
  <p>
   شکل 2-12. یک <strong>Customer aggregate</strong> ممکن است با یک یا چند <strong>Order</strong> یا <strong>Wishlist aggregates</strong> مرتبط باشد
  </p>
  <p>
   اگر این روابط بین <strong>aggregates</strong> در محدوده یک microservice واحد وجود داشته باشد، در صورت استفاده از یک پایگاه داده رابطه‌ای، می‌توان آنها را به راحتی با استفاده از چیزی مانند یک رابطه کلید خارجی ذخیره کرد. اگرچه روابط بین این <strong>aggregates</strong>، <strong>microservice boundaries</strong> را در بر می‌گیرد، ما به روشی برای مدل‌سازی روابط نیاز داریم.
  </p>
  <p>
   اکنون، ما می‌توانیم به سادگی <strong>ID</strong> <strong>aggregate</strong> را مستقیماً در پایگاه داده محلی خود ذخیره کنیم. به عنوان مثال، یک microservice <strong>Finance</strong> را در نظر بگیرید که یک دفتر کل مالی را مدیریت می‌کند، که معاملات را در برابر یک مشتری ذخیره می‌کند. به صورت محلی، در داخل پایگاه داده microservice <strong>Finance</strong> ما می‌توانیم یک ستون <strong>CustID</strong> داشته باشیم که حاوی <strong>ID</strong> آن مشتری است. اگر می‌خواستیم اطلاعات بیشتری در مورد آن مشتری دریافت کنیم، باید از آن <strong>ID</strong> برای جستجو در برابر microservice <strong>Customer</strong> استفاده می‌کردیم.
  </p>
  <p>
   مشکل این مفهوم این است که خیلی صریح نیست—در واقع، رابطه بین ستون <strong>CustID</strong> و مشتری از راه دور کاملاً ضمنی است. برای دانستن نحوه استفاده از آن <strong>ID</strong>، باید به کد خود microservice <strong>Finance</strong> نگاه می‌کردیم. خوب است اگر بتوانیم یک <strong>reference</strong> به یک <strong>foreign aggregate</strong> را به روشی ذخیره کنیم که آشکارتر باشد.
  </p>
  <p>
   در شکل 2-13، ما چیزهایی را تغییر داده‌ایم تا رابطه را صریح کنیم. به جای یک <strong>ID</strong> ساده برای <strong>customer reference</strong>، ما در عوض یک <strong>URI</strong> را ذخیره می‌کنیم، که ممکن است در صورت ساخت یک سیستم مبتنی بر <strong>REST</strong> از آن استفاده کنیم.12
  </p>
  <p>54 | Chapter 2: How to Model Microservices</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0080/image_1.png" alt="Image from page 80" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>