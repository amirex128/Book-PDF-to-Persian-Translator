<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 194</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p><em>building block</em> برای <em>service meshes</em> و سایر انواع نرم‌افزارهای مبتنی بر <em>proxy</em> است—به عنوان مثال، این یک <em>building block</em> مهم برای <em>Istio</em> و <em>Ambassador</em> است.</p>
  <p>این <em>proxies</em> به نوبه خود توسط یک <em>control plane</em> مدیریت می‌شوند. این مجموعه‌ای از نرم‌افزار خواهد بود که به شما کمک می‌کند ببینید چه اتفاقی می‌افتد و آنچه را که در حال انجام است، کنترل کنید. به عنوان مثال، هنگام استفاده از یک <em>service mesh</em> برای پیاده‌سازی <em>mutual TLS</em>، از <em>control plane</em> برای توزیع گواهی‌های <em>client</em> و <em>server</em> استفاده می‌شود.</p>
  <h4>Aren’t service meshes smart pipes?</h4>
  <p>بنابراین همه این صحبت‌ها در مورد قرار دادن رفتار مشترک در یک <em>service mesh</em> ممکن است زنگ‌های هشدار را برای برخی از شما به صدا درآورد. آیا این رویکرد در معرض همان نوع مشکلات <em>enterprise service buses</em> یا <em>overly bloated API gateways</em> نیست؟ آیا ما در معرض خطر قرار دادن بیش از حد "<em>smarts</em>" در <em>service mesh</em> خود نیستیم؟</p>
  <p>نکته اصلی که در اینجا باید به خاطر داشت این است که رفتار مشترکی که ما در حال قرار دادن آن در <em>mesh</em> هستیم، مختص هیچ <em>microservice</em> واحدی نیست. هیچ عملکرد تجاری به بیرون نشت نکرده است. ما در حال پیکربندی چیزهای عمومی مانند نحوه رسیدگی به <em>request time-outs</em> هستیم.
  <p>از نظر رفتار مشترکی که ممکن است بخواهید به ازای هر <em>microservice</em> تنظیم کنید، این معمولاً چیزی است که به خوبی برآورده می‌شود، بدون نیاز به انجام کار روی یک پلتفرم مرکزی. به عنوان مثال، با <em>Istio</em>، من می‌توانم الزامات <em>time-out</em> خود را به صورت خودکار فقط با تغییر تعریف <em>service</em> خود تعریف کنم.</p>
  <h4>Do you need one?</h4>
  <p>هنگامی که استفاده از <em>service meshes</em> برای اولین بار شروع به محبوب شدن کرد، درست پس از انتشار نسخه اول این کتاب، من مزایای زیادی را در این ایده دیدم اما همچنین آشفتگی زیادی را در این فضا دیدم. مدل‌های استقرار مختلف پیشنهاد، ساخته و سپس کنار گذاشته شدند، و تعداد شرکت‌هایی که راه‌حل‌هایی را در این فضا ارائه می‌کردند به طور چشمگیری افزایش یافت؛ اما حتی برای آن ابزارهایی که مدت‌ها بود وجود داشتند، کمبود ظاهری ثبات وجود داشت. <em>Linkerd</em>، که مسلماً به اندازه هر کس دیگری در پیشگامی این فضا تلاش کرد، محصول خود را از ابتدا در انتقال از نسخه 1 به نسخه 2 کاملاً بازسازی کرد. <em>Istio</em>، که <em>service mesh</em> مورد تأیید <em>Google</em> بود، سال‌ها طول کشید تا به نسخه اولیه 1.0 برسد، و حتی با این وجود تغییرات قابل توجهی در معماری خود داشت (تا حدودی طعنه‌آمیز، اگرچه منطقی، به یک مدل استقرار <em>monolithic</em> بیشتر برای <em>control plane</em> خود حرکت کرد).</p>
  <p>در بیشتر پنج سال گذشته، وقتی از من پرسیده می‌شد "آیا باید یک <em>service mesh</em> تهیه کنیم؟" توصیه من این بود: "اگر می‌توانید شش ماه صبر کنید قبل از اینکه تصمیمی بگیرید، پس شش ماه صبر کنید." من به این ایده فروخته شدم اما نگران ثبات بودم. و چیزی مانند یک <em>service mesh</em> جایی نیست که من شخصاً بخواهم ریسک زیادی کنم—برای اینکه همه چیز به خوبی کار کند، بسیار کلیدی و ضروری است. شما آن را در مسیر بحرانی خود قرار می‌دهید. از نظر اینکه چقدر آن را جدی می‌گیرم، با انتخاب یک <em>message broker</em> یا <em>cloud provider</em> برابری می‌کند.</p>
 </div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>