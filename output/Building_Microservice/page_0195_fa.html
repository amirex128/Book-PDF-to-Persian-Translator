<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 195</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>از آن زمان، خوشحالم که بگویم، این فضا بالغ شده است. آشفتگی تا حدودی کاهش یافته است، اما ما همچنان دارای یک جمع (سالم) از فروشندگان هستیم. با این حال، <em>service meshes</em> برای همه مناسب نیستند. اولاً، اگر شما در <em>Kubernetes</em> نیستید، گزینه‌های شما محدود است. ثانیاً، آن‌ها پیچیدگی را اضافه می‌کنند. اگر شما پنج <em>microservices</em> دارید، من فکر نمی‌کنم شما بتوانید به راحتی یک <em>service mesh</em> را توجیه کنید (این قابل بحث است که آیا شما می‌توانید <em>Kubernetes</em> را توجیه کنید اگر فقط پنج <em>microservices</em> داشته باشید!). برای سازمان‌هایی که <em>microservices</em> بیشتری دارند، به خصوص اگر آن‌ها می‌خواهند این گزینه را داشته باشند که آن <em>microservices</em> در زبان‌های برنامه‌نویسی مختلف نوشته شوند، <em>service meshes</em> ارزش دیدن را دارند. با این حال، تحقیقات خود را انجام دهید—جابجایی بین <em>service meshes</em> دردناک است!</p>
  <p><em>Monzo</em> سازمانی است که به صراحت در مورد اینکه چگونه استفاده از یک <em>service mesh</em> برای آن‌ها ضروری بود تا اجازه دهند معماری خود را در مقیاسی که انجام می‌دهد، اجرا کنند، صحبت کرده است. استفاده از نسخه 1 <em>Linkerd</em> برای کمک به مدیریت <em>inter-microservice RPC calls</em>، بسیار مفید بود. جالب اینجاست که <em>Monzo</em> مجبور شد درد یک <em>service mesh migration</em> را تحمل کند تا به آن‌ها در دستیابی به مقیاسی که نیاز داشتند، کمک کند، زمانی که معماری قدیمی‌تر <em>Linkerd v1</em> دیگر الزامات آن‌ها را برآورده نمی‌کرد. در پایان، آن‌ها به‌طور مؤثر به یک <em>service mesh in-house</em> که از <em>Envoy proxy</em> استفاده می‌کرد، منتقل شدند.</p>
  <h4>What About Other Protocols?</h4>
  <p><em>API gateways</em> و <em>service meshes</em> عمدتاً برای رسیدگی به <em>HTTP-related calls</em> استفاده می‌شوند. بنابراین <em>REST</em>، <em>SOAP</em>، <em>gRPC</em>، و موارد مشابه را می‌توان از طریق این محصولات مدیریت کرد. با این حال، وقتی شروع به نگاه کردن به ارتباط از طریق <em>protocols</em> دیگر می‌کنید، مانند استفاده از <em>message brokers</em> مانند <em>Kafka</em>، اوضاع کمی مبهم‌تر می‌شود. به طور معمول، در این مرحله <em>service mesh</em> دور زده می‌شود—ارتباط مستقیماً با خود <em>broker</em> انجام می‌شود. این بدان معناست که شما نمی‌توانید فرض کنید که <em>service mesh</em> شما قادر به کار به عنوان یک واسطه برای همه <em>calls</em> بین <em>microservices</em> است.</p>
  <h4>Documenting Services</h4>
  <p>با تجزیه سیستم‌های خود به <em>microservices</em> ریزدانه، ما امیدواریم که درزهای زیادی را به شکل <em>APIs</em> در معرض نمایش قرار دهیم که مردم می‌توانند از آن‌ها برای انجام کارهای بسیار خوب استفاده کنند. اگر کشف ما درست باشد، ما می‌دانیم که چیزها کجا هستند. اما چگونه می‌دانیم که آن چیزها چه می‌کنند یا چگونه از آن‌ها استفاده کنیم؟ یک گزینه، بدیهی است، داشتن <em>documentation</em> در مورد <em>APIs</em> است. البته، <em>documentation</em> اغلب می‌تواند منسوخ شود. در حالت ایده‌آل، ما اطمینان حاصل می‌کنیم که <em>documentation</em> ما همیشه با <em>microservice API</em> به‌روز است و دیدن این <em>documentation</em> را زمانی که می‌دانیم یک <em>service endpoint</em> کجاست، آسان می‌کنیم.</p>
  <h4>Explicit Schemas</h4>
  <p>داشتن <em>explicit schemas</em> راه زیادی را به سمت آسان‌تر کردن درک آنچه هر <em>endpoint</em> داده شده در معرض نمایش قرار می‌دهد، طی می‌کند، اما به خودی خود اغلب کافی نیستند. همانطور که قبلاً بحث کردیم، <em>schemas</em> به نشان دادن ساختار کمک می‌کنند، اما آن‌ها خیلی دور نمی‌روند</p>
 </div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>