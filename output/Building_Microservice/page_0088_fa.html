<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 88</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   ثانیاً، تمرکز بر تعریف یک زبان مشترک و فراگیر، هنگام تعریف <strong>microservice endpoints</strong>، بسیار کمک می‌کند. این به طور مرتب یک واژگان مشترک را به ما می‌دهد که می‌توانیم هنگام ارائه <strong>APIs</strong>، قالب‌های رویداد، و موارد مشابه، از آن استفاده کنیم. همچنین به حل این مشکل کمک می‌کند که استانداردسازی <strong>APIs</strong> تا چه حد نیاز دارد که از نظر اجازه دادن به تغییر زبان در داخل <strong>bounded contexts</strong> پیش برود—تغییر در داخل یک <strong>boundary</strong> بر آن <strong>boundary</strong> تأثیر می‌گذارد.
  </p>
  <p>
   تغییراتی که ما در سیستم خود پیاده‌سازی می‌کنیم اغلب در مورد تغییراتی است که <strong>business</strong> می‌خواهد در نحوه رفتار سیستم ایجاد کند. ما در حال تغییر <strong>functionality</strong>—قابلیت‌ها—هستیم که در معرض دید مشتریان ما قرار دارند. اگر سیستم‌های ما در امتداد <strong>bounded contexts</strong> که <strong>domain</strong> ما را نشان می‌دهند تجزیه شوند، احتمال اینکه هر تغییری که می‌خواهیم ایجاد کنیم به یک <strong>microservice boundary</strong> واحد منزوی شود، بیشتر است. این تعداد مکان‌هایی را که باید در آن تغییر ایجاد کنیم کاهش می‌دهد و به ما اجازه می‌دهد تا آن تغییر را سریعاً مستقر کنیم.
  </p>
  <p>
   اساساً، <strong>DDD</strong>، <strong>business domain</strong> را در قلب نرم‌افزاری که در حال ساخت آن هستیم، قرار می‌دهد. تشویقی که به ما می‌دهد تا زبان <strong>business</strong> را وارد طراحی کد و <strong>service</strong> خود کنیم، به بهبود تخصص <strong>domain</strong> در بین افرادی که نرم‌افزار را می‌سازند کمک می‌کند. این به نوبه خود به ایجاد درک و همدلی برای کاربران نرم‌افزار ما کمک می‌کند و ارتباطات بیشتری را بین تحویل فنی، توسعه محصول و کاربران نهایی ایجاد می‌کند. اگر شما علاقه‌مند به حرکت به سمت تیم‌های <strong>stream-aligned</strong> هستید، <strong>DDD</strong> به عنوان یک مکانیسم برای کمک به همسو کردن معماری فنی با ساختار سازمانی گسترده‌تر، به خوبی عمل می‌کند. در جهانی که ما به طور فزاینده‌ای در تلاشیم تا سیلوها را بین <strong>IT</strong> و "<strong>business</strong>" از بین ببریم، این چیز بدی نیست.
  </p>
  <h4>جایگزین‌هایی برای <strong>Business Domain Boundaries</strong></h4>
  <p>
   همانطور که شرح دادم، <strong>DDD</strong> می‌تواند هنگام ساخت معماری‌های microservice بسیار مفید باشد، اما این اشتباه خواهد بود که فکر کنیم این تنها تکنیکی است که شما باید هنگام یافتن <strong>microservice boundaries</strong> در نظر بگیرید. در واقع، من اغلب از روش‌های متعددی در ارتباط با <strong>DDD</strong> برای کمک به شناسایی چگونگی (و اینکه آیا) یک سیستم باید تقسیم شود، استفاده می‌کنم. بیایید به برخی از عوامل دیگری که ممکن است هنگام یافتن <strong>boundaries</strong> در نظر بگیریم، نگاهی بیندازیم.
  </p>
  <h4>فرّاریت</h4>
  <p>
   من به طور فزاینده‌ای در مورد مخالفت با تجزیه <strong>domain-oriented</strong>، اغلب توسط طرفداران فرّاریت، شنیده‌ام که عامل اصلی تجزیه است. تجزیه مبتنی بر فرّاریت شما را وادار می‌کند تا بخش‌هایی از سیستم خود را که دچار تغییرات مکرر می‌شوند، شناسایی کنید و سپس آن <strong>functionality</strong> را به <strong>services</strong> خود استخراج کنید، جایی که می‌توانند به طور موثرتری روی آنها کار کرد. از نظر مفهومی، من با این موضوع مشکلی ندارم، اما ترویج آن به عنوان تنها راه انجام کارها مفید نیست، به خصوص زمانی که ما محرک‌های مختلفی را در نظر می‌گیریم که ممکن است ما را به سمت microservices سوق دهند. به عنوان مثال، اگر بزرگترین مشکل من مربوط به نیاز به مقیاس‌بندی برنامه من باشد، تجزیه و تحلیل مبتنی بر فرّاریت بعید است که مزایای زیادی را به همراه داشته باشد.
  </p>
  <p>62 | Chapter 2: How to Model Microservices</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>