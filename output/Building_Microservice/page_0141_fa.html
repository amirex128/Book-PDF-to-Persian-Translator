<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 141</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   به طور گسترده‌تر. این امر پیچیدگی را از نظر مدیریت دید <strong>events</strong>های مختلف و اطمینان از اینکه هر دو <strong>events</strong> واقعاً منتشر می‌شوند، اضافه می‌کند. چه اتفاقی می‌افتد وقتی که یک microservice نوع اول <strong>event</strong> را ارسال می‌کند اما قبل از اینکه <strong>event</strong> دوم بتواند ارسال شود، از بین می‌رود؟
  </p>
  <p>
   یکی دیگر از ملاحظات این است که هنگامی که ما داده‌ها را در یک <strong>event</strong> قرار می‌دهیم، به بخشی از قرارداد ما با دنیای بیرون تبدیل می‌شود. ما باید آگاه باشیم که اگر فیلدی را از یک <strong>event</strong> حذف کنیم، ممکن است طرف‌های خارجی را خراب کنیم. <strong>Information hiding</strong> هنوز یک مفهوم مهم در همکاری <strong>event-driven</strong> است—هر چه داده‌های بیشتری در یک <strong>event</strong> قرار دهیم، مفروضات بیشتری را که طرف‌های خارجی در مورد <strong>event</strong> خواهند داشت. قانون کلی من این است که اگر خوشحال باشم که داده‌های یکسان را از طریق یک <strong>request-response API</strong> به اشتراک بگذارم، در قرار دادن اطلاعات در یک <strong>event</strong> مشکلی ندارم.
  </p>
  <h4>کجا از آن استفاده کنیم</h4>
  <p>
   همکاری <strong>event-driven</strong> در موقعیت‌هایی که اطلاعات می‌خواهد پخش شود، و در موقعیت‌هایی که شما از معکوس کردن قصد خوشحال هستید، رونق دارد. حرکت از یک مدل گفتن به چیزهای دیگر که چه کاری انجام دهند و در عوض به microservicesهای پایین‌دست اجازه دهید که این موضوع را برای خودشان حل کنند، جاذبه زیادی دارد.
  </p>
  <p>
   در موقعیتی که شما بر <em>coupling</em> آزادتر بیش از عوامل دیگر تمرکز می‌کنید، همکاری <strong>event-driven</strong> جذابیت آشکاری خواهد داشت.
  </p>
  <p>
   نکته احتیاطی این است که اغلب منابع جدیدی از پیچیدگی وجود دارد که با این سبک از همکاری به وجود می‌آید، به خصوص اگر شما در معرض آن قرار گرفته باشید.
  </p>
  <p>
   اگر در مورد این شکل از ارتباط مطمئن نیستید، به یاد داشته باشید که معماری microservice ما می‌تواند (و احتمالاً خواهد بود) شامل ترکیبی از سبک‌های مختلف تعامل باشد. شما مجبور نیستید با همکاری <strong>event-driven</strong> به طور کامل پیش بروید. شاید فقط با یک <strong>event</strong> شروع کنید و از آنجا پیش بروید.
  </p>
  <p>
   من شخصاً خود را به سمت همکاری <strong>event-driven</strong> تقریباً به عنوان یک پیش‌فرض سوق می‌دهم. به نظر می‌رسد مغز من به گونه‌ای دوباره سیم‌کشی شده است که این نوع ارتباطات برای من بدیهی به نظر می‌رسند. این کاملاً مفید نیست، زیرا تلاش برای توضیح اینکه چرا این مورد صادق است، دشوار است، به جز اینکه بگویم درست به نظر می‌رسد. اما این فقط سوگیری درونی من است—من به طور طبیعی به سمت آنچه می‌دانم، بر اساس تجربیات خودم، گرایش پیدا می‌کنم. این احتمال زیادی وجود دارد که جذابیت من برای این شکل از تعامل تقریباً به‌طور کامل ناشی از تجربیات بد قبلی‌ام با سیستم‌های بیش از حد <em>coupled</em> باشد. من ممکن است فقط در حال جنگیدن با آخرین نبرد بارها و بارها باشم بدون در نظر گرفتن اینکه شاید این بار واقعاً متفاوت است.
  </p>
  <p>
   آنچه که من خواهم گفت، کنار گذاشتن سوگیری‌های خودم است، این است که من تیم‌های بسیار بیشتری را می‌بینم که تعاملات <strong>request-response</strong> را با تعاملات <strong>event-driven</strong> جایگزین می‌کنند تا بالعکس.
  </p>
  <p>Pattern: Event-Driven Communication | 115</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>