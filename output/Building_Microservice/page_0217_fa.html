<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 217</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>مهم است که شما همچنان <em>services</em> را که این جریان‌های <em>orchestrated</em> را تشکیل می‌دهند، به عنوان موجودیت‌هایی که <em>local state</em> و رفتار خود را دارند، در نظر بگیرید. آن‌ها مسئول <em>local state machines</em> خود هستند.</p>
  <p>اگر منطق جایی دارد که می‌تواند متمرکز شود، متمرکز خواهد شد!</p>
  <p>یک راه برای اجتناب از تمرکز بیش از حد با جریان‌های <em>orchestrated</em>، اطمینان از این است که <em>services</em> مختلف نقش <em>orchestrator</em> را برای جریان‌های مختلف ایفا می‌کنند. شما ممکن است یک <em>Order Processor microservice</em> داشته باشید که سفارش را مدیریت می‌کند، یک <em>Returns microservice</em> برای مدیریت فرآیند بازگشت و بازپرداخت، یک <em>Goods Receiving microservice</em> که ورود سهام جدید و قرار دادن آن در قفسه‌ها را مدیریت می‌کند، و غیره. چیزی مانند <em>Warehouse microservice</em> ما ممکن است توسط همه آن <em>orchestrators</em> استفاده شود؛ چنین مدلی به شما این امکان را می‌دهد که عملکرد را در خود <em>Warehouse microservice</em> نگه دارید، و به شما امکان می‌دهد تا عملکرد را در همه آن جریان‌ها دوباره استفاده کنید.</p>
  <h4>BPM Tools</h4>
  <p>ابزارهای <em>business process modeling (BPM)</em> سال‌هاست که در دسترس هستند. به طور کلی، آن‌ها برای این طراحی شده‌اند که به غیرتوسعه‌دهندگان اجازه دهند جریان‌های فرآیند تجاری را تعریف کنند، که اغلب از ابزارهای بصری <em>drag-and-drop</em> استفاده می‌کنند. ایده این است که توسعه‌دهندگان بلوک‌های ساختمانی این فرآیندها را ایجاد می‌کنند، و سپس غیرتوسعه‌دهندگان این بلوک‌های ساختمانی را به هم متصل می‌کنند تا جریان‌های فرآیند بزرگ‌تری را ایجاد کنند. به نظر می‌رسد استفاده از چنین ابزارهایی، واقعاً به خوبی با راهی برای پیاده‌سازی <em>orchestrated sagas</em> مطابقت دارد، و در واقع، <em>process orchestration</em> تقریباً مورد استفاده اصلی ابزارهای <em>BPM</em> است (یا، برعکس، استفاده از ابزارهای <em>BPM</em> منجر به این می‌شود که شما باید <em>orchestration</em> را اتخاذ کنید).</p>
  <p>در تجربه من، من بسیار از ابزارهای <em>BPM</em> متنفر شده‌ام. دلیل اصلی این است که <em>central conceit</em>—که غیرتوسعه‌دهندگان، فرآیند تجاری را تعریف خواهند کرد—در تجربه من تقریباً هرگز درست نبوده است. <em>Tooling</em> با هدف قرار دادن غیرتوسعه‌دهندگان، در نهایت توسط توسعه‌دهندگان استفاده می‌شود، و متأسفانه این ابزارها اغلب به روش‌هایی کار می‌کنند که با نحوه عملکرد توسعه‌دهندگان ناسازگار است. آن‌ها اغلب به استفاده از <em>GUIs</em> برای تغییر جریان‌ها نیاز دارند، جریان‌هایی که ایجاد می‌کنند ممکن است دشوار (یا غیرممکن) باشد که کنترل <em>version</em> شوند، خود جریان‌ها ممکن است با <em>testing</em> طراحی نشده باشند، و موارد دیگر.</p>
  <p>اگر توسعه‌دهندگان شما قصد دارند فرآیندهای تجاری شما را پیاده‌سازی کنند، به آن‌ها اجازه دهید از <em>tooling</em> استفاده کنند که آن‌ها می‌دانند و درک می‌کنند و برای <em>workflows</em> آن‌ها مناسب است. به طور کلی، این به معنای این است که فقط به آن‌ها اجازه دهید از کد برای پیاده‌سازی این موارد استفاده کنند! اگر شما نیاز به دید به نحوه پیاده‌سازی یک فرآیند تجاری یا نحوه عملکرد آن دارید، در این صورت، بسیار آسان‌تر است که یک نمایش بصری از یک <em>workflow</em> را از کد ارائه دهید تا اینکه از یک نمایش بصری از <em>workflow</em> خود برای توصیف نحوه عملکرد کد خود استفاده کنید.</p>
 </div>

        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0217/image_1.png" alt="Image from page 217" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>