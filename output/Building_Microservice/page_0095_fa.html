<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 95</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   17 Vaughn Vernon, Implementing Domain-Driven Design (Upper Saddle River, NJ: Addison-Wesley, 2013).
  </p>
  <p>
   18 Vaughn Vernon, Domain-Driven Design Distilled (Boston: Addison-Wesley, 2016).
  </p>
  <p>
   اگر تمرکز شما بر بهبود سرعت تحویل باشد، منطق زیادی دارد، اما اگر این باعث شود که <strong>service</strong> را استخراج کنید که از <strong>organizational boundaries</strong> عبور می‌کند، انتظار داشته باشید که سرعت تغییر شما به دلیل <strong>delivery contention</strong> آسیب ببیند.
  </p>
  <p>
   من ممکن است یک <strong>Warehouse service</strong> خوب را بر اساس درک خود از <strong>business domain</strong> تعریف کنم، اما اگر بخشی از آن سیستم نیاز به پیاده‌سازی در <strong>C++</strong> و بخش دیگری در <strong>Kotlin</strong> داشته باشد، باید این‌بار براساس این خطوط فنی بیشتر تجزیه کنید.
  </p>
  <p>
   <strong>Organizational</strong> و <strong>domain-driven service boundaries</strong>، نقطه شروع من هستند. اما این فقط رویکرد پیش‌فرض من است. معمولاً، تعدادی از عواملی که در اینجا شرح داده‌ام وارد عمل می‌شوند، و اینکه کدام یک بر تصمیمات شما تأثیر می‌گذارد، بر اساس مشکلاتی است که شما در تلاش برای حل آنها هستید. شما باید به شرایط خاص خود نگاه کنید تا تعیین کنید چه چیزی برای شما بهترین است—و امیدوارم که چند گزینه مختلف برای در نظر گرفتن به شما داده باشم. فقط به یاد داشته باشید، اگر کسی بگوید "تنها راه انجام این کار X است!"، احتمالاً فقط در حال فروش تعصب بیشتری به شما هستند. شما می‌توانید بهتر از این عمل کنید.
  </p>
  <p>
   با تمام این گفته‌ها، بیایید با بررسی <strong>domain-driven design</strong> با جزئیات بیشتر، به موضوع <strong>domain modeling</strong> بپردازیم.
  </p>
  <h4>خلاصه</h4>
  <p>
   در این فصل، شما کمی در مورد اینکه چه چیزی یک <strong>microservice boundary</strong> خوب را می‌سازد، و نحوه یافتن <strong>seams</strong> در <strong>problem space</strong> ما که مزایای دوگانه <em>coupling</em> کم و <em>cohesion</em> قوی را به ما می‌دهد، آموخته‌اید. داشتن درک دقیقی از <strong>domain</strong> ما می‌تواند یک ابزار حیاتی در کمک به ما در یافتن این <strong>seams</strong> باشد، و با همسو کردن microservicesهای خود با این <strong>boundaries</strong> ما اطمینان می‌دهیم که سیستم حاصل، تمام شانس خود را برای حفظ آن فضایل دست نخورده دارد. ما همچنین نکاتی در مورد چگونگی تقسیم بیشتر microservicesهایمان نیز دریافت کرده‌ایم.
  </p>
  <p>
   ایده‌های ارائه شده در <em>Domain-Driven Design</em> نوشته <strong>Eric Evans</strong>، برای یافتن <strong>boundaries</strong> منطقی برای <strong>services</strong> ما بسیار مفید هستند، و من فقط در اینجا به آن اشاره کردم—کتاب <strong>Eric</strong> به جزئیات بیشتری می‌پردازد. اگر می‌خواهید عمیق‌تر شوید، می‌توانم کتاب <strong>Vaughn Vernon’s Implementing Domain-Driven Design</strong>17 را توصیه کنم تا به شما کمک کند تا جنبه‌های عملی این رویکرد را درک کنید، در حالی که <strong>Domain-Driven Design Distilled</strong> نوشته <strong>Vernon</strong>18 یک مرور کلی عالی است اگر به دنبال چیزی مختصرتر هستید.
  </p>
  <p>
   بخش زیادی از این فصل نحوه یافتن <strong>boundary</strong> برای microservicesهایمان را توصیف کرده است. اما اگر در حال حاضر یک برنامه <strong>monolithic</strong> دارید و به دنبال مهاجرت به سمت معماری microservice هستید چه؟ این چیزی است که ما در فصل بعد با جزئیات بیشتری به آن خواهیم پرداخت.
  </p>
  <p>Summary | 69</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>