<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 84</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   و انبار نیاز به دانستن چیزی در مورد مشتری ما دارند. بخش مالی باید در مورد پرداخت‌های مالی انجام شده به یک مشتری بداند، در حالی که انبار باید در مورد مشتری به اندازه‌ای بداند که بداند چه بسته‌هایی ارسال شده است تا امکان ردیابی تحویل‌ها را فراهم کند.
  </p>
  <p>
   وقتی چنین وضعیتی دارید، یک مدل مشترک مانند مشتری می‌تواند معانی متفاوتی در <strong>bounded contexts</strong> مختلف داشته باشد و بنابراین ممکن است به نام‌های مختلفی خوانده شود. ما ممکن است از حفظ نام "مشتری" در امور مالی خوشحال باشیم، اما در انبار ممکن است آنها را "دریافت‌کننده" بنامیم، زیرا این نقشی است که آنها در آن <strong>context</strong> ایفا می‌کنند.
  </p>
  <p>
   ما اطلاعاتی را در مورد مشتری در هر دو مکان ذخیره می‌کنیم، اما اطلاعات متفاوت است. امور مالی اطلاعاتی را در مورد پرداخت‌های مالی مشتری (یا بازپرداخت‌ها) ذخیره می‌کند. انبار اطلاعات مربوط به کالاهای حمل شده را ذخیره می‌کند. ما همچنان ممکن است نیاز داشته باشیم که هر دو مفهوم محلی را به یک مشتری جهانی پیوند دهیم، و ممکن است بخواهیم اطلاعات مشترک و مشترک در مورد آن مشتری مانند نام یا آدرس ایمیل آنها را جستجو کنیم—ما می‌توانیم از تکنیکی مانند آنچه در شکل 2-13 نشان داده شده است برای دستیابی به این هدف استفاده کنیم.
  </p>
  <h4>نگاشت <strong>Aggregates</strong> و <strong>Bounded Contexts</strong> به Microservices</h4>
  <p>
   هم <strong>aggregate</strong> و هم <strong>bounded context</strong> به ما واحدهای <em>cohesion</em> را با <strong>interfaces</strong> کاملاً تعریف شده با سیستم گسترده‌تر می‌دهند. <strong>Aggregate</strong> یک <strong>state machine</strong> خودکفا است که بر یک مفهوم <strong>domain</strong> واحد در سیستم ما تمرکز می‌کند، در حالی که <strong>bounded context</strong> نشان‌دهنده مجموعه‌ای از <strong>aggregates</strong> مرتبط است، باز هم با یک <strong>interface</strong> صریح به دنیای گسترده‌تر.
  </p>
  <p>
   بنابراین هر دو می‌توانند به خوبی به عنوان <strong>service boundaries</strong> کار کنند. همانطور که قبلاً ذکر کردم، هنگام شروع کار، می‌خواهید تعداد <strong>services</strong> را که با آنها کار می‌کنید، کاهش دهید. در نتیجه، شما احتمالاً باید <strong>services</strong> را هدف قرار دهید که کل <strong>bounded contexts</strong> را در بر می‌گیرند. همانطور که پای خود را پیدا می‌کنید و تصمیم به تقسیم این <strong>services</strong> به <strong>services</strong> کوچک‌تر می‌گیرید، باید به خاطر داشته باشید که <strong>aggregates</strong> خود نمی‌خواهند از هم جدا شوند—یک microservice می‌تواند یک یا چند <strong>aggregates</strong> را مدیریت کند، اما ما نمی‌خواهیم یک <strong>aggregate</strong> توسط بیش از یک microservice مدیریت شود.
  </p>
  <h4>لاک‌پشت‌ها تا انتها</h4>
  <p>
   در ابتدا، شما احتمالاً تعدادی از <strong>bounded contexts</strong> با <strong>coarse-grained</strong> را شناسایی خواهید کرد. اما این <strong>bounded contexts</strong> به نوبه خود می‌توانند <strong>bounded contexts</strong> بیشتری را شامل شوند. به عنوان مثال، شما می‌توانید انبار را به قابلیت‌های مرتبط با تکمیل سفارش، مدیریت موجودی، یا دریافت کالا تجزیه کنید. هنگام در نظر گرفتن <strong>boundaries</strong> microservicesهای خود، ابتدا از نظر <strong>contexts</strong> بزرگتر و <strong>coarse-grained</strong> فکر کنید، و سپس هنگام جستجوی مزایای تقسیم این <strong>seams</strong>، در امتداد این <strong>contexts</strong> تو در تو تقسیم کنید.
  </p>
  <p>
   یک ترفند در اینجا این است که حتی اگر تصمیم دارید یک <strong>service</strong> را که یک <strong>bounded context</strong> کامل را مدل می‌کند به <strong>services</strong> کوچک‌تر در آینده تقسیم کنید، همچنان می‌توانید این تصمیم را از دنیای بیرون پنهان کنید—شاید با ارائه یک <strong>API</strong> با <strong>coarser-grained</strong> به مصرف‌کنندگان. تصمیم به
  </p>
  <p>58 | Chapter 2: How to Model Microservices</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>