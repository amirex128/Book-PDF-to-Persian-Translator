<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 165</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>به گفته برخی از کارشناسان که بیان می‌کنند تضمین تحویل دقیقاً یک بار در همه موارد غیرممکن است، در حالی که کارشناسان دیگر می‌گویند شما اساساً می‌توانید این کار را با چند <em>workarounds</em> ساده انجام دهید. به هر حال، اگر <em>broker</em> انتخابی شما ادعا می‌کند که این را پیاده‌سازی می‌کند، پس واقعاً به نحوه پیاده‌سازی آن توجه کنید. حتی بهتر از آن، <em>consumers</em> خود را به گونه‌ای بسازید که برای این واقعیت آماده باشند که ممکن است <em>message</em> را بیش از یک بار دریافت کنند و بتوانند این وضعیت را مدیریت کنند. یک مثال بسیار ساده این است که هر <em>message</em> دارای یک <em>ID</em> باشد، که یک <em>consumer</em> می‌تواند هر بار که یک <em>message</em> دریافت می‌شود، آن را بررسی کند. اگر یک <em>message</em> با آن <em>ID</em> قبلاً پردازش شده باشد، <em>message</em> جدیدتر را می‌توان نادیده گرفت.</p>
  <h4>انتخاب‌ها</h4>
  <p>انواع مختلفی از <em>message brokers</em> وجود دارد. نمونه‌های محبوب شامل <em>RabbitMQ</em>، <em>ActiveMQ</em> و <em>Kafka</em> (که به زودی بیشتر بررسی خواهیم کرد) می‌شوند. فروشندگان اصلی <em>public cloud</em> نیز انواع محصولاتی را ارائه می‌دهند که این نقش را ایفا می‌کنند، از نسخه‌های مدیریت شده آن <em>brokers</em> که می‌توانید روی زیرساخت خود نصب کنید تا پیاده‌سازی‌های <em>bespoke</em> که مختص یک پلتفرم خاص هستند. به عنوان مثال، <em>AWS</em> دارای <em>Simple Queue Service (SQS)</em>، <em>Simple Notification Service (SNS)</em> و <em>Kinesis</em> است، که همگی انواع مختلفی از <em>brokers</em> کاملاً مدیریت شده را ارائه می‌دهند. در واقع، <em>SQS</em> دومین محصولی بود که توسط <em>AWS</em> منتشر شد، که در سال 2006 راه‌اندازی شد.</p>
  <h4>Kafka</h4>
  <p><em>Kafka</em> به دلیل محبوبیت اخیر آن، ارزش برجسته کردن را دارد. بخشی از این محبوبیت به دلیل استفاده از <em>Kafka</em> در کمک به جابجایی حجم زیادی از داده‌ها به عنوان بخشی از پیاده‌سازی <em>stream processing pipelines</em> است. این می‌تواند به انتقال از پردازش <em>batch-oriented</em> به پردازش <em>real-time</em> کمک کند.</p>
  <p>چند ویژگی از <em>Kafka</em> وجود دارد که ارزش برجسته کردن را دارند. اولاً، برای مقیاس بسیار بزرگ طراحی شده است—در <em>LinkedIn</em> ساخته شد تا چندین <em>message clusters</em> موجود را با یک پلتفرم واحد جایگزین کند. <em>Kafka</em> ساخته شده است تا امکان وجود چندین <em>consumers</em> و <em>producers</em> را فراهم کند—من با یک متخصص در یک شرکت فناوری بزرگ صحبت کردم که بیش از پنجاه هزار <em>producers</em> و <em>consumers</em> داشت که روی یک <em>cluster</em> کار می‌کردند. منصفانه است که بگوییم، تعداد بسیار کمی از سازمان‌ها در آن سطح از مقیاس با مشکل مواجه هستند، اما برای برخی از سازمان‌ها، توانایی مقیاس‌بندی آسان <em>Kafka</em> (نسبتاً) می‌تواند بسیار مفید باشد.</p>
  <p>یکی دیگر از ویژگی‌های نسبتاً منحصربه‌فرد <em>Kafka</em>، پایداری <em>message</em> است. با یک <em>message broker</em> معمولی، هنگامی که آخرین <em>consumer</em> یک <em>message</em> را دریافت کرد، <em>broker</em> دیگر نیازی به نگه داشتن آن <em>message</em> ندارد. با <em>Kafka</em>، <em>messages</em> را می‌توان برای یک دوره قابل تنظیم ذخیره کرد. این بدان معناست که <em>messages</em> را می‌توان برای همیشه ذخیره کرد. این می‌تواند به <em>consumers</em> اجازه دهد تا <em>messages</em> را که قبلاً پردازش کرده‌اند دوباره وارد کنند، یا به <em>consumers</em> تازه مستقر شده اجازه می‌دهد تا <em>messages</em> را که قبلاً ارسال شده‌اند، پردازش کنند.</p>
  <p>در نهایت، <em>Kafka</em> پشتیبانی داخلی برای <em>stream processing</em> را ارائه کرده است. به جای استفاده از <em>Kafka</em> برای ارسال <em>messages</em> به یک ابزار پردازش <em>stream</em> اختصاصی مانند <em>Apache</em></p>
 </div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>