<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 328</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
    <p>
        اجرای آنها را، اما هرگز اعداد را بررسی نمی‌کنند. اغلب این به این دلیل است که مردم نمی‌دانند نتیجه "خوب" چه شکلی است. شما واقعاً نیاز به داشتن اهداف دارید. هنگامی که شما یک <strong>microservice</strong> را ارائه می‌دهید تا به عنوان بخشی از یک معماری گسترده‌تر استفاده شود، داشتن انتظارات خاصی که متعهد به ارائه آنها هستید—<strong>SLOs</strong> که قبلاً ذکر کردم—رایج است.
    </p>
    <p>
        اگر به عنوان بخشی از این کار متعهد به ارائه سطح خاصی از عملکرد هستید، پس منطقی است که هر تست خودکاری به شما بازخورد دهد که آیا شما به احتمال زیاد به آن هدف می‌رسید (و امیدوارم از آن فراتر بروید) یا خیر.
    </p>
    <p>
        به جای اهداف عملکردی خاص، تست‌های عملکرد خودکار هنوز هم می‌توانند در کمک به شما در دیدن اینکه چگونه عملکرد <strong>microservice</strong> شما با ایجاد تغییرات متفاوت است، بسیار مفید باشند. می‌تواند یک شبکه ایمنی برای شما باشد تا در صورت ایجاد تغییری که باعث تخریب چشمگیر عملکرد می‌شود، شما را بگیرد. بنابراین جایگزینی برای یک هدف خاص ممکن است این باشد که اگر <strong>delta</strong> در عملکرد از یک <strong>build</strong> به <strong>build</strong> بعدی بیش از حد متفاوت باشد، تست با شکست مواجه شود.
    </p>
    <p>
        تست عملکرد باید در هماهنگی با درک عملکرد سیستم واقعی (که ما در فصل 10 بیشتر در مورد آن بحث خواهیم کرد) انجام شود، و در حالت ایده‌آل شما باید از همان ابزارها در محیط تست عملکرد خود برای تجسم رفتار سیستم استفاده کنید، همانند ابزارهایی که در <strong>production</strong> استفاده می‌کنید. این رویکرد می‌تواند مقایسه مشابه با مشابه را بسیار آسان‌تر کند.
    </p>
    <h4>Robustness Tests</h4>
    <p>
        یک معماری <strong>microservice</strong> اغلب فقط به اندازه ضعیف‌ترین حلقه خود قابل اعتماد است، و در نتیجه، این برای <strong>microservices</strong> ما رایج است که مکانیسم‌هایی را در خود ایجاد کنیم تا به آنها اجازه دهیم قابلیت اطمینان خود را برای بهبود قابلیت اطمینان سیستم بهبود بخشند. ما این موضوع را بیشتر در "الگوهای پایداری" در صفحه 395 بررسی خواهیم کرد، اما نمونه‌ها شامل اجرای چندین نمونه از یک <strong>microservice</strong> در پشت یک <strong>load balancer</strong> برای تحمل خرابی یک نمونه، یا استفاده از <strong>circuit breakers</strong> برای مدیریت برنامه‌ریزی شده موقعیت‌هایی است که در آن <strong>microservices downstream</strong> نمی‌توانند تماس بگیرند.
    </p>
    <p>
        در چنین شرایطی، داشتن تست‌هایی که به شما امکان می‌دهد تا شکست‌های خاصی را دوباره ایجاد کنید تا اطمینان حاصل شود که <strong>microservice</strong> شما به عنوان یک کل به عملکرد خود ادامه می‌دهد، می‌تواند مفید باشد. به طور طبیعی، پیاده‌سازی این تست‌ها می‌تواند کمی دشوارتر باشد. به عنوان مثال، ممکن است لازم باشد یک <strong>time-out</strong> شبکه مصنوعی بین یک <strong>microservice</strong> تحت تست و یک <strong>stub</strong> خارجی ایجاد کنید. با این حال، آنها می‌توانند ارزشمند باشند، به خصوص اگر شما در حال ایجاد <strong>functionality</strong> مشترکی هستید که در چندین <strong>microservices</strong> استفاده خواهد شد—به عنوان مثال، استفاده از یک پیاده‌سازی <strong>service mesh</strong> پیش‌فرض برای مدیریت <strong>circuit breaking</strong>.
    </p>
    <p>
        302 | Chapter 9: Testing
    </p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>