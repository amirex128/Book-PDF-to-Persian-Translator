<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 132</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>Commands Versus Requests</h4>
  <p>
   من از برخی از افراد شنیده‌ام که در مورد ارسال <strong>commands</strong>، به جای <strong>requests</strong>، به طور خاص در زمینه ارتباط <strong>asynchronous request-response</strong> صحبت می‌کنند. قصد پشت اصطلاح <strong>command</strong>، تا حدودی همانند قصد <strong>request</strong> است—یعنی، یک microservice بالادستی از یک microservice پایین‌دست می‌خواهد کاری را انجام دهد.
  </p>
  <p>
   با این حال، شخصاً من اصطلاح <strong>request</strong> را خیلی بیشتر ترجیح می‌دهم. یک <strong>command</strong> به معنای یک دستورالعمل است که باید اطاعت شود، و می‌تواند منجر به وضعیتی شود که در آن افراد احساس کنند که باید بر اساس <strong>command</strong> عمل شود. یک <strong>request</strong> به معنای چیزی است که می‌توان آن را رد کرد. درست است که یک microservice هر <strong>request</strong> را بر اساس شایستگی‌های خود بررسی می‌کند و بر اساس منطق داخلی خود، تصمیم می‌گیرد که آیا باید بر اساس <strong>request</strong> عمل شود یا خیر. اگر <strong>request</strong> که برای آن ارسال شده است، منطق داخلی را نقض کند، microservice باید آن را رد کند. اگرچه این یک تفاوت ظریف است، اما من احساس نمی‌کنم که اصطلاح <strong>command</strong> معنای یکسانی را منتقل کند.
  </p>
  <p>
   من از استفاده از <strong>request</strong> به جای <strong>command</strong> استفاده خواهم کرد، اما هر اصطلاحی که شما تصمیم به استفاده از آن دارید، فقط به یاد داشته باشید که یک microservice می‌تواند <strong>request/command</strong> را در صورت مناسب رد کند.
  </p>
  <h4>پیاده‌سازی: Synchronous Versus Asynchronous</h4>
  <p>
   فراخوانی‌های <strong>request-response</strong> مانند این را می‌توان به سبک <strong>blocking synchronous</strong> یا سبک ناهمزمان <strong>nonblocking</strong> پیاده‌سازی کرد. با یک <strong>synchronous call</strong>، آنچه معمولاً مشاهده می‌کنید، باز شدن یک اتصال شبکه با microservice پایین‌دست است، و <strong>request</strong> در امتداد این اتصال ارسال می‌شود. اتصال در حالی باز نگه داشته می‌شود که microservice بالادستی منتظر پاسخ microservice پایین‌دست است. در این مورد، microservice که پاسخ را ارسال می‌کند، واقعاً نیازی به دانستن چیزی در مورد microservice که <strong>request</strong> را ارسال کرده است، ندارد—این فقط مواردی را از طریق یک اتصال ورودی ارسال می‌کند. اگر آن اتصال از بین برود، شاید به این دلیل که نمونه microservice بالادستی یا پایین‌دستی از بین می‌رود، در این صورت ممکن است با مشکلی مواجه شویم.
  </p>
  <p>
   با یک <strong>asynchronous request-response</strong>، اوضاع کمتر سرراست است. بیایید فرآیند مرتبط با رزرو سهام را دوباره بررسی کنیم. در شکل 4-10، درخواست رزرو سهام به عنوان یک پیام از طریق نوعی <strong>message broker</strong> ارسال می‌شود (ما در ادامه این فصل <strong>message brokers</strong> را بررسی خواهیم کرد). به جای اینکه پیام مستقیماً از <strong>Order Processor</strong> به microservice <strong>Inventory</strong> برود، در عوض در یک صف قرار می‌گیرد. <strong>Inventory</strong> هنگامی که قادر است، پیام‌ها را از این صف مصرف می‌کند. این درخواست را می‌خواند، کار مرتبط با رزرو سهام را انجام می‌دهد، و سپس نیاز دارد که پاسخ را به یک صف که <strong>Order Processor</strong> از آن می‌خواند، برگرداند. microservice <strong>Inventory</strong> باید بداند که پاسخ را از کجا مسیریابی کند. در مثال ما، این پاسخ را از طریق صف دیگری ارسال می‌کند که به نوبه خود توسط <strong>Order Processor</strong> مصرف می‌شود.
  </p>
  <p>106 | Chapter 4: Microservice Communication Styles</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>