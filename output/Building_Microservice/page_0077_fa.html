<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 77</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   11 Eric Evans, Domain-Driven Design: Tackling Complexity in the Heart of Software (Boston: Addison-Wesley,
   2004).
  </p>
  <p>
   در این موقعیت، ما همچنین این مشکل را داریم که <strong>internal data structure</strong> جدول <strong>order</strong> ما در معرض دید یک طرف خارجی قرار دارد. هنگام تغییر <strong>Order service</strong>، ما اکنون باید در مورد ایجاد تغییرات در آن جدول خاص بسیار مراقب باشیم—این حتی فرض می‌کند که برای ما آشکار است که این جدول مستقیماً توسط یک طرف خارجی قابل دسترسی است. راه حل آسان در اینجا این است که <strong>Warehouse</strong> درخواست‌هایی را به خود <strong>Order service</strong> ارسال کند، جایی که ما می‌توانیم درخواست را بررسی کنیم اما جزئیات داخلی را نیز پنهان کنیم و تغییرات بعدی در <strong>Order service</strong> را بسیار آسان‌تر کنیم.
  </p>
  <p>
   اگر روی یک microservice کار می‌کنید، ضروری است که یک جدایی واضح بین آنچه که می‌توان آزادانه تغییر داد و آنچه که نمی‌تواند داشته باشید. به صراحت، به عنوان یک توسعه‌دهنده شما باید بدانید چه زمانی در حال تغییر <strong>functionality</strong> هستید که بخشی از قراردادی است که <strong>service</strong> شما به دنیای بیرون نشان می‌دهد. شما باید اطمینان حاصل کنید که اگر تغییراتی ایجاد می‌کنید، <strong>consumers</strong> بالادستی را خراب نخواهید کرد. <strong>Functionality</strong> که بر قرارداد microservice شما تأثیری ندارد، می‌تواند بدون نگرانی تغییر کند.
  </p>
  <p>
   مطمئناً اینطور است که مشکلاتی که با <strong>common coupling</strong> رخ می‌دهد، در مورد <strong>content coupling</strong> نیز صدق می‌کند، اما <strong>content coupling</strong> دارای سردردهای اضافی است که آن را به اندازه‌ای مشکل‌ساز می‌کند که برخی از افراد از آن به عنوان <strong>pathological coupling</strong> یاد می‌کنند.
  </p>
  <p>
   وقتی به یک طرف خارجی اجازه می‌دهید مستقیماً به پایگاه داده شما دسترسی داشته باشد، پایگاه داده در واقع بخشی از آن قرارداد خارجی می‌شود، اگرچه جایی که شما نمی‌توانید به راحتی در مورد اینکه چه چیزی را می‌توان یا نمی‌توان تغییر داد، استدلال کنید. شما توانایی تعریف آنچه را که به اشتراک گذاشته شده است (و بنابراین نمی‌تواند به راحتی تغییر کند) و آنچه پنهان است، از دست داده‌اید. <strong>Information hiding</strong> از پنجره بیرون رفته است.
  </p>
  <p>
   به طور خلاصه، از <strong>content coupling</strong> اجتناب کنید.
  </p>
  <h4>Just Enough Domain-Driven Design</h4>
  <p>
   همانطور که در فصل 1 معرفی کردم، مکانیسم اصلی که ما برای یافتن <strong>microservice boundaries</strong> استفاده می‌کنیم، در اطراف خود <strong>domain</strong> است، و از <strong>domain-driven design (DDD)</strong> برای کمک به ایجاد مدلی از <strong>domain</strong> خود استفاده می‌کنیم. بیایید اکنون درک خود را از نحوه عملکرد <strong>DDD</strong> در زمینه microservices گسترش دهیم.
  </p>
  <p>
   تمایل به داشتن برنامه‌های ما که دنیای واقعی را که در آن فعالیت خواهند کرد بهتر نشان می‌دهد، چیز جدیدی نیست. زبان‌های برنامه‌نویسی شی‌گرا مانند <strong>Simula</strong> برای این توسعه داده شدند تا به ما اجازه دهند <strong>domains</strong> واقعی را مدل‌سازی کنیم. اما بیش از قابلیت‌های زبان برنامه‌نویسی برای تحقق این ایده لازم است.
  </p>
  <p>
   <em>Domain-Driven Design</em> نوشته <strong>Eric Evans</strong>11 مجموعه‌ای از ایده‌های مهم را ارائه کرد که به ما کمک کرد تا <strong>problem domain</strong> را در برنامه‌های خود بهتر نشان دهیم. بررسی کامل
  </p>
  <p>Just Enough Domain-Driven Design | 51</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>