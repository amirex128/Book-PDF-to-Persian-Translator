<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 100</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   تیم قبلاً روی یک ابزار مشابه، <strong>GoCD</strong>، که اکنون یک ابزار تحویل مداوم <strong>open source</strong> است که می‌تواند به صورت محلی مستقر شود، به جای میزبانی در <strong>cloud</strong>، کار می‌کرد.
  </p>
  <p>
   اگرچه در مراحل اولیه مقداری استفاده مجدد از کد بین پروژه‌های <strong>Snap CI</strong> و <strong>GoCD</strong> وجود داشت، اما در پایان <strong>Snap CI</strong> به یک <strong>codebase</strong> کاملاً جدید تبدیل شد. با این وجود، تجربه قبلی تیم در <strong>domain</strong> ابزار <strong>CD</strong> آنها را بر آن داشت تا در شناسایی <strong>boundaries</strong> و ساخت سیستم خود به عنوان مجموعه‌ای از microservices سریعتر عمل کنند.
  </p>
  <p>
   با این حال، پس از گذشت چند ماه، مشخص شد که موارد استفاده از <strong>Snap CI</strong> به اندازه کافی متفاوت است که برداشت اولیه از <strong>service boundaries</strong> کاملاً درست نبود.
  </p>
  <p>
   این امر منجر به ایجاد تغییرات زیادی در <strong>services</strong> شد، و یک هزینه مرتبط با تغییر زیاد. در نهایت، تیم <strong>services</strong> را دوباره در یک سیستم <strong>monolithic</strong> ادغام کرد، و به اعضای تیم زمان داد تا بهتر درک کنند که <strong>boundaries</strong> باید در کجا وجود داشته باشد. یک سال بعد، تیم توانست سیستم <strong>monolithic</strong> را به microservices تقسیم کند، که <strong>boundaries</strong> آن بسیار پایدارتر بود. این به هیچ وجه تنها نمونه از این وضعیت نیست که من دیده‌ام. تجزیه زودرس یک سیستم به microservices می‌تواند پرهزینه باشد، به خصوص اگر شما در <strong>domain</strong> جدید هستید. از بسیاری جهات، داشتن یک <strong>codebase</strong> موجود که می‌خواهید به microservices تجزیه کنید، به همین دلیل بسیار آسان‌تر است تا اینکه بخواهید از ابتدا به سمت microservices بروید.
  </p>
  <h4>چه چیزی را ابتدا تقسیم کنیم؟</h4>
  <p>
   هنگامی که شما درک کاملی از اینکه چرا فکر می‌کنید microservices یک ایده خوب است، دارید، می‌توانید از این درک برای کمک به اولویت‌بندی microservicesهایی که ابتدا ایجاد می‌کنید، استفاده کنید. آیا می‌خواهید برنامه را مقیاس‌بندی کنید؟ <strong>Functionality</strong> که در حال حاضر توانایی سیستم را در رسیدگی به بار محدود می‌کند، در صدر فهرست قرار خواهد داشت. آیا می‌خواهید زمان ورود به بازار را بهبود ببخشید؟ به فرّاریت سیستم نگاه کنید تا قطعات <strong>functionality</strong> را که بیشتر تغییر می‌کنند، شناسایی کنید، و ببینید که آیا آنها می‌توانند به عنوان microservices کار کنند یا خیر. شما می‌توانید از ابزارهای <strong>static analysis</strong> مانند <strong>CodeScene</strong> برای یافتن سریع بخش‌های فرّار <strong>codebase</strong> خود استفاده کنید. شما می‌توانید نمونه‌ای از یک نمای <strong>CodeScene</strong> را در شکل 3-1 ببینید، که در آن نقاط داغ را در پروژه <strong>open source Apache Zookeeper</strong> مشاهده می‌کنیم.
  </p>
  <p>
   اما شما همچنین باید در نظر بگیرید که چه تجزیه‌هایی امکان‌پذیر هستند. برخی از <strong>functionality</strong>ها می‌توانند به قدری عمیق در برنامه <strong>monolithic</strong> موجود قرار گیرند که دیدن نحوه جدا شدن آنها غیرممکن است. یا شاید <strong>functionality</strong> مورد نظر برای برنامه بسیار حیاتی است که هر تغییری پرخطر تلقی می‌شود. از طرف دیگر، <strong>functionality</strong> که می‌خواهید مهاجرت کنید، ممکن است از قبل تا حدودی خودمحور باشد، و بنابراین استخراج آن بسیار ساده به نظر می‌رسد.
  </p>
  <p>74 | Chapter 3: Splitting the Monolith</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>