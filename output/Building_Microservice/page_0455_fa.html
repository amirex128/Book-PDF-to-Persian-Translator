<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 455</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>تقسیم داده‌ها (ادامه)</h4>

  <p>درست کردن <strong>partition key</strong> می‌تواند دشوار باشد. در شکل 13-5، ما از یک طرح تقسیم‌بندی نسبتاً ساده استفاده کردیم، که در آن حجم کار را بر اساس نام خانوادگی مشتری تقسیم کردیم. مشتریانی که نام خانوادگی آنها با A–M شروع می‌شود به پارتیشن 1 می‌روند و مشتریانی که نامشان با N–Z شروع می‌شود به پارتیشن 2 می‌روند. همانطور که در هنگام اشتراک این مثال اشاره کردم، این یک استراتژی تقسیم‌بندی خوب نیست. با تقسیم داده‌ها، ما توزیع یکنواخت بار را می‌خواهیم. اما ما نمی‌توانیم انتظار توزیع یکنواخت را با طرحی که من شرح داده‌ام داشته باشیم. به عنوان مثال، در چین، از نظر تاریخی تعداد بسیار کمی نام خانوادگی وجود داشته است و حتی امروزه تعداد آنها کمتر از 4000 تخمین زده می‌شود. 100 نام خانوادگی محبوب، که بیش از 80٪ از جمعیت را تشکیل می‌دهند، به شدت به سمت آن نام‌های خانوادگی که با N–Z در ماندارین شروع می‌شوند، متمایل هستند. این نمونه‌ای از یک طرح مقیاس‌بندی است که بعید است توزیع یکنواخت بار را ارائه دهد، و در سراسر کشورها و فرهنگ‌های مختلف می‌تواند نتایج بسیار متفاوتی را به همراه داشته باشد.</p>

  <p>یک جایگزین معقول‌تر ممکن است تقسیم‌بندی بر اساس یک شناسه منحصربه‌فرد باشد که هنگام ثبت‌نام به هر مشتری داده می‌شود. این احتمالاً به ما توزیع یکنواختی از بار می‌دهد و همچنین با موقعیتی که در آن شخصی نام خود را تغییر می‌دهد، مقابله می‌کند.</p>

  <p>افزودن پارتیشن‌های جدید به یک طرح موجود اغلب می‌تواند بدون دردسر زیاد انجام شود. به عنوان مثال، افزودن یک <strong>node</strong> جدید به یک حلقه Cassandra نیازی به متعادل‌سازی مجدد دستی داده‌ها ندارد. در عوض، Cassandra پشتیبانی داخلی برای توزیع پویا داده‌ها در سراسر <strong>nodes</strong> دارد. Kafka همچنین اضافه کردن پارتیشن‌های جدید را پس از واقعیت نسبتاً آسان می‌کند، اگرچه پیام‌هایی که قبلاً در یک پارتیشن قرار دارند جابجا نمی‌شوند—اما تولیدکنندگان و مصرف‌کنندگان می‌توانند به طور پویا مطلع شوند.</p>

  <p>وقتی متوجه می‌شوید که طرح پارتیشن‌بندی شما فقط برای هدف مناسب نیست، مانند مورد طرح مبتنی بر نام خانوادگی ما که قبلاً توضیح داده شد، اوضاع پیچیده‌تر می‌شود. در آن موقعیت، ممکن است یک راه دردناک در پیش داشته باشید. من به یاد دارم که سال‌ها پیش با یک مشتری چت می‌کردم که در نهایت مجبور شد سیستم تولید اصلی خود را به مدت سه روز آفلاین کند تا طرح پارتیشن‌بندی را برای پایگاه داده اصلی خود تغییر دهد.</p>

  <p>ما همچنین می‌توانیم به مشکلی در مورد <strong>queries</strong> برخورد کنیم. جستجوی یک رکورد واحد آسان است، زیرا من فقط می‌توانم تابع هشینگ را اعمال کنم تا بفهمم داده‌ها باید در کدام نمونه قرار گیرند و سپس آن را از <strong>shard</strong> صحیح بازیابی کنم. اما <strong>queries</strong> که داده‌ها را در چندین <strong>node</strong> در بر می‌گیرند، چطور؟—به عنوان مثال، یافتن همه مشتریانی که بالای 18 سال سن دارند؟ اگر می‌خواهید به تمام <strong>shards</strong> پرس و جو کنید، باید یا به هر <strong>shard</strong> جداگانه پرس و جو کنید و در حافظه به هم بپیوندید یا یک انبار خواندن جایگزین داشته باشید که در آن هر دو مجموعه داده در دسترس باشند. اغلب، <strong>querying</strong> در سراسر <strong>shards</strong> توسط یک مکانیزم ناهمزمان، با استفاده از نتایج <strong>cached</strong> انجام می‌شود. به عنوان مثال، Mongo از کارهای <strong>map/reduce</strong> برای انجام این <strong>queries</strong> استفاده می‌کند.</p>

  <p>همانطور که ممکن است از این بررسی اجمالی استنباط کرده باشید، مقیاس‌بندی پایگاه‌های داده برای نوشتن جایی است که اوضاع بسیار پیچیده می‌شود، و جایی که قابلیت‌های پایگاه‌های داده مختلف واقعاً شروع به تمایز می‌کنند. من اغلب می‌بینم که مردم فناوری پایگاه داده را تغییر می‌دهند، وقتی شروع به رسیدن به محدودیت‌هایی در مورد میزان سهولت مقیاس‌بندی حجم نوشتن موجود خود می‌کنند.</p>

  <p>اگر این اتفاق برای شما افتاد، خرید یک <strong>box</strong> بزرگتر اغلب سریع‌ترین راه برای حل</p>
  <p>چهار محور مقیاس‌پذیری | 429</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>