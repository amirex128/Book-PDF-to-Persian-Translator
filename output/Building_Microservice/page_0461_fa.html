<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 461</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>شروع کوچک (ادامه)</h4>

  <p>رویکرد سریع‌تری برای شروع. نگرانی‌های من در مورد پیچیدگی پیاده‌سازی به <strong>event sourcing</strong> گسترش می‌یابد—موقعیت‌هایی وجود دارد که واقعاً مناسب هستند، اما با مجموعه‌ای از سردردها همراه است که باید در نظر گرفته شوند. هر دو الگو به یک تغییر اساسی در تفکر برای توسعه‌دهندگان نیاز دارند، که همیشه کارها را چالش‌برانگیزتر می‌کند. اگر تصمیم به استفاده از هر یک از این الگوها گرفتید، فقط مطمئن شوید که این بار شناختی افزایش یافته برای توسعه‌دهندگان شما ارزشش را دارد.</p>

  <p>یک نکته پایانی در مورد <strong>CQRS</strong> و <strong>event sourcing</strong>: از دیدگاه معماری <strong>microservice</strong>، تصمیم به استفاده یا عدم استفاده از این تکنیک‌ها یک جزئیات پیاده‌سازی داخلی <strong>microservice</strong> است. اگر تصمیم گرفته‌اید <strong>microservice</strong> را با تقسیم مسئولیت خواندن و نوشتن در فرآیندها و مدل‌های مختلف پیاده‌سازی کنید، به عنوان مثال، این باید برای مصرف‌کنندگان <strong>microservice</strong> نامرئی باشد. اگر درخواست‌های ورودی نیاز به هدایت مجدد به مدل مناسب بر اساس درخواست ارائه شده دارند، این را به مسئولیت <strong>microservice</strong> که <strong>CQRS</strong> را پیاده‌سازی می‌کند، بسپارید. پنهان نگه داشتن این جزئیات پیاده‌سازی از مصرف‌کنندگان، انعطاف‌پذیری زیادی را برای تغییر نظر شما در آینده یا تغییر نحوه استفاده از این الگوها به شما می‌دهد.</p>

  <h4><strong>Caching</strong></h4>

  <p><strong>Caching</strong> یک بهینه‌سازی عملکرد است که معمولاً مورد استفاده قرار می‌گیرد که بر اساس آن نتیجه قبلی برخی عملیات ذخیره می‌شود تا درخواست‌های بعدی بتوانند از این مقدار ذخیره شده استفاده کنند تا اینکه زمان و منابع را برای محاسبه مجدد مقدار صرف کنند.</p>

  <p>به عنوان مثال، <strong>microservice</strong> توصیه‌ها را در نظر بگیرید که باید سطح موجودی را قبل از توصیه یک مورد بررسی کند—هیچ نقطه‌ای برای توصیه چیزی که ما در انبار نداریم وجود ندارد! اما ما تصمیم گرفته‌ایم یک کپی محلی از سطوح موجودی را در توصیه (نوعی <strong>client-side caching</strong>) نگه داریم تا <strong>latency</strong> عملیات خود را بهبود بخشیم—ما از نیاز به بررسی سطح موجودی هر زمان که نیاز به توصیه چیزی داشته باشیم، اجتناب می‌کنیم. منبع حقیقت برای سطوح موجودی، <strong>microservice</strong> موجودی است، که به عنوان منشأ <strong>cache client</strong> در <strong>microservice</strong> توصیه‌ها در نظر گرفته می‌شود. وقتی Recommendation نیاز به جستجوی یک سطح موجودی دارد، ابتدا می‌تواند به <strong>cache</strong> محلی خود نگاه کند. اگر ورودی مورد نیاز آن یافت شود، این یک <strong>cache hit</strong> در نظر گرفته می‌شود. اگر داده‌ها یافت نشد، یک <strong>cache miss</strong> است، که منجر به نیاز به دریافت اطلاعات از <strong>microservice</strong> موجودی پایین‌دستی می‌شود. از آنجا که داده‌ها در مبدأ، البته می‌توانند تغییر کنند، ما به نوعی راهی برای بی‌اعتبار کردن ورودی‌ها در <strong>cache</strong> توصیه‌ها نیاز داریم تا بدانیم چه زمانی داده‌های <strong>cached</strong> محلی آنقدر قدیمی شده‌اند که دیگر نمی‌توان از آنها استفاده کرد.</p>

  <p><strong>Caches</strong> می‌توانند نتایج جستجوهای ساده را ذخیره کنند، همانطور که در این مثال، اما واقعاً آنها می‌توانند هر قطعه‌ای از داده‌ها را ذخیره کنند، مانند نتیجه یک محاسبه پیچیده. ما می‌توانیم <strong>cache</strong> کنیم تا به بهبود عملکرد سیستم خود به عنوان بخشی از کمک به کاهش <strong>latency</strong>، برای مقیاس‌بندی برنامه خود و در برخی موارد حتی برای بهبود <strong>robustness</strong> سیستم خود کمک کنیم. با در نظر گرفتن این واقعیت که تعدادی از مکانیسم‌های <strong>invalidation</strong> وجود دارد که می‌توانیم از آنها استفاده کنیم، و مکان‌های متعددی که می‌توانیم <strong>cache</strong> کنیم، به این معنی است که ما تعداد زیادی</p>
  <p><strong>Caching</strong> | 435</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>