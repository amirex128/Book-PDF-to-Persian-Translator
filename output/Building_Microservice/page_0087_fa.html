<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 87</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   16 <strong>Alberto Brandolini</strong>, <strong>EventStorming</strong> (Victoria, BC: Leanpub, forthcoming).
  </p>
  <p>
   در مرحله بعد، شرکت‌کنندگان دستوراتی را شناسایی می‌کنند که باعث می‌شوند این <strong>events</strong> اتفاق بیفتند. یک <strong>command</strong> تصمیمی است که توسط یک انسان (یک کاربر نرم‌افزار) برای انجام کاری گرفته می‌شود. در اینجا شما در تلاشید تا <strong>boundary</strong> سیستم را درک کنید، و <strong>key human actors</strong> را در سیستم شناسایی کنید. <strong>Commands</strong> روی یادداشت‌های چسبنده آبی ثبت می‌شوند.
  </p>
  <p>
   متخصصان فناوری در جلسه <strong>event storming</strong> باید به آنچه که همکاران غیرفنی خود در اینجا ارائه می‌دهند، گوش فرا دهند. یک بخش کلیدی از این تمرین این است که اجازه ندهید هیچ پیاده‌سازی فعلی، درک <strong>domain</strong> را تحریف کند (این بعداً خواهد آمد). در این مرحله شما می‌خواهید فضایی ایجاد کنید که در آن بتوانید مفاهیم را از ذهن ذی‌نفعان کلیدی خارج کنید و در معرض دید قرار دهید.
  </p>
  <p>
   با ثبت <strong>events</strong> و <strong>commands</strong>، <strong>aggregates</strong> در مرحله بعد می‌آیند. <strong>events</strong> که در این مرحله دارید، نه تنها برای به اشتراک گذاشتن آنچه در سیستم اتفاق می‌افتد مفید هستند، بلکه شروع به برجسته کردن اینکه <strong>aggregates</strong> بالقوه چه چیزی می‌توانند باشند، می‌کنند. به رویداد <strong>domain</strong> ذکر شده "<strong>Order Placed</strong>" فکر کنید. اسم در اینجا—“<strong>Order</strong>”—می‌تواند یک <strong>aggregate</strong> بالقوه باشد. و "<strong>Placed</strong>" چیزی را توصیف می‌کند که می‌تواند برای یک سفارش اتفاق بیفتد، بنابراین این ممکن است بخشی از چرخه عمر <strong>aggregate</strong> باشد. <strong>Aggregates</strong> با یادداشت‌های چسبنده زرد نشان داده می‌شوند، و <strong>commands</strong> و <strong>events</strong> مرتبط با آن <strong>aggregate</strong> جابه‌جا می‌شوند و در اطراف <strong>aggregate</strong> خوشه‌بندی می‌شوند. این همچنین به شما کمک می‌کند تا درک کنید که <strong>aggregates</strong> چگونه با یکدیگر مرتبط هستند—<strong>events</strong> از یک <strong>aggregate</strong> ممکن است رفتاری را در دیگری ایجاد کند.
  </p>
  <p>
   با شناسایی <strong>aggregates</strong>، آنها در <strong>bounded contexts</strong> گروه‌بندی می‌شوند. <strong>Bounded contexts</strong> معمولاً ساختار سازمانی یک شرکت را دنبال می‌کنند، و شرکت‌کنندگان در این تمرین در موقعیت خوبی قرار دارند تا درک کنند که چه <strong>aggregates</strong> توسط کدام بخش از سازمان استفاده می‌شود.
  </p>
  <p>
   بیشتر از آنچه که من فقط توصیف کردم، برای <strong>event storming</strong> وجود دارد—این فقط به عنوان یک مرور اجمالی در نظر گرفته شده بود. برای نگاه دقیق‌تر به <strong>event storming</strong>، پیشنهاد می‌کنم کتاب (در حال حاضر در حال انجام) <strong>EventStorming</strong> توسط <strong>Alberto Brandolini</strong> (<strong>Leanpub</strong>) را مطالعه کنید.16
  </p>
  <h4>The Case for Domain-Driven Design for Microservices</h4>
  <p>
   ما بررسی کرده‌ایم که چگونه <strong>DDD</strong> می‌تواند در زمینه microservices کار کند، بنابراین بیایید خلاصه کنیم که چگونه این رویکرد برای ما مفید است.
  </p>
  <p>
   اولاً، بخش بزرگی از آنچه که <strong>DDD</strong> را بسیار قدرتمند می‌کند این است که <strong>bounded contexts</strong>، که برای <strong>DDD</strong> بسیار مهم هستند، صریحاً در مورد پنهان کردن اطلاعات هستند—ارائه یک <strong>boundary</strong> روشن به سیستم گسترده‌تر در حالی که پیچیدگی داخلی را که می‌تواند بدون تأثیر بر سایر بخش‌های سیستم تغییر کند، پنهان می‌کند. این بدان معناست که وقتی ما از یک رویکرد <strong>DDD</strong> پیروی می‌کنیم، خواه متوجه آن شویم یا نه، ما همچنین <strong>information hiding</strong> را اتخاذ می‌کنیم—و همانطور که دیده‌ایم، این برای کمک به یافتن <strong>microservice boundaries</strong> پایدار حیاتی است.
  </p>
  <p>The Case for Domain-Driven Design for Microservices | 61</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>