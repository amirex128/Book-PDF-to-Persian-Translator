<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 472</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4><strong>Invalidation</strong> (ادامه)</h4>

  <p>واقعاً تغییر کرده است. اگر یک رویداد <strong>heartbeat</strong> دریافت نشود، <strong>client</strong> می‌تواند یک مشکل را فرض کند و می‌تواند هر کاری را که مناسب‌تر است انجام دهد—شاید به یک کاربر اطلاع دهد که داده‌های قدیمی را می‌بیند، یا شاید فقط عملکرد را خاموش کند.</p>

  <p>شما همچنین باید در نظر بگیرید که اعلان شامل چه چیزی است. اگر اعلان فقط می‌گوید "این چیز تغییر کرده است" بدون اینکه بگوید تغییر چیست، پس هنگام دریافت اعلان، یک مصرف‌کننده باید به مبدأ برود و داده‌های جدید را دریافت کند. از سوی دیگر، اگر اعلان شامل وضعیت فعلی داده‌ها باشد، مصرف‌کنندگان می‌توانند آن را مستقیماً در <strong>cache</strong> محلی خود بارگذاری کنند. داشتن یک اعلان که حاوی داده‌های بیشتری است می‌تواند باعث ایجاد مشکلاتی در رابطه با اندازه شود و همچنین خطر بالقوه قرار دادن داده‌های حساس را به طور گسترده ایجاد می‌کند. ما قبلاً این معاوضه را با نگاهی به ارتباطات مبتنی بر رویداد در "What’s in an Event?" در صفحه 111 با جزئیات بیشتری بررسی کردیم.</p>

  <h4><strong>Write-through</strong></h4>

  <p>با یک <strong>write-through cache</strong>، <strong>cache</strong> همزمان با حالت مبدأ به‌روزرسانی می‌شود. "همزمان" جایی است که <strong>caches write-through</strong> دشوار می‌شوند، البته. پیاده‌سازی یک مکانیسم <strong>write-through</strong> در یک <strong>cache server-side</strong> تا حدودی ساده است، زیرا شما می‌توانید یک پایگاه داده و یک <strong>cache in-memory</strong> را در همان تراکنش بدون مشکل زیاد به‌روزرسانی کنید. اگر <strong>cache</strong> در جای دیگری باشد، استدلال در مورد اینکه "همزمان" به معنای به‌روزرسانی این ورودی‌ها است، دشوارتر است.</p>

  <p>به دلیل این دشواری، شما معمولاً می‌بینید که <strong>caching write-through</strong> در معماری <strong>microservice</strong> در سمت سرور استفاده می‌شود. مزایای آن کاملاً واضح است—پنجره‌ای که در آن یک <strong>client</strong> ممکن است داده‌های قدیمی را ببیند، می‌تواند عملاً حذف شود. این امر در مقابل این واقعیت متعادل است که <strong>caches server-side</strong> ممکن است به طور کلی کمتر مفید باشند، که شرایطی را محدود می‌کند که در آن یک <strong>cache write-through</strong> در <strong>microservices</strong> مؤثر خواهد بود.</p>

  <h4><strong>Write-behind</strong></h4>

  <p>با یک <strong>write-behind cache</strong>، خود <strong>cache</strong> ابتدا به‌روزرسانی می‌شود، و سپس مبدأ به‌روزرسانی می‌شود. از نظر مفهومی، شما می‌توانید <strong>cache</strong> را به عنوان یک بافر در نظر بگیرید. نوشتن در <strong>cache</strong> سریعتر از به‌روزرسانی مبدأ است. بنابراین ما نتیجه را در <strong>cache</strong> می‌نویسیم، که امکان خواندن‌های بعدی سریعتر را فراهم می‌کند، و اطمینان داریم که مبدأ پس از آن به‌روزرسانی می‌شود.</p>

  <p>نگرانی اصلی در مورد <strong>caches write-behind</strong> به طور بالقوه از دست رفتن داده‌ها خواهد بود. اگر خود <strong>cache</strong> بادوام نباشد، ما می‌توانیم داده‌ها را قبل از نوشته شدن داده‌ها به مبدأ از دست بدهیم. علاوه بر این، ما اکنون در یک نقطه جالب هستیم—مبدأ در این زمینه چیست؟ ما انتظار داریم که مبدأ، <strong>microservice</strong> باشد که این داده‌ها از آن منبع گرفته شده‌اند—اما اگر ابتدا <strong>cache</strong> را به‌روزرسانی کنیم، آیا این واقعاً مبدأ است؟ منبع حقیقت ما چیست؟ هنگام استفاده از <strong>caching</strong>، مهم است که داده‌های <strong>cached</strong> (و احتمالاً منسوخ شده) و داده‌هایی را که می‌توان در واقع</p>

  <p>446 | فصل 13: مقیاس‌پذیری</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>