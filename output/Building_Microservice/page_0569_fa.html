<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 569</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <h4>ساختار سازمانی</h4>

  <p>7 <em>Paul Ingles</em>, “Convergence to Kubernetes,” <em>Medium</em>, June 18, 2018, <a href="https://oreil.ly/ON81J">https://oreil.ly/ON81J</a>.</p>

  <p>داشتن یک معماری <strong>microservice</strong> مشترک، آسان‌تر خواهد بود، و همچنین، ممکن است مشکلات را کاهش دهد.
   برای کمک به هماهنگی بین تمام اعضای یک تیم، در اینجا دو اصل وجود دارد:</p>

  <ul>
   <li>نقطه تماس، یعنی فردی که می‌تواند در مورد عملکردها و درخواست‌های تیم مشاوره دهد.</li>
   <li>مدرک کتبی یا <strong>API</strong> برای نحوه انجام کارها.</li>
  </ul>

  <p>هر دو این اصول نیز در ساختار سازمانی مفید هستند. (<em>API</em> تیمی می‌تواند به عنوان یک <strong>guideline</strong> عمل کند.)</p>

  <p>برای این منظور، <em>REA</em> از تیم‌های <strong>cross-functional</strong> استفاده می‌کند. این بدان معناست که هر تیم <em>full stack</em> است—معمار، <strong>frontend</strong>، <strong>backend</strong>، <em>testers</em> و <em>product owner</em>ها در داخل تیم‌ها فعالیت می‌کنند. این امر به تیم‌های <em>REA</em> اجازه می‌دهد تا با سرعت بیشتری کار کنند، با حداقل تعامل با تیم‌های دیگر—به طور مشابه، برای همه <strong>microservices</strong> آنها، تیم‌ها از یک <em>code repository</em> استفاده می‌کنند.</p>

  <p>به منظور ایجاد یک ساختار عالی و پایدار، از <strong>APIs</strong> استفاده کنید. این به شما کمک می‌کند تا بدانید که آیا شما یک <strong>API</strong> خوب را پیاده‌سازی کرده‌اید یا خیر. در این مورد، <em>REA</em> استفاده از یک <strong>API</strong> برای دسترسی به اطلاعات را تشویق می‌کند. این به شما کمک می‌کند تا دریابید آیا شما به طور مؤثر این <strong>API</strong> را ساخته‌اید یا خیر.</p>

  <p>به نظر می‌رسد که مزایای اصلی از ساختار <strong>stream-aligned</strong> که <em>REA</em> از آن استفاده می‌کند، این است که به شما اجازه می‌دهد تا <strong>CI/CD</strong> را به درستی انجام دهید. <em>CI/CD</em>، شامل:
   • اجرای تست‌های واحد خودکار
   • استقرار تغییرات به صورت خودکار
   • ارائه بازخورد فوری به توسعه‌دهندگان در مورد هر تغییری که انجام داده‌اند.</p>

  <p>مزیت کلیدی معماری <strong>microservices</strong> در سطح سازمانی، این است که توسعه‌دهندگان می‌توانند بر روی یک مؤلفه متمرکز شوند، در حالی که بقیه، روی بخش‌های دیگر کار می‌کنند.</p>

  <p>با این حال، هم‌افزایی می‌تواند مشکل‌ساز باشد. زمانی که <strong>teams</strong> سعی می‌کنند راه‌حل‌های مشترک را مجدداً استفاده کنند، مشکلات ممکن است ظاهر شوند—به عنوان مثال، اگر <em>teams</em> در حال تلاش برای به اشتراک گذاشتن کد منبع باشند، ممکن است به <em>coupling</em> بیشتر منجر شود.</p>

  <p>این موضوع را می‌توان به عنوان "بازگشت به جاده" تصور کرد. برای حل مشکلات پیچیده، شما معمولاً به <em>guidelines</em> و فرآیندها نیاز دارید، که آنها را به سمت همسویی سوق می‌دهد. این بدان معناست که شما باید مطمئن باشید که افراد در حال استفاده از شیوه‌های مشترک در داخل تیم هستند.</p>

  <p>این رویکرد توسط <em>Netflix</em> در آغوش گرفته شده است. "قانون <em>Conway</em>" می‌گوید که معماری شما، معماری است که تیم‌ها با آن ارتباط برقرار می‌کنند، و همچنین به این معناست که برای ایجاد بهترین معماری، باید به چگونگی ساختار تیم‌ها توجه کنید.</p>

  <h4>استاندارد مورد نیاز</h4>

  <p>هنگامی که شما در حال کار بر روی عملکردهای خود هستید و در مورد مبادلاتی که باید انجام دهید فکر می‌کنید، یکی از مهم‌ترین تعادل‌هایی که باید پیدا کنید این است که چه مقدار تغییرپذیری باید در سیستم خود مجاز کنید. یکی از راه‌های کلیدی برای شناسایی آنچه باید از <strong>microservice</strong> به <strong>microservice</strong> ثابت باشد، تعریف این است که یک <strong>microservice</strong> خوش رفتار و خوب چگونه به نظر می‌رسد. یک <strong>microservice</strong> "شهروند خوب" در سیستم شما چیست؟ چه قابلیت‌هایی باید داشته باشد تا اطمینان حاصل شود که سیستم شما قابل مدیریت است و یک <strong>microservice</strong> بد، کل سیستم را از کار نمی‌اندازد؟ همانطور که در مورد افراد نیز صدق می‌کند، آنچه یک <strong>microservice</strong> "شهروند خوب" است در یک زمینه، منعکس‌کننده آنچه در جای دیگری به نظر می‌رسد، نیست. با این وجود، برخی از ویژگی‌های مشترک <strong>microservices</strong> خوش رفتار وجود دارد که فکر می‌کنم مشاهده آنها نسبتاً مهم است. اینها چند مورد از حوزه‌های کلیدی هستند که در آنها اجازه دادن به واگرایی زیاد می‌تواند منجر به یک زمان بسیار وحشتناک شود. همانطور که <em>Ben Christensen</em> از <em>Facebook</em> بیان می‌کند، وقتی به تصویر بزرگتر فکر می‌کنید، "باید یک سیستم منسجم باشد که از بخش‌های کوچک بسیاری تشکیل شده باشد، اما همه در کنار هم قرار می‌گیرند." بنابراین شما باید تعادلی پیدا کنید که در آن خودمختاری <strong>microservices</strong> فردی را بهینه کنید بدون اینکه از تصویر بزرگتر غافل شوید. تعریف ویژگی‌های واضحی که هر <strong>microservice</strong> باید داشته باشد، یک راه برای روشن بودن در مورد محل قرارگیری این تعادل است. بیایید به برخی از آن ویژگی‌ها بپردازیم.</p>

  <h4>نظارت</h4>

  <p>ضروری است که ما بتوانیم دیدگاه‌های منسجم و متقابل سرویسی از سلامت سیستم خود ترسیم کنیم. این باید یک دیدگاه در سطح سیستم باشد، نه یک دیدگاه مختص <strong>microservice</strong>. همانطور که در فصل 10 بحث کردیم، دانستن سلامت یک <strong>microservice</strong> فردی مفید است، اما اغلب فقط زمانی که شما در تلاش هستید تا یک مشکل گسترده‌تر را تشخیص دهید یا یک روند بزرگ‌تر را درک کنید. برای آسان کردن این کار تا حد امکان، من پیشنهاد می‌کنم که اطمینان حاصل کنید که همه <strong>microservices</strong>، معیارهای مرتبط با سلامت و پایش عمومی را به روشی یکسان منتشر می‌کنند.
   شما ممکن است یک مکانیزم <strong>push</strong> را انتخاب کنید، که در آن هر <strong>microservice</strong> نیاز به فشار دادن این داده‌ها به یک مکان مرکزی دارد. هر چه را انتخاب می‌کنید، سعی کنید آن را استاندارد نگه دارید. فناوری داخل <strong>box</strong> را <em>opaque</em> کنید، و از سیستم‌های نظارتی خود نخواهید که برای پشتیبانی از آن تغییر کنند. <em>Logging</em> در اینجا در همان دسته قرار می‌گیرد: ما به آن در یک مکان نیاز داریم.
   رابط‌ها</p>

  <p>انتخاب تعداد کمی از فناوری‌های رابط تعریف‌شده به یکپارچه‌سازی مصرف‌کنندگان جدید کمک می‌کند. داشتن یک استاندارد خوب است. دوتا هم خیلی بد نیست. داشتن بیست سبک مختلف ادغام خوب نیست. این فقط در مورد انتخاب فناوری و پروتکل نیست. به عنوان مثال، اگر <em>HTTP/REST</em> را انتخاب کنید، آیا از فعل‌ها یا اسم‌ها استفاده می‌کنید؟ چگونه صفحه بندی منابع را مدیریت خواهید کرد؟ چگونه نسخه‌سازی <em>endpoints</em> را مدیریت خواهید کرد؟</p>

  <p>استاندارد مورد نیاز | 543</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>