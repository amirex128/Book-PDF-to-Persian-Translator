<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 398</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
            <div>
    <p>هنگامی که شما از <em>HTTPS</em> ساده قدیمی یا <em>mutual TLS</em> استفاده می‌کنید، داده‌ها برای طرف‌های واسطه قابل مشاهده نخواهند بود—این به این دلیل است که <em>TLS</em> داده‌های ارسالی را رمزگذاری می‌کند. این می‌تواند مشکل‌ساز باشد اگر شما صریحاً داده‌ها را در معرض دید قرار دهید—به عنوان مثال، <em>reverse proxies</em> (پراکسی‌های معکوس) مانند <em>Squid</em> یا <em>Varnish</em> قادر به <em>cache</em> (کش) کردن پاسخ‌های <em>HTTP</em> هستند، اما این با <em>HTTPS</em> امکان‌پذیر نیست.</p>
    <h5>Manipulation of data (دستکاری داده‌ها)</h5>
    <p>ما می‌توانیم تعدادی از موقعیت‌هایی را تصور کنیم که در آن دستکاری داده‌های ارسالی می‌تواند بد باشد—به عنوان مثال، تغییر میزان پولی که ارسال می‌شود. بنابراین در شکل 11-6، ما باید اطمینان حاصل کنیم که مهاجم بالقوه قادر به تغییر <em>request</em> (درخواست) ارسالی به <em>Payment</em> (پرداخت) از <em>Order Processor</em> (پردازشگر سفارش) نیست.</p>
    <p>به طور معمول، انواع حفاظت‌هایی که داده‌ها را نامرئی می‌کنند، همچنین اطمینان حاصل می‌کنند که داده‌ها نمی‌توانند دستکاری شوند (<em>HTTPS</em> این کار را انجام می‌دهد، به عنوان مثال). با این حال، ما می‌توانیم تصمیم بگیریم که داده‌ها را در معرض دید قرار دهیم اما همچنان می‌خواهیم اطمینان حاصل کنیم که نمی‌توان آنها را دستکاری کرد. برای <em>HTTP</em>، یک رویکرد این است که از یک <em>hash-based message authentication code</em> (<em>HMAC</em>) (کد احراز هویت پیام مبتنی بر هش) برای امضای داده‌های ارسالی استفاده کنیم. با <em>HMAC</em>، یک هش تولید می‌شود و همراه با داده‌ها ارسال می‌شود، و گیرنده می‌تواند هش را در برابر داده‌ها بررسی کند تا تأیید کند که داده‌ها تغییر نکرده‌اند.</p>
    <h5>Data at Rest (داده‌ها در حالت سکون)</h5>
    <p>داده‌های بی‌تحرک، یک مسئولیت است، به‌خصوص اگر حساس باشد. امیدواریم که ما هر کاری که می‌توانستیم انجام داده‌ایم تا اطمینان حاصل کنیم که مهاجمان نمی‌توانند به شبکه ما نفوذ کنند، و همچنین نمی‌توانند به برنامه‌ها یا سیستم‌های عامل ما نفوذ کنند تا به داده‌های اساسی دسترسی پیدا کنند. با این حال، ما باید آماده باشیم در صورت انجام این کار—<em>defense in depth</em> (دفاع در عمق) کلیدی است.</p>
    <p>بسیاری از نقض‌های امنیتی با مشخصات بالا که ما می‌شنویم، شامل داده‌های در حالت <em>rest</em> (سکون) است که توسط یک مهاجم به دست آمده، و آن داده‌ها توسط مهاجم قابل خواندن است. این اتفاق یا به این دلیل می‌افتد که داده‌ها در یک فرم غیر رمزگذاری شده ذخیره شده‌اند یا به این دلیل که مکانیسم مورد استفاده برای محافظت از داده‌ها، یک نقص اساسی داشته است.</p>
    <p>مکانیسم‌هایی که داده‌ها را در حالت <em>rest</em> (سکون) می‌توانند محافظت کنند، زیاد و متنوع هستند، اما چند مورد کلی وجود دارد که باید در نظر داشت.</p>
    <ul>
        <li>Go with the well known (با شناخته‌شده‌ها بروید)</li>
        <p>در برخی موارد، شما می‌توانید کار رمزگذاری داده‌ها را به نرم‌افزار موجود واگذار کنید—به عنوان مثال، با استفاده از پشتیبانی داخلی <em>database</em> (پایگاه داده) خود برای رمزگذاری. با این حال، اگر نیاز به رمزگذاری و رمزگشایی داده‌ها در سیستم خود پیدا کردید، اطمینان حاصل کنید که از پیاده‌سازی‌های شناخته‌شده و آزمایش شده استفاده می‌کنید. آسان‌ترین راهی که می‌توانید در رمزگذاری داده‌ها خرابکاری کنید، این است که سعی کنید الگوریتم‌های رمزگذاری خود را پیاده‌سازی کنید، یا حتی سعی کنید الگوریتم شخص دیگری را پیاده‌سازی کنید. هر زبان برنامه‌نویسی که استفاده می‌کنید، شما به پیاده‌سازی‌های بررسی‌شده و به‌روزرسانی‌شده مرتب رمزگذاری با اعتبار دسترسی خواهید داشت.</p>
    </ul>
    <p><em>372 | Chapter 11: Security</em></p>
</div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>