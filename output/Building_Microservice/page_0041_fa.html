<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 41</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   5 David Heinemeier Hansson, “The Majestic Monolith,” Signal v. Noise, February 29, 2016, https://oreil.ly/ WwG1C.
  </p>
  <p>
   آن را یک <strong>monolith</strong> در نظر بگیرید. مسلماً، معماری‌های متعددی با این تعریف مطابقت دارند، اما من در مورد مواردی که اغلب می‌بینم بحث خواهم کرد: <strong>single-process monolith</strong>، <strong>modular monolith</strong> و <strong>distributed monolith</strong>.
  </p>
  <h4>The Single-Process Monolith</h4>
  <p>
   متداول‌ترین مثالی که هنگام بحث در مورد <strong>monoliths</strong> به ذهن می‌رسد، سیستمی است که در آن همه کد به عنوان یک <strong>single process</strong> مستقر می‌شود، همانطور که در شکل 1-6 نشان داده شده است. ممکن است چندین نمونه از این <strong>process</strong> را به دلایل استحکام یا مقیاس‌پذیری داشته باشید، اما اساساً تمام کد در یک <strong>single process</strong> بسته‌بندی شده است. در واقعیت، این سیستم‌های <strong>single-process</strong> می‌توانند سیستم‌های توزیع‌شده ساده‌ای به خودی خود باشند زیرا تقریباً همیشه در نهایت داده‌ها را از یک پایگاه داده می‌خوانند یا داده‌ها را در یک پایگاه داده ذخیره می‌کنند، یا اطلاعات را به برنامه‌های وب یا تلفن همراه ارائه می‌دهند.
  </p>
  <p>
   شکل 1-6. در یک <strong>single-process monolith</strong>، همه کدها در یک <strong>single process</strong> بسته‌بندی می‌شوند
  </p>
  <p>
   اگرچه این با درک اکثر مردم از یک <strong>classic monolith</strong> مطابقت دارد، اما اکثر سیستم‌هایی که با آنها روبرو می‌شوم، کمی پیچیده‌تر از این هستند. ممکن است دو یا چند <strong>monolith</strong> داشته باشید که به یکدیگر <em>tightly coupled</em> هستند، که احتمالاً برخی از نرم‌افزارهای فروشنده نیز در آن وجود دارد.
  </p>
  <p>
   یک استقرار <strong>classic single-process monolithic</strong> می‌تواند برای بسیاری از سازمان‌ها منطقی باشد. David Heinemeier Hansson، خالق <strong>Ruby on Rails</strong>، به طور موثر این موضوع را مطرح کرده است که چنین معماری برای سازمان‌های کوچکتر منطقی است. 5 با این حال، حتی با رشد سازمان، <strong>monolith</strong> می‌تواند با آن رشد کند، که ما را به سمت <strong>modular monolith</strong> می‌برد.
  </p>
  <p>The Monolith | 15</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        <div class="page-image"><img src="page_0041/image_1.png" alt="Image from page 41" /></div>

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>