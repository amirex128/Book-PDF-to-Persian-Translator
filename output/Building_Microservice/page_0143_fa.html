<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 143</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   4 Gregor Hohpe and Bobby Woolf, Enterprise Integration Patterns (Boston: Addison-Wesley, 2003).
  </p>
  <p>
   من همچنین به شدت توصیه می‌کنم که <em>Enterprise Integration Patterns</em> نوشته <strong>Gregor Hohpe</strong> و <strong>Bobby Woolf</strong> را بررسی کنید،4 که جزئیات بیشتری در مورد الگوهای مختلف <strong>messaging</strong> که ممکن است بخواهید در این فضا در نظر بگیرید، دارد.
  </p>
  <p>
   با این حال، ما همچنین باید در مورد سبک‌های ادغام که ممکن است "ساده‌تر" در نظر بگیریم، صادق باشیم—مشکلات مرتبط با دانستن اینکه آیا کارها انجام شده‌اند یا خیر به اشکال ناهمزمان ادغام محدود نمی‌شود. با یک فراخوانی <strong>synchronous</strong>، <strong>blocking</strong>، اگر یک <strong>time-out</strong> دریافت کنید، آیا این به این دلیل اتفاق افتاده است که درخواست گم شده است و طرف پایین‌دست آن را دریافت نکرده است؟ یا آیا درخواست انجام شد، اما پاسخ گم شد؟ در آن موقعیت چه می‌کنید؟ اگر دوباره تلاش کنید، اما درخواست اصلی انجام شد، چه اتفاقی می‌افتد؟ (خوب، اینجاست که <strong>idempotency</strong> وارد می‌شود، موضوعی که ما در فصل 12 پوشش می‌دهیم.)
  </p>
  <p>
   به‌طور مسلم، با توجه به رسیدگی به شکست، فراخوانی‌های <strong>synchronous blocking</strong> می‌تواند باعث ایجاد سردردهای زیادی در ما شود، زمانی که صحبت از مشخص کردن این است که آیا اتفاقاتی افتاده است (یا نه). فقط این است که آن سردردها ممکن است برای ما آشنا‌تر باشند!
  </p>
  <h4>خلاصه</h4>
  <p>
   در این فصل، من برخی از سبک‌های اصلی ارتباط microservice را شکسته‌ام و در مورد مبادله‌های مختلف بحث کردم. همیشه یک گزینه درست وجود ندارد، اما امیدوارم اطلاعات کافی در مورد فراخوانی‌های <strong>synchronous</strong> و <strong>asynchronous</strong> و سبک‌های ارتباطی <strong>event-driven</strong> و <strong>request-response</strong> ارائه کرده باشم تا به شما در انجام فراخوانی صحیح برای <strong>context</strong> داده شده‌تان کمک کنم. سوگیری‌های من نسبت به همکاری ناهمزمان و <strong>event-driven</strong>، نه تنها تابعی از تجربیات من، بلکه همچنین از بیزاری من از <em>coupling</em> به طور کلی است. اما این سبک از ارتباط با پیچیدگی قابل توجهی همراه است که نمی‌توان آن را نادیده گرفت، و هر موقعیتی منحصربه‌فرد است.
  </p>
  <p>
   در این فصل، من به طور خلاصه به چند فناوری خاص اشاره کردم که می‌توانند برای پیاده‌سازی این سبک‌های تعامل استفاده شوند. ما اکنون برای شروع بخش دوم این کتاب—پیاده‌سازی—آماده‌ایم. در فصل بعد، ما به بررسی پیاده‌سازی ارتباط microservice با جزئیات بیشتر خواهیم پرداخت.
  </p>
  <p>Summary | 117</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>