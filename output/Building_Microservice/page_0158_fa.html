<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 158</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p><em>required</em> برای هر عملیات. در نهایت، این یک <em>trade-off</em> است. اگر تصمیم به اتخاذ یک سبک <em>HATEOAS</em> از <em>REST</em> گرفتید، پیشنهاد می‌کنم ابتدا <em>clients</em> خود را به این <em>controls</em> هدایت کنید و سپس در صورت لزوم بعداً بهینه‌سازی کنید. به یاد داشته باشید که استفاده از <em>HTTP</em> مقدار زیادی کمک <em>out of the box</em> را در اختیار ما قرار می‌دهد، که قبلاً در مورد آن بحث کردیم.</p>
  <p>بدی‌های <em>premature optimization</em> قبلاً به خوبی مستند شده‌اند، بنابراین نیازی نیست که در اینجا به آن‌ها بپردازم. همچنین توجه داشته باشید که بسیاری از این رویکردها برای ایجاد <em>distributed hypertext systems</em> توسعه یافته‌اند و همه آن‌ها مناسب نیستند! گاهی اوقات شما فقط <em>good old-fashioned RPC</em> را می‌خواهید.</p>
  <p>با وجود این معایب، <em>REST over HTTP</em> یک انتخاب پیش‌فرض منطقی برای تعاملات <em>service-to-service</em> است. اگر می‌خواهید بیشتر بدانید، من کتاب <em>REST in Practice: Hypermedia and Systems Architecture (O’Reilly)</em> نوشته <em>Jim Webber, Savas Parastatidis</em> و <em>Ian Robinson</em> را توصیه می‌کنم، که موضوع <em>REST over HTTP</em> را به طور عمیق پوشش می‌دهد.</p>
  <h4>کجا از آن استفاده کنیم</h4>
  <p>با توجه به استفاده گسترده آن در صنعت، یک <em>REST-over-HTTP-based API</em> یک انتخاب آشکار برای یک <em>synchronous request-response interface</em> است، اگر به دنبال دسترسی از طیف وسیعی از <em>clients</em> ممکن هستید. این یک اشتباه خواهد بود که به یک <em>REST API</em> به عنوان یک انتخاب "به اندازه کافی خوب برای اکثر موارد" فکر کنیم، اما چیزی در این مورد وجود دارد. این یک سبک <em>interface</em> است که به طور گسترده درک می‌شود که اکثر مردم با آن آشنا هستند، و <em>interoperability</em> را از طیف وسیعی از فناوری‌ها تضمین می‌کند.</p>
  <p>عمدتاً به دلیل قابلیت‌های <em>HTTP</em> و میزان <em>REST</em> که بر اساس این قابلیت‌ها ساخته شده است (به جای پنهان کردن آن‌ها)، <em>REST-based APIs</em> در موقعیت‌هایی که می‌خواهید <em>caching</em> بزرگ و مؤثر از <em>requests</em> داشته باشید، عالی هستند. به همین دلیل است که آن‌ها انتخاب‌های آشکاری برای قرار دادن <em>APIs</em> در معرض <em>external parties</em> یا <em>client interfaces</em> هستند. با این حال، آن‌ها ممکن است در مقایسه با <em>communication protocols</em> کارآمدتر رنج ببرند، و اگرچه می‌توانید <em>asynchronous interaction protocols</em> را بر روی <em>REST-based APIs</em> بسازید، اما این واقعاً با توجه به جایگزین‌ها برای ارتباط عمومی <em>microservice-to-microservice</em> مناسب نیست.</p>
  <p>با وجود قدردانی فکری از اهداف پشت <em>HATEOAS</em>، من شواهد زیادی مبنی بر اینکه کار اضافی برای پیاده‌سازی این سبک از <em>REST</em>، مزایای ارزشمندی را در درازمدت ارائه می‌دهد، ندیده‌ام، و همچنین نمی‌توانم در چند سال گذشته به یاد بیاورم که با هیچ تیمی در حال پیاده‌سازی یک معماری <em>microservice</em> صحبت کرده باشم که بتواند در مورد ارزش استفاده از <em>HATEOAS</em> صحبت کند. تجربیات من بدیهی است که فقط یک مجموعه از داده‌ها هستند، و من شک ندارم که برای برخی از افراد <em>HATEOAS</em> ممکن است خوب عمل کرده باشد. اما به نظر نمی‌رسد که این مفهوم به اندازه آنچه فکر می‌کردم فراگیر شده باشد. این می‌تواند به این دلیل باشد که مفاهیم پشت <em>HATEOAS</em> برای درک ما بیش از حد بیگانه هستند، یا ممکن است کمبود ابزارها یا استانداردهای موجود در این فضا باشد، یا شاید این مدل فقط برای انواع سیستم‌هایی که ما در نهایت ساخته‌ایم، کارآمد نباشد. البته این نیز ممکن است که مفاهیم پشت <em>HATEOAS</em> واقعاً با نحوه ساخت <em>microservices</em> ما سازگار نباشد.</p>
 </div>

        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>