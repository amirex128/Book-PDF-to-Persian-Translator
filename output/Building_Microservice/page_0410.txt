the claims that the token is making—this is just the result of encoding the JSON
structure in Example 11-1. The signature is used to ensure that the payload hasn’t
been manipulated, and it can also be used to ensure that the token was generated by
whom you think it was (assuming the token is signed with a private key).
As a simple string, this token can be easily passed along via different communication
protocols—as a header in HTTP (in the Authorization header), for example, or per‐
haps as a piece of metadata in a message. This encoded string can of course be sent
over encrypted transport protocol—for example, TLS over HTTP—in which case the
token wouldn’t be visible to people observing the communication.
Using tokens
Let’s take a look at a common way to use JWT tokens in a microservice architecture.
In Figure 11-9, our customer logs in as normal, and once authenticated we generate
some sort of token to represent their logged-in session (likely an OAuth token),
which is stored on the client device. Subsequent requests from that client device hit
our gateway, which generates a JWT token that will be valid for the duration of that
request. It is this JWT token that is then passed to the downstream microservices.
They are able to validate the token and extract claims from the payload to determine
what sort of authorization is appropriate.
Figure 11-9. A JWT token is generated for a specific request and passed to downstream
microservices
384 
| 
Chapter 11: Security
