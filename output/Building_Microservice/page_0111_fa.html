<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 111</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   ما باید با این واقعیت کنار بیاییم که با جدا کردن پایگاه‌های داده خود به دلایلی که ممکن است بسیار خوب باشند، با مجموعه جدیدی از مشکلات مواجه خواهیم شد.
  </p>
  <h4>ابزارها</h4>
  <p>
   تغییر پایگاه‌های داده به دلایل زیادی دشوار است، که یکی از آنها این است که ابزارهای محدودی برای ایجاد تغییرات آسان در دسترس هستند. با کد، ما ابزارهای <strong>refactoring</strong> را در <strong>IDEs</strong> خود ساخته‌ایم، و ما این مزیت را داریم که سیستم‌هایی که در حال تغییر آنها هستیم اساساً <strong>stateless</strong> هستند. با یک پایگاه داده، چیزهایی که ما در حال تغییر آنها هستیم، <strong>state</strong> دارند، و ما همچنین فاقد ابزارهای مناسب از نوع <strong>refactoring</strong> هستیم.
  </p>
  <p>
   ابزارهای زیادی وجود دارد که به شما کمک می‌کند تا فرآیند تغییر <strong>schema</strong> یک پایگاه داده رابطه‌ای را مدیریت کنید، اما بیشتر آنها از الگوی یکسانی پیروی می‌کنند. هر تغییر <strong>schema</strong> در یک اسکریپت <strong>delta</strong> کنترل‌شده با نسخه تعریف می‌شود. سپس این اسکریپت‌ها به ترتیب دقیق و به روشی <strong>idempotent</strong> اجرا می‌شوند. <strong>Rails migrations</strong> به این ترتیب کار می‌کنند، همانطور که <strong>DBDeploy</strong>، ابزاری که من سال‌ها پیش در ایجاد آن کمک کردم، اینگونه بود.
  </p>
  <p>
   امروزه من افراد را به <strong>Flyway</strong> یا <strong>Liquibase</strong> ارجاع می‌دهم تا به همان نتیجه برسند، اگر از قبل ابزاری ندارند که به این ترتیب کار کند.
  </p>
  <h4>پایگاه داده گزارش‌دهی</h4>
  <p>
   به عنوان بخشی از استخراج microservices از برنامه <strong>monolithic</strong> ما، ما همچنین پایگاه‌های داده خود را از هم جدا می‌کنیم، زیرا می‌خواهیم دسترسی به <strong>data storage</strong> داخلی خود را پنهان کنیم. با پنهان کردن دسترسی مستقیم به پایگاه‌های داده خود، ما قادر به ایجاد <strong>interfaces</strong> پایدارتر هستیم، که <strong>independent deployability</strong> را ممکن می‌سازد. متأسفانه، این امر باعث ایجاد مشکلاتی می‌شود زمانی که ما موارد استفاده مشروعی برای دسترسی به داده‌ها از بیش از یک microservice داریم، یا زمانی که آن داده‌ها بهتر است در یک پایگاه داده، و نه از طریق چیزی مانند یک <strong>REST API</strong>، در دسترس قرار گیرند.
  </p>
  <p>
   با یک پایگاه داده گزارش‌دهی، ما در عوض یک پایگاه داده اختصاصی ایجاد می‌کنیم که برای دسترسی خارجی طراحی شده است، و ما مسئولیت push داده‌ها را از <strong>internal storage</strong> به پایگاه داده گزارش‌دهی که از بیرون قابل دسترسی است، می‌کنیم، همانطور که در شکل 3-8 مشاهده می‌شود.
  </p>
  <p>
   پایگاه داده گزارش‌دهی به ما امکان می‌دهد مدیریت <strong>internal state</strong> را پنهان کنیم، در حالی که هنوز داده‌ها را در یک پایگاه داده ارائه می‌کنیم—چیزی که می‌تواند بسیار مفید باشد. به عنوان مثال، شما ممکن است بخواهید به افراد اجازه دهید که <strong>queries SQL</strong> تعریف شده را اجرا کنند، <strong>joins</strong> در مقیاس بزرگ را اجرا کنند، یا از <strong>toolchains</strong> موجود که انتظار دارند به یک <strong>SQL endpoint</strong> دسترسی داشته باشند، استفاده کنند.
  </p>
  <p>
   پایگاه داده گزارش‌دهی یک راه‌حل خوب برای این مشکل است.
  </p>
  <p>Data Decomposition Concerns | 85</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>