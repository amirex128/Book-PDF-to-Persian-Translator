<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 16</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   به گونه‌ای ساختاردهی شود که هر microservice توسط یک تیم مهندسی پشتیبانی شود. چندین راه برای انجام این کار وجود
   دارد. اولین روش سازماندهی مجدد شرکت حول پذیرش microservice این است که یک تیم را به هر microservice اختصاص
   دهید. اندازه تیم کاملاً با پیچیدگی و حجم کار microservice تعیین می‌شود و باید توسط توسعه‌دهندگان و مهندسان قابلیت
   اطمینان سایت به اندازه کافی پشتیبانی شود تا هم توسعه ویژگی و هم چرخش در دسترس بودن سرویس بدون تحمیل بار به تیم
   مدیریت شود. دومی این است که چندین سرویس را به یک تیم اختصاص دهید و از آن تیم بخواهید سرویس‌ها را به موازات هم
   توسعه دهند. این روش زمانی بهترین عملکرد را دارد که تیم‌ها حول محصولات یا حوزه‌های تجاری خاص سازماندهی شده
   باشند و مسئول توسعه هرگونه سرویس مرتبط با آن محصولات یا حوزه‌ها باشند. اگر شرکتی روش دوم سازماندهی مجدد را
   انتخاب کند، باید اطمینان حاصل کند که توسعه‌دهندگان بیش از حد کار نمی‌کنند و با وظایف، قطعی‌ها یا خستگی عملیاتی
   مواجه نمی‌شوند.
  </p>
  <p>
   یکی دیگر از بخش‌های مهم پذیرش microservice، ایجاد یک اکوسیستم microservice است. به طور معمول (یا، حداقل،
   امیدواریم)، شرکتی که یک برنامه monolithic بزرگ را اجرا می‌کند، یک سازمان زیرساختی اختصاصی خواهد داشت که
   مسئول طراحی، ساخت و نگهداری زیرساختی است که برنامه بر روی آن اجرا می‌شود. هنگامی که یک monolith به
   microservices تقسیم می‌شود، مسئولیت‌های سازمان زیرساختی برای ارائه یک پلتفرم پایدار برای توسعه و اجرای
   microservices به شدت افزایش می‌یابد. تیم‌های زیرساخت باید زیرساخت پایداری را در اختیار تیم‌های microservice قرار
   دهند که اکثر پیچیدگی‌های تعاملات بین microservices را انتزاع می‌کند.
  </p>
  <p>
   هنگامی که این سه مرحله تکمیل شد—componentization برنامه، بازسازی تیم‌های مهندسی برای پشتیبانی از هر
   microservice، و توسعه سازمان زیرساختی در داخل شرکت—مهاجرت می‌تواند آغاز شود. برخی از تیم‌ها کد مربوطه
   microservice خود را مستقیماً از monolith به یک سرویس جداگانه بیرون می‌کشند و ترافیک monolith را تا زمانی که
   متقاعد شوند که microservice می‌تواند عملکرد مورد نظر خود را به تنهایی انجام دهد، در سایه قرار می‌دهند. سایر
   تیم‌ها انتخاب می‌کنند که سرویس را از ابتدا بسازند، با یک صفحه تمیز شروع کنند، و ترافیک را در سایه قرار دهند یا
   پس از گذراندن آزمایش‌های مناسب سرویس را دوباره هدایت کنند. بهترین رویکرد برای مهاجرت به عملکرد
   microservice بستگی دارد و من دیده‌ام که هر دو رویکرد در بیشتر موارد به یک اندازه خوب عمل می‌کنند، اما کلید
   واقعی یک مهاجرت موفق، برنامه‌ریزی و اجرای کامل، دقیق و با دقت مستند شده، همراه با درک این است که
   مهاجرت کامل یک monolith بزرگ می‌تواند چندین سال طول بکشد.
  </p>
  <p>
   با توجه به تمام کارهای انجام شده در تقسیم یک monolith به microservices، ممکن است بهتر باشد که با معماری
   microservice شروع کنیم، از تمام چالش‌های مقیاس‌پذیری دردناک صرف نظر کنیم و از درام مهاجرت microservice اجتناب
   کنیم. این رویکرد ممکن است برای برخی از شرکت‌ها درست باشد، اما می‌خواهم چندین کلمه احتیاط را ارائه کنم. شرکت‌های
   کوچک اغلب زیرساخت‌های لازم را برای حفظ microservices، حتی در مقیاس بسیار کوچک، ندارند: معماری microservice
   خوب به زیرساخت پایدار و اغلب بسیار پیچیده نیاز دارد. چنین زیرساخت پایداری به یک تیم بزرگ و اختصاصی نیاز دارد
  </p>
  <p>8 | فصل 1: Microservices</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>