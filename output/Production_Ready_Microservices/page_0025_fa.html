<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 25</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   برای اولین بار، حوزه‌های مسئولیت را تقسیم کنید و سپس مشخص کنید که توسعه‌دهندگان برای طراحی، ساخت و نگهداری
   سرویس‌های خود به چه وظایفی باید قادر باشند.
  </p>
  <p>
   در یک شرکت که معماری microservice را پذیرفته است، مسئولیت‌ها باید با دقت به تیم‌های مهندسی مختلف واگذار
   شوند. یک راه آسان برای انجام این کار این است که یک زیرسازمان مهندسی برای هر لایه از اکوسیستم microservice،
   همراه با تیم‌های دیگری که هر لایه را به هم متصل می‌کنند، ایجاد کنید. هر یک از این سازمان‌های مهندسی، که
   به‌طور نیمه مستقل عمل می‌کنند، مسئولیت همه چیز در لایه خود را بر عهده خواهند داشت: تیم‌های TechOps
   مسئول لایه 1 خواهند بود، تیم‌های زیرساخت مسئول لایه 2 خواهند بود، تیم‌های پلتفرم برنامه مسئول لایه 3
   خواهند بود و تیم‌های microservice مسئول لایه 4 خواهند بود (البته این یک دیدگاه بسیار ساده شده است، اما شما
   ایده کلی را دریافت می‌کنید).
  </p>
  <p>
   در این طرح سازمانی، هر زمان که یک مهندس که روی یکی از لایه‌های بالاتر کار می‌کند نیاز به راه‌اندازی، پیکربندی
   یا استفاده از چیزی در یکی از لایه‌های پایین‌تر داشته باشد، باید یک ابزار سلف‌سرویس وجود داشته باشد که مهندس
   بتواند از آن استفاده کند. به عنوان مثال، تیمی که روی پیام‌رسانی برای اکوسیستم کار می‌کند باید یک ابزار
   سلف‌سرویس بسازد تا اگر یک توسعه‌دهنده در تیم microservice نیاز به پیکربندی پیام‌رسانی برای سرویس خود دارد،
   بتواند به راحتی پیام‌رسانی را بدون نیاز به درک تمام پیچیدگی‌های سیستم پیام‌رسانی، پیکربندی کند.
  </p>
  <p>
   دلایل زیادی برای داشتن این ابزارهای متمرکز و سلف‌سرویس برای هر لایه وجود دارد. در یک اکوسیستم microservice
   متنوع، مهندس متوسط ​​در هر تیم، هیچ دانش (یا بسیار کم) در مورد نحوه عملکرد سرویس‌ها و سیستم‌ها در تیم‌های
   دیگر نخواهد داشت، و به سادگی هیچ راهی وجود ندارد که آن‌ها بتوانند در هر سرویس و سیستم متخصص شوند، در حالی
   که روی خودشان کار می‌کنند—به سادگی نمی‌توان این کار را انجام داد. هر توسعه‌دهنده به طور جداگانه تقریباً هیچ
   چیز به جز سرویس خود را نخواهد دانست، اما در کنار هم، تمام توسعه‌دهندگان که در اکوسیستم کار می‌کنند،
   به‌طور جمعی همه چیز را خواهند دانست. به جای تلاش برای آموزش هر توسعه‌دهنده در مورد پیچیدگی‌های هر ابزار و
   سرویس در اکوسیستم، رابط‌های کاربری پایدار و آسان برای استفاده را برای هر قسمت از اکوسیستم بسازید، و سپس
   آن‌ها را در مورد نحوه استفاده از آن‌ها آموزش دهید و تربیت کنید. همه چیز را به یک جعبه سیاه تبدیل کنید و دقیقاً
   نحوه عملکرد و نحوه استفاده از آن را مستند کنید.
  </p>
  <p>
   دلیل دوم برای ساختن این ابزارها و ساختن آن‌ها به خوبی این است که، صادقانه بگویم، شما نمی‌خواهید توسعه‌دهنده‌ای از
   تیم دیگر بتواند تغییرات اساسی در سرویس یا سیستم شما ایجاد کند، به خصوص تغییری که می‌تواند باعث قطعی شود.
   این امر به ویژه برای سرویس‌ها و سیستم‌های متعلق به لایه‌های پایین‌تر (لایه 1، لایه 2 و لایه 3) صادق و اجباری
   است. اجازه دادن به افراد غیرمتخصص برای ایجاد تغییرات در چیزهای داخل این لایه‌ها، یا درخواست (یا بدتر از آن،
   انتظار) از آن‌ها برای متخصص شدن در این حوزه‌ها، یک دستورالعمل برای فاجعه است. نمونه‌ای از جایی که این می‌تواند
   به طرز وحشتناکی اشتباه شود، مدیریت پیکربندی است: اجازه دادن به توسعه‌دهندگان در تیم‌های microservice برای
   ایجاد تغییرات در پیکربندی‌های سیستم بدون داشتن تخصص لازم برای انجام این کار، می‌تواند و منجر به قطعی‌های
   تولید در مقیاس بزرگ شود، اگر تغییری ایجاد شود که بر چیزی غیر از سرویس خودشان تأثیر بگذارد.
  </p>
  <p>اکوسیستم Microservice | 17</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>