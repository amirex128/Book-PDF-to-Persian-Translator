<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 46</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   توسط مشتری قرار می‌دهد). هم customers و هم orders به microservicesهای دیگری وابسته هستند: customers به microservice
   دیگری که آن را customers-dependency می‌نامیم وابسته است، و orders به یکی که آن را orders-dependency می‌نامیم
   وابسته است. احتمال اینکه customers-dependency و orders-dependency وابستگی‌های خاص خود را داشته باشند، بسیار
   زیاد است، بنابراین نمودار وابستگی برای receipt-sender به سرعت بسیار، بسیار پیچیده می‌شود.
  </p>
  <p>
   از آنجایی که receipt-sender می‌خواهد از SLA خود محافظت کند و 99.99٪ زمان uptime را به همه کلاینت‌های خود ارائه
   دهد، تیم آن باید اطمینان حاصل کند که به SLAهای تمام وابستگی‌های downstream به‌شدت پایبند است. اگر SLA
   receipt-sender به در دسترس بودن customers 99.99٪ از زمان بستگی داشته باشد، اما uptime واقعی customers
   فقط 89.99٪ از زمان باشد، در دسترس بودن receipt-sender به خطر می‌افتد و اکنون فقط 89.98٪ است. هر یک از
   وابستگی‌های receipt-sender می‌توانند ضربه‌ای مشابه به در دسترس بودن خود وارد کنند، اگر هیچ یک از وابستگی‌ها در
   زنجیره وابستگی، SLAهای خود را برآورده نکنند.
  </p>
  <p>
   یک microservice پایدار و قابل اعتماد باید شکست‌های وابستگی از این نوع را کاهش دهد (و بله، برآورده نکردن یک SLA
   یک شکست است!). این کار را می‌توان با داشتن backups، fallbacks، caching و/یا جایگزین‌هایی برای هر وابستگی در
   صورت شکست آن‌ها، انجام داد.
  </p>
  <p>
   قبل از اینکه بتوان برای شکست‌های وابستگی برنامه‌ریزی و کاهش داد، باید وابستگی‌های یک microservice شناخته،
   مستند و ردیابی شوند. هر وابستگی که می‌تواند به SLA یک microservice آسیب برساند، باید در نمودار معماری و
   مستندات microservice (به فصل 7، مستندات و درک مراجعه کنید) گنجانده شود و باید در dashboard(های) سرویس (به
   ??? مراجعه کنید) گنجانده شود. علاوه بر این، تمام وابستگی‌ها باید با ایجاد خودکار نمودارهای وابستگی برای هر
   سرویس، ردیابی شوند، که می‌توان با پیاده‌سازی یک سیستم ردیابی توزیع‌شده در سراسر تمام microservices در
   سازمان، این کار را انجام داد.
  </p>
  <p>
   هنگامی که تمام وابستگی‌ها شناخته و ردیابی شدند، گام بعدی این است که backups، جایگزین‌ها، fallbacks یا caching را
   برای هر وابستگی تنظیم کنید. روش درست برای انجام این کار کاملاً به نیازهای سرویس بستگی دارد. به عنوان مثال، اگر
   عملکرد یک وابستگی را می‌توان با فراخوانی endpoint یک سرویس دیگر پر کرد، پس شکست وابستگی اولیه باید توسط
   microservice مدیریت شود تا درخواست‌ها به جای آن به جایگزین ارسال شوند. اگر درخواست‌هایی که باید به
   وابستگی ارسال شوند، در صورت عدم در دسترس بودن وابستگی، در یک صف نگهداری شوند، باید یک صف پیاده‌سازی
   شود. راه دیگری برای مدیریت شکست‌های وابستگی، قرار دادن caching برای وابستگی در داخل سرویس است: هر داده
   مربوطه را cache کنید تا هرگونه شکست به درستی مدیریت شود.
  </p>
  <p>
   نوع cache که اغلب در این موارد استفاده می‌شود، یک cache Least Recently Used (LRU) است، که در آن داده‌های
   مربوطه در یک صف نگهداری می‌شوند، و داده‌های استفاده نشده حذف می‌شوند، زمانی که صف cache پر می‌شود.
   کتابخانه‌های LRU آسان برای پیاده‌سازی (اغلب یک خط کد برای هر نمونه‌سازی)، کارآمد (نیازی به برقراری تماس‌های
   شبکه گران‌قیمت نیست)، با عملکرد خوب (داده‌ها بلافاصله در دسترس هستند) هستند، و کار مناسبی را در کاهش هرگونه
   شکست وابستگی انجام می‌دهند. این به عنوان defensive caching شناخته می‌شود و برای محافظت از یک microservice
   در برابر شکست‌های وابستگی‌های آن مفید است: اطلاعاتی را که
  </p>
  <p>38 | فصل 3: پایداری و قابلیت اطمینان</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>