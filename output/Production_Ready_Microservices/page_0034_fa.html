<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>صفحه 34</title>
    <link rel="stylesheet" href="fontiran.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }
        body {
            font-family: IRANSansX, Tahoma, Arial, sans-serif;
            line-height: 1.8;
            text-align: right;
            direction: rtl;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: white;
        }
        .chapter-content {
            margin-bottom: 20px;
            text-align: right;
            direction: rtl;
        }
        .translated-content {
            font-size: 14pt;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .page-images {
            text-align: center;
            margin: 20px 0;
            page-break-before: always;
        }
        .page-image {
            margin: 10px 0;
            text-align: center;
        }
        .page-image img {
            max-width: 100%;
            height: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .code-block {
            direction: ltr;
            text-align: left;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', Courier, monospace;
        }
        .english-text {
            direction: ltr;
            text-align: left;
            display: inline-block;
        }
        .heading {
            color: #2c3e50;
            margin-top: 25px;
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        .paragraph {
            margin-bottom: 15px;
            text-align: right;
            direction: rtl;
        }
        ul, ol {
            padding-right: 20px;
            padding-left: 0;
            text-align: right;
            direction: rtl;
        }
        li {
            margin-bottom: 10px;
            text-align: right;
            direction: rtl;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            text-align: right;
            direction: rtl;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: right;
            direction: rtl;
        }
        th {
            background-color: #f8f9fa;
        }
        @media print {
            body {
                margin: 0;
                padding: 0;
            }
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="translated-content">
             <div>
  <p>
   یک microservice پایدار، سرویسی است که برای آن، توسعه، استقرار، پذیرش فناوری‌های جدید و از رده خارج کردن یا
   deprecate کردن سایر سرویس‌ها، منجر به بی‌ثباتی در سراسر اکوسیستم microservice بزرگ‌تر نمی‌شود. این امر مستلزم
   اعمال اقداماتی برای محافظت در برابر عواقب منفی است که ممکن است توسط این نوع تغییرات معرفی شوند. یک
   microservice قابل اعتماد، سرویسی است که می‌توان به آن توسط سایر microservicesها و توسط کل اکوسیستم اعتماد
   کرد. پایداری با قابلیت اطمینان همراه است زیرا هر نیاز به پایداری، نیاز به قابلیت اطمینان را نیز به همراه دارد (و
   برعکس): به عنوان مثال، processهای استقرار پایدار با این الزام همراه است که هر استقرار جدید قابلیت اطمینان
   microservice را از دیدگاه یکی از کلاینت‌ها یا وابستگی‌های آن‌ها به خطر نیندازد.
  </p>
  <p>
   چندین کار وجود دارد که می‌توان برای اطمینان از پایداری و قابلیت اطمینان یک microservice انجام داد. یک چرخه توسعه
   استاندارد را می‌توان برای محافظت در برابر practiceهای توسعه ضعیف پیاده‌سازی کرد. process استقرار را می‌توان به
   گونه‌ای طراحی کرد که تغییرات کد مجبور شوند قبل از راه‌اندازی در تمام سرورهای تولید، از مراحل متعددی عبور کنند.
   می‌توان از شکست‌های وابستگی محافظت کرد. health checkها، routing مناسب و circuit breaking می‌توانند در کانال‌های
   routing و کشف ایجاد شوند تا الگوهای ترافیکی غیرعادی را مدیریت کنند. در نهایت، microservicesها و endpointsهای
   آن‌ها می‌توانند deprecate و/یا decommission شوند بدون اینکه باعث هیچ‌گونه شکستی برای سایر microservicesها
   شوند.
  </p>
  <h3>یک سرویس آماده تولید، پایدار و قابل اعتماد است</h3>
  <ul>
   <li>دارای یک چرخه توسعه استاندارد است.</li>
   <li>کد آن از طریق تست‌های lint، unit، integration و end-to-end کاملاً تست شده است.</li>
   <li>process تست، بسته‌بندی، ساخت و release آن کاملاً خودکار است.</li>
   <li>دارای یک pipeline استقرار استاندارد است که شامل مراحل staging، canary و production است.</li>
   <li>کلاینت‌های آن شناخته شده‌اند.</li>
   <li>وابستگی‌های آن شناخته شده‌اند، و پشتیبان‌گیری، جایگزین‌ها، fallbacks و caching در صورت خرابی وجود دارد.</li>
   <li>دارای routing و کشف پایدار و قابل اعتماد است.</li>
  </ul>
  <h3>چرخه توسعه</h3>
  <p>
   پایداری و قابلیت اطمینان یک microservice با توسعه‌دهنده فردی که کد را به سرویس کمک می‌کند، شروع می‌شود.
   اکثر قطعی‌ها و خرابی‌های microservice ناشی از باگ‌هایی است که در کد معرفی شده‌اند و در مرحله توسعه، در هیچ یک
   از تست‌ها، یا در هیچ مرحله‌ای از process استقرار، شناسایی نشده‌اند. کاهش
  </p>
  <p>26 | فصل 3: پایداری و قابلیت اطمینان</p>
 </div>
 
        </div>
    </div>
    <div class="page-images">
        
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            if (window.Prism) {
                Prism.highlightAll();
            }
        });
    </script>
</body>
</html>