<!DOCTYPE html>
<html lang="fa">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>page_0009</title>
    <link rel="stylesheet" href="fontiran.css">
    <!-- Add Prism CSS for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
    <style>
        @page {
            size: A4;
            margin: 1.5cm;
        }
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'IRANSansX', 'Tahoma', 'Arial', sans-serif;
            line-height: 1.5;
            background-color: #f8f9fa;
            /* A4 size enforcement */
            width: 21cm;
            height: 29.7cm;
        }
        .container {
            width: 18cm; /* A4 width minus margins */
            min-height: 26.7cm; /* A4 height minus margins */
            background-color: white;
            padding: 1cm;
            box-sizing: border-box;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
        }
        .persian-translation {
            text-align: right;
            direction: rtl;
            font-size: 1em;
            font-family: 'IRANSansX', 'Tahoma', 'Arial', sans-serif;
            margin-bottom: 20px;
            /* Don't hide any overflow text, let it flow naturally */
            overflow: visible;
        }
        /* Style for code blocks */
        pre[class*="language-"] {
            direction: ltr;
            text-align: left;
            border-radius: 5px;
            margin: 1em 0;
            font-size: 0.9em;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        code {
            direction: ltr;
            font-family: 'Courier New', Courier, monospace;
            background-color: #f5f5f5;
            border-radius: 3px;
            padding: 2px 4px;
        }
        .page-images {
            margin: 1cm 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1cm;
        }
        .page-image {
            max-width: 100%;
            height: auto;
            object-fit: contain;
        }
        .page-number {
            text-align: center;
            margin-top: 10px;
            font-size: 0.9em;
            color: #777;
        }
        @media print {
            body {
                background: none;
                width: 21cm;
                height: 29.7cm;
            }
            .container {
                box-shadow: none;
                padding: 1cm;
                height: auto;
                min-height: auto;
            }
            /* Page break utility */
            .page-break {
                page-break-before: always;
            }
            /* Ensure code blocks print with background colors */
            pre[class*="language-"] {
                print-color-adjust: exact;
                -webkit-print-color-adjust: exact;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div dir='rtl' class='persian-translation'><p><b>فهرست</b></p>
<p>11.6.مدل‌های خواندن . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271</p>
<p>11.6.1. از مدل‌های خواندن داخلی در زمان نیاز به اطلاعات استفاده کنید . . 271</p>
<p>11.6.2. یک پیاده‌سازی استاندارد برای انبار انتخاب کنید . . . . . . . . . 274</p>
<p>11.6.3. برای مدل‌های نمایش، داده‌ها را برای رندر آماده کنید . . . . . . . 276</p>
<p>11.7.مدل‌سازی فرآیند . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277</p>
<p>11.8.خلاصه . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280</p>
<p>12.لایه‌های معماری 281</p>
<p>12.1.MVC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281</p>
<p>12.2.مجموعه‌ای استاندارد از لایه‌ها . . . . . . . . . . . . . . . . . . . . . . . . . 283</p>
<p>12.2.1. لایه زیرساخت . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284</p>
<p>12.2.2. لایه کاربرد . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285</p>
<p>12.2.3. لایه دامنه . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286</p>
<p>12.2.4. بالا و پایین لایه سلسله مراتب . . . . . . . . . . . . . . . . . . . 287</p>
<p>12.3.قانون وابستگی . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288</p>
<p>12.4.ملموس کردن لایه‌ها . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290</p>
<p>12.4.1. مستندسازی معماری . . . . . . . . . . . . . . . . . . . . . . . . . . 290</p>
<p>12.4.2. استفاده از فضاهای نام برای لایه‌ها . . . . . . . . . . . . . . . . . 291</p>
<p>12.4.3. تأیید خودکار تصمیمات طراحی . . . . . . . . . . . . . . . . . . 293</p>
<p>12.5.خلاصه . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296</p>
<p>13.پورت‌ها و آداپتورها 298</p>
<p>13.1.معماری شش ضلعی . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 298</p>
<p>13.2.پورت‌ها . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299</p>
<p>13.3.آداپتورها برای پورت‌های خروجی . . . . . . . . . . . . . . . . . . . . . . . 301</p>
<p>13.4.آداپتورها برای پورت‌های ورودی . . . . . . . . . . . . . . . . . . . . . . . 303</p>
<p>13.5.کاربرد به عنوان رابط . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308</p>
<p>13.6.ترکیب پورت‌ها و آداپتورها با لایه‌ها . . . . . . . . . . . . . . . . . . . 314</p>
<p>13.7.ساختار لایه زیرساخت . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315</p>
<p>13.8.خلاصه . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 317</p>
<p>14.استراتژی آزمون برای برنامه‌های جدا شده 319</p>
<p>14.1.آزمون‌های واحد . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319</p>
<p>14.2.آزمون‌های آداپتور . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 323</p>
<p>14.3.آزمون‌های قرارداد برای آداپتورهای پورت خروجی . . . . . . . . . . . . . 324</p>
<p>14.4.آزمون‌های هدایت‌شده برای آداپتورهای پورت ورودی . . . . . . . . . . . . 329</p>
<p>14.5.آزمون‌های مورد استفاده . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338</p>
<p>viii</p>
</div>
        
        
        
        <div class="page-number">
            9
        </div>
    </div>
    
    <!-- Add Prism JS for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        // Initialize Prism highlighting
        document.addEventListener('DOMContentLoaded', (event) => {
            /* Add line-numbers class to all pre elements if not already there */
            document.querySelectorAll('pre').forEach(block => {
                if (!block.classList.contains('line-numbers')) {
                    block.classList.add('line-numbers');
                }
                
                /* If language class is not specified, add 'language-clike' as default */
                let hasLanguageClass = false;
                block.classList.forEach(className => {
                    if (className.startsWith('language-')) {
                        hasLanguageClass = true;
                    }
                });
                
                if (!hasLanguageClass) {
                    block.classList.add('language-clike');
                }
                
                /* Ensure code elements inside pre also have the correct language class */
                const codeElement = block.querySelector('code');
                if (codeElement) {
                    if (!hasLanguageClass) {
                        codeElement.classList.add('language-clike');
                    } else {
                        /* Copy the language class from pre to code if code doesn't have it */
                        block.classList.forEach(className => {
                            if (className.startsWith('language-') && !codeElement.classList.contains(className)) {
                                codeElement.classList.add(className);
                            }
                        });
                    }
                }
            });
            
            /* Re-highlight all code blocks */
            if (window.Prism) {
                Prism.highlightAll();
            }
            
            /* Smart image scaling based on page content */
            const container = document.querySelector('.container');
            const textElement = document.querySelector('.persian-translation');
            const imageContainer = document.querySelector('.page-images');
            
            if (imageContainer && textElement) {
                const images = imageContainer.querySelectorAll('.page-image');
                if (images.length > 0) {
                    /* Calculate available space */
                    const containerHeight = container.clientHeight;
                    const textHeight = textElement.clientHeight;
                    const pageNumberHeight = document.querySelector('.page-number').clientHeight;
                    const availableHeight = containerHeight - textHeight - pageNumberHeight - 40; /* Extra margins */
                    
                    /* Estimate total height of images */
                    let totalImageHeight = 0;
                    images.forEach(img => {
                        /* Wait for image to load to get accurate height */
                        img.onload = function() {
                            /* Get natural aspect ratio */
                            const ratio = img.naturalWidth / img.naturalHeight;
                            /* Calculate height based on max width */
                            const estimatedHeight = (img.clientWidth / ratio);
                            totalImageHeight += estimatedHeight + 40; /* Add gap */
                            
                            /* Check if images don't fit */
                            if (totalImageHeight > availableHeight) {
                                /* Try to scale down by up to 30% */
                                const scaleFactor = Math.max(0.7, availableHeight / totalImageHeight);
                                
                                /* If even with 30% reduction it doesn't fit, set page-break */
                                if (scaleFactor < 0.7) {
                                    imageContainer.classList.add('page-break');
                                } else {
                                    /* Scale images to fit */
                                    images.forEach(i => {
                                        i.style.maxWidth = (scaleFactor * 100) + '%';
                                    });
                                }
                            }
                        };
                        
                        /* Force layout calculation in case image is already loaded */
                        if (img.complete) {
                            img.onload();
                        }
                    });
                }
            }
        });
    </script>
</body>
</html>