<!DOCTYPE html>
<html lang="fa">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>page_0011</title>
    <link rel="stylesheet" href="fontiran.css">
    <!-- Add Prism CSS for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
    <style>
        @page {
            size: A4;
            margin: 1.5cm;
        }
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'IRANSansX', 'Tahoma', 'Arial', sans-serif;
            line-height: 1.5;
            background-color: #f8f9fa;
            /* A4 size enforcement */
            width: 21cm;
            height: 29.7cm;
        }
        .container {
            width: 18cm; /* A4 width minus margins */
            min-height: 26.7cm; /* A4 height minus margins */
            background-color: white;
            padding: 1cm;
            box-sizing: border-box;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
        }
        .persian-translation {
            text-align: right;
            direction: rtl;
            font-size: 1em;
            font-family: 'IRANSansX', 'Tahoma', 'Arial', sans-serif;
            margin-bottom: 20px;
            /* Don't hide any overflow text, let it flow naturally */
            overflow: visible;
        }
        /* Style for code blocks */
        pre[class*="language-"] {
            direction: ltr;
            text-align: left;
            border-radius: 5px;
            margin: 1em 0;
            font-size: 0.9em;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        code {
            direction: ltr;
            font-family: 'Courier New', Courier, monospace;
            background-color: #f5f5f5;
            border-radius: 3px;
            padding: 2px 4px;
        }
        .page-images {
            margin: 1cm 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1cm;
        }
        .page-image {
            max-width: 100%;
            height: auto;
            object-fit: contain;
        }
        .page-number {
            text-align: center;
            margin-top: 10px;
            font-size: 0.9em;
            color: #777;
        }
        @media print {
            body {
                background: none;
                width: 21cm;
                height: 29.7cm;
            }
            .container {
                box-shadow: none;
                padding: 1cm;
                height: auto;
                min-height: auto;
            }
            /* Page break utility */
            .page-break {
                page-break-before: always;
            }
            /* Ensure code blocks print with background colors */
            pre[class*="language-"] {
                print-color-adjust: exact;
                -webkit-print-color-adjust: exact;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div dir='rtl' class='persian-translation'><p><b>مقدمه</b></p>
<p><b>1. پیشگفتار</b></p>
<p>کتاب قبلی من، <i>راهنمای سبک طراحی شی‌گرا</i>، با فصل 10 - «راهنمای میدانی برای اشیاء»، به پایان می‌رسد که ویژگی‌های برخی از انواع رایج اشیاء مانند کنترل‌کننده‌ها، موجودیت‌ها، اشیاء مقدار، انبارها، مشترکان رویداد و غیره را نشان می‌دهد.</p>
<p>این فصل با مروری بر چگونگی یافتن جایگاه طبیعی این انواع مختلف اشیاء در مجموعه‌ای از لایه‌های معماری به پایان می‌رسد.</p>
<p>برخی از خوانندگان اشاره کردند که راهنمای میدانی به خودی خود به اندازه کافی دقیق نبوده تا به آن‌ها کمک کند از این انواع اشیاء در پروژه‌های خود استفاده کنند. و برخی از افراد اعتراض کردند که مفاهیم معماری به‌طور خلاصه در این فصل توصیف‌شده، به راحتی قابل اعمال به پروژه‌های دنیای واقعی نیز نیستند. کاملاً درست می‌گویند؛ آن فصل آخر بیشتر شبیه یک طعمه بود تا یک رساله.</p>
<p>متأسفانه من نتوانستم منبع جایگزینی را برای آن خوانندگان ارائه دهم.</p>
<p>برخی مقالات و کتاب‌های خوب در این زمینه وجود دارد، اما فقط برخی از الگوها و مفاهیم معماری را پوشش می‌دهند.</p>
<p>تا جایی که من می‌دانم، هیچ راهنمای جامع در مورد ترکیب همه این الگوها وجود ندارد. بنابراین تصمیم گرفتم خودم آن را بنویسم: نمایشگاهی از الگوهای طراحی، مانند موجودیت‌ها و سرویس‌های کاربردی، توضیح می‌دهد که چگونه همه آن‌ها در یک برنامه «معماری خوب» با هم کار می‌کنند.</p>
<p>با این حال، توصیف ساده الگوهای موجود به اندازه نشان دادن چگونگی اختراع آن‌ها توسط خودتان، صرفاً با تلاش برای جدا کردن کد برنامه خود از زیرساخت اطراف آن، مفید نیست.</p>
<p>به همین ترتیب، این کتاب راهنمایی برای جدا کردن مدل دامنه و موارد استفاده برنامه از چارچوب، پایگاه داده و غیره شد.</p>
<p>x</p>
</div>
        
        
        
        <div class="page-number">
            11
        </div>
    </div>
    
    <!-- Add Prism JS for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <script>
        // Initialize Prism highlighting
        document.addEventListener('DOMContentLoaded', (event) => {
            /* Add line-numbers class to all pre elements if not already there */
            document.querySelectorAll('pre').forEach(block => {
                if (!block.classList.contains('line-numbers')) {
                    block.classList.add('line-numbers');
                }
                
                /* If language class is not specified, add 'language-clike' as default */
                let hasLanguageClass = false;
                block.classList.forEach(className => {
                    if (className.startsWith('language-')) {
                        hasLanguageClass = true;
                    }
                });
                
                if (!hasLanguageClass) {
                    block.classList.add('language-clike');
                }
                
                /* Ensure code elements inside pre also have the correct language class */
                const codeElement = block.querySelector('code');
                if (codeElement) {
                    if (!hasLanguageClass) {
                        codeElement.classList.add('language-clike');
                    } else {
                        /* Copy the language class from pre to code if code doesn't have it */
                        block.classList.forEach(className => {
                            if (className.startsWith('language-') && !codeElement.classList.contains(className)) {
                                codeElement.classList.add(className);
                            }
                        });
                    }
                }
            });
            
            /* Re-highlight all code blocks */
            if (window.Prism) {
                Prism.highlightAll();
            }
            
            /* Smart image scaling based on page content */
            const container = document.querySelector('.container');
            const textElement = document.querySelector('.persian-translation');
            const imageContainer = document.querySelector('.page-images');
            
            if (imageContainer && textElement) {
                const images = imageContainer.querySelectorAll('.page-image');
                if (images.length > 0) {
                    /* Calculate available space */
                    const containerHeight = container.clientHeight;
                    const textHeight = textElement.clientHeight;
                    const pageNumberHeight = document.querySelector('.page-number').clientHeight;
                    const availableHeight = containerHeight - textHeight - pageNumberHeight - 40; /* Extra margins */
                    
                    /* Estimate total height of images */
                    let totalImageHeight = 0;
                    images.forEach(img => {
                        /* Wait for image to load to get accurate height */
                        img.onload = function() {
                            /* Get natural aspect ratio */
                            const ratio = img.naturalWidth / img.naturalHeight;
                            /* Calculate height based on max width */
                            const estimatedHeight = (img.clientWidth / ratio);
                            totalImageHeight += estimatedHeight + 40; /* Add gap */
                            
                            /* Check if images don't fit */
                            if (totalImageHeight > availableHeight) {
                                /* Try to scale down by up to 30% */
                                const scaleFactor = Math.max(0.7, availableHeight / totalImageHeight);
                                
                                /* If even with 30% reduction it doesn't fit, set page-break */
                                if (scaleFactor < 0.7) {
                                    imageContainer.classList.add('page-break');
                                } else {
                                    /* Scale images to fit */
                                    images.forEach(i => {
                                        i.style.maxWidth = (scaleFactor * 100) + '%';
                                    });
                                }
                            }
                        };
                        
                        /* Force layout calculation in case image is already loaded */
                        if (img.complete) {
                            img.onload();
                        }
                    });
                }
            }
        });
    </script>
</body>
</html>